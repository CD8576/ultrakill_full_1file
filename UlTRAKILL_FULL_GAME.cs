// File generated by dotnet-combine at 2025-11-12__16_32_17

using CustomRay;
using DebugOverlays;
using Discord;
using Fishing;
using GameConsole;
using GameConsole.Commands;
using GameConsole.CommandTree;
using GameConsole.pcon;
using JetBrains.Annotations;
using JigglePhysics;
using Logic;
using NewBlood;
using NewBlood.IK;
using NewBlood.Rendering;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;
using pcon.core;
using pcon.core.Attributes;
using pcon.core.Interfaces;
using pcon.core.Models;
using plog;
using plog.Handlers;
using plog.Helpers;
using plog.Models;
using plog.unity.Extensions;
using plog.unity.Handlers;
using Sandbox;
using Sandbox.Arm;
using ScriptableObjects;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using TMPro;
using Train;
using ULTRAKILL.Cheats;
using ULTRAKILL.Cheats.UnityEditor;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Controls;
using UnityEngine.InputSystem.DualShock;
using UnityEngine.InputSystem.LowLevel;
using UnityEngine.InputSystem.Utilities;
using UnityEngine.Networking;
using UnityEngine.ParticleSystemJobs;
using UnityEngine.ProBuilder;
using UnityEngine.Rendering;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.ResourceManagement.ResourceLocations;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;
using UnityEngine.Video;
using Vertx.Debugging;




public class AbruptLevelChanger : MonoBehaviour
{
	public bool loadingSplash;

	public bool saveMission;

	public void AbruptChangeLevel(string levelname)
	{
		if (saveMission)
		{
			MonoSingleton<PreviousMissionSaver>.Instance.previousMission = MonoSingleton<StatsManager>.Instance.levelNumber;
		}
		SceneHelper.LoadScene(levelname);
	}

	public void NormalChangeLevel(string levelname)
	{
		MonoSingleton<OptionsManager>.Instance.ChangeLevel(levelname);
	}

	public void PositionChangeLevel(string levelname)
	{
		MonoSingleton<OptionsManager>.Instance.ChangeLevelWithPosition(levelname);
	}

	public void GoToLevel(int missionNumber)
	{
		SceneHelper.LoadScene(GetMissionName.GetSceneName(missionNumber));
	}

	public void GoToSavedLevel()
	{
		PreviousMissionSaver instance = MonoSingleton<PreviousMissionSaver>.Instance;
		if (instance != null)
		{
			_ = instance.previousMission;
			Object.Destroy(instance.gameObject);
			GoToLevel(instance.previousMission);
		}
		else
		{
			GoToLevel(GameProgressSaver.GetProgress(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty")));
		}
	}
}



[Serializable]
public class ActionDisplayConfig
{
	public InputActionReference actionRef;

	public string requiredWeapon;

	public bool hidden;
}



[DefaultExecutionOrder(500)]
public class ActivateArena : MonoBehaviour
{
	public bool onlyWave;

	[HideInInspector]
	public bool activated;

	public Door[] doors;

	public GameObject[] enemies;

	private int currentEnemy;

	public bool forEnemy;

	public int waitForStatus;

	public bool activateOnEnable;

	private ArenaStatus astat;

	private bool playerIn;

	private void OnEnable()
	{
		if (activated || !activateOnEnable || DisableEnemySpawns.DisableArenaTriggers)
		{
			return;
		}
		if (waitForStatus > 0)
		{
			if (astat == null)
			{
				astat = GetComponentInParent<ArenaStatus>();
			}
			if (astat == null || astat.currentStatus < waitForStatus)
			{
				return;
			}
		}
		Activate();
	}

	private void Update()
	{
		if (playerIn && (bool)astat && astat.currentStatus >= waitForStatus && !activated)
		{
			Activate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (DisableEnemySpawns.DisableArenaTriggers)
		{
			return;
		}
		if (waitForStatus > 0)
		{
			if (astat == null)
			{
				astat = GetComponentInParent<ArenaStatus>();
			}
			if (astat == null)
			{
				return;
			}
			if (astat.currentStatus < waitForStatus)
			{
				if ((!forEnemy && other.gameObject.CompareTag("Player") && !activated) || (forEnemy && other.gameObject.CompareTag("Enemy") && !activated))
				{
					playerIn = true;
				}
				return;
			}
		}
		if ((!forEnemy && other.gameObject.CompareTag("Player") && !activated) || (forEnemy && other.gameObject.CompareTag("Enemy") && !activated))
		{
			Activate();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if ((!forEnemy && other.gameObject.CompareTag("Player") && !activated) || (forEnemy && other.gameObject.CompareTag("Enemy") && !activated))
		{
			playerIn = false;
		}
	}

	public void Activate()
	{
		if (DisableEnemySpawns.DisableArenaTriggers || activated)
		{
			return;
		}
		activated = true;
		if (!onlyWave && !forEnemy)
		{
			MonoSingleton<MusicManager>.Instance.ArenaMusicStart();
		}
		if (doors.Length != 0)
		{
			Door[] array = doors;
			foreach (Door door in array)
			{
				if (!door.gameObject.activeSelf)
				{
					door.gameObject.SetActive(value: true);
				}
				door.Lock();
			}
			if (enemies.Length != 0)
			{
				Invoke("SpawnEnemy", 1f);
			}
			else
			{
				Object.Destroy(this);
			}
		}
		else if (enemies.Length != 0)
		{
			SpawnEnemy();
		}
		else
		{
			Object.Destroy(this);
		}
	}

	private void SpawnEnemy()
	{
		if (currentEnemy >= enemies.Length)
		{
			Object.Destroy(this);
			return;
		}
		float time = 0.1f;
		if (enemies[currentEnemy] != null)
		{
			if (enemies[currentEnemy].activeSelf)
			{
				time = 0f;
			}
			else
			{
				enemies[currentEnemy].SetActive(value: true);
			}
		}
		currentEnemy++;
		if (currentEnemy < enemies.Length)
		{
			Invoke("SpawnEnemy", time);
		}
		else
		{
			Object.Destroy(this);
		}
	}
}



public class ActivateNextWave : MonoBehaviour
{
	public bool lastWave;

	private bool activated;

	public int deadEnemies;

	public int enemyCount;

	private ActivateNextWave[] linkedAnws;

	public GameObject[] nextEnemies;

	private int currentEnemy;

	public Door[] doors;

	private int currentDoor;

	public GameObject[] toActivate;

	private bool objectsActivated;

	public Door doorForward;

	private float slowDown = 1f;

	public bool forEnemies;

	public bool killChallenge;

	public bool noActivationDelay;

	public void CountEnemies()
	{
		enemyCount = base.transform.childCount;
	}

	private void Awake()
	{
		linkedAnws = GetComponents<ActivateNextWave>();
	}

	private void FixedUpdate()
	{
		if (deadEnemies < 0)
		{
			deadEnemies = 0;
		}
		if (activated || deadEnemies < enemyCount)
		{
			return;
		}
		activated = true;
		if (!lastWave)
		{
			if (toActivate.Length != 0)
			{
				GameObject[] array = toActivate;
				foreach (GameObject gameObject in array)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(value: true);
					}
				}
			}
			if (doors.Length != 0)
			{
				Door[] array2 = doors;
				foreach (Door door in array2)
				{
					if (door != null)
					{
						door.Unlock();
					}
				}
			}
			Invoke("SpawnEnemy", (!noActivationDelay) ? 1 : 0);
		}
		else
		{
			Invoke("EndWaves", (!noActivationDelay) ? 1 : 0);
			if (!forEnemies)
			{
				MonoSingleton<TimeController>.Instance.SlowDown(0.15f);
			}
		}
	}

	private void SpawnEnemy()
	{
		if (nextEnemies.Length != 0)
		{
			if (nextEnemies[currentEnemy] != null)
			{
				nextEnemies[currentEnemy].SetActive(value: true);
			}
			currentEnemy++;
		}
		if (currentEnemy < nextEnemies.Length)
		{
			Invoke("SpawnEnemy", 0.1f);
		}
		else
		{
			Object.Destroy(this);
		}
	}

	private void EndWaves()
	{
		if (toActivate.Length != 0 && !objectsActivated)
		{
			GameObject[] array = toActivate;
			foreach (GameObject gameObject in array)
			{
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
			}
			objectsActivated = true;
			EndWaves();
		}
		else if (currentDoor < doors.Length)
		{
			doors[currentDoor].Unlock();
			if (doors[currentDoor] == doorForward)
			{
				doors[currentDoor].Open(enemy: false, skull: true);
			}
			currentDoor++;
			Invoke("EndWaves", 0.1f);
		}
		else
		{
			if (!forEnemies)
			{
				MonoSingleton<MusicManager>.Instance.ArenaMusicEnd();
				slowDown = 1f;
			}
			if (killChallenge)
			{
				MonoSingleton<ChallengeManager>.Instance.ChallengeDone();
			}
			Object.Destroy(this);
		}
	}

	public void AddDeadEnemy()
	{
		deadEnemies++;
		if (linkedAnws.Length <= 1)
		{
			return;
		}
		ActivateNextWave[] array = linkedAnws;
		foreach (ActivateNextWave activateNextWave in array)
		{
			if (activateNextWave != this)
			{
				activateNextWave.deadEnemies++;
			}
		}
	}
}



public class ActivateNextWaveHP : MonoBehaviour
{
	public bool lastWave;

	private bool activated;

	public EnemyIdentifier target;

	public float health;

	public GameObject[] nextEnemies;

	private int currentEnemy;

	public Door[] doors;

	private int currentDoor;

	public GameObject[] toActivate;

	private bool objectsActivated;

	public Door doorForward;

	public bool forEnemies;

	private void Update()
	{
		if (activated || ((bool)target && (!target.gameObject.activeInHierarchy || !(target.health <= health)) && (!(health <= 0f) || !target.dead)))
		{
			return;
		}
		activated = true;
		if (!lastWave)
		{
			if (toActivate.Length != 0)
			{
				GameObject[] array = toActivate;
				foreach (GameObject gameObject in array)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(value: true);
					}
				}
			}
			Invoke("SpawnEnemy", 1f);
		}
		else
		{
			Invoke("EndWaves", 1f);
			if (!forEnemies)
			{
				MonoSingleton<TimeController>.Instance.SlowDown(0.15f);
			}
		}
	}

	private void SpawnEnemy()
	{
		if (nextEnemies.Length != 0 && nextEnemies.Length > currentEnemy)
		{
			if (nextEnemies[currentEnemy] != null)
			{
				nextEnemies[currentEnemy].SetActive(value: true);
			}
			currentEnemy++;
		}
		if (currentEnemy < nextEnemies.Length)
		{
			Invoke("SpawnEnemy", 0.1f);
		}
		else
		{
			Object.Destroy(this);
		}
	}

	private void EndWaves()
	{
		if (toActivate.Length != 0 && !objectsActivated)
		{
			GameObject[] array = toActivate;
			foreach (GameObject gameObject in array)
			{
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
			}
			objectsActivated = true;
			EndWaves();
		}
		else if (currentDoor < doors.Length)
		{
			doors[currentDoor].Unlock();
			if (doors[currentDoor] == doorForward)
			{
				doors[currentDoor].Open(enemy: false, skull: true);
			}
			currentDoor++;
			Invoke("EndWaves", 0.1f);
		}
		else
		{
			if (!forEnemies)
			{
				MonoSingleton<MusicManager>.Instance.ArenaMusicEnd();
				MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", 1f);
				MonoSingleton<AudioMixerController>.Instance.doorSound.SetFloat("allPitch", 1f);
			}
			Object.Destroy(this);
		}
	}
}



public class ActivateOnController : MonoBehaviour
{
	public bool oneTime;

	private bool doneOnce;

	public UltrakillEvent onController;

	public UltrakillEvent onNoController;

	private bool activated;

	private void Start()
	{
		Check();
	}

	private void Update()
	{
		Check();
	}

	private void Check()
	{
		if (!oneTime || !doneOnce)
		{
			if ((!doneOnce || activated) && (Gamepad.current == null || !Gamepad.current.enabled))
			{
				activated = false;
				onController?.Revert();
				onNoController?.Invoke();
			}
			else if (!activated && Gamepad.current != null && Gamepad.current.enabled)
			{
				activated = true;
				onController?.Invoke();
				onNoController?.Revert();
			}
			doneOnce = true;
		}
	}
}



public class ActivateOnSliderValues : MonoBehaviour
{
	public Slider[] sliders;

	public float[] values;

	public GameObject[] activateOnValues;

	public GameObject[] deactivateOnValues;

	private void Start()
	{
		CheckSliders();
	}

	private void Update()
	{
		CheckSliders();
	}

	private void CheckSliders()
	{
		int num = 0;
		for (int i = 0; i < sliders.Length; i++)
		{
			if (sliders[i].value == values[i])
			{
				num++;
			}
		}
		if (num == sliders.Length)
		{
			GameObject[] array = activateOnValues;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: true);
			}
			array = deactivateOnValues;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: false);
			}
		}
		else
		{
			GameObject[] array = activateOnValues;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: false);
			}
			array = deactivateOnValues;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: true);
			}
		}
	}
}



public class ActivateOnSoundEnd : MonoBehaviour
{
	private AudioSource aud;

	private bool hasStarted;

	[SerializeField]
	private UltrakillEvent events;

	[SerializeField]
	private bool dontWaitForStart;

	[SerializeField]
	private bool oneTime;

	private bool activated;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (aud.isPlaying || dontWaitForStart)
		{
			hasStarted = true;
		}
		if (hasStarted && (!activated || oneTime) && !aud.isPlaying && aud.time == 0f)
		{
			activated = true;
			hasStarted = false;
			events.Invoke();
			if (oneTime)
			{
				base.enabled = false;
			}
		}
	}
}



[Serializable]
public class ActivePatterns
{
	public string[] enabledPatterns;

	public string[] enabledPatternPacks;
}



[Serializable]
public struct ActivityRankIcon
{
	public string Image;

	public string Text;
}



public class AddForce : MonoBehaviour
{
	private Rigidbody rb;

	private bool valuesSet;

	public Vector3 force;

	public bool relative;

	public bool onEnable;

	public bool oneTime;

	private bool beenActivated;

	private void OnEnable()
	{
		if (onEnable)
		{
			Push();
		}
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			rb = GetComponent<Rigidbody>();
		}
	}

	private void Push()
	{
		if (!oneTime || !beenActivated)
		{
			if (!valuesSet)
			{
				SetValues();
			}
			if (relative)
			{
				rb.AddRelativeForce(force, ForceMode.VelocityChange);
			}
			else
			{
				rb.AddForce(force, ForceMode.VelocityChange);
			}
			beenActivated = true;
		}
	}
}


[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class AdditionalMapDetails : MonoSingleton<AdditionalMapDetails>
{
	public bool hasAuthorLinks;

	public AuthorLink[] authorLinks;
}



public class AddKill : MonoBehaviour
{
	private void Start()
	{
		GoreZone goreZone = GoreZone.ResolveGoreZone(base.transform);
		if (goreZone != null && goreZone.checkpoint != null)
		{
			goreZone.AddDeath();
			goreZone.checkpoint.sm.kills++;
		}
		else
		{
			MonoSingleton<StatsManager>.Instance.kills++;
		}
	}
}



public static class AddressablesExtensions
{
	private static readonly plog.Logger Log = new plog.Logger("AddressablesExtensions");

	public static GameObject ToAsset(this AssetReference reference)
	{
		return AssetHelper.LoadPrefab(reference);
	}

	public static GameObject[] ToAssets(this AssetReference[] references)
	{
		List<GameObject> list = new List<GameObject>();
		for (int i = 0; i < references.Length; i++)
		{
			if (references[i] == null || !references[i].RuntimeKeyIsValid())
			{
				Log.Warning($"Invalid asset reference at index {i}.");
				continue;
			}
			GameObject gameObject = references[i].ToAsset();
			if (gameObject == null || gameObject.Equals(null))
			{
				Log.Warning($"Failed to load asset at index {i}.\nRuntime key: {references[i].RuntimeKey}");
			}
			else
			{
				list.Add(gameObject);
			}
		}
		return list.ToArray();
	}
}



public class AdvancedOptions : MonoBehaviour
{
	public void ResetCyberGrind()
	{
		GameProgressSaver.ResetBestCyber();
	}
}


public enum AffectedSubjects
{
	All,
	PlayerOnly,
	EnemiesOnly
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class AgonyController : MonoSingleton<AgonyController>
{
	[SerializeField]
	private GameObject reloadPrompt;
}



[Serializable]
public enum AltarType
{
	Blue,
	Red,
	Stone
}



public class AlterMenuVector3Field : MonoBehaviour
{
	public TMP_Text nameText;

	public InputField xField;

	public InputField yField;

	public InputField zField;
}



[Serializable]
public struct AlterOption
{
	public string targetKey;

	[Space]
	public bool useInt;

	public int intValue;

	[Space]
	public bool useFloat;

	public float floatValue;

	[Space]
	public bool useBool;

	public bool boolValue;

	[Space]
	public bool useVector;

	public Vector3 vectorValue;
}



public class AltPickUp : MonoBehaviour
{
	public string pPref;

	public UnityEvent onPickUp;

	private void OnCollisionEnter(Collision other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			GotActivated();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			GotActivated();
		}
	}

	private void GotActivated()
	{
		GameProgressSaver.AddGear(pPref + "alt");
		MonoSingleton<PrefsManager>.Instance.SetInt("weapon." + pPref + "0", 2);
		MonoSingleton<GunSetter>.Instance.ResetWeapons();
		MonoSingleton<GunSetter>.Instance.ForceWeapon(pPref + "0");
		onPickUp?.Invoke();
		Object.Destroy(base.gameObject);
	}
}



public class AlwaysLookAtCamera : MonoBehaviour
{
	public Transform overrideTarget;

	public EnemyTarget target;

	[Space]
	[Tooltip("If the target is player (null), use the camera instead of the player head position. Helpful in third-person mode.")]
	public bool preferCameraOverHead;

	[Tooltip("Copies camera's rotation instead of looking at the camera, this will mean the object always appears flat like a sprite.")]
	public bool faceScreenInsteadOfCamera;

	public bool dontRotateIfBlind;

	public float speed;

	public bool easeIn;

	public float maxAngle;

	[Space]
	public bool useXAxis = true;

	public bool useYAxis = true;

	public bool useZAxis = true;

	[Space]
	public Vector3 rotationOffset;

	[Space]
	public float maxXAxisFromParent;

	public float maxYAxisFromParent;

	public float maxZAxisFromParent;

	[Header("Enemy")]
	public EnemyIdentifier eid;

	private int difficulty;

	public bool difficultyVariance;

	private float difficultySpeedMultiplier = 1f;

	private void Start()
	{
		if ((bool)eid && eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		UpdateDifficulty();
		EnsureTargetExists();
		SlowUpdate();
	}

	private void EnsureTargetExists()
	{
		if (target == null || !target.isValid || (overrideTarget != null && target.trackedTransform != overrideTarget))
		{
			target = ((overrideTarget == null) ? EnemyTarget.TrackPlayer() : new EnemyTarget(overrideTarget));
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.5f);
		EnsureTargetExists();
	}

	private void LateUpdate()
	{
		if (target == null || !target.isValid || (dontRotateIfBlind && BlindEnemies.Blind))
		{
			return;
		}
		float num = speed;
		if ((bool)eid)
		{
			num *= eid.totalSpeedModifier;
		}
		if (difficultyVariance)
		{
			num *= difficultySpeedMultiplier;
		}
		Transform transform = ((preferCameraOverHead && target.isPlayer) ? MonoSingleton<CameraController>.Instance.cam.transform : target.headTransform);
		if (speed == 0f && useXAxis && useYAxis && useZAxis)
		{
			if (faceScreenInsteadOfCamera)
			{
				base.transform.rotation = transform.rotation;
				base.transform.Rotate(Vector3.up * 180f, Space.Self);
			}
			else
			{
				base.transform.LookAt(transform);
			}
		}
		else
		{
			Vector3 position = transform.position;
			if (!useXAxis)
			{
				position.x = base.transform.position.x;
			}
			if (!useYAxis)
			{
				position.y = base.transform.position.y;
			}
			if (!useZAxis)
			{
				position.z = base.transform.position.z;
			}
			Quaternion quaternion = Quaternion.LookRotation(position - base.transform.position, Vector3.up);
			if (maxAngle != 0f && Quaternion.Angle(base.transform.rotation, quaternion) > maxAngle)
			{
				return;
			}
			if (speed == 0f)
			{
				base.transform.rotation = quaternion;
			}
			if (easeIn)
			{
				float num2 = 1f;
				if (difficultyVariance)
				{
					if (difficulty == 1)
					{
						num2 = 0.8f;
					}
					else if (difficulty == 0)
					{
						num2 = 0.5f;
					}
				}
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * num * (Quaternion.Angle(base.transform.rotation, quaternion) * num2));
			}
			else
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * num);
			}
		}
		if (maxXAxisFromParent != 0f)
		{
			base.transform.localRotation = Quaternion.Euler(Mathf.Clamp(base.transform.localRotation.eulerAngles.x, 0f - maxXAxisFromParent, maxXAxisFromParent), base.transform.localRotation.eulerAngles.y, base.transform.localRotation.eulerAngles.z);
		}
		if (maxYAxisFromParent != 0f)
		{
			base.transform.localRotation = Quaternion.Euler(base.transform.localRotation.eulerAngles.x, Mathf.Clamp(base.transform.localRotation.eulerAngles.y, 0f - maxYAxisFromParent, maxYAxisFromParent), base.transform.localRotation.eulerAngles.z);
		}
		if (maxZAxisFromParent != 0f)
		{
			base.transform.localRotation = Quaternion.Euler(base.transform.localRotation.eulerAngles.x, base.transform.localRotation.eulerAngles.y, Mathf.Clamp(base.transform.localRotation.eulerAngles.z, 0f - maxZAxisFromParent, maxZAxisFromParent));
		}
		if (rotationOffset != Vector3.zero)
		{
			base.transform.localRotation = Quaternion.Euler(base.transform.localRotation.eulerAngles + rotationOffset);
		}
	}

	public void ChangeOverrideTarget(EnemyTarget target)
	{
		this.target = target;
		overrideTarget = target.trackedTransform;
	}

	public void ChangeOverrideTarget(Transform target)
	{
		this.target = new EnemyTarget(target);
		overrideTarget = target;
	}

	public void SnapToTarget()
	{
		EnsureTargetExists();
		if (target != null)
		{
			Vector3 headPosition = target.headPosition;
			if (!useXAxis)
			{
				headPosition.x = base.transform.position.x;
			}
			if (!useYAxis)
			{
				headPosition.y = base.transform.position.y;
			}
			if (!useZAxis)
			{
				headPosition.z = base.transform.position.z;
			}
			Quaternion rotation = Quaternion.LookRotation(headPosition - base.transform.position);
			base.transform.rotation = rotation;
		}
	}

	public void ChangeSpeed(float newSpeed)
	{
		speed = newSpeed;
	}

	public void ChangeDifficulty(int newDiff)
	{
		difficulty = newDiff;
		UpdateDifficulty();
	}

	public void UpdateDifficulty()
	{
		if (difficulty == 1)
		{
			difficultySpeedMultiplier = 0.8f;
		}
		else if (difficulty == 0)
		{
			difficultySpeedMultiplier = 0.6f;
		}
	}
}



public class AmbientFader : MonoBehaviour
{
	private float fadeAmount = 1f;

	public float target = 1f;

	public float time;

	private bool activated;

	public bool onEnable;

	private void Start()
	{
		fadeAmount = Shader.GetGlobalFloat("_AmbientStrength");
		target = fadeAmount;
		if (onEnable)
		{
			activated = true;
		}
	}

	private void Update()
	{
		if (activated)
		{
			fadeAmount = Mathf.MoveTowards(fadeAmount, target, 1f / time * Time.deltaTime);
			Shader.SetGlobalFloat("_AmbientStrength", fadeAmount);
			if (fadeAmount == target)
			{
				activated = false;
			}
		}
	}

	public void FadeTo(float newTarget)
	{
		target = newTarget;
		if (time == 0f)
		{
			fadeAmount = target;
			Shader.SetGlobalFloat("_AmbientStrength", fadeAmount);
		}
		else
		{
			activated = true;
		}
	}
}



public class AmbientGlow : MonoBehaviour
{
	private SpriteRenderer sr;

	private float originalAlpha;

	public float glowVariance = 0.2f;

	public float glowSpeed = 0.2f;

	private float target;

	private Color clr;

	private void Start()
	{
		sr = GetComponent<SpriteRenderer>();
		originalAlpha = sr.color.a;
		target = originalAlpha + glowVariance;
	}

	private void Update()
	{
		clr = sr.color;
		clr.a = Mathf.MoveTowards(sr.color.a, target, Time.deltaTime * glowSpeed);
		sr.color = clr;
		if (clr.a == target)
		{
			if (target > originalAlpha)
			{
				target = originalAlpha - glowVariance;
			}
			else
			{
				target = originalAlpha + glowVariance;
			}
		}
	}
}



public class AnimatedTexture : MonoBehaviour
{
	[SerializeField]
	private int materialIndex;

	[SerializeField]
	private float delay;

	[SerializeField]
	private Texture2D[] framePool;

	[SerializeField]
	private TextureType textureType;

	private TimeSince counter;

	private int selector;

	private MaterialPropertyBlock block;

	private Renderer renderer;

	private static readonly int MainTexID = Shader.PropertyToID("_MainTex");

	private static readonly int EmissiveTexID = Shader.PropertyToID("_EmissiveTex");

	private int texID;

	private void Awake()
	{
		switch (textureType)
		{
		case TextureType.Main:
			texID = MainTexID;
			break;
		case TextureType.Emissive:
			texID = EmissiveTexID;
			break;
		}
		block = new MaterialPropertyBlock();
		renderer = GetComponent<Renderer>();
		renderer.GetPropertyBlock(block, materialIndex);
		counter = 0f;
	}

	private void Update()
	{
		if ((float)counter > delay)
		{
			if (selector >= framePool.Length)
			{
				selector = 0;
			}
			block.SetTexture(texID, framePool[selector]);
			renderer.SetPropertyBlock(block, materialIndex);
			selector++;
			counter = 0f;
		}
	}
}



public class AnimationEvent : MonoBehaviour
{
	[SerializeField]
	private UnityEvent onEvent;

	public void TriggerTheEvent()
	{
		onEvent.Invoke();
	}
}



[DisallowMultipleComponent]
public sealed class AnimationEventMessage : MessageDispatcher<AnimationEvent>.Callback<AnimationEventMessageEvent>
{
	private void OnAnimationEvent(AnimationEvent evt)
	{
		Handler.Invoke(evt);
	}
}



public sealed class AnimationEventMessageEvent : UnityEvent<AnimationEvent>
{
}



public class AnimationEventToUltrakillEvent : MonoBehaviour
{
	public int eventNumber;

	public UltrakillEvent onEvent;

	public void ToUltrakillEvent(int num)
	{
		if (num == eventNumber)
		{
			onEvent.Invoke();
		}
	}
}



public class AnimationSpeedRandomizer : MonoBehaviour
{
	private Animator anim;

	public float speed = 1f;

	public float maxRandomness = 0.1f;

	public bool randomizePlaybackPosition;

	private void Start()
	{
		anim = GetComponent<Animator>();
		anim.speed = speed + Random.Range(0f - maxRandomness, maxRandomness);
		if (randomizePlaybackPosition)
		{
			anim.Play(0, -1, Random.Range(0f, 1f));
		}
	}
}



public class Arena : MonoBehaviour
{
	public Door[] doors;

	private void Awake()
	{
		ActivateNextWave[] waves = GetWaves();
		AutoSetupWaves(waves);
		ActivateNextWave[] array = waves;
		for (int i = 0; i < array.Length; i++)
		{
			GameObject[] enemies = GetEnemies(array[i].transform);
			for (int j = 0; j < enemies.Length; j++)
			{
				enemies[j].SetActive(value: false);
			}
		}
	}

	public ActivateNextWave[] GetWaves()
	{
		List<ActivateNextWave> list = new List<ActivateNextWave>();
		foreach (Transform item in base.transform)
		{
			if ((bool)item.GetComponent<ActivateNextWave>())
			{
				list.Add(item.GetComponent<ActivateNextWave>());
			}
		}
		return list.ToArray();
	}

	public static GameObject[] GetEnemies(Transform target)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in target.transform)
		{
			list.Add(item.gameObject);
		}
		return list.ToArray();
	}

	public ActivateArena GetActivateArena()
	{
		return GetComponentInChildren<ActivateArena>();
	}

	private void ConfigureActivateArena(ActivateArena aa)
	{
		aa.doors = doors;
		ActivateNextWave[] waves = GetWaves();
		if (waves.Length != 0)
		{
			aa.enemies = GetEnemies(waves[0].transform);
		}
	}

	private void ConfigureWaves(ActivateNextWave[] waves)
	{
		if (waves == null || waves.Length == 0)
		{
			return;
		}
		for (int i = 0; i < waves.Length; i++)
		{
			waves[i].CountEnemies();
			if (i < waves.Length - 1)
			{
				waves[i].nextEnemies = GetEnemies(waves[i + 1].transform);
			}
			waves[i].doors = new Door[0];
			waves[i].lastWave = false;
		}
		waves[^1].doors = doors;
		waves[^1].lastWave = true;
	}

	public void AutoSetupWaves(ActivateNextWave[] waves)
	{
		ConfigureWaves(waves);
		ConfigureActivateArena(GetActivateArena());
	}

	private void OnDrawGizmosSelected()
	{
		Door[] array = doors;
		foreach (Door door in array)
		{
			Gizmos.color = new Color(1f, 1f, 0f, 0.5f);
			Vector3? vector = null;
			Vector3? vector2 = null;
			Vector3 vector3 = Vector3.zero;
			Vector3 vector4 = Vector3.zero;
			GameObject gameObject = ((door.doorType != 0) ? door.gameObject : door.transform.parent.gameObject);
			Renderer[] componentsInChildren = gameObject.GetComponentsInChildren<Renderer>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				Bounds bounds = componentsInChildren[j].bounds;
				float num = bounds.center.x - bounds.size.x;
				float num2 = bounds.center.x + bounds.size.x;
				float num3 = bounds.center.y - bounds.size.y;
				float num4 = bounds.center.y + bounds.size.y;
				float num5 = bounds.center.z - bounds.size.z;
				float num6 = bounds.center.z + bounds.size.z;
				if (!vector.HasValue)
				{
					vector4 = new Vector3(num, num3, num5);
					vector3 = new Vector3(num2, num4, num6);
					vector2 = new Vector3(vector3.x - vector4.x, vector3.y - vector4.y, vector3.z - vector4.z);
					vector = new Vector3(num + vector2.Value.x / 2f, num3 + vector2.Value.y / 2f, num5 + vector2.Value.z / 2f);
					continue;
				}
				if (num < vector4.x)
				{
					vector4.x = num;
				}
				if (vector3.x < num2)
				{
					vector3.x = num2;
				}
				if (num3 < vector4.y)
				{
					vector4.y = num3;
				}
				if (vector3.y < num4)
				{
					vector3.y = num4;
				}
				if (num5 < vector4.z)
				{
					vector4.z = num5;
				}
				if (vector3.z < num6)
				{
					vector3.z = num6;
				}
			}
			vector2 = new Vector3(vector3.x - vector4.x, vector3.y - vector4.y, vector3.z - vector4.z);
			vector = new Vector3(vector4.x + vector2.Value.x / 2f, vector4.y + vector2.Value.y / 2f, vector4.z + vector2.Value.z / 2f);
			Gizmos.color = new Color(1f, 1f, 0f, 1f);
			Gizmos.DrawWireCube(vector.Value, vector2.Value * 0.75f);
			Gizmos.color = new Color(1f, 1f, 0f, 0.15f);
			Gizmos.DrawCube(vector.Value, vector2.Value * 0.75f);
		}
	}
}



[CreateAssetMenu(menuName = "ULTRAKILL/Arena Pattern")]
public class ArenaPattern : ScriptableObject
{
	[TextArea(16, 16)]
	public string heights = "0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000";

	[TextArea(16, 16)]
	public string prefabs = "0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000";
}



public class ArenaStatus : MonoBehaviour
{
	public int currentStatus;

	public void SetStatus(int i)
	{
		currentStatus = i;
	}

	public void AddToStatus(int i)
	{
		currentStatus += i;
	}
}



[Serializable]
public class ArmVariantSetting
{
	public VariantOption blueVariant;

	public VariantOption redVariant;

	public VariantOption greenVariant;
}



public class AspectRatioChanger : MonoBehaviour
{
	private AspectRatioFitter arf;

	public float targetRatio = 1.7778f;

	public float speed = 1f;

	private void Start()
	{
		arf = GetComponent<AspectRatioFitter>();
		if (targetRatio == 0f)
		{
			targetRatio = arf.aspectRatio;
		}
	}

	private void Update()
	{
		if ((bool)arf && arf.aspectRatio != targetRatio)
		{
			arf.aspectRatio = Mathf.MoveTowards(arf.aspectRatio, targetRatio, Time.deltaTime * speed);
		}
	}

	public void ChangeRatio(float ratio)
	{
		targetRatio = ratio;
	}

	public void ChangeSpeed(float newSpeed)
	{
		speed = newSpeed;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance | SingletonFlags.PersistAutoInstance | SingletonFlags.DestroyDuplicates)]
public class AssetHelper : MonoSingleton<AssetHelper>
{
	private static readonly plog.Logger Log = new plog.Logger("AssetHelper");

	private Dictionary<string, GameObject> prefabCache = new Dictionary<string, GameObject>();

	protected override void OnEnable()
	{
		base.OnEnable();
		Object.DontDestroyOnLoad(base.gameObject);
	}

	public static GameObject LoadPrefab(string address)
	{
		if (MonoSingleton<AssetHelper>.Instance.prefabCache.ContainsKey(address))
		{
			if (!(MonoSingleton<AssetHelper>.Instance.prefabCache[address] == null) && !MonoSingleton<AssetHelper>.Instance.prefabCache[address].Equals(null))
			{
				return MonoSingleton<AssetHelper>.Instance.prefabCache[address];
			}
			MonoSingleton<AssetHelper>.Instance.prefabCache.Remove(address);
		}
		GameObject gameObject = Addressables.LoadAssetAsync<GameObject>(address).WaitForCompletion();
		MonoSingleton<AssetHelper>.Instance.prefabCache.Add(address, gameObject);
		return gameObject;
	}

	public static GameObject LoadPrefab(AssetReference reference)
	{
		if (reference == null || reference.Equals(null) || reference.RuntimeKey == null || !reference.RuntimeKeyIsValid())
		{
			Log.Warning($"Missing asset reference.\nRuntime key: {reference.RuntimeKey}");
			return null;
		}
		string key = reference.RuntimeKey.ToString();
		if (MonoSingleton<AssetHelper>.Instance.prefabCache.ContainsKey(key))
		{
			if (!(MonoSingleton<AssetHelper>.Instance.prefabCache[key] == null) && !MonoSingleton<AssetHelper>.Instance.prefabCache[key].Equals(null))
			{
				return MonoSingleton<AssetHelper>.Instance.prefabCache[key];
			}
			MonoSingleton<AssetHelper>.Instance.prefabCache.Remove(key);
		}
		GameObject gameObject = reference.LoadAssetAsync<GameObject>().WaitForCompletion();
		MonoSingleton<AssetHelper>.Instance.prefabCache.Add(key, gameObject);
		return gameObject;
	}

	public static void SpawnPrefabAsync(string prefab, Vector3 position, Quaternion rotation)
	{
		MonoSingleton<AssetHelper>.Instance.StartCoroutine(MonoSingleton<AssetHelper>.Instance.LoadPrefab(prefab, position, rotation));
	}

	public IEnumerator LoadPrefab(string prefab, Vector3 position, Quaternion rotation)
	{
		AsyncOperationHandle<GameObject> loadOperation = Addressables.LoadAssetAsync<GameObject>(prefab);
		yield return loadOperation;
		Object.Instantiate(loadOperation.Result, position, rotation);
	}
}



[Serializable]
public class AssetReferenceSoundtrackSong : AssetReferenceT<SoundtrackSong>
{
	public AssetReferenceSoundtrackSong(string guid)
		: base(guid)
	{
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class AssistController : MonoSingleton<AssistController>
{
	public bool majorEnabled;

	[HideInInspector]
	public bool cheatsEnabled;

	[HideInInspector]
	public bool hidePopup;

	[HideInInspector]
	public float gameSpeed;

	[HideInInspector]
	public float damageTaken;

	[HideInInspector]
	public bool infiniteStamina;

	[HideInInspector]
	public bool disableHardDamage;

	[HideInInspector]
	public bool disableWhiplashHardDamage;

	[HideInInspector]
	public bool disableWeaponFreshness;

	public int punchAssistFrames = 6;

	[HideInInspector]
	public int difficultyOverride = -1;

	private StatsManager sman;

	private void Start()
	{
		majorEnabled = MonoSingleton<PrefsManager>.Instance.GetBool("majorAssist");
		gameSpeed = MonoSingleton<PrefsManager>.Instance.GetFloat("gameSpeed");
		damageTaken = MonoSingleton<PrefsManager>.Instance.GetFloat("damageTaken");
		infiniteStamina = MonoSingleton<PrefsManager>.Instance.GetBool("infiniteStamina");
		disableHardDamage = MonoSingleton<PrefsManager>.Instance.GetBool("disableHardDamage");
		disableWhiplashHardDamage = MonoSingleton<PrefsManager>.Instance.GetBool("disableWhiplashHardDamage");
		disableWeaponFreshness = MonoSingleton<PrefsManager>.Instance.GetBool("disableWeaponFreshness");
	}

	public void MajorEnabled()
	{
		majorEnabled = true;
		if (sman == null)
		{
			sman = MonoSingleton<StatsManager>.Instance;
		}
		sman.MajorUsed();
	}
}



public class AssistOptions : MonoBehaviour
{
	public Toggle majorEnable;

	public Slider gameSpeed;

	public Slider damageTaken;

	public Toggle infiniteStamina;

	public Toggle disableWhiplashHardDamage;

	public Toggle disableHardDamage;

	public Toggle disableWeaponFreshness;

	public Toggle autoAim;

	public Slider autoAimSlider;

	public TMP_Dropdown bossDifficultyOverride;

	public Toggle hidePopup;

	public GameObject autoAimGroup;

	public GameObject majorPopup;

	public GameObject majorBlocker;

	public static float autoAimAmount;

	private void Start()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetBool("majorAssist"))
		{
			majorEnable.isOn = true;
			majorBlocker.SetActive(value: false);
		}
		else
		{
			majorEnable.isOn = false;
			majorBlocker.SetActive(value: true);
		}
		gameSpeed.value = MonoSingleton<PrefsManager>.Instance.GetFloat("gameSpeed") * 100f;
		damageTaken.value = MonoSingleton<PrefsManager>.Instance.GetFloat("damageTaken") * 100f;
		infiniteStamina.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("infiniteStamina");
		disableWhiplashHardDamage.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("disableWhiplashHardDamage");
		disableHardDamage.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("disableHardDamage");
		disableWeaponFreshness.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("disableWeaponFreshness");
		autoAim.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("autoAim");
		bossDifficultyOverride.value = MonoSingleton<PrefsManager>.Instance.GetInt("bossDifficultyOverride");
		bossDifficultyOverride.RefreshShownValue();
		MonoSingleton<AssistController>.Instance.difficultyOverride = bossDifficultyOverride.value - 1;
		hidePopup.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("hideMajorAssistPopup");
		autoAimSlider.value = MonoSingleton<PrefsManager>.Instance.GetFloat("autoAimAmount") * 100f;
		MonoSingleton<CameraFrustumTargeter>.Instance.maxHorAim = autoAimSlider.value / 100f;
	}

	public void MajorCheck()
	{
		if (!MonoSingleton<PrefsManager>.Instance.GetBool("majorAssist"))
		{
			majorPopup.SetActive(value: true);
			return;
		}
		MonoSingleton<PrefsManager>.Instance.SetBool("majorAssist", content: false);
		MonoSingleton<AssistController>.Instance.majorEnabled = false;
		majorEnable.isOn = false;
		majorBlocker.SetActive(value: true);
	}

	public void MajorEnable()
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("majorAssist", content: true);
		MonoSingleton<AssistController>.Instance.MajorEnabled();
		majorEnable.isOn = true;
		majorBlocker.SetActive(value: false);
	}

	public void GameSpeed(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("gameSpeed", stuff / 100f);
		MonoSingleton<AssistController>.Instance.gameSpeed = stuff / 100f;
	}

	public void DamageTaken(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("damageTaken", stuff / 100f);
		MonoSingleton<AssistController>.Instance.damageTaken = stuff / 100f;
	}

	public void InfiniteStamina(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("infiniteStamina", stuff);
		MonoSingleton<AssistController>.Instance.infiniteStamina = stuff;
	}

	public void DisableWhiplashHardDamage(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("disableWhiplashHardDamage", stuff);
		MonoSingleton<AssistController>.Instance.disableWhiplashHardDamage = stuff;
	}

	public void DisableHardDamage(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("disableHardDamage", stuff);
		MonoSingleton<AssistController>.Instance.disableHardDamage = stuff;
	}

	public void DisableWeaponFreshness(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("disableWeaponFreshness", stuff);
		MonoSingleton<AssistController>.Instance.disableWeaponFreshness = stuff;
	}

	public void HidePopup(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("hideMajorAssistPopup", stuff);
		MonoSingleton<AssistController>.Instance.hidePopup = stuff;
	}

	public void AutoAim(bool stuff)
	{
		CameraFrustumTargeter.IsEnabled = stuff;
		autoAimGroup.SetActive(stuff);
	}

	public void AutoAimAmount(float stuff)
	{
		if (CameraFrustumTargeter.IsEnabled && (bool)MonoSingleton<CameraFrustumTargeter>.Instance)
		{
			MonoSingleton<CameraFrustumTargeter>.Instance.maxHorAim = stuff / 100f;
		}
		MonoSingleton<PrefsManager>.Instance.SetFloat("autoAimAmount", stuff / 100f);
	}

	public void BossDifficultyOverride(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("bossDifficultyOverride", stuff);
		MonoSingleton<AssistController>.Instance.difficultyOverride = stuff - 1;
	}
}



public class AttackTrail : MonoBehaviour
{
	public Transform target;

	public Transform pivot;

	public int distance;

	private void Update()
	{
		if ((bool)target && (bool)pivot)
		{
			Vector3 position = target.position;
			Vector3 position2 = target.position + (target.position - pivot.position).normalized * distance;
			Quaternion rotation = Quaternion.LookRotation(base.transform.position - position);
			base.transform.SetPositionAndRotation(position2, rotation);
		}
	}

	public void DelayedDestroy(float time)
	{
		Invoke("DestroyNow", time);
	}

	private void DestroyNow()
	{
		Object.Destroy(base.gameObject);
	}
}



public class AttributeChecker : MonoBehaviour
{
	public HitterAttribute targetAttribute;

	public GameObject toActivate;

	public void DelayedActivate(float time = 0.5f)
	{
		Invoke("Activate", time);
	}

	public void Activate()
	{
		toActivate.gameObject.SetActive(value: true);
		base.gameObject.SetActive(value: false);
	}
}



public class AudioContinueOnEnable : MonoBehaviour
{
	public bool autoStartIfNotPlaying = true;

	private bool wasPlaying;

	private float currentTime;

	private AudioSource aud;

	private void OnEnable()
	{
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		if (!aud.isPlaying && (autoStartIfNotPlaying || wasPlaying))
		{
			aud.Play();
			aud.time = currentTime;
		}
	}

	private void Update()
	{
		if (aud.isPlaying)
		{
			currentTime = aud.time;
			wasPlaying = true;
		}
		else
		{
			wasPlaying = false;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
[DefaultExecutionOrder(-10)]
public class AudioMixerController : MonoSingleton<AudioMixerController>
{
	[Header("Mixers")]
	public AudioMixer allSound;

	public AudioMixer goreSound;

	public AudioMixer musicSound;

	public AudioMixer doorSound;

	public AudioMixer unfreezeableSound;

	[Header("Mixer Groups")]
	public AudioMixerGroup allGroup;

	public AudioMixerGroup goreGroup;

	public AudioMixerGroup musicGroup;

	public AudioMixerGroup doorGroup;

	public AudioMixerGroup unfreezeableGroup;

	[HideInInspector]
	public float sfxVolume;

	[HideInInspector]
	public float musicVolume;

	[HideInInspector]
	public float optionsMusicVolume;

	[HideInInspector]
	public bool muffleMusic;

	[Space]
	public bool forceOff;

	private float temporaryDipAmount;

	private bool isUnderWater;

	protected override void Awake()
	{
		sfxVolume = MonoSingleton<PrefsManager>.Instance.GetFloat("sfxVolume");
		optionsMusicVolume = MonoSingleton<PrefsManager>.Instance.GetFloat("musicVolume");
		musicVolume = optionsMusicVolume;
		muffleMusic = MonoSingleton<PrefsManager>.Instance.GetBool("muffleMusic");
		if (!forceOff)
		{
			SetSFXVolume(sfxVolume);
			musicSound.SetFloat("allVolume", CalculateVolume(optionsMusicVolume));
		}
		IsInWater(isInWater: false);
	}

	private void Update()
	{
		if (musicVolume > optionsMusicVolume)
		{
			SetMusicVolume(optionsMusicVolume);
		}
		UpdateSFXVolume();
	}

	public void SetMusicVolume(float volume)
	{
		if (!forceOff)
		{
			musicSound.SetFloat("allVolume", CalculateVolume(volume));
		}
		musicVolume = volume;
	}

	public void SetSFXVolume(float volume)
	{
		sfxVolume = volume;
		UpdateSFXVolume();
	}

	private void UpdateSFXVolume()
	{
		float value;
		if (!forceOff)
		{
			allSound.SetFloat("allVolume", CalculateVolume((allSound.GetFloat("allPitch", out value) && value == 0f) ? 0f : sfxVolume) + temporaryDipAmount);
		}
		goreSound.SetFloat("allVolume", CalculateVolume((goreSound.GetFloat("allPitch", out value) && value == 0f) ? 0f : sfxVolume) + temporaryDipAmount);
		doorSound.SetFloat("allVolume", CalculateVolume((doorSound.GetFloat("allPitch", out value) && value == 0f) ? 0f : sfxVolume) + temporaryDipAmount);
		unfreezeableSound.SetFloat("allVolume", CalculateVolume((unfreezeableSound.GetFloat("allPitch", out value) && value == 0f) ? 0f : sfxVolume) + temporaryDipAmount);
	}

	public void TemporaryDip(float amount)
	{
		temporaryDipAmount = amount;
		SetSFXVolume(sfxVolume);
	}

	public float CalculateVolume(float volume)
	{
		if (volume > 0f)
		{
			return Mathf.Log10(volume) * 20f;
		}
		return -80f;
	}

	public void IsInWater(bool isInWater)
	{
		float value = ((!isInWater) ? (-80) : 0);
		isUnderWater = isInWater;
		allSound.SetFloat("lowPassVolume", value);
		if (muffleMusic || !isInWater)
		{
			musicSound.SetFloat("lowPassVolume", value);
		}
		goreSound.SetFloat("lowPassVolume", value);
		doorSound.SetFloat("lowPassVolume", value);
		unfreezeableSound.SetFloat("lowPassVolume", value);
	}

	public void MuffleMusic(bool isOn)
	{
		muffleMusic = isOn;
		if (!isOn)
		{
			musicSound.SetFloat("lowPassVolume", -80f);
		}
		else if (isUnderWater)
		{
			musicSound.SetFloat("lowPassVolume", 0f);
		}
	}
}



[CreateAssetMenu(fileName = "AudioSubtitle", menuName = "ULTRAKILL/Subtitle")]
public class AudioSubtitle : ScriptableObject
{
}



public static class AudioTypeEx
{
	public const AudioType ASF = (AudioType)3;

	public const AudioType AT3 = (AudioType)4;

	public const AudioType CDDA = (AudioType)5;

	public const AudioType DLS = (AudioType)6;

	public const AudioType FLAC = (AudioType)7;

	public const AudioType FSB = (AudioType)8;

	public const AudioType GCADPCM = (AudioType)9;

	public const AudioType MIDI = (AudioType)11;

	public const AudioType PLAYLIST = (AudioType)15;

	public const AudioType RAW = (AudioType)16;

	public const AudioType SF2 = (AudioType)18;

	public const AudioType USER = (AudioType)19;

	public const AudioType XWMA = (AudioType)25;

	public const AudioType BCWAV = (AudioType)26;

	public const AudioType AT9 = (AudioType)27;

	public const AudioType PCM = (AudioType)28;

	public const AudioType ADPCM = (AudioType)29;
}



[Serializable]
public class AuthorLink
{
	public LinkPlatform platform;

	public string username;

	public string displayName;

	[Header("Optional")]
	public string description;
}



public class AuthorLinkRow : MonoBehaviour
{
	public Text platformName;

	public Text platformUsername;

	public Text platformDisplayName;

	public Text description;

	private string url;

	public void Instantiate(string platform, string username, string displayName, Color platformColor, string targetURL, string descriptionText = "")
	{
		AuthorLinkRow authorLinkRow = Object.Instantiate(this, base.transform.parent, worldPositionStays: false);
		authorLinkRow.platformName.text = platform;
		authorLinkRow.platformName.color = platformColor;
		authorLinkRow.platformUsername.text = username;
		authorLinkRow.platformDisplayName.text = displayName;
		authorLinkRow.description.text = descriptionText;
		authorLinkRow.url = targetURL;
		authorLinkRow.gameObject.SetActive(value: true);
	}

	public void OnClick()
	{
		Application.OpenURL(url);
	}
}



public class AutoRegisterState : MonoBehaviour
{
	public string stateKey;

	[Space]
	public bool trackSelf = true;

	[Tooltip("If any of the tracked objects remain active, the state will be considered valid")]
	public GameObject[] additionalTrackedObjects;

	[FormerlySerializedAs("playerInputBlocking")]
	[Space]
	public LockMode playerInputLock;

	[FormerlySerializedAs("cameraInputBlocking")]
	public LockMode cameraInputLock;

	public LockMode cursorLock;

	[Space]
	public int priority = 1;

	private GameState ownState;

	private void OnEnable()
	{
		List<GameObject> list = new List<GameObject>();
		if (trackSelf)
		{
			list.Add(base.gameObject);
		}
		if (additionalTrackedObjects != null)
		{
			list.AddRange(additionalTrackedObjects);
		}
		if (ownState == null)
		{
			if (list.Count == 0)
			{
				ownState = new GameState(stateKey);
			}
			else if (list.Count == 1)
			{
				ownState = new GameState(stateKey, list[0]);
			}
			else
			{
				ownState = new GameState(stateKey, list.ToArray());
			}
		}
		ownState.playerInputLock = playerInputLock;
		ownState.cameraInputLock = cameraInputLock;
		ownState.cursorLock = cursorLock;
		ownState.priority = priority;
		GameStateManager.Instance.RegisterState(ownState);
	}

	private void OnDestroy()
	{
		GameStateManager.Instance.PopState(stateKey);
	}
}



internal class BackSelectEvent : MonoBehaviour
{
	[SerializeField]
	private UnityEvent m_OnBack;

	public void InvokeOnBack()
	{
		m_OnBack?.Invoke();
	}
}



public class BackSelectOverride : MonoBehaviour
{
	[SerializeField]
	public Selectable Selectable;
}



public class BaitItem : MonoBehaviour
{
	[SerializeField]
	private bool silentFail;

	[SerializeField]
	private GameObject consumedPrefab;

	[SerializeField]
	private FishObject[] attractFish;

	[SerializeField]
	private FishDB[] supportedWaters;

	private bool used;

	private void OnTriggerEnter(Collider other)
	{
		if (used || other.gameObject.layer != 4)
		{
			return;
		}
		Water component = other.GetComponent<Water>();
		if (component.fishDB == null)
		{
			return;
		}
		used = true;
		if (!supportedWaters.Contains(component.fishDB))
		{
			if (!silentFail)
			{
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=red>This bait didn't work here!</color>");
			}
		}
		else
		{
			Object.Instantiate(consumedPrefab, base.transform.position, Quaternion.identity);
			component.attractFish = attractFish;
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("A fish took the bait.");
			Object.Destroy(base.gameObject);
		}
	}
}



public class BakeVertexLights : MonoBehaviour
{
	public List<Renderer> bakedRenderers;

	private MaterialPropertyBlock[] rendPropBlocks;

	[HideInInspector]
	public int UVTargetChannel = 2;

	private float _strength;

	public float Strength
	{
		get
		{
			return _strength;
		}
		set
		{
			if (_strength != value)
			{
				_strength = value;
				UpdateChannelStrength(UVTargetChannel, _strength);
			}
		}
	}

	private void Start()
	{
		rendPropBlocks = new MaterialPropertyBlock[bakedRenderers.Count];
		for (int i = 0; i < bakedRenderers.Count; i++)
		{
			MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
			bakedRenderers[i].GetPropertyBlock(materialPropertyBlock);
			MonoBehaviour.print(materialPropertyBlock.isEmpty);
			rendPropBlocks[i] = materialPropertyBlock;
		}
	}

	private void Update()
	{
		float value = Mathf.Sin(Time.time * 10f) * 0.5f + 0.5f;
		float value2 = Mathf.Sin(Time.time * 10f + 3.14f) * 0.5f + 0.5f;
		for (int i = 0; i < bakedRenderers.Count; i++)
		{
			MaterialPropertyBlock materialPropertyBlock = rendPropBlocks[i];
			materialPropertyBlock.SetFloat("_BakedLights1Strength", value);
			materialPropertyBlock.SetFloat("_BakedLights2Strength", value2);
			bakedRenderers[i].SetPropertyBlock(materialPropertyBlock);
		}
	}

	private void UpdateChannelStrength(int targetChannel, float strength)
	{
		int num = Mathf.Clamp(targetChannel - 2, 1, 6);
		string text = $"_BakedLights{num}Strength";
		strength = Mathf.Clamp01(strength);
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		foreach (Renderer bakedRenderer in bakedRenderers)
		{
			bakedRenderer.GetPropertyBlock(materialPropertyBlock);
			materialPropertyBlock.SetFloat(text, strength);
			bakedRenderer.SetPropertyBlock(materialPropertyBlock);
		}
	}
}



public class BasicConfirmationDialog : MonoBehaviour
{
	[SerializeField]
	private GameObject blocker;

	[SerializeField]
	private UnityEvent onConfirm;

	public void ShowDialog()
	{
		base.gameObject.SetActive(value: true);
		blocker.SetActive(value: true);
	}

	private void Update()
	{
		if (MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame || (Gamepad.current != null && Gamepad.current.buttonEast.wasPressedThisFrame))
		{
			Cancel();
		}
	}

	public void Confirm()
	{
		base.gameObject.SetActive(value: false);
		blocker.SetActive(value: false);
		onConfirm.Invoke();
	}

	public void Cancel()
	{
		base.gameObject.SetActive(value: false);
		blocker.SetActive(value: false);
	}
}



public class BasicEnemyDataRelay : MonoBehaviour, IPlaceholdableComponent
{
	[HideInInspector]
	public EnemyType enemyType;

	[HideInInspector]
	public float health = 1f;

	public void WillReplace(GameObject oldObject, GameObject newObject, bool isSelfBeingReplaced)
	{
		if (isSelfBeingReplaced)
		{
			BasicEnemyDataRelay component = newObject.GetComponent<BasicEnemyDataRelay>();
			if ((bool)component)
			{
				component.Apply(this);
			}
		}
	}

	private void Apply(BasicEnemyDataRelay source)
	{
		if (TryGetComponent<Zombie>(out var component))
		{
			component.health = source.health;
		}
		if (TryGetComponent<Drone>(out var component2))
		{
			component2.health = source.health;
		}
		if (TryGetComponent<Machine>(out var component3))
		{
			component3.health = source.health;
		}
		Statue componentInChildren = GetComponentInChildren<Statue>();
		if ((bool)componentInChildren)
		{
			componentInChildren.health = source.health;
		}
		SpiderBody componentInChildren2 = GetComponentInChildren<SpiderBody>();
		if ((bool)componentInChildren2)
		{
			componentInChildren2.health = source.health;
		}
	}
}



public class BattleDimmingLights : MonoBehaviour
{
	private Light[] lights;

	private float[] intensities;

	private float lerp = 1f;

	public float speedMultiplier = 1f;

	public bool disabledUnlessAlwaysDark;

	[Header("Ambient Color")]
	public bool dimAmbientLight;

	private Color originalAmbientLightColor;

	public Color dimmedAmbientLightColor;

	private void Start()
	{
		lights = GetComponentsInChildren<Light>();
		intensities = new float[lights.Length];
		for (int i = 0; i < lights.Length; i++)
		{
			intensities[i] = lights[i].intensity;
		}
		originalAmbientLightColor = RenderSettings.ambientLight;
	}

	private void Update()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetBool("level_7-1.alwaysDark"))
		{
			for (int i = 0; i < lights.Length; i++)
			{
				lights[i].intensity = 0f;
			}
			if (dimAmbientLight)
			{
				RenderSettings.ambientLight = dimmedAmbientLightColor;
			}
		}
		else if (!disabledUnlessAlwaysDark && (MonoSingleton<MusicManager>.Instance.IsInBattle() || lerp < 1f))
		{
			lerp = Mathf.MoveTowards(lerp, (!MonoSingleton<MusicManager>.Instance.IsInBattle()) ? 1 : 0, Time.deltaTime * speedMultiplier);
			for (int j = 0; j < lights.Length; j++)
			{
				lights[j].intensity = Mathf.Lerp(0f, intensities[j], lerp);
			}
			if (dimAmbientLight)
			{
				RenderSettings.ambientLight = Color.Lerp(dimmedAmbientLightColor, originalAmbientLightColor, lerp);
			}
		}
	}

	public void Active(bool stuff)
	{
		disabledUnlessAlwaysDark = !stuff;
	}
}



public class Beamgun : MonoBehaviour
{
	[SerializeField]
	private Transform shootPoint;

	[SerializeField]
	private BeamgunBeam beam;

	[SerializeField]
	private GameObject beamDrone;

	private GameObject currentBeamDrone;

	private float tempWidthCooldown;

	private void Start()
	{
	}

	private void Update()
	{
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			if (!beam.gameObject.activeSelf)
			{
				beam.gameObject.SetActive(value: true);
			}
			beam.fakeStartPoint = shootPoint.position;
			float num = Mathf.Clamp(MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 5f, 0.1f, 0.25f);
			if (beam.beamWidth > num)
			{
				tempWidthCooldown = Mathf.MoveTowards(tempWidthCooldown, 1f, Time.deltaTime * 50f);
				if (tempWidthCooldown >= 1f)
				{
					beam.beamWidth = num;
				}
			}
			else
			{
				tempWidthCooldown = Mathf.MoveTowards(tempWidthCooldown, 0f, Time.deltaTime * 50f);
				beam.beamWidth = num;
			}
			beam.beamCheckSpeed = 1f + (num - 0.1f) * 5f;
		}
		else if (beam.gameObject.activeSelf)
		{
			beam.gameObject.SetActive(value: false);
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame)
		{
			if (!currentBeamDrone)
			{
				currentBeamDrone = Object.Instantiate(beamDrone, base.transform.position + base.transform.forward, base.transform.rotation);
			}
			else
			{
				Object.Destroy(currentBeamDrone);
			}
		}
	}
}



public class BeamgunBeam : MonoBehaviour
{
	public bool active = true;

	[SerializeField]
	private LineRenderer line;

	[HideInInspector]
	public Vector3 fakeStartPoint;

	[SerializeField]
	private ParticleSystem hitParticle;

	private EnemyIdentifierIdentifier hitTarget;

	private Vector3 hitPosition;

	public bool canHitPlayer;

	private float beamCheckTime;

	public float beamCheckSpeed = 1f;

	private float playerDamageCooldown;

	public float beamWidth = 0.1f;

	private void Start()
	{
		line.widthMultiplier = beamWidth;
		hitParticle.transform.localScale = Vector3.one * beamWidth * 5f;
	}

	private void FixedUpdate()
	{
		if (beamCheckTime > 0f)
		{
			beamCheckTime = Mathf.MoveTowards(beamCheckTime, 0f, Time.deltaTime * beamCheckSpeed * 15f);
		}
		if (beamCheckTime <= 0f)
		{
			beamCheckTime = 1f;
			if ((bool)hitTarget)
			{
				hitTarget.eid.DeliverDamage(hitTarget.transform.gameObject, (hitPosition - base.transform.position).normalized * 10f, hitPosition, 0.15f, tryForExplode: false, 0.5f);
			}
		}
	}

	private void Update()
	{
		hitTarget = null;
		if (playerDamageCooldown > 0f)
		{
			playerDamageCooldown = Mathf.MoveTowards(playerDamageCooldown, 0f, Time.deltaTime);
		}
		if (active)
		{
			line.enabled = true;
			if (line.widthMultiplier != beamWidth)
			{
				line.widthMultiplier = Mathf.MoveTowards(line.widthMultiplier, beamWidth, Time.deltaTime * 25f);
				hitParticle.transform.localScale = Vector3.one * line.widthMultiplier * 5f;
			}
			if (fakeStartPoint != Vector3.zero)
			{
				line.SetPosition(0, fakeStartPoint);
			}
			else
			{
				line.SetPosition(0, line.transform.position);
			}
			hitPosition = base.transform.position + base.transform.forward * 9999f;
			Vector3 forward = base.transform.forward * -1f;
			LayerMask layerMask = LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment);
			if (canHitPlayer && playerDamageCooldown <= 0f)
			{
				layerMask = LayerMaskDefaults.Get(LMD.EnemiesEnvironmentAndPlayer);
			}
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, float.PositiveInfinity, layerMask, QueryTriggerInteraction.Ignore))
			{
				Breakable component2;
				if (hitInfo.transform.gameObject.layer != 8 && hitInfo.transform.gameObject.layer != 24)
				{
					if (hitInfo.collider.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
					{
						MonoSingleton<NewMovement>.Instance.GetHurt(10, invincible: true);
						playerDamageCooldown = 1f;
					}
					else if (hitInfo.transform.gameObject.layer == 10 || hitInfo.transform.gameObject.layer == 11)
					{
						if (hitInfo.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
						{
							hitTarget = component;
						}
						else
						{
							Grenade componentInParent = hitInfo.transform.GetComponentInParent<Grenade>();
							if ((bool)componentInParent)
							{
								componentInParent.Explode(big: true);
							}
						}
					}
				}
				else if (hitInfo.transform.gameObject.CompareTag("Breakable") && hitInfo.transform.TryGetComponent<Breakable>(out component2) && !component2.precisionOnly)
				{
					component2.Break();
				}
				hitPosition = hitInfo.point;
				forward = hitInfo.normal;
			}
			line.SetPosition(1, hitPosition);
			hitParticle.transform.position = hitPosition;
			hitParticle.transform.forward = forward;
			if (!hitParticle.isPlaying)
			{
				hitParticle.Play();
			}
		}
		else
		{
			if (line.enabled)
			{
				line.enabled = false;
			}
			if (hitParticle.isPlaying)
			{
				hitParticle.Stop();
			}
		}
	}
}


public enum BeamType
{
	Revolver,
	Railgun,
	MaliciousFace,
	Enemy
}



public class BeatInfo : MonoBehaviour
{
	[HideInInspector]
	public bool valuesSet;

	public float bpm;

	public float timeSignature;

	[HideInInspector]
	public AudioSource aud;

	public TimeSignatureChange[] timeSignatureChanges;

	public void SetValues()
	{
		if (valuesSet)
		{
			return;
		}
		valuesSet = true;
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		if (timeSignatureChanges.Length != 0)
		{
			float num = 0f;
			float num2 = timeSignature;
			float num3 = 0f;
			for (int i = 0; i < timeSignatureChanges.Length; i++)
			{
				timeSignatureChanges[i].time = num + 60f / bpm * 4f * (timeSignatureChanges[i].onMeasure - num3 - 1f) * num2;
				num = timeSignatureChanges[i].time;
				num2 = timeSignatureChanges[i].timeSignature;
				num3 = timeSignatureChanges[i].onMeasure - 1f;
			}
		}
	}
}



public class BestiaryCheck : MonoBehaviour
{
	public EnemyType enemy;

	public bool killRequired;

	public UltrakillEvent onEnemyUnlocked;

	private void Start()
	{
		int[] bestiary = GameProgressSaver.GetBestiary();
		if (bestiary.Length > (int)enemy && bestiary[(int)enemy] >= ((!killRequired) ? 1 : 2))
		{
			onEnemyUnlocked?.Invoke();
		}
	}
}



[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class BestiaryData : MonoSingleton<BestiaryData>
{
	private bool checkedSave;

	private Dictionary<EnemyType, int> foundEnemies = new Dictionary<EnemyType, int>();

	private void InitDictionary()
	{
		foundEnemies.Clear();
		foreach (object value in Enum.GetValues(typeof(EnemyType)))
		{
			foundEnemies.Add((EnemyType)value, 0);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		base.gameObject.AddComponent<UnlockablesData>();
	}

	private void Start()
	{
		if (!checkedSave)
		{
			CheckSave();
		}
	}

	public int GetEnemy(EnemyType enemy)
	{
		if (!checkedSave)
		{
			CheckSave();
		}
		return foundEnemies[enemy];
	}

	public void SetEnemy(EnemyType enemy, int newState = 2)
	{
		if (!checkedSave)
		{
			CheckSave();
		}
		if (foundEnemies[enemy] >= newState)
		{
			return;
		}
		foundEnemies[enemy] = newState;
		GameProgressSaver.SetBestiary(enemy, newState);
		foreach (EnemyInfoPage instance in ListComponent<EnemyInfoPage>.InstanceList)
		{
			instance.UpdateInfo();
			instance.DisplayInfo();
		}
	}

	public void CheckSave()
	{
		checkedSave = true;
		InitDictionary();
		int[] bestiary = GameProgressSaver.GetBestiary();
		for (int i = 0; i < bestiary.Length; i++)
		{
			int value = bestiary[i];
			foundEnemies[(EnemyType)i] = value;
		}
	}
}



public class BigDoor : MonoBehaviour
{
	public bool open;

	[HideInInspector]
	public bool gotPos;

	public Vector3 openRotation;

	[HideInInspector]
	public Quaternion targetRotation;

	[HideInInspector]
	public Quaternion origRotation;

	public float speed;

	private float tempSpeed;

	public float gradualSpeedMultiplier;

	private CameraController cc;

	public bool screenShake;

	private AudioSource aud;

	public AudioClip openSound;

	public AudioClip closeSound;

	private float origPitch;

	public Light openLight;

	public bool reverseDirection;

	private Door controller;

	public bool playerSpeedMultiplier;

	private void Awake()
	{
		if (!gotPos)
		{
			targetRotation.eulerAngles = base.transform.localRotation.eulerAngles + openRotation;
			origRotation = base.transform.localRotation;
			gotPos = true;
		}
		cc = MonoSingleton<CameraController>.Instance;
		aud = GetComponent<AudioSource>();
		if ((bool)aud)
		{
			origPitch = aud.pitch;
		}
		controller = GetComponentInParent<Door>();
		tempSpeed = speed;
		if (open)
		{
			base.transform.localRotation = targetRotation;
		}
	}

	private void Update()
	{
		if (gradualSpeedMultiplier != 0f)
		{
			if ((open && base.transform.localRotation != targetRotation) || (!open && base.transform.localRotation != origRotation))
			{
				tempSpeed += Time.deltaTime * tempSpeed * gradualSpeedMultiplier;
			}
			else
			{
				tempSpeed = speed;
			}
		}
		if (open && base.transform.localRotation != targetRotation)
		{
			base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, targetRotation, Time.deltaTime * (playerSpeedMultiplier ? Mathf.Max(tempSpeed, tempSpeed * (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 15f)) : tempSpeed));
			if (screenShake)
			{
				cc.CameraShake(0.05f);
			}
			if (base.transform.localRotation == targetRotation)
			{
				if ((bool)aud)
				{
					aud.clip = closeSound;
					aud.loop = false;
					aud.pitch = Random.Range(origPitch - 0.1f, origPitch + 0.1f);
					aud.Play();
				}
				controller?.onFullyOpened?.Invoke();
			}
		}
		else
		{
			if (open || !(base.transform.localRotation != origRotation))
			{
				return;
			}
			base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, origRotation, Time.deltaTime * (playerSpeedMultiplier ? Mathf.Max(tempSpeed, tempSpeed * (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 15f)) : tempSpeed));
			if (screenShake)
			{
				cc.CameraShake(0.05f);
			}
			if (base.transform.localRotation == origRotation)
			{
				if ((bool)aud)
				{
					aud.clip = closeSound;
					aud.loop = false;
					aud.pitch = Random.Range(origPitch - 0.1f, origPitch + 0.1f);
					aud.Play();
				}
				if ((bool)controller && controller.doorType != 0)
				{
					controller.BigDoorClosed();
				}
				if (openLight != null)
				{
					openLight.enabled = false;
				}
			}
		}
	}

	public void Open()
	{
		if (!(base.transform.localRotation != targetRotation))
		{
			return;
		}
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
			origPitch = aud.pitch;
		}
		open = true;
		if ((bool)aud)
		{
			aud.clip = openSound;
			aud.loop = true;
			aud.pitch = Random.Range(origPitch - 0.1f, origPitch + 0.1f);
			aud.Play();
		}
		if (Quaternion.Angle(base.transform.localRotation, origRotation) < 20f)
		{
			if (reverseDirection)
			{
				targetRotation.eulerAngles = origRotation.eulerAngles - openRotation;
			}
			else
			{
				targetRotation.eulerAngles = origRotation.eulerAngles + openRotation;
			}
		}
	}

	public void Close()
	{
		if (base.transform.localRotation != origRotation)
		{
			open = false;
			if ((bool)aud)
			{
				aud.clip = openSound;
				aud.loop = true;
				aud.pitch = Random.Range(origPitch / 2f - 0.1f, origPitch / 2f + 0.1f);
				aud.Play();
			}
		}
	}
}



public class BigDoorOpener : MonoBehaviour
{
	public BigDoor[] bigDoors;

	public bool dontCloseOnDisable;

	private void Start()
	{
		BigDoor[] array = bigDoors;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Open();
		}
	}

	private void OnEnable()
	{
		BigDoor[] array = bigDoors;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Open();
		}
	}

	private void OnDisable()
	{
		if (!dontCloseOnDisable)
		{
			BigDoor[] array = bigDoors;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Close();
			}
		}
	}
}



public class billboard : MonoBehaviour
{
	public static Transform cam;

	public Vector3 freeRotation = Vector3.one;

	private Vector3 eangles = Vector3.zero;

	private void Start()
	{
		if (cam == null)
		{
			cam = MonoSingleton<CameraController>.Instance.GetComponent<Transform>();
		}
	}

	private void LateUpdate()
	{
		base.transform.LookAt(cam);
		base.transform.Rotate(0f, 180f, 0f);
		eangles = base.transform.eulerAngles;
		eangles.x *= freeRotation.x;
		eangles.y *= freeRotation.y;
		eangles.z *= freeRotation.z;
		base.transform.eulerAngles = eangles;
	}
}



public class BlackHoleCannon : MonoBehaviour
{
	public Transform shootPoint;

	public GameObject bh;

	private GameObject currentbh;

	public LayerMask lmask;

	private RaycastHit rhit;

	private GameObject cam;

	private CameraController cc;

	private AudioSource aud;

	private WeaponHUD whud;

	public AudioClip emptyClick;

	private void Start()
	{
		cam = Camera.main.gameObject;
		cc = cam.GetComponent<CameraController>();
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (!MonoSingleton<GunControl>.Instance.activated)
		{
			return;
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)
		{
			if (!currentbh)
			{
				Shoot();
			}
			else
			{
				aud.PlayOneShot(emptyClick, 1f);
			}
		}
		if (currentbh != null && MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && currentbh.TryGetComponent<BlackHoleProjectile>(out var component))
		{
			component.Activate();
		}
	}

	private void Shoot()
	{
		Vector3 position = cam.transform.position + cam.transform.forward;
		currentbh = Object.Instantiate(bh, position, cam.transform.rotation);
		if (Physics.Raycast(cam.transform.position, cam.transform.forward, out rhit, float.PositiveInfinity, lmask))
		{
			currentbh.transform.LookAt(rhit.point);
		}
		else
		{
			currentbh.transform.rotation = cam.transform.rotation;
		}
		aud.Play();
		cc.CameraShake(0.5f);
	}
}



public class BlackHoleProjectile : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("BlackHoleProjectile");

	public EnemyTarget target;

	private Rigidbody rb;

	public float speed;

	private Light bhlight;

	private float targetRange;

	private RaycastHit rhit;

	public LayerMask lmask;

	private AudioSource aud;

	public GameObject lightningBolt;

	public GameObject lightningBolt2;

	private Transform aura;

	public Material additive;

	private bool activated;

	private bool collapsing;

	private float power;

	private StyleCalculator scalc;

	private int killAmount;

	public List<EnemyIdentifier> shootList = new List<EnemyIdentifier>();

	private List<Rigidbody> caughtList = new List<Rigidbody>();

	public bool enemy;

	public EnemyType safeType;

	private Collider col;

	[HideInInspector]
	public bool fadingIn;

	private Vector3 origScale;

	public GameObject spawnEffect;

	public GameObject explosionEffect;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		bhlight = GetComponent<Light>();
		targetRange = Random.Range(0, 15);
		aura = base.transform.GetChild(0);
		aud = GetComponent<AudioSource>();
		Invoke("ShootRandomLightning", Random.Range(0.5f, 1.5f));
		col = GetComponent<Collider>();
		if (enemy && !activated)
		{
			col.enabled = false;
		}
		if (target == null)
		{
			target = EnemyTarget.TrackPlayerIfAllowed();
		}
	}

	private void FixedUpdate()
	{
		if (!enemy)
		{
			if (!activated)
			{
				rb.velocity = base.transform.forward * speed;
			}
		}
		else if (!collapsing && activated)
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(target.position - base.transform.position), Time.fixedDeltaTime * 10f * speed);
			rb.velocity = base.transform.forward * speed;
		}
	}

	private void OnDisable()
	{
		CancelInvoke("ShootRandomLightning");
	}

	private void OnEnable()
	{
		ShootRandomLightning();
	}

	private void Update()
	{
		if (bhlight.range != targetRange)
		{
			bhlight.range = Mathf.MoveTowards(bhlight.range, targetRange, 100f * Time.deltaTime);
		}
		else if (activated)
		{
			targetRange = Random.Range(10, 20);
		}
		else
		{
			targetRange = Random.Range(0, 15);
		}
		if (activated && !enemy)
		{
			aura.transform.localPosition = new Vector3(Random.Range(-0.1f, 0.1f), Random.Range(-0.1f, 0.1f), Random.Range(-0.1f, 0.1f));
		}
		else
		{
			aura.transform.localPosition = new Vector3(Random.Range(-0.05f, 0.05f), Random.Range(-0.05f, 0.05f), Random.Range(-0.05f, 0.05f));
		}
		if (fadingIn)
		{
			base.transform.localScale = Vector3.MoveTowards(base.transform.localScale, origScale, Time.deltaTime * origScale.magnitude);
			aud.pitch = 1f - Vector3.Distance(base.transform.localScale, origScale) / origScale.magnitude;
			if (base.transform.localScale == origScale)
			{
				aud.pitch = 1f;
				fadingIn = false;
			}
		}
		if (collapsing)
		{
			if (aud.pitch > 0f)
			{
				aud.pitch -= Time.deltaTime;
			}
			else if (aud.pitch != 0f)
			{
				aud.pitch = 0f;
			}
			foreach (Rigidbody caught in caughtList)
			{
				if (caught != null)
				{
					caught.transform.position = base.transform.position;
				}
			}
			if (base.transform.localScale.x > 0f)
			{
				base.transform.localScale -= Vector3.one * Time.deltaTime;
			}
			else
			{
				Explode();
			}
		}
		else
		{
			if (!activated)
			{
				return;
			}
			if (!enemy)
			{
				aud.pitch += Time.deltaTime / 2f;
			}
			if (power < 3f)
			{
				power += Time.deltaTime;
			}
			if (caughtList.Count == 0)
			{
				return;
			}
			List<Rigidbody> list = new List<Rigidbody>();
			foreach (Rigidbody caught2 in caughtList)
			{
				if (caught2 == null)
				{
					list.Add(caught2);
					continue;
				}
				if (Vector3.Distance(caught2.transform.position, base.transform.position) < 9f)
				{
					caught2.transform.position = Vector3.MoveTowards(caught2.transform.position, base.transform.position, power * Time.deltaTime * (10f - Vector3.Distance(caught2.transform.position, base.transform.position)));
				}
				else
				{
					caught2.transform.position = Vector3.MoveTowards(caught2.transform.position, base.transform.position, power * Time.deltaTime);
				}
				if (Vector3.Distance(caught2.transform.position, base.transform.position) < 1f)
				{
					CharacterJoint component = caught2.GetComponent<CharacterJoint>();
					if (component != null)
					{
						Object.Destroy(component);
					}
					caught2.GetComponent<Collider>().enabled = false;
				}
				if (!(Vector3.Distance(caught2.transform.position, base.transform.position) < 0.25f))
				{
					continue;
				}
				List<Rigidbody> list2 = new List<Rigidbody>();
				list.Add(caught2);
				caught2.useGravity = false;
				caught2.velocity = Vector3.zero;
				caught2.isKinematic = true;
				caught2.transform.SetParent(base.transform);
				caught2.transform.localPosition = Vector3.zero;
				if (list2.Count != 0)
				{
					foreach (Rigidbody item in list2)
					{
						caughtList.Remove(item);
					}
				}
				list2.Clear();
			}
			if (list.Count == 0)
			{
				return;
			}
			foreach (Rigidbody item2 in list)
			{
				caughtList.Remove(item2);
			}
		}
	}

	private void ShootRandomLightning()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		int num = Random.Range(2, 6);
		for (int i = 0; i < num; i++)
		{
			if (Physics.Raycast(base.transform.position, Random.insideUnitSphere.normalized, out rhit, 8f * base.transform.localScale.x, lmask))
			{
				LineRenderer component = Object.Instantiate(lightningBolt, base.transform.position, base.transform.rotation).GetComponent<LineRenderer>();
				component.SetPosition(0, base.transform.position);
				component.SetPosition(1, rhit.point);
				component.widthMultiplier = base.transform.localScale.x * 2f;
			}
		}
		if (!activated || enemy)
		{
			Invoke("ShootRandomLightning", Random.Range(0.5f, 3f));
		}
	}

	private void ShootTargetLightning()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		if (shootList.Count != 0)
		{
			List<EnemyIdentifier> list = new List<EnemyIdentifier>();
			foreach (EnemyIdentifier shoot in shootList)
			{
				if (shoot == null)
				{
					list.Add(shoot);
				}
				else
				{
					if (enemy && (shoot.enemyType == safeType || shoot.immuneToFriendlyFire || EnemyIdentifier.CheckHurtException(safeType, shoot.enemyType)))
					{
						continue;
					}
					LineRenderer component = Object.Instantiate(lightningBolt2, base.transform.position, base.transform.rotation).GetComponent<LineRenderer>();
					component.SetPosition(0, base.transform.position);
					component.SetPosition(1, shoot.transform.position);
					if (!enemy)
					{
						shoot.hitter = "secret";
					}
					else
					{
						shoot.hitter = "enemy";
					}
					shoot.DeliverDamage(shoot.gameObject, Vector3.zero, shoot.transform.position, 1f, tryForExplode: false);
					if (shoot.dead)
					{
						list.Add(shoot);
						Rigidbody[] componentsInChildren = shoot.GetComponentsInChildren<Rigidbody>();
						foreach (Rigidbody item in componentsInChildren)
						{
							caughtList.Add(item);
						}
					}
				}
			}
			if (list.Count != 0)
			{
				foreach (EnemyIdentifier item2 in list)
				{
					shootList.Remove(item2);
				}
				list.Clear();
			}
		}
		if (!enemy)
		{
			ShootRandomLightning();
		}
		Invoke("ShootTargetLightning", 0.5f);
	}

	public void Activate()
	{
		if (fadingIn)
		{
			base.transform.localScale = origScale;
		}
		if ((bool)spawnEffect)
		{
			Object.Instantiate(spawnEffect, base.transform.position, Quaternion.identity).transform.localScale = base.transform.localScale * 5f;
		}
		activated = true;
		if (!rb)
		{
			rb = GetComponent<Rigidbody>();
		}
		rb.velocity = Vector3.zero;
		base.transform.GetChild(0).GetComponent<SpriteRenderer>().material = additive;
		GetComponentInChildren<ParticleSystem>().Play();
		ShootTargetLightning();
		if (!enemy)
		{
			Invoke("Collapse", 3f);
		}
		else if ((bool)col)
		{
			col.enabled = true;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!enemy || target == null)
		{
			return;
		}
		Log.Info($"BlackHole OnTriggerEnter <b>{other.name}</b> for target: <b>{target}</b>");
		if (!target.IsTargetTransform(other.gameObject.transform))
		{
			return;
		}
		Explode();
		NewMovement instance = MonoSingleton<NewMovement>.Instance;
		if (!(instance == null))
		{
			if (instance.hp > 10)
			{
				instance.GetHurt(instance.hp - 1, invincible: true);
				instance.ForceAntiHP(99f);
			}
			else
			{
				instance.GetHurt(10, invincible: true);
			}
		}
	}

	private void Collapse()
	{
		collapsing = true;
	}

	public void FadeIn()
	{
		if (origScale == Vector3.zero)
		{
			origScale = base.transform.localScale;
		}
		base.transform.localScale = Vector3.zero;
		fadingIn = true;
	}

	public void Explode()
	{
		Log.Info("Explode. FadeIn: " + fadingIn);
		Object.Instantiate(explosionEffect, base.transform.position, Quaternion.identity).transform.localScale = base.transform.localScale * 5f;
		EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
		{
			if (!((bool)enemyIdentifierIdentifier & (bool)enemyIdentifierIdentifier.eid) || (!enemyIdentifierIdentifier.gameObject.CompareTag("EndLimb") && !enemyIdentifierIdentifier.gameObject.CompareTag("Head")))
			{
				continue;
			}
			if (!enemy)
			{
				enemyIdentifierIdentifier.eid.hitter = "secret";
			}
			else
			{
				enemyIdentifierIdentifier.eid.hitter = "enemy";
			}
			enemyIdentifierIdentifier.eid.DeliverDamage(enemyIdentifierIdentifier.gameObject, Vector3.zero, enemyIdentifierIdentifier.gameObject.transform.position, 100f, tryForExplode: false);
			if (enemyIdentifierIdentifier.eid.exploded)
			{
				continue;
			}
			enemyIdentifierIdentifier.eid.exploded = true;
			if (!enemy && !enemyIdentifierIdentifier.eid.blessed && !enemyIdentifierIdentifier.eid.puppet)
			{
				if (scalc == null)
				{
					scalc = MonoSingleton<StyleCalculator>.Instance;
				}
				killAmount++;
				scalc.shud.AddPoints(50 - killAmount * 10, "ultrakill.compressed");
				scalc.HitCalculator("", "", "", dead: true);
			}
		}
		Object.Destroy(base.gameObject);
	}
}



public class BlackHoleTrigger : MonoBehaviour
{
	private BlackHoleProjectile bhp;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 12)
		{
			if (!bhp)
			{
				bhp = GetComponentInParent<BlackHoleProjectile>();
			}
			EnemyIdentifier component = other.GetComponent<EnemyIdentifier>();
			if ((bool)component && (!bhp.enemy || (component.enemyType != bhp.safeType && !component.immuneToFriendlyFire && !EnemyIdentifier.CheckHurtException(bhp.safeType, component.enemyType) && !bhp.shootList.Contains(component))))
			{
				bhp.shootList.Add(component);
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == 12)
		{
			if (!bhp)
			{
				bhp = GetComponentInParent<BlackHoleProjectile>();
			}
			EnemyIdentifier component = other.GetComponent<EnemyIdentifier>();
			if ((bool)component && (!bhp.enemy || (component.enemyType != bhp.safeType && !component.immuneToFriendlyFire && !EnemyIdentifier.CheckHurtException(bhp.safeType, component.enemyType) && bhp.shootList.Contains(component))))
			{
				bhp.shootList.Remove(component);
			}
		}
	}
}



public class Bleeder : MonoBehaviour
{
	private GoreZone gz;

	public EnemyType[] ignoreTypes;

	public void GetHit(Vector3 point, GoreType type, bool fromExplosion = false)
	{
		if (gz == null)
		{
			gz = GoreZone.ResolveGoreZone(base.transform);
		}
		GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(type, isUnderwater: false, isSandified: false, isBlessed: false, null, fromExplosion);
		if ((bool)gore)
		{
			gore.transform.position = point;
			gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
			Bloodsplatter component = gore.GetComponent<Bloodsplatter>();
			gore.SetActive(value: true);
			if ((bool)component)
			{
				component.GetReady();
			}
		}
	}
}



public class Blink : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


public enum BlockType
{
	PlasticGeneric,
	Wood,
	Metal,
	Water,
	Grass,
	Glass,
	HotSand,
	Lava,
	Acid
}



public class BloodAbsorber : MonoBehaviour, IBloodstainReceiver
{
	private struct CollisionData
	{
		public Vector3 position;

		public float distance;
	}

	public string painterName;

	public Shader absorptionShader;

	public Texture noiseTex;

	public Texture2D visibilityMask;

	public int texelsPerWorldUnit = 10;

	public float forgivenessCutoff = 0.01f;

	public float bloodUpdateRate = 0.02f;

	public float timeUntilSleep = 4f;

	public bool clearBlood;

	public bool fillBlood;

	[SerializeField]
	private float maxFill;

	[HideInInspector]
	public float fillAmount = 999f;

	public bool isCompleted;

	private float sleepTimer;

	private bool isWashing;

	private float bloodTimer;

	private bool isSleeping = true;

	private CommandBuffer cb;

	private Material absMat;

	public RenderTexture paintBuffer;

	public RenderTexture bloodMap;

	public RenderTexture clampedMap;

	public RenderTexture dilationMask;

	public RenderTexture bloodMapCheckpoint;

	private MeshRenderer[] absorbers;

	private MeshFilter[] absorberMFs;

	private MaterialPropertyBlock propBlock;

	private ComputeBuffer cbuff;

	[HideInInspector]
	public GameObject owningRoom;

	private BloodCheckerManager bcm;

	[SerializeField]
	private AudioSource cleanSuccess;

	public Cubemap cleanedMap;

	private List<CollisionData> collisionDataList;

	private Coroutine checkFillRoutine;

	private float baseAccuracy;

	private void Start()
	{
		bcm = MonoSingleton<BloodCheckerManager>.Instance;
		cb = new CommandBuffer
		{
			name = "PaintRenderer"
		};
		absorbers = GetComponentsInChildren<MeshRenderer>();
		absorberMFs = new MeshFilter[absorbers.Length];
		CombineInstance[] array = new CombineInstance[absorbers.Length];
		for (int i = 0; i < absorbers.Length; i++)
		{
			MeshRenderer meshRenderer = absorbers[i];
			if (meshRenderer.TryGetComponent<MeshFilter>(out var component))
			{
				absorberMFs[i] = component;
				array[i].mesh = component.sharedMesh;
			}
			else
			{
				Debug.LogError("No mesh found for: " + meshRenderer.gameObject.name);
			}
		}
		Mesh mesh = new Mesh();
		mesh.CombineMeshes(array);
		int num = Math.Min(Mathf.CeilToInt(Mathf.Sqrt(mesh.GetUVDistributionMetric(1)) * (float)texelsPerWorldUnit), 4096);
		float f = Mathf.Log(num, 2f);
		f = Mathf.Round(f);
		f = Mathf.Pow(2f, f);
		int num2 = (int)f;
		propBlock = new MaterialPropertyBlock();
		absMat = new Material(absorptionShader);
		paintBuffer = new RenderTexture(num, num, 0, RenderTextureFormat.R16, 0)
		{
			filterMode = FilterMode.Point
		};
		bloodMap = new RenderTexture(num, num, 0, RenderTextureFormat.R8, 0)
		{
			filterMode = FilterMode.Point
		};
		dilationMask = new RenderTexture(num, num, 0, RenderTextureFormat.R8, 0)
		{
			filterMode = FilterMode.Point
		};
		clampedMap = new RenderTexture(num2, num2, 0, RenderTextureFormat.RHalf)
		{
			filterMode = FilterMode.Point,
			useMipMap = true,
			autoGenerateMips = false
		};
		paintBuffer.Create();
		bloodMap.Create();
		clampedMap.Create();
		dilationMask.Create();
		InitializeRTs();
		InitializeDilationMask();
		propBlock.SetTexture("_BloodBuffer", paintBuffer);
		propBlock.SetTexture("_BloodTex", bloodMap);
		propBlock.SetTexture("_DilationMask", dilationMask);
		for (int j = 0; j < absorbers.Length; j++)
		{
			absorbers[j].SetPropertyBlock(propBlock);
		}
		if (visibilityMask == null)
		{
			visibilityMask = Texture2D.whiteTexture;
		}
		cbuff = new ComputeBuffer(100, 16);
		collisionDataList = new List<CollisionData>(cbuff.count);
		baseAccuracy = forgivenessCutoff;
	}

	public void ToggleHigherAccuracy(bool isOn)
	{
		forgivenessCutoff = (isOn ? 0.0001f : baseAccuracy);
	}

	private void OnEnable()
	{
		BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
		if (instance != null)
		{
			instance.bloodAbsorbers++;
		}
	}

	private void OnDisable()
	{
		BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
		if (instance != null)
		{
			instance.bloodAbsorbers--;
		}
	}

	public void StartCheckingFill()
	{
		if (checkFillRoutine == null)
		{
			StartCoroutine(CheckFill());
		}
	}

	public void StoreBloodCopy()
	{
		if (bloodMapCheckpoint == null)
		{
			bloodMapCheckpoint = new RenderTexture(bloodMap);
		}
		Graphics.CopyTexture(bloodMap, bloodMapCheckpoint);
	}

	public void RestoreBloodCopy()
	{
		if (bloodMapCheckpoint != null)
		{
			Graphics.CopyTexture(bloodMapCheckpoint, bloodMap);
		}
		else
		{
			InitializeRTs();
		}
		if (isCompleted)
		{
			StartCheckingFill();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.transform.TryGetComponent<GoreSplatter>(out var component))
		{
			component.bloodAbsorberCount++;
			bcm.AddGoreToRoom(this, component);
		}
		else
		{
			if (!collision.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
			{
				return;
			}
			component2.bloodAbsorberCount++;
			if (component2.eid == component2.GetComponentInParent<EnemyIdentifier>())
			{
				EnemyIdentifierIdentifier[] componentsInChildren = component2.eid.GetComponentsInChildren<EnemyIdentifierIdentifier>();
				foreach (EnemyIdentifierIdentifier litter in componentsInChildren)
				{
					bcm.AddGibToRoom(this, litter);
				}
			}
			else
			{
				bcm.AddGibToRoom(this, component2);
			}
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		EnemyIdentifierIdentifier component2;
		if (collision.transform.TryGetComponent<GoreSplatter>(out var component))
		{
			component.bloodAbsorberCount--;
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
			{
				component.Invoke("RepoolIfNoAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
		}
		else if (collision.transform.TryGetComponent<EnemyIdentifierIdentifier>(out component2))
		{
			component2.bloodAbsorberCount--;
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
			{
				component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
		}
	}

	private IEnumerator CheckFill()
	{
		UnclearedAbsorber();
		yield return new WaitForSeconds(3f);
		if (maxFill == 0f)
		{
			Debug.LogWarning("No max fill data for: " + base.gameObject.name);
			Graphics.Blit(bloodMap, clampedMap, absMat, 5);
			clampedMap.GenerateMips();
			AsyncGPUReadbackRequest request = AsyncGPUReadback.Request(clampedMap, clampedMap.mipmapCount - 1, AsyncGetFilledSpace);
			yield return new WaitUntil(() => request.done);
		}
		fillAmount = 999f;
		int timesChecked = -1;
		while (fillAmount >= forgivenessCutoff)
		{
			timesChecked = Math.Min(2, timesChecked + 1);
			Graphics.Blit(bloodMap, clampedMap, absMat, 5);
			clampedMap.GenerateMips();
			AsyncGPUReadbackRequest request = AsyncGPUReadback.Request(clampedMap, clampedMap.mipmapCount - 1, AsyncGetCurrentFillAmount);
			yield return new WaitUntil(() => request.done);
		}
		if (timesChecked == 2)
		{
			UnityEngine.Object.Instantiate(cleanSuccess);
		}
		checkFillRoutine = null;
		StartCoroutine(ClearedAbsorber());
		isWashing = true;
		fillAmount = 1f;
		cb.Clear();
		cb.SetRenderTarget(bloodMap);
		cb.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
		Graphics.ExecuteCommandBuffer(cb);
	}

	private IEnumerator ClearedAbsorber()
	{
		isCompleted = true;
		float time = 0f;
		propBlock.SetTexture("_CubeTex", cleanedMap);
		while (time < 1f)
		{
			float value = Mathf.Lerp(0f, 0.06f, time);
			propBlock.SetFloat("_ReflectionStrength", value);
			Color value2 = Color.Lerp(new Color(1f, 0.9f, 0.5f), Color.white, time);
			propBlock.SetColor("_EmissiveColor", value2);
			float value3 = Mathf.Lerp(2f, 1f, time);
			propBlock.SetFloat("_EmissiveIntensity", value3);
			int num = absorbers.Length;
			for (int i = 0; i < num; i++)
			{
				absorbers[i].SetPropertyBlock(propBlock);
			}
			time += Time.deltaTime;
			yield return null;
		}
	}

	private void UnclearedAbsorber()
	{
		isCompleted = false;
		propBlock.SetFloat("_ReflectionStrength", 0f);
		propBlock.SetColor("_EmissiveColor", Color.white);
		propBlock.SetFloat("_EmissiveIntensity", 1f);
		int num = absorbers.Length;
		for (int i = 0; i < num; i++)
		{
			absorbers[i].SetPropertyBlock(propBlock);
		}
	}

	private void AsyncGetFilledSpace(AsyncGPUReadbackRequest request)
	{
		if (!clampedMap)
		{
			Debug.LogError("No blood map exists while attempting to calculate absorber max fill.");
		}
		maxFill = request.GetData<half>()[0];
		fillAmount = maxFill;
	}

	private void AsyncGetCurrentFillAmount(AsyncGPUReadbackRequest request)
	{
		if ((bool)clampedMap)
		{
			float num = request.GetData<half>()[0];
			fillAmount = num / maxFill;
		}
	}

	private void OnValidate()
	{
		if (clearBlood)
		{
			InitializeRTs();
			clearBlood = false;
		}
		if (fillBlood)
		{
			Graphics.Blit(visibilityMask, bloodMap, absMat, 7);
			fillBlood = false;
		}
		int num = visibilityMask.width * visibilityMask.height;
		float num2 = 0f;
		for (int i = 0; i < visibilityMask.width; i++)
		{
			for (int j = 0; j < visibilityMask.height; j++)
			{
				num2 += visibilityMask.GetPixel(i, j).r;
			}
		}
		maxFill = num2 / (float)num;
	}

	private void InitializeRTs()
	{
		cb.Clear();
		cb.SetRenderTarget(paintBuffer);
		cb.ClearRenderTarget(clearDepth: true, clearColor: true, Color.black);
		cb.SetRenderTarget(bloodMap);
		cb.ClearRenderTarget(clearDepth: true, clearColor: true, Color.black);
		Graphics.ExecuteCommandBuffer(cb);
	}

	private void InitializeDilationMask()
	{
		cb.Clear();
		cb.SetRenderTarget(dilationMask);
		for (int i = 0; i < absorbers.Length; i++)
		{
			MeshRenderer renderer = absorbers[i];
			int subMeshCount = absorberMFs[i].sharedMesh.subMeshCount;
			for (int j = 0; j < subMeshCount; j++)
			{
				cb.DrawRenderer(renderer, absMat, j, 6);
			}
		}
		Graphics.ExecuteCommandBuffer(cb);
	}

	private void Update()
	{
		if (!isSleeping && sleepTimer >= timeUntilSleep)
		{
			cb.Clear();
			cb.SetRenderTarget(paintBuffer);
			cb.ClearRenderTarget(clearDepth: true, clearColor: true, Color.black);
			Graphics.ExecuteCommandBuffer(cb);
			clearBlood = false;
			isSleeping = true;
			return;
		}
		if (bloodTimer >= bloodUpdateRate)
		{
			Graphics.Blit(null, paintBuffer, absMat, 1);
			absMat.SetTexture("_VisibilityMask", visibilityMask);
			Graphics.Blit(paintBuffer, bloodMap, absMat, isWashing ? 3 : 2);
			bloodTimer = 0f;
		}
		bloodTimer += Time.deltaTime;
		sleepTimer += Time.deltaTime;
	}

	public bool HandleBloodstainHit(ref RaycastHit hit)
	{
		if (isCompleted)
		{
			StartCheckingFill();
		}
		if (isWashing)
		{
			cb.Clear();
			cb.SetRenderTarget(paintBuffer);
			cb.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
		}
		isWashing = false;
		isSleeping = false;
		sleepTimer = 0f;
		Vector3 point = hit.point;
		Vector3 normal = hit.normal;
		Vector3 vector = normal * -1f;
		Quaternion quaternion = Quaternion.LookRotation(normal, Vector3.up);
		Quaternion quaternion2 = Quaternion.AngleAxis(UnityEngine.Random.Range(0f, 360f), normal);
		Matrix4x4 value = Matrix4x4.Rotate(quaternion * quaternion2);
		absMat.SetVector("_HitPos", point);
		absMat.SetVector("_HitNorm", vector);
		absMat.SetMatrix("_RotMat", value);
		absMat.SetTexture("_MainTex", paintBuffer);
		absMat.SetTexture("_NoiseTex", noiseTex);
		absMat.SetTexture("_VisibilityMask", visibilityMask);
		cb.Clear();
		cb.SetRenderTarget(paintBuffer);
		propBlock.SetFloat("_IsWashing", 0f);
		int num = absorbers.Length;
		for (int i = 0; i < num; i++)
		{
			MeshRenderer meshRenderer = absorbers[i];
			int subMeshCount = absorberMFs[i].sharedMesh.subMeshCount;
			for (int j = 0; j < subMeshCount; j++)
			{
				cb.DrawRenderer(meshRenderer, absMat, j, 0);
			}
			meshRenderer.SetPropertyBlock(propBlock);
		}
		Graphics.ExecuteCommandBuffer(cb);
		Graphics.Blit(paintBuffer, bloodMap, absMat, 2);
		return true;
	}

	public void ProcessWasherSpray(ref List<ParticleCollisionEvent> pEvents, Vector3 position)
	{
		if (!isWashing)
		{
			cb.Clear();
			cb.SetRenderTarget(paintBuffer);
			cb.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
		}
		isWashing = true;
		collisionDataList.Clear();
		int num = 0;
		foreach (ParticleCollisionEvent pEvent in pEvents)
		{
			if (num >= cbuff.count)
			{
				break;
			}
			CollisionData collisionData = default(CollisionData);
			collisionData.position = pEvent.intersection;
			collisionData.distance = Vector3.Distance(pEvent.intersection, position);
			CollisionData item = collisionData;
			collisionDataList.Add(item);
			num++;
		}
		cbuff.SetData(collisionDataList);
		isSleeping = false;
		sleepTimer = 0f;
		absMat.SetFloat("_HitCount", num);
		absMat.SetBuffer("_HitData", cbuff);
		absMat.SetTexture("_MainTex", paintBuffer);
		absMat.SetTexture("_NoiseTex", noiseTex);
		cb.Clear();
		cb.SetRenderTarget(paintBuffer);
		propBlock.SetFloat("_IsWashing", 1f);
		int num2 = absorbers.Length;
		for (int i = 0; i < num2; i++)
		{
			MeshRenderer meshRenderer = absorbers[i];
			int subMeshCount = absorberMFs[i].sharedMesh.subMeshCount;
			for (int j = 0; j < subMeshCount; j++)
			{
				cb.DrawRenderer(meshRenderer, absMat, j, 4);
			}
			meshRenderer.SetPropertyBlock(propBlock);
		}
		Graphics.ExecuteCommandBuffer(cb);
		absMat.SetTexture("_VisibilityMask", visibilityMask);
		Graphics.Blit(paintBuffer, bloodMap, absMat, 3);
	}
}



public class BloodAbsorberChild : MonoBehaviour, IBloodstainReceiver
{
	[HideInInspector]
	public BloodAbsorber bloodGroup;

	private void Start()
	{
		bloodGroup = GetComponentInParent<BloodAbsorber>();
	}

	private void OnEnable()
	{
		BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
		if (instance != null)
		{
			instance.bloodAbsorberChildren++;
		}
	}

	private void OnDisable()
	{
		BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
		if (instance != null)
		{
			instance.bloodAbsorberChildren--;
		}
	}

	public bool HandleBloodstainHit(ref RaycastHit hit)
	{
		bloodGroup.HandleBloodstainHit(ref hit);
		return true;
	}

	public void ProcessWasherSpray(ref List<ParticleCollisionEvent> pEvents, Vector3 position)
	{
		bloodGroup.ProcessWasherSpray(ref pEvents, position);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class BloodCheckerManager : MonoSingleton<BloodCheckerManager>
{
	public Canvas washingCanvas;

	public GameObject painterGUITemplate;

	public TextMeshProUGUI roomName;

	public TextMeshProUGUI activePainter;

	public TextMeshProUGUI toDoText;

	public TextMeshProUGUI cleanText;

	public TextMeshProUGUI litterCount;

	public Slider activePercentSlider;

	private string activePainterName;

	public GameObject finalDoorOpener;

	public List<GameObject> trackedRooms = new List<GameObject>();

	public int[] roomLitterForgiveness = new int[5];

	private Dictionary<GameObject, List<BloodAbsorber>> rooms = new Dictionary<GameObject, List<BloodAbsorber>>();

	private Dictionary<GameObject, HashSet<GoreSplatter>> roomGore = new Dictionary<GameObject, HashSet<GoreSplatter>>();

	private Dictionary<GameObject, HashSet<EnemyIdentifierIdentifier>> roomGibs = new Dictionary<GameObject, HashSet<EnemyIdentifierIdentifier>>();

	public Dictionary<BloodAbsorber, GameObject> toDoEntries = new Dictionary<BloodAbsorber, GameObject>();

	public Cubemap[] cleanedMaps = new Cubemap[5];

	private GameObject pondToDoEntry;

	public Pond pond;

	public HashSet<GameObject> pondLitter = new HashSet<GameObject>();

	public bool startedWashing;

	private int litterCheckIndex;

	public int[] roomLitterCounts = new int[5];

	public bool[] roomCompletions = new bool[5];

	private int totalLitterCount = 999;

	public List<GameObject> completedRoomStates = new List<GameObject>();

	[HideInInspector]
	public bool playerInPond;

	public bool higherAccuracy;

	public void HigherAccuracy(bool useHigherAccuracy)
	{
		higherAccuracy = useHigherAccuracy;
		foreach (List<BloodAbsorber> value in rooms.Values)
		{
			foreach (BloodAbsorber item in value)
			{
				item.ToggleHigherAccuracy(higherAccuracy);
			}
		}
	}

	private void Start()
	{
		foreach (GameObject trackedRoom in trackedRooms)
		{
			BloodAbsorber[] componentsInChildren = trackedRoom.GetComponentsInChildren<BloodAbsorber>();
			roomGore.Add(trackedRoom, new HashSet<GoreSplatter>());
			roomGibs.Add(trackedRoom, new HashSet<EnemyIdentifierIdentifier>());
			BloodAbsorber[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].owningRoom = trackedRoom;
			}
			rooms.Add(trackedRoom, componentsInChildren.ToList());
		}
		Transform parent = painterGUITemplate.transform.parent;
		painterGUITemplate.SetActive(value: false);
		foreach (KeyValuePair<GameObject, List<BloodAbsorber>> room in rooms)
		{
			int num = trackedRooms.IndexOf(room.Key);
			Cubemap cleanedMap = cleanedMaps[num];
			foreach (BloodAbsorber item in room.Value)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(painterGUITemplate, parent);
				gameObject.transform.GetChild(0).gameObject.SetActive(value: false);
				gameObject.transform.GetChild(1).GetComponent<TextMeshProUGUI>().text = item.painterName;
				gameObject.name = item.painterName;
				toDoEntries.Add(item, gameObject);
				item.cleanedMap = cleanedMap;
			}
		}
		pondToDoEntry = UnityEngine.Object.Instantiate(painterGUITemplate, parent);
		pondToDoEntry.transform.GetChild(0).gameObject.SetActive(value: false);
		pondToDoEntry.transform.GetChild(1).GetComponent<TextMeshProUGUI>().text = "Pond";
		pondToDoEntry.name = "Pond";
		washingCanvas.enabled = false;
	}

	private void RemoveNullLitters()
	{
		litterCheckIndex = (litterCheckIndex + 1) % rooms.Count;
		GameObject key = trackedRooms[litterCheckIndex];
		roomGore[key].RemoveWhere((GoreSplatter x) => x == null || !x.gameObject.activeInHierarchy);
		roomGibs[key].RemoveWhere((EnemyIdentifierIdentifier x) => x == null || !x.gameObject.activeInHierarchy || x.transform.lossyScale == Vector3.zero);
		pondLitter.RemoveWhere((GameObject x) => x == null || !x.activeInHierarchy || x.transform.lossyScale == Vector3.zero);
		Invoke("RemoveNullLitters", 0.033f);
	}

	private void CheckLevelStates()
	{
		CheckLitterCounts();
		CheckLevelCompletion();
		Invoke("CheckLevelStates", 1f);
	}

	private void CheckLitterCounts()
	{
		int[] array = new int[5];
		roomLitterCounts.CopyTo(array, 0);
		foreach (KeyValuePair<GameObject, HashSet<GoreSplatter>> item in roomGore)
		{
			int num = trackedRooms.IndexOf(item.Key);
			roomLitterCounts[num] = item.Value.Count;
		}
		foreach (KeyValuePair<GameObject, HashSet<EnemyIdentifierIdentifier>> roomGib in roomGibs)
		{
			int num2 = trackedRooms.IndexOf(roomGib.Key);
			roomLitterCounts[num2] += roomGib.Value.Count;
		}
		int num3 = trackedRooms.IndexOf(pond.owningRoom);
		roomLitterCounts[num3] += pondLitter.Count;
		totalLitterCount = 0;
		for (int i = 0; i < roomLitterCounts.Length; i++)
		{
			roomLitterCounts[i] = Math.Max(0, roomLitterCounts[i] - roomLitterForgiveness[i]);
			if (roomLitterCounts[i] <= 0)
			{
				_ = array[i];
				_ = 0;
				GameObject gameObject = trackedRooms[i];
				foreach (GoreSplatter item2 in roomGore[gameObject])
				{
					item2.Repool();
				}
				foreach (EnemyIdentifierIdentifier item3 in roomGibs[gameObject])
				{
					if (item3.TryGetComponent<Collider>(out var component))
					{
						GibDestroyer.LimbBegone(component);
					}
				}
				if (gameObject == pond.owningRoom)
				{
					foreach (GameObject item4 in pondLitter)
					{
						Collider component3;
						if (item4.TryGetComponent<GoreSplatter>(out var component2))
						{
							component2.Repool();
						}
						else if (item4.TryGetComponent<Collider>(out component3))
						{
							GibDestroyer.LimbBegone(component3);
						}
					}
				}
			}
			totalLitterCount += roomLitterCounts[i];
		}
	}

	public void StartCheckingBlood()
	{
		if (startedWashing)
		{
			return;
		}
		startedWashing = true;
		foreach (List<BloodAbsorber> value in rooms.Values)
		{
			foreach (BloodAbsorber item in value)
			{
				item.StartCheckingFill();
			}
		}
		Invoke("RemoveNullLitters", 0.033f);
		Invoke("CheckLevelStates", 0.5f);
	}

	private void ToggleHigherAccuracy(bool isTrue)
	{
		foreach (List<BloodAbsorber> value in rooms.Values)
		{
			foreach (BloodAbsorber item in value)
			{
				item.ToggleHigherAccuracy(isTrue);
			}
		}
	}

	private void Update()
	{
		if (!startedWashing)
		{
			return;
		}
		washingCanvas.enabled = false;
		Transform transform = MonoSingleton<CameraController>.Instance.transform;
		bool flag = false;
		if (Physics.Raycast(transform.position, transform.forward, out var hitInfo, 50f, (int)LayerMaskDefaults.Get(LMD.Environment) | 0x10, QueryTriggerInteraction.Collide))
		{
			Pond component3;
			if (hitInfo.transform.gameObject.layer != 4)
			{
				hitInfo.transform.TryGetComponent<BloodAbsorber>(out var component);
				if (component == null && hitInfo.transform.TryGetComponent<BloodAbsorberChild>(out var component2))
				{
					component = component2.bloodGroup;
				}
				if (component != null)
				{
					UpdateDisplay(component);
					flag = true;
				}
			}
			else if (hitInfo.transform.TryGetComponent<Pond>(out component3))
			{
				flag = true;
				UpdateDisplay(null);
			}
		}
		if (!flag && playerInPond)
		{
			UpdateDisplay(null);
		}
	}

	private void CheckLevelCompletion()
	{
		bool flag = totalLitterCount <= 0;
		foreach (GameObject trackedRoom in trackedRooms)
		{
			flag &= IsRoomCompleted(trackedRoom);
		}
		if (flag)
		{
			finalDoorOpener.SetActive(value: true);
		}
	}

	private bool IsRoomCompleted(GameObject roomToCheck)
	{
		bool flag = true;
		foreach (BloodAbsorber item in rooms[roomToCheck])
		{
			toDoEntries[item].transform.GetChild(0).gameObject.SetActive(item.isCompleted);
			flag &= item.isCompleted;
		}
		if (roomToCheck == pond.owningRoom)
		{
			bool flag2 = pond.bloodFillAmount <= 0.001f;
			pondToDoEntry.transform.GetChild(0).gameObject.SetActive(flag2);
			flag = flag && flag2;
		}
		int num = trackedRooms.IndexOf(roomToCheck);
		flag &= roomLitterCounts[num] == 0;
		completedRoomStates[num].SetActive(flag);
		roomCompletions[num] = flag;
		return flag;
	}

	public void StoreBlood()
	{
		foreach (List<BloodAbsorber> value in rooms.Values)
		{
			foreach (BloodAbsorber item in value)
			{
				item.StoreBloodCopy();
			}
		}
		pond.StoreBlood();
	}

	public void RestoreBlood()
	{
		foreach (List<BloodAbsorber> value in rooms.Values)
		{
			foreach (BloodAbsorber item in value)
			{
				item.RestoreBloodCopy();
			}
		}
		pond.RestoreBlood();
	}

	public void UpdateDisplay(BloodAbsorber bA)
	{
		washingCanvas.enabled = !HideUI.Active;
		GameObject gameObject = null;
		if (bA != null)
		{
			if (bA.painterName != activePainterName)
			{
				activePainter.text = bA.painterName;
			}
			gameObject = bA.owningRoom;
		}
		else
		{
			gameObject = pond.owningRoom;
			activePainter.text = "Pond";
		}
		if (gameObject == null)
		{
			Debug.LogError("No room found on UpdateDisplay");
		}
		roomName.SetText(gameObject.name);
		pondToDoEntry.SetActive(value: false);
		foreach (GameObject value2 in toDoEntries.Values)
		{
			value2.SetActive(value: false);
		}
		int num = trackedRooms.IndexOf(gameObject);
		if (roomCompletions[num])
		{
			litterCount.transform.parent.gameObject.SetActive(value: false);
			cleanText.gameObject.SetActive(value: true);
			toDoText.gameObject.SetActive(value: false);
			return;
		}
		litterCount.transform.parent.gameObject.SetActive(value: true);
		toDoText.gameObject.SetActive(value: true);
		int num2 = roomLitterCounts[num];
		litterCount.text = num2.ToString();
		foreach (BloodAbsorber item in rooms[gameObject])
		{
			toDoEntries[item].SetActive(value: true);
		}
		if (gameObject == pond.owningRoom)
		{
			pondToDoEntry.SetActive(value: true);
		}
		if (bA == null)
		{
			if (pond.bloodFillAmount <= 0.001f)
			{
				activePercentSlider.value = 100f;
			}
			else
			{
				activePercentSlider.value = (1f - pond.bloodFillAmount) * 100f;
			}
		}
		else if (bA.isCompleted)
		{
			activePercentSlider.value = 100f;
		}
		else
		{
			float value = (1f - bA.fillAmount) * 100f;
			activePercentSlider.value = value;
		}
	}

	public void AddPondGore(GoreSplatter litter)
	{
		pondLitter.Add(litter.gameObject);
		foreach (HashSet<GoreSplatter> value in roomGore.Values)
		{
			value.Remove(litter);
		}
	}

	public void AddPondGib(EnemyIdentifierIdentifier litter)
	{
		pondLitter.Add(litter.gameObject);
		foreach (HashSet<EnemyIdentifierIdentifier> value in roomGibs.Values)
		{
			value.Remove(litter);
		}
	}

	public void AddGoreToRoom(BloodAbsorber absorber, GoreSplatter litter)
	{
		pondLitter.Remove(litter.gameObject);
		foreach (HashSet<GoreSplatter> value in roomGore.Values)
		{
			value.Remove(litter);
		}
		roomGore[absorber.owningRoom].Add(litter);
	}

	public void AddGibToRoom(BloodAbsorber absorber, EnemyIdentifierIdentifier litter)
	{
		pondLitter.Remove(litter.gameObject);
		foreach (HashSet<EnemyIdentifierIdentifier> value in roomGibs.Values)
		{
			value.Remove(litter);
		}
		roomGibs[absorber.owningRoom].Add(litter);
	}
}



public class BloodDestroyer : MonoBehaviour, IBloodstainReceiver
{
	private void OnEnable()
	{
		MonoSingleton<BloodsplatterManager>.Instance.bloodDestroyers++;
	}

	private void OnDisable()
	{
		MonoSingleton<BloodsplatterManager>.Instance.bloodDestroyers--;
	}

	public bool HandleBloodstainHit(ref RaycastHit hit)
	{
		return false;
	}
}



[RequireComponent(typeof(Rigidbody))]
public class BloodFiller : MonoBehaviour
{
	public float fullFillThreshold = 1f;

	public float fillSpeed = 1f;

	public float fillTimePerHit = 0.5f;

	public float fillAmount;

	[HideInInspector]
	public bool fullyFilled;

	private AudioSource aud;

	private Bounds meshBounds;

	private Renderer rend;

	private MaterialPropertyBlock propBlock;

	private MeshFilter mf;

	private Collider col;

	public GameObject bloodIngestParticle;

	private float heartBeatCooldown;

	public UltrakillEvent onFullyFilled;

	private List<int> eids = new List<int>();

	private List<float> eidCooldowns = new List<float>();

	private List<float> eidAmounts = new List<float>();

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		rend = GetComponent<Renderer>();
		propBlock = new MaterialPropertyBlock();
		mf = GetComponent<MeshFilter>();
		col = GetComponent<Collider>();
		meshBounds = mf.mesh.bounds;
		Vector4 value = meshBounds.size;
		Vector4 value2 = meshBounds.center;
		value2.w = 1f;
		propBlock.SetVector("_MeshScale", value);
		propBlock.SetVector("_MeshCenter", value2);
		propBlock.SetFloat("_FillAmount", fillAmount);
		rend.SetPropertyBlock(propBlock);
	}

	private void OnEnable()
	{
		MonoSingleton<BloodsplatterManager>.Instance.bloodFillers.Add(base.gameObject);
		MonoSingleton<BloodsplatterManager>.Instance.hasBloodFillers = true;
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<BloodsplatterManager>.Instance.bloodFillers.Remove(base.gameObject);
			if (MonoSingleton<BloodsplatterManager>.Instance.bloodFillers.Count == 0)
			{
				MonoSingleton<BloodsplatterManager>.Instance.hasBloodFillers = false;
			}
		}
	}

	private void Update()
	{
		if (fillAmount > 0f && !fullyFilled)
		{
			heartBeatCooldown = Mathf.MoveTowards(heartBeatCooldown, 0f, Time.deltaTime * Mathf.Max(0.25f, 3f * fillAmount));
			if (heartBeatCooldown <= 0f)
			{
				aud.Play();
				aud.pitch = Mathf.Lerp(1f, 1.5f, fillAmount);
				heartBeatCooldown = 1f;
			}
		}
		if (eidCooldowns.Count <= 0)
		{
			return;
		}
		for (int num = eidCooldowns.Count - 1; num >= 0; num--)
		{
			eidCooldowns[num] = Mathf.MoveTowards(eidCooldowns[num], 0f, Time.deltaTime);
			if (eidCooldowns[num] == 0f)
			{
				eidCooldowns.RemoveAt(num);
				eidAmounts.RemoveAt(num);
				eids.RemoveAt(num);
			}
		}
	}

	public void FillBloodSlider(float amount, Vector3 position, int eidID = 0)
	{
		if (fullyFilled || (eidID != 0 && eids.Contains(eidID) && !(eidAmounts[eids.IndexOf(eidID)] < amount)))
		{
			return;
		}
		if ((bool)bloodIngestParticle)
		{
			Vector3 vector = new Vector3(base.transform.position.x, position.y, base.transform.position.z);
			GameObject obj = Object.Instantiate(bloodIngestParticle, vector, Quaternion.LookRotation(position - vector));
			ParticleSystem componentInChildren = obj.GetComponentInChildren<ParticleSystem>();
			if ((bool)componentInChildren && componentInChildren.emission.burstCount > 0)
			{
				ParticleSystem.Burst burst = componentInChildren.emission.GetBurst(0);
				burst.count = new ParticleSystem.MinMaxCurve(Mathf.Max(3f, burst.count.constantMin * (amount / 50f)), Mathf.Max(3f, burst.count.constantMax * (amount / 50f)));
				componentInChildren.emission.SetBurst(0, burst);
			}
			AudioSource component = obj.GetComponent<AudioSource>();
			if ((bool)component)
			{
				component.pitch = Mathf.Lerp(3f, 2f, amount / 50f);
				component.volume = Mathf.Lerp(0.5f, 1f, amount / 50f);
			}
		}
		if (eidID != 0)
		{
			if (!eids.Contains(eidID))
			{
				eids.Add(eidID);
				eidCooldowns.Add(0.5f);
				eidAmounts.Add(amount);
			}
			else
			{
				int index = eids.IndexOf(eidID);
				amount -= eidAmounts[index];
				eidAmounts[index] += amount;
				eidCooldowns[index] = 0.5f;
			}
		}
		StartCoroutine(FillBlood(amount));
	}

	private IEnumerator FillBlood(float amount)
	{
		Vector4 value = meshBounds.size;
		Vector4 value2 = meshBounds.center;
		propBlock.SetVector("_MeshScale", value);
		propBlock.SetVector("_MeshCenter", value2);
		rend.SetPropertyBlock(propBlock);
		float timer = 0f;
		float initialFillAmount = fillAmount;
		amount *= fillSpeed;
		while (timer <= fillTimePerHit)
		{
			float t = timer / fillTimePerHit;
			float num = fillAmount;
			float num2 = Mathf.Lerp(initialFillAmount, initialFillAmount + amount * 0.01f, t);
			fillAmount += Mathf.Clamp01(num2 - num);
			propBlock.SetFloat("_FillAmount", fillAmount);
			rend.SetPropertyBlock(propBlock);
			timer += Time.deltaTime;
			if (fillAmount >= fullFillThreshold)
			{
				FullyFilled();
				timer = fillTimePerHit + 1f;
			}
			yield return null;
		}
	}

	private void FullyFilled()
	{
		fullyFilled = true;
		fillAmount = 1f;
		onFullyFilled?.Invoke();
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
		propBlock.SetFloat("_FillAmount", fillAmount);
		rend.SetPropertyBlock(propBlock);
	}

	public void InstaFill()
	{
		StartCoroutine(FillBlood(9999f));
	}
}



public class Bloodsplatter : MonoBehaviour
{
	public BSType bloodSplatterType;

	[HideInInspector]
	public ParticleSystem part;

	private int i;

	private AudioSource aud;

	private int eidID;

	private SpriteRenderer sr;

	private MeshRenderer mr;

	private NewMovement nmov;

	public int hpAmount;

	private SphereCollider col;

	public bool hpOnParticleCollision;

	[HideInInspector]
	public bool beenPlayed;

	public bool halfChance;

	public bool ready;

	private GoreZone gz;

	public bool underwater;

	private MaterialPropertyBlock propertyBlock;

	private bool canCollide = true;

	public BloodsplatterManager bsm;

	[HideInInspector]
	public bool fromExplosion;

	private ComponentsDatabase cdatabase;

	[HideInInspector]
	public EnemyIdentifier eid
	{
		set
		{
			if (value != null)
			{
				eidID = value.GetInstanceID();
			}
		}
	}

	private void Awake()
	{
		if (propertyBlock == null)
		{
			propertyBlock = new MaterialPropertyBlock();
		}
		if (!part)
		{
			part = GetComponent<ParticleSystem>();
		}
		if (part == null)
		{
			part = GetComponentInChildren<ParticleSystem>();
		}
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		if (!col)
		{
			col = GetComponent<SphereCollider>();
		}
		cdatabase = MonoSingleton<ComponentsDatabase>.Instance;
		ParticleSystem.MainModule main = part.main;
		main.stopAction = ParticleSystemStopAction.Callback;
		part.AddListener<ParticleSystemStoppedMessage>(Repool);
	}

	private void OnEnable()
	{
		if (beenPlayed)
		{
			return;
		}
		beenPlayed = true;
		if (bsm == null)
		{
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
		}
		bool flag = bsm.forceOn || MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled");
		if ((bool)part)
		{
			part.Clear();
			if (flag)
			{
				part.Play();
			}
		}
		canCollide = true;
		if (aud != null)
		{
			aud.pitch = Random.Range(0.75f, 1.5f);
			aud.Play();
		}
		if ((bool)col)
		{
			col.enabled = true;
		}
		if (underwater)
		{
			Invoke("DisableCollider", 2.5f);
		}
		else
		{
			Invoke("DisableCollider", 0.25f);
		}
	}

	private void OnDisable()
	{
		CancelInvoke("DisableCollider");
		ready = false;
	}

	private void OnTriggerEnter(Collider other)
	{
		Collide(other);
	}

	private void Collide(Collider other)
	{
		if (ready && !(bsm == null))
		{
			if (bsm.hasBloodFillers && ((bsm.bloodFillers.Contains(other.gameObject) && other.gameObject.TryGetComponent<BloodFiller>(out var component)) || ((bool)other.attachedRigidbody && bsm.bloodFillers.Contains(other.attachedRigidbody.gameObject) && other.attachedRigidbody.TryGetComponent<BloodFiller>(out component))))
			{
				component.FillBloodSlider(hpAmount, base.transform.position, eidID);
			}
			else if (canCollide && other.gameObject.CompareTag("Player"))
			{
				MonoSingleton<NewMovement>.Instance.GetHealth(hpAmount, silent: false, fromExplosion);
				DisableCollider();
			}
		}
	}

	public void Repool()
	{
		if (bloodSplatterType == BSType.dontpool)
		{
			Object.Destroy(base.gameObject);
		}
		if (bloodSplatterType == BSType.unknown)
		{
			Debug.LogWarning(string.Concat(base.gameObject, "has an unknown BSType, this shouldn't happen!"));
			Object.Destroy(base.gameObject);
		}
		gz = null;
		eid = null;
		fromExplosion = false;
		ready = false;
		beenPlayed = false;
		base.transform.localScale = Vector3.one;
		if ((bool)bsm)
		{
			bsm.RepoolGore(this, bloodSplatterType);
		}
	}

	private void PlayBloodSound(Vector3 position)
	{
		if (Random.value < 0.1f)
		{
			bsm.splatterClip.PlayClipAtPoint(bsm.goreAudioGroup, position, 256, 1f, 1f, 0.5f, AudioRolloffMode.Logarithmic);
		}
	}

	[BurstCompile]
	public void CreateBloodstain(ref RaycastHit hit, BloodsplatterManager bsman)
	{
		bsm = bsman;
		Collider collider = hit.collider;
		if (collider == null)
		{
			return;
		}
		Rigidbody rigidbody = hit.rigidbody;
		GameObject gameObject = (rigidbody ? rigidbody.gameObject : collider.gameObject);
		Vector3 point = hit.point;
		if (StockMapInfo.Instance.continuousGibCollisions && gameObject.TryGetComponent<IBloodstainReceiver>(out var component) && component.HandleBloodstainHit(ref hit))
		{
			PlayBloodSound(point);
			return;
		}
		if (ready && hpOnParticleCollision && gameObject.CompareTag("Player"))
		{
			MonoSingleton<NewMovement>.Instance.GetHealth(3, silent: false, fromExplosion);
			return;
		}
		Transform transform = gameObject.transform;
		float bloodstainChance = bsm.GetBloodstainChance();
		bloodstainChance = (halfChance ? (bloodstainChance / 2f) : bloodstainChance);
		if (!((float)Random.Range(0, 100) < bloodstainChance) || (!gameObject.CompareTag("Wall") && !gameObject.CompareTag("Floor") && !gameObject.CompareTag("Moving") && ((!gameObject.CompareTag("Glass") && !gameObject.CompareTag("GlassFloor")) || transform.childCount <= 0)))
		{
			return;
		}
		Vector3 normal = hit.normal;
		if (!gz)
		{
			gz = GoreZone.ResolveGoreZone(base.transform);
		}
		PlayBloodSound(point);
		Vector3 vector = point + normal * 0.2f;
		if (gameObject.CompareTag("Moving") || ((bool)cdatabase && cdatabase.scrollers.Contains(transform)))
		{
			if ((bool)cdatabase && cdatabase.scrollers.Contains(transform) && transform.TryGetComponent<ScrollingTexture>(out var component2))
			{
				component2.parent.CreateChild(vector, normal);
			}
			else
			{
				gameObject.GetOrAddComponent<BloodstainParent>().CreateChild(vector, normal, fromStep: true);
			}
		}
		else if (gameObject.CompareTag("Glass") || gameObject.CompareTag("GlassFloor"))
		{
			gameObject.GetOrAddComponent<BloodstainParent>().CreateChild(vector, normal, fromStep: true);
		}
		else
		{
			bsm.CreateBloodstain(vector, normal);
		}
	}

	private void DisableCollider()
	{
		canCollide = false;
		if (!part.isPlaying)
		{
			Repool();
		}
	}

	public void GetReady()
	{
		ready = true;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class BloodsplatterManager : MonoSingleton<BloodsplatterManager>
{
	public struct InstanceProperties
	{
		public float3 pos;

		public float3 norm;

		public float isOil;

		public int parentIndex;

		public const int SIZE = 32;
	}

	public struct ClearJob : IJobParallelFor
	{
		[WriteOnly]
		public NativeArray<InstanceProperties> props;

		public void Execute(int index)
		{
			props[index] = default(InstanceProperties);
		}
	}

	public bool forceOn;

	public bool forceGibs;

	public bool neverFreezeGibs;

	public bool overrideBloodstainChance;

	public float bloodstainChance;

	public GameObject head;

	public GameObject limb;

	public GameObject body;

	public GameObject small;

	public GameObject smallest;

	public GameObject splatter;

	public GameObject underwater;

	public GameObject sand;

	public GameObject blessing;

	public GameObject chestExplosion;

	public GameObject brainChunk;

	public GameObject skullChunk;

	public GameObject eyeball;

	public GameObject jawChunk;

	public GameObject[] gib;

	public GameObject bloodStain;

	private Dictionary<BSType, Queue<GameObject>> gorePool = new Dictionary<BSType, Queue<GameObject>>();

	private Queue<GameObject> stainPool = new Queue<GameObject>();

	private Dictionary<BSType, int> defaultHPValues = new Dictionary<BSType, int>();

	private int order;

	private Transform goreStore;

	public bool hasBloodFillers;

	public HashSet<GameObject> bloodFillers = new HashSet<GameObject>();

	private WaitForSeconds slowUpdate = new WaitForSeconds(2f);

	public AudioMixerGroup goreAudioGroup;

	public AudioClip splatterClip;

	[HideInInspector]
	public int bloodDestroyers;

	[HideInInspector]
	public int bloodAbsorbers;

	[HideInInspector]
	public int bloodAbsorberChildren;

	public NativeArray<InstanceProperties> checkpointProps;

	public NativeArray<InstanceProperties> props;

	public NativeArray<float4x4> parents;

	public ComputeBuffer instanceBuffer;

	public ComputeBuffer parentBuffer;

	private int checkpointPropIndex;

	private int propIndex;

	private int parentIndex = 1;

	public Mesh stainMesh;

	public Material stainMat;

	public Bounds bloodstainBounds;

	public ClearJob clearJob;

	public const float PARTICLE_COLLISION_STEP_DT = 0.128f;

	public TimeSince sinceLastStep;

	private OptionsManager opm;

	public bool goreOn
	{
		get
		{
			if (!forceOn && !forceGibs)
			{
				return MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled");
			}
			return true;
		}
	}

	public event Action<int> reuseParentIndex;

	public event Action<int> reuseStainIndex;

	public event Action StainsCleared;

	public event Action<float> ParticleCollisionStep;

	public event Action PostCollisionStep;

	public void SaveBloodstains()
	{
		checkpointPropIndex = propIndex;
		checkpointProps.CopyFrom(props);
	}

	public void LoadBloodstains()
	{
		props.CopyFrom(checkpointProps);
		propIndex = checkpointPropIndex;
		instanceBuffer.SetData(props);
	}

	public int CreateBloodstain(float3 pos, float3 norm, int parent = 0)
	{
		propIndex = (propIndex + 1) % props.Length;
		props[propIndex] = new InstanceProperties
		{
			pos = pos,
			norm = norm,
			parentIndex = parent
		};
		this.reuseStainIndex?.Invoke(propIndex);
		instanceBuffer.SetData(props, propIndex, propIndex, 1);
		return propIndex;
	}

	public void DeleteBloodstain(int index)
	{
		props[index] = default(InstanceProperties);
		this.reuseStainIndex?.Invoke(index);
		instanceBuffer.SetData(props, index, index, 1);
	}

	public int CreateParent(float4x4 initialMatrix)
	{
		int num = parentIndex++;
		if (num >= parents.Length)
		{
			num = (parentIndex = 1);
		}
		this.reuseParentIndex?.Invoke(num);
		parents[num] = initialMatrix;
		return num;
	}

	public float GetBloodstainChance()
	{
		if (overrideBloodstainChance)
		{
			return bloodstainChance;
		}
		return opm.bloodstainChance;
	}

	protected override void Awake()
	{
		base.Awake();
		bloodstainBounds = new Bounds(Vector3.zero, Vector3.one * 100000f);
		props = new NativeArray<InstanceProperties>((int)MonoSingleton<PrefsManager>.Instance.GetFloatLocal("bloodStainMax", 100000f), Allocator.Persistent);
		checkpointProps = new NativeArray<InstanceProperties>(props.Length, Allocator.Persistent);
		instanceBuffer = new ComputeBuffer(props.Length, 32, ComputeBufferType.Structured);
		instanceBuffer.SetData(props);
		clearJob.props = props;
		parents = new NativeArray<float4x4>(512, Allocator.Persistent);
		parentBuffer = new ComputeBuffer(parents.Length, 64, ComputeBufferType.Structured);
		parents[0] = float4x4.identity;
		stainMat.SetBuffer("instanceBuffer", instanceBuffer);
		stainMat.SetBuffer("parentBuffer", parentBuffer);
		goreStore = base.transform.GetChild(0);
		float num = 0f;
		foreach (BSType value in Enum.GetValues(typeof(BSType)))
		{
			if (value != BSType.dontpool && value != BSType.unknown)
			{
				gorePool.Add(value, new Queue<GameObject>());
				num += 1f;
			}
		}
		opm = MonoSingleton<OptionsManager>.Instance;
		StartCoroutine(InitPools());
	}

	private void Update()
	{
		if ((float)sinceLastStep >= 0.128f)
		{
			sinceLastStep = 0f;
			this.ParticleCollisionStep?.Invoke(0.128f);
			this.PostCollisionStep?.Invoke();
		}
	}

	public void ClearStains()
	{
		clearJob.Schedule(props.Length, 512).Complete();
		instanceBuffer.SetData(props);
		this.StainsCleared?.Invoke();
	}

	private void LateUpdate()
	{
		parentBuffer.SetData(parents);
		Graphics.DrawMeshInstancedProcedural(stainMesh, 0, stainMat, bloodstainBounds, props.Length);
	}

	protected override void OnEnable()
	{
		base.OnEnable();
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		checkpointProps.Dispose();
		props.Dispose();
		parents.Dispose();
		instanceBuffer.Release();
		parentBuffer.Release();
	}

	private GameObject GetPrefabByBSType(BSType bloodType)
	{
		return bloodType switch
		{
			BSType.head => head, 
			BSType.limb => limb, 
			BSType.body => body, 
			BSType.small => small, 
			BSType.smallest => smallest, 
			BSType.splatter => splatter, 
			BSType.underwater => underwater, 
			BSType.sand => sand, 
			BSType.blessing => blessing, 
			BSType.chestExplosion => chestExplosion, 
			BSType.brainChunk => brainChunk, 
			BSType.skullChunk => skullChunk, 
			BSType.eyeball => eyeball, 
			BSType.jawChunk => jawChunk, 
			BSType.gib => gib[UnityEngine.Random.Range(0, gib.Length)], 
			_ => null, 
		};
	}

	private IEnumerator InitPools()
	{
		InitPool(BSType.head);
		yield return null;
		InitPool(BSType.limb);
		yield return null;
		InitPool(BSType.body);
		yield return null;
		InitPool(BSType.small);
		yield return null;
		InitPool(BSType.splatter);
		yield return null;
		InitPool(BSType.underwater);
		yield return null;
		InitPool(BSType.smallest);
		yield return null;
		InitPool(BSType.sand);
		yield return null;
		InitPool(BSType.blessing);
		yield return null;
		InitPool(BSType.brainChunk);
		yield return null;
		InitPool(BSType.skullChunk);
		yield return null;
		InitPool(BSType.eyeball);
		yield return null;
		InitPool(BSType.jawChunk);
		yield return null;
		InitPool(BSType.gib);
		yield return null;
		InitPool(BSType.chestExplosion);
		yield return null;
	}

	private void InitPool(BSType bloodSplatterType)
	{
		Queue<GameObject> queue = gorePool[bloodSplatterType];
		GameObject prefabByBSType = GetPrefabByBSType(bloodSplatterType);
		if (prefabByBSType.TryGetComponent<Bloodsplatter>(out var component))
		{
			defaultHPValues.Add(bloodSplatterType, component.hpAmount);
		}
		int num = ((bloodSplatterType == BSType.body) ? 200 : 100);
		if (bloodSplatterType == BSType.gib || bloodSplatterType == BSType.brainChunk || bloodSplatterType == BSType.skullChunk || bloodSplatterType == BSType.eyeball || bloodSplatterType == BSType.jawChunk)
		{
			num = 200;
		}
		for (int i = 0; i < num; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefabByBSType, goreStore);
			queue.Enqueue(gameObject);
			if (gameObject.TryGetComponent<Bloodsplatter>(out component))
			{
				component.bsm = this;
			}
		}
	}

	private void InitStains()
	{
		for (int i = 0; i < 500; i++)
		{
			stainPool.Enqueue(UnityEngine.Object.Instantiate(bloodStain, goreStore));
		}
	}

	public GameObject GetStain(Vector3 position, Quaternion rotation)
	{
		GameObject gameObject = null;
		while (gameObject == null && stainPool.Count > 0)
		{
			gameObject = stainPool.Dequeue();
		}
		if (gameObject == null)
		{
			gameObject = UnityEngine.Object.Instantiate(bloodStain, position, rotation);
		}
		gameObject.transform.SetPositionAndRotation(position, rotation);
		gameObject.SetActive(value: true);
		return gameObject;
	}

	public void RepoolStain(GameObject stain)
	{
		if (stain != null)
		{
			stain.SetActive(value: false);
			stainPool.Enqueue(stain);
		}
	}

	public void RepoolGore(Bloodsplatter bs, BSType type)
	{
		if (type != BSType.dontpool && defaultHPValues.TryGetValue(type, out var value))
		{
			bs.hpAmount = value;
		}
		RepoolGore(bs.gameObject, type);
	}

	public void RepoolGore(GameObject go, BSType type)
	{
		if ((bool)go)
		{
			if (type != BSType.dontpool)
			{
				ReturnToQueue(go, type);
			}
			else
			{
				UnityEngine.Object.Destroy(go);
			}
		}
	}

	private void ReturnToQueue(GameObject go, BSType type)
	{
		if (type == BSType.unknown || type == BSType.dontpool)
		{
			UnityEngine.Object.Destroy(go);
		}
		go.SetActive(value: false);
		gorePool[type].Enqueue(go);
		go.transform.SetParent(goreStore);
		go.transform.localScale = Vector3.one;
	}

	public GameObject GetFromQueue(BSType type)
	{
		GameObject gameObject = null;
		Queue<GameObject> queue = gorePool[type];
		while (gameObject == null && queue.Count > 0)
		{
			gameObject = queue.Dequeue();
		}
		if (gameObject == null)
		{
			gameObject = UnityEngine.Object.Instantiate(GetPrefabByBSType(type), goreStore);
		}
		if (gameObject == null)
		{
			return null;
		}
		gameObject.SetActive(value: true);
		return gameObject;
	}

	public GameObject GetGore(GoreType got, EnemyIdentifier eid, bool fromExplosion = false)
	{
		return GetGore(got, eid.underwater, eid.sandified, eid.blessed, eid, fromExplosion);
	}

	public GameObject GetGore(GoreType got, bool isUnderwater = false, bool isSandified = false, bool isBlessed = false, EnemyIdentifier eid = null, bool fromExplosion = false)
	{
		if (isBlessed)
		{
			GameObject fromQueue = GetFromQueue(BSType.blessing);
			AudioSource component = fromQueue.GetComponent<AudioSource>();
			float splatterWeight = GetSplatterWeight(got);
			component.pitch = 1.15f + UnityEngine.Random.Range(-0.15f, 0.15f);
			component.volume = splatterWeight * 0.9f + 0.1f;
			fromQueue.transform.localScale *= splatterWeight * splatterWeight * 3f;
			return fromQueue;
		}
		if (isSandified)
		{
			GameObject fromQueue = GetFromQueue(BSType.sand);
			if (got == GoreType.Head)
			{
				return fromQueue;
			}
			AudioSource component2 = fromQueue.GetComponent<AudioSource>();
			AudioSource component3 = fromQueue.transform.GetChild(0).GetComponent<AudioSource>();
			AudioSource originalAudio = GetOriginalAudio(got);
			if ((bool)originalAudio)
			{
				component2.clip = originalAudio.clip;
				component2.volume = originalAudio.volume - 0.35f;
				component3.volume = originalAudio.volume - 0.2f;
			}
			return fromQueue;
		}
		switch (got)
		{
		case GoreType.Head:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				PrepareGore(fromQueue, -1, eid, fromExplosion);
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.head);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		case GoreType.Limb:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				fromQueue.transform.localScale *= 0.75f;
				PrepareGore(fromQueue, 20, eid, fromExplosion);
				AudioSource component8 = fromQueue.GetComponent<AudioSource>();
				AudioSource component9 = limb.GetComponent<AudioSource>();
				component8.clip = component9.clip;
				component8.volume = component9.volume;
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.limb);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		case GoreType.Body:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				fromQueue.transform.localScale *= 0.5f;
				PrepareGore(fromQueue, 10, eid, fromExplosion);
				AudioSource component12 = fromQueue.GetComponent<AudioSource>();
				AudioSource component13 = body.GetComponent<AudioSource>();
				component12.clip = component13.clip;
				component12.volume = component13.volume;
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.body);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		case GoreType.Small:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				fromQueue.transform.localScale *= 0.25f;
				PrepareGore(fromQueue, 10, eid, fromExplosion);
				AudioSource component6 = fromQueue.GetComponent<AudioSource>();
				AudioSource component7 = small.GetComponent<AudioSource>();
				component6.clip = component7.clip;
				component6.volume = component7.volume;
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.small);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		case GoreType.Smallest:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				fromQueue.transform.localScale *= 0.15f;
				PrepareGore(fromQueue, 5, eid, fromExplosion);
				AudioSource component10 = fromQueue.GetComponent<AudioSource>();
				AudioSource component11 = smallest.GetComponent<AudioSource>();
				component10.clip = component11.clip;
				component10.volume = component11.volume;
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.smallest);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		case GoreType.Splatter:
		{
			GameObject fromQueue;
			if (isUnderwater)
			{
				fromQueue = GetFromQueue(BSType.underwater);
				PrepareGore(fromQueue, -1, eid, fromExplosion);
				AudioSource component4 = fromQueue.GetComponent<AudioSource>();
				AudioSource component5 = splatter.GetComponent<AudioSource>();
				component4.clip = component5.clip;
				component4.volume = component5.volume;
				return fromQueue;
			}
			fromQueue = GetFromQueue(BSType.splatter);
			PrepareGore(fromQueue, -1, eid, fromExplosion);
			return fromQueue;
		}
		default:
			return null;
		}
	}

	private void PrepareGore(GameObject gob, int healthChange = -1, EnemyIdentifier eid = null, bool fromExplosion = false)
	{
		if ((healthChange >= 0 || !(eid == null) || fromExplosion) && gob.TryGetComponent<Bloodsplatter>(out var component))
		{
			if (healthChange >= 0)
			{
				component.hpAmount = healthChange;
			}
			if ((bool)eid)
			{
				component.eid = eid;
			}
			if (fromExplosion)
			{
				component.fromExplosion = true;
			}
		}
	}

	public GameObject GetGib(BSType type)
	{
		Queue<GameObject> queue = gorePool[type];
		GameObject gameObject = null;
		while (queue.Count > 0 && gameObject == null)
		{
			gameObject = queue.Dequeue();
		}
		if (gameObject == null)
		{
			gameObject = UnityEngine.Object.Instantiate(GetPrefabByBSType(type));
		}
		return gameObject;
	}

	private AudioSource GetOriginalAudio(GoreType got)
	{
		return got switch
		{
			GoreType.Limb => limb.GetComponent<AudioSource>(), 
			GoreType.Body => body.GetComponent<AudioSource>(), 
			GoreType.Small => small.GetComponent<AudioSource>(), 
			GoreType.Smallest => smallest.GetComponent<AudioSource>(), 
			_ => null, 
		};
	}

	private float GetSplatterWeight(GoreType got)
	{
		return got switch
		{
			GoreType.Limb => 0.75f, 
			GoreType.Body => 0.5f, 
			GoreType.Small => 0.125f, 
			GoreType.Smallest => 0.075f, 
			_ => 1f, 
		};
	}
}



public class BloodsplatterSoundpicker : MonoBehaviour
{
	public AudioClip head;

	public AudioClip limb;

	public AudioClip body;
}



public class Bloodstain : MonoBehaviour
{
	public int trackedIndex;

	private void OnDestroy()
	{
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			MonoSingleton<BloodsplatterManager>.Instance.props[trackedIndex] = default(BloodsplatterManager.InstanceProperties);
			base.transform.hasChanged = false;
		}
	}
}



public class BloodstainParent : MonoBehaviour
{
	public int parentIndex;

	public float4x4 matrixAtStep;

	private HashSet<int> children = new HashSet<int>();

	public void OnStep()
	{
		matrixAtStep = GetMatrix();
	}

	public float4x4 GetMatrix()
	{
		return float4x4.TRS(base.transform.position, base.transform.rotation, new float3(1));
	}

	private void Start()
	{
		parentIndex = MonoSingleton<BloodsplatterManager>.Instance.CreateParent(GetMatrix());
		OnStep();
		MonoSingleton<BloodsplatterManager>.Instance.reuseStainIndex += OnStainIndexReuse;
		MonoSingleton<BloodsplatterManager>.Instance.reuseParentIndex += OnParentIndexReuse;
		MonoSingleton<BloodsplatterManager>.Instance.StainsCleared += OnStainsCleared;
		MonoSingleton<BloodsplatterManager>.Instance.PostCollisionStep += OnStep;
	}

	public void OnStainsCleared()
	{
		parentIndex = -1;
		children.Clear();
	}

	public void CreateChild(float3 pos, float3 norm, bool fromStep = false)
	{
		if (parentIndex == -1)
		{
			parentIndex = MonoSingleton<BloodsplatterManager>.Instance.CreateParent(GetMatrix());
		}
		float4x4 a = math.inverse(fromStep ? matrixAtStep : GetMatrix());
		float3 pos2 = math.transform(a, pos);
		float3 norm2 = math.rotate(a, norm);
		int item = MonoSingleton<BloodsplatterManager>.Instance.CreateBloodstain(pos2, norm2, parentIndex);
		children.Add(item);
	}

	private void OnStainIndexReuse(int index)
	{
		children.Remove(index);
	}

	private void OnParentIndexReuse(int index)
	{
		if (index == parentIndex)
		{
			parentIndex = -1;
			ClearChildren();
		}
	}

	private void Update()
	{
		if (parentIndex != -1 && base.transform.hasChanged)
		{
			MonoSingleton<BloodsplatterManager>.Instance.parents[parentIndex] = GetMatrix();
			base.transform.hasChanged = false;
		}
	}

	private void OnDestroy()
	{
		if ((bool)MonoSingleton<BloodsplatterManager>.Instance)
		{
			MonoSingleton<BloodsplatterManager>.Instance.reuseStainIndex -= OnStainIndexReuse;
			MonoSingleton<BloodsplatterManager>.Instance.reuseParentIndex -= OnParentIndexReuse;
			MonoSingleton<BloodsplatterManager>.Instance.PostCollisionStep -= OnStep;
			MonoSingleton<BloodsplatterManager>.Instance.StainsCleared -= OnStainsCleared;
		}
	}

	private void OnDisable()
	{
		ClearChildren();
	}

	public void ClearChildren()
	{
		if (MonoSingleton<BloodsplatterManager>.Instance == null)
		{
			children.Clear();
			return;
		}
		foreach (int item in new HashSet<int>(children))
		{
			MonoSingleton<BloodsplatterManager>.Instance.DeleteBloodstain(item);
		}
		children.Clear();
	}
}



public class BloodUnderwaterChecker : MonoBehaviour
{
	private bool cancelled;

	private DryZoneController dzc;

	private void OnEnable()
	{
		dzc = MonoSingleton<DryZoneController>.Instance;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (cancelled || other.gameObject.layer != 4)
		{
			return;
		}
		Vector3 position = base.transform.position;
		Vector3 vector = new Vector3(position.x, position.y + 1.5f, position.z);
		if (!(Vector3.Distance(other.ClosestPointOnBounds(vector), vector) < 0.5f))
		{
			return;
		}
		if (dzc.dryZones != null && dzc.dryZones.Count > 0)
		{
			Collider[] array = Physics.OverlapSphere(position, 0.01f, 65536, QueryTriggerInteraction.Collide);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].TryGetComponent<DryZone>(out var _))
				{
					base.gameObject.SetActive(value: false);
					cancelled = true;
					return;
				}
			}
		}
		GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Body, isUnderwater: true);
		if (!gore)
		{
			return;
		}
		Bloodsplatter component2 = base.transform.parent.GetComponent<Bloodsplatter>();
		Bloodsplatter component3 = gore.GetComponent<Bloodsplatter>();
		if ((bool)component3 && (bool)component2)
		{
			component3.hpAmount = component2.hpAmount;
			component3.fromExplosion = component2.fromExplosion;
			if (component2.ready)
			{
				component3.GetReady();
			}
		}
		gore.transform.position = base.transform.position;
		GoreZone componentInParent = GetComponentInParent<GoreZone>();
		if (componentInParent != null && componentInParent.goreZone != null)
		{
			gore.transform.SetParent(componentInParent.goreZone, worldPositionStays: true);
		}
		gore.SetActive(value: true);
		base.transform.parent.gameObject.SetActive(value: false);
	}
}



public class Bonus : MonoBehaviour
{
	private Vector3 cRotation;

	public GameObject breakEffect;

	private bool activated;

	public bool ghost;

	public bool tutorial;

	public bool superCharge;

	public bool dontReplaceWithGhost;

	[HideInInspector]
	public bool beenFound;

	public int secretNumber = -1;

	public GameObject ghostVersion;

	private void Start()
	{
		cRotation = new Vector3(Random.Range(-5, 5), Random.Range(-5, 5), Random.Range(-5, 5));
		if (secretNumber >= 0 && !ghostVersion && MonoSingleton<StatsManager>.Instance.secretObjects[secretNumber] != base.gameObject)
		{
			MonoSingleton<StatsManager>.Instance.secretObjects[secretNumber] = base.gameObject;
		}
		if (beenFound || (secretNumber >= 0 && MonoSingleton<StatsManager>.Instance.newSecrets.Contains(secretNumber)))
		{
			Debug.Log("Name: " + base.gameObject.name + ". Been Found: " + beenFound.ToString() + ". Secret Number: " + secretNumber);
			BeenFound();
		}
	}

	public void UpdateStatsManagerReference()
	{
		if (secretNumber >= 0 && !ghost && MonoSingleton<StatsManager>.Instance.secretObjects[secretNumber] != base.gameObject)
		{
			MonoSingleton<StatsManager>.Instance.secretObjects[secretNumber] = base.gameObject;
		}
	}

	private void Update()
	{
		base.transform.Rotate(cRotation * Time.deltaTime * 5f);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.gameObject.CompareTag("Player") || activated)
		{
			return;
		}
		if (!ghost)
		{
			activated = true;
			MonoSingleton<TimeController>.Instance.ParryFlash();
			StyleHUD instance = MonoSingleton<StyleHUD>.Instance;
			StatsManager instance2 = MonoSingleton<StatsManager>.Instance;
			Object.Instantiate(breakEffect, base.transform.position, Quaternion.identity);
			instance.AddPoints(0, "ultrakill.secret");
			instance2.secrets++;
			instance2.SecretFound(secretNumber);
			Object.Destroy(base.gameObject);
		}
		else
		{
			if (tutorial)
			{
				MonoSingleton<TimeController>.Instance.ParryFlash();
			}
			Object.Instantiate(breakEffect, base.transform.position, Quaternion.identity);
			Object.Destroy(base.gameObject);
		}
		if (superCharge)
		{
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				MonoSingleton<NewMovement>.Instance.SuperCharge();
			}
			else
			{
				MonoSingleton<PlatformerMovement>.Instance.AddExtraHit(2);
			}
			if (!MonoSingleton<PrefsManager>.Instance.GetBool("hideSuperChargePopup") && MonoSingleton<PrefsManager>.Instance.GetInt("difficulty") > 0)
			{
				MonoSingleton<PrefsManager>.Instance.SetBool("hideSuperChargePopup", content: true);
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=red>RED SOUL ORBS</color> give <color=green>200 HEALTH</color>. \nOverheal cannot be regained with blood.", "", "", 1);
			}
		}
		else if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			MonoSingleton<PlatformerMovement>.Instance.AddExtraHit();
		}
	}

	public void BeenFound()
	{
		if (ghostVersion == null)
		{
			Debug.Log("No ghost version for " + base.gameObject.name);
			ghostVersion = PrefabReplacer.Instance.LoadPrefab("Bonus Ghost");
			return;
		}
		GameObject gameObject = Object.Instantiate(ghostVersion, base.transform.position, base.transform.rotation);
		if ((bool)base.transform.parent)
		{
			gameObject.transform.SetParent(base.transform.parent, worldPositionStays: true);
		}
		if (TryGetComponent<DualWieldPickup>(out var component) && gameObject.TryGetComponent<DualWieldPickup>(out var component2))
		{
			component2.juiceAmount = component.juiceAmount;
		}
		base.gameObject.SetActive(value: false);
		Object.Destroy(base.gameObject);
	}
}



public class Bootstrap : MonoBehaviour
{
	private void Start()
	{
		Debug.Log(Addressables.RuntimePath);
		GameBuildSettings instance = GameBuildSettings.GetInstance();
		if (!instance.noTutorial && (!GameProgressSaver.GetTutorial() || !GameProgressSaver.GetIntro()))
		{
			MonoSingleton<PrefsManager>.Instance.SetInt("weapon.arm0", 1);
			SceneHelper.LoadScene("Tutorial", noBlocker: true);
		}
		else if (instance.startScene != null)
		{
			SceneHelper.LoadScene(instance.startScene, noBlocker: true);
		}
		else
		{
			SceneHelper.LoadScene("Intro", noBlocker: true);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class BossBarManager : MonoSingleton<BossBarManager>
{
	private static readonly plog.Logger Log = new plog.Logger("BossBarManager");

	[SerializeField]
	private float overflowShrinkFactor = 0.14f;

	[SerializeField]
	private float minimumSize = 0.3f;

	[SerializeField]
	private float baseOverflowedSize = 0.82f;

	[Space]
	[SerializeField]
	private RectTransform containerRect;

	[SerializeField]
	private BossHealthBarTemplate template;

	[SerializeField]
	private SliderLayer[] layers;

	private readonly Dictionary<int, BossHealthBarTemplate> bossBars = new Dictionary<int, BossHealthBarTemplate>();

	private readonly Dictionary<int, TimeSince> bossBarLastUpdated = new Dictionary<int, TimeSince>();

	private readonly Queue<int> bossBarsToRemove = new Queue<int>();

	private bool bossBarsVisible = true;

	private const float BossBarTimeToExpire = 3f;

	public void UpdateBossBar(BossHealthBar bossBar)
	{
		if (bossBar.source == null || !bossBar.source.Dead)
		{
			int bossBarId = bossBar.bossBarId;
			IEnemyHealthDetails source = bossBar.source;
			if (!bossBars.ContainsKey(bossBarId))
			{
				CreateBossBar(bossBar);
			}
			BossHealthBarTemplate bossHealthBarTemplate = bossBars[bossBarId];
			bossHealthBarTemplate.UpdateState(source);
			if (bossBar.secondaryBar)
			{
				bossHealthBarTemplate.UpdateSecondaryBar(bossBar);
			}
			else
			{
				bossHealthBarTemplate.ResetSecondaryBar();
			}
			if (!source.Dead)
			{
				bossBarLastUpdated[bossBarId] = 0f;
			}
		}
	}

	public void ExpireImmediately(int bossBarId)
	{
		if (bossBars.TryGetValue(bossBarId, out var value))
		{
			Log.Info($"Immediately removing boss bar {value.bossNameText.text} ({bossBarId})");
			bossBarLastUpdated[bossBarId] = 3f;
		}
	}

	private void CreateBossBar(BossHealthBar bossBar)
	{
		Log.Info($"Creating Boss Bar for {bossBar.bossName} ({bossBar.bossBarId})");
		BossHealthBarTemplate bossHealthBarTemplate = Object.Instantiate(template, containerRect);
		bossHealthBarTemplate.Initialize(bossBar, layers);
		bossHealthBarTemplate.UpdateState(bossBar.source);
		bossBars.Add(bossBar.bossBarId, bossHealthBarTemplate);
		if (bossBarsVisible)
		{
			RecalculateStretch();
		}
		else
		{
			bossHealthBarTemplate.SetVisible(isVisible: false);
		}
	}

	private void Update()
	{
		while (bossBarsToRemove.Count > 0)
		{
			int num = bossBarsToRemove.Dequeue();
			Log.Info($"Removing Expired Boss Bar for {bossBars[num].bossNameText.text} ({num})");
			Object.Destroy(bossBars[num].gameObject);
			bossBars.Remove(num);
			bossBarLastUpdated.Remove(num);
			RecalculateStretch();
		}
		foreach (KeyValuePair<int, BossHealthBarTemplate> bossBar in bossBars)
		{
			int key = bossBar.Key;
			if ((float)bossBarLastUpdated[key] > 3f && !bossBarsToRemove.Contains(key))
			{
				bossBarsToRemove.Enqueue(key);
			}
		}
		if (bossBarsVisible == HideUI.Active)
		{
			bossBarsVisible = !HideUI.Active;
			RefreshVisibility();
		}
	}

	private void RecalculateStretch()
	{
		float b = 1f;
		if (bossBars.Count > 2)
		{
			b = baseOverflowedSize - (float)(bossBars.Count - 2) * overflowShrinkFactor;
		}
		b = Mathf.Max(minimumSize, b);
		containerRect.localScale = new Vector3(1f, b, 1f);
		foreach (BossHealthBarTemplate value in bossBars.Values)
		{
			value.ScaleChanged(b);
		}
	}

	private void RefreshVisibility()
	{
		foreach (BossHealthBarTemplate value in bossBars.Values)
		{
			if (!(value == null))
			{
				value.SetVisible(bossBarsVisible);
			}
		}
		if (bossBarsVisible)
		{
			RecalculateStretch();
		}
	}

	public void ForceLayoutRebuild()
	{
		LayoutRebuilder.ForceRebuildLayoutImmediate(containerRect);
	}
}



public class BossHealthBar : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("BossHealthBar");

	[HideInInspector]
	public int bossBarId;

	[HideInInspector]
	public IEnemyHealthDetails source;

	public HealthLayer[] healthLayers;

	public string bossName;

	public bool secondaryBar;

	[FormerlySerializedAs("secondaryColor")]
	[SerializeField]
	public Color secondaryBarColor = Color.white;

	public float secondaryBarValue;

	private void Awake()
	{
		source = GetComponent<IEnemyHealthDetails>();
		source.ForceGetHealth();
		if (healthLayers == null)
		{
			healthLayers = Array.Empty<HealthLayer>();
		}
		if (healthLayers.Length == 0)
		{
			healthLayers = new HealthLayer[1];
			healthLayers[0] = new HealthLayer
			{
				health = source.Health
			};
		}
		if (string.IsNullOrEmpty(bossName))
		{
			bossName = source.FullName;
		}
		if (bossBarId == 0)
		{
			bossBarId = GetInstanceID();
		}
		else
		{
			Log.Info($"Taking over boss bar {bossBarId}");
		}
	}

	private void Start()
	{
		MonoSingleton<BossBarManager>.Instance.UpdateBossBar(this);
	}

	private void OnEnable()
	{
		if (!source.Dead)
		{
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if (instance == null)
			{
				instance = MonoSingleton<MusicManager>.Instance;
			}
			if (instance.useBossTheme)
			{
				instance.PlayBossMusic();
			}
		}
	}

	public void UpdateSecondaryBar(float value)
	{
		secondaryBarValue = value;
	}

	public void SetSecondaryBarColor(Color clr)
	{
		secondaryBarColor = clr;
	}

	private void Update()
	{
		MonoSingleton<BossBarManager>.Instance.UpdateBossBar(this);
	}

	private void OnDisable()
	{
		DisappearBar();
	}

	public void DisappearBar()
	{
		if ((bool)MonoSingleton<BossBarManager>.Instance)
		{
			MonoSingleton<BossBarManager>.Instance.ExpireImmediately(bossBarId);
		}
	}
}



public class BossHealthBarTemplate : MonoBehaviour
{
	private static readonly Color IdolProtectedColor = new Color(0.25f, 0.75f, 1f);

	public BossHealthSliderTemplate sliderTemplate;

	public TMP_Text bossNameText;

	public BossHealthSliderTemplate thinSliderTemplate;

	private TMP_Text[] textInstances;

	private Slider[] hpSlider;

	private Slider[] hpAfterImage;

	private Color[] hpColors;

	private float[] healFadeLerps;

	private float introCharge;

	private float waitForDamage;

	private GameObject filler;

	private float shakeTime;

	private Vector3 originalPosition;

	private bool done;

	private Slider secondarySlider;

	private GameObject secondaryObject;

	private int currentHpSlider;

	private int currentAfterImageSlider;

	private IEnemyHealthDetails source;

	public void Initialize(BossHealthBar bossBar, SliderLayer[] colorLayers)
	{
		source = bossBar.source;
		List<Slider> list = new List<Slider>();
		List<Slider> list2 = new List<Slider>();
		HealthLayer[] healthLayers = bossBar.healthLayers;
		bossNameText.text = bossBar.bossName.ToUpper();
		float num = 0f;
		for (int i = 0; i < healthLayers.Length; i++)
		{
			BossHealthSliderTemplate bossHealthSliderTemplate = Object.Instantiate(sliderTemplate, sliderTemplate.transform.parent);
			bossHealthSliderTemplate.name = "Health After Image " + bossBar.bossName;
			list2.Add(bossHealthSliderTemplate.slider);
			bossHealthSliderTemplate.slider.minValue = num;
			bossHealthSliderTemplate.slider.maxValue = num + healthLayers[i].health;
			bossHealthSliderTemplate.gameObject.SetActive(value: true);
			bossHealthSliderTemplate.background.SetActive(i == 0);
			bossHealthSliderTemplate.fill.color = colorLayers[i].afterImageColor;
			BossHealthSliderTemplate bossHealthSliderTemplate2 = Object.Instantiate(sliderTemplate, sliderTemplate.transform.parent);
			bossHealthSliderTemplate2.name = "Health Slider " + bossBar.bossName;
			list.Add(bossHealthSliderTemplate2.slider);
			bossHealthSliderTemplate2.slider.minValue = num;
			bossHealthSliderTemplate2.slider.maxValue = num + healthLayers[i].health;
			bossHealthSliderTemplate2.gameObject.SetActive(value: true);
			bossHealthSliderTemplate2.background.SetActive(value: false);
			bossHealthSliderTemplate2.fill.color = colorLayers[i].color;
			num += healthLayers[i].health;
		}
		hpSlider = list.ToArray();
		hpAfterImage = list2.ToArray();
		textInstances = GetComponentsInChildren<TMP_Text>(includeInactive: true);
		filler = sliderTemplate.filler;
		originalPosition = filler.transform.localPosition;
		for (int num2 = hpSlider.Length - 1; num2 >= 0; num2--)
		{
			if (bossBar.source.Health > hpSlider[num2].minValue)
			{
				currentHpSlider = num2;
				currentAfterImageSlider = currentHpSlider;
				break;
			}
		}
		Slider[] array = hpSlider;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].value = 0f;
		}
		array = hpAfterImage;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].value = 0f;
		}
		hpColors = new Color[hpSlider.Length];
		healFadeLerps = new float[hpSlider.Length];
		for (int k = 0; k < hpColors.Length; k++)
		{
			hpColors[k] = hpSlider[k].targetGraphic.color;
			hpSlider[k].targetGraphic.color = GetHPColor(k);
		}
		for (int l = 0; l < healFadeLerps.Length; l++)
		{
			healFadeLerps[l] = 1f;
		}
		if (bossBar.secondaryBar)
		{
			CreateSecondaryBar(bossBar);
		}
		base.gameObject.SetActive(value: true);
	}

	public void SetVisible(bool isVisible)
	{
		base.gameObject.SetActive(isVisible);
	}

	private void CreateSecondaryBar(BossHealthBar bossBar)
	{
		if (!secondaryObject)
		{
			BossHealthSliderTemplate bossHealthSliderTemplate = Object.Instantiate(thinSliderTemplate, thinSliderTemplate.transform.parent);
			secondarySlider = bossHealthSliderTemplate.slider;
			secondaryObject = bossHealthSliderTemplate.gameObject;
			secondarySlider.targetGraphic.color = bossBar.secondaryBarColor;
			secondarySlider.value = bossBar.secondaryBarValue;
			secondaryObject.SetActive(value: true);
			MonoSingleton<BossBarManager>.Instance.ForceLayoutRebuild();
		}
	}

	public void UpdateSecondaryBar(BossHealthBar bossBar)
	{
		if (!secondaryObject || !secondarySlider)
		{
			CreateSecondaryBar(bossBar);
		}
		secondarySlider.value = bossBar.secondaryBarValue;
		secondarySlider.targetGraphic.color = bossBar.secondaryBarColor;
	}

	public void ResetSecondaryBar()
	{
		if ((bool)secondaryObject || (bool)secondarySlider)
		{
			if ((bool)secondaryObject)
			{
				Object.Destroy(secondaryObject);
			}
			secondaryObject = null;
			secondarySlider = null;
			MonoSingleton<BossBarManager>.Instance.ForceLayoutRebuild();
		}
	}

	public void ScaleChanged(float scale)
	{
		TMP_Text[] array = textInstances;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].transform.localScale = new Vector3(scale, 1f, 1f);
		}
	}

	public void UpdateState(IEnemyHealthDetails details)
	{
		if (source == null || source != details)
		{
			source = details;
		}
	}

	private Color GetHPColor(int index)
	{
		if (source != null && source.Blessed)
		{
			return IdolProtectedColor;
		}
		return hpColors[index];
	}

	private void Update()
	{
		if (hpSlider[currentHpSlider].value != source.Health)
		{
			if (introCharge < source.Health)
			{
				introCharge = Mathf.MoveTowards(introCharge, source.Health, (source.Health - introCharge) * Time.deltaTime * 3f);
				Slider[] array = hpSlider;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].value = introCharge;
				}
			}
			else
			{
				if (hpSlider[currentHpSlider].value < source.Health)
				{
					hpSlider[currentHpSlider].targetGraphic.color = Color.green;
					healFadeLerps[currentHpSlider] = 0f;
				}
				shakeTime = 5f * (hpSlider[currentHpSlider].value - source.Health);
				hpSlider[currentHpSlider].value = source.Health;
				waitForDamage = 0.15f;
				if (hpSlider[currentHpSlider].minValue > source.Health && currentHpSlider > 0)
				{
					currentHpSlider--;
					hpSlider[currentHpSlider].value = source.Health;
				}
				else if (hpSlider[currentHpSlider].maxValue < source.Health && currentHpSlider < hpSlider.Length - 1)
				{
					hpSlider[currentHpSlider].value = hpSlider[currentHpSlider].value;
					currentHpSlider++;
				}
			}
		}
		if (hpAfterImage[currentAfterImageSlider].value != hpSlider[currentHpSlider].value)
		{
			if (waitForDamage > 0f && hpSlider[0].value > 0f)
			{
				waitForDamage = Mathf.MoveTowards(waitForDamage, 0f, Time.deltaTime);
			}
			else if (hpAfterImage[currentAfterImageSlider].value > hpSlider[currentHpSlider].value)
			{
				hpAfterImage[currentAfterImageSlider].value = Mathf.MoveTowards(hpAfterImage[currentAfterImageSlider].value, hpSlider[currentHpSlider].value, Time.deltaTime * (Mathf.Abs((hpAfterImage[currentAfterImageSlider].value - hpSlider[currentHpSlider].value) * 5f) + 0.5f));
			}
			else
			{
				hpAfterImage[currentAfterImageSlider].value = hpSlider[currentHpSlider].value;
			}
			if (hpAfterImage[currentAfterImageSlider].value <= hpAfterImage[currentAfterImageSlider].minValue && currentAfterImageSlider > 0)
			{
				currentAfterImageSlider--;
			}
		}
		for (int j = 0; j < hpColors.Length; j++)
		{
			if (hpSlider[j].targetGraphic.color != GetHPColor(j))
			{
				healFadeLerps[j] = Mathf.MoveTowards(healFadeLerps[j], 1f, Time.deltaTime * 2f);
				hpSlider[j].targetGraphic.color = Color.Lerp(Color.green, GetHPColor(j), healFadeLerps[j]);
			}
		}
		if (shakeTime != 0f)
		{
			if (shakeTime > 10f)
			{
				shakeTime = 10f;
			}
			shakeTime = Mathf.MoveTowards(shakeTime, 0f, Time.deltaTime * 10f);
			if (shakeTime <= 0f)
			{
				shakeTime = 0f;
				filler.transform.localPosition = originalPosition;
			}
			else
			{
				filler.transform.localPosition = new Vector3(originalPosition.x + Random.Range(0f - shakeTime, shakeTime), originalPosition.y + Random.Range(0f - shakeTime, shakeTime), originalPosition.z);
			}
		}
	}
}



public class BossHealthSliderTemplate : MonoBehaviour
{
	public Slider slider;

	public Image fill;

	public GameObject filler;

	public GameObject background;
}



public class BossIdentifier : MonoBehaviour
{
	private EnemyIdentifier eid;

	private AlwaysLookAtCamera alac;

	private void Awake()
	{
		CheckDifficultyOverride();
	}

	private void OnEnable()
	{
		CheckDifficultyOverride();
	}

	public void CheckDifficultyOverride()
	{
		if (!eid && !TryGetComponent<EnemyIdentifier>(out eid))
		{
			if (MonoSingleton<AssistController>.Instance.majorEnabled && ((bool)alac || TryGetComponent<AlwaysLookAtCamera>(out alac)))
			{
				alac.ChangeDifficulty(MonoSingleton<AssistController>.Instance.difficultyOverride);
			}
			else
			{
				Object.Destroy(this);
			}
		}
		else if (MonoSingleton<AssistController>.Instance.majorEnabled)
		{
			eid.difficultyOverride = MonoSingleton<AssistController>.Instance.difficultyOverride;
		}
		else
		{
			eid.difficultyOverride = -1;
		}
	}
}



public class Breakable : MonoBehaviour, IAlter, IAlterOptions<bool>
{
	public bool unbreakable;

	public bool weak;

	public bool precisionOnly;

	public bool interrupt;

	public bool breakOnThrown;

	[HideInInspector]
	public EnemyIdentifier interruptEnemy;

	public bool playerOnly;

	public bool accurateExplosionsOnly;

	public bool forceGroundSlammable;

	[Space(10f)]
	public GameObject breakParticle;

	public AssetReference breakParticleFallback;

	public bool particleAtBoundsCenter;

	public Transform customPositionRotation;

	[Space(10f)]
	public bool crate;

	public int bounceHealth;

	[HideInInspector]
	public int originalBounceHealth;

	public GameObject crateCoin;

	public int coinAmount;

	private float defaultHeight;

	public bool protectorCrate;

	[Space(10f)]
	public GameObject[] activateOnBreak;

	public GameObject[] destroyOnBreak;

	public UltrakillEvent destroyEvent;

	private bool broken;

	private Collider col;

	private TimeSince? timeSinceBurn;

	private ItemIdentifier itid;

	private Rigidbody rb;

	public string alterKey => "breakable";

	public string alterCategoryName => "Breakable";

	public AlterOption<bool>[] options => new AlterOption<bool>[2]
	{
		new AlterOption<bool>
		{
			name = "Weak",
			key = "weak",
			value = weak,
			callback = delegate(bool value)
			{
				weak = value;
			}
		},
		new AlterOption<bool>
		{
			name = "Unbreakable",
			key = "unbreakable",
			value = unbreakable,
			callback = delegate(bool value)
			{
				unbreakable = value;
			}
		}
	};

	private void Start()
	{
		defaultHeight = base.transform.localScale.y;
		originalBounceHealth = bounceHealth;
		if ((breakParticle == null || breakParticle.Equals(null) || SceneHelper.IsPlayingCustom) && breakParticleFallback != null && breakParticleFallback.RuntimeKeyIsValid())
		{
			breakParticle = breakParticleFallback.ToAsset();
		}
		if (breakOnThrown)
		{
			rb = GetComponent<Rigidbody>();
			itid = GetComponent<ItemIdentifier>();
		}
	}

	public void Bounce()
	{
		if (originalBounceHealth > 0 && (bool)crateCoin && ((bool)col || TryGetComponent<Collider>(out col)))
		{
			Object.Instantiate(crateCoin, col.bounds.center, Quaternion.identity, GoreZone.ResolveGoreZone(base.transform).transform);
		}
		if (bounceHealth > 1)
		{
			base.transform.localScale = new Vector3(base.transform.localScale.x, defaultHeight / 4f, base.transform.localScale.z);
			bounceHealth--;
		}
		else
		{
			Break();
		}
	}

	private void Update()
	{
		if ((float?)timeSinceBurn > 3f)
		{
			Break();
		}
		if (crate && base.transform.localScale.y != defaultHeight)
		{
			base.transform.localScale = new Vector3(base.transform.localScale.x, Mathf.MoveTowards(base.transform.localScale.y, defaultHeight, Time.deltaTime * 10f), base.transform.localScale.z);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (breakOnThrown && (bool)itid && !itid.pickedUp && itid.beenPickedUp && (rb == null || !rb.isKinematic) && collision.gameObject != MonoSingleton<NewMovement>.Instance.gameObject)
		{
			Break();
		}
	}

	private void HitWith(GameObject target)
	{
		if (breakOnThrown && (bool)itid && (target.layer == 10 || target.layer == 11))
		{
			if (MonoSingleton<FistControl>.Instance.heldObject == itid)
			{
				MonoSingleton<FistControl>.Instance.currentPunch.ResetHeldState();
			}
			base.transform.position = target.transform.position;
			Break();
		}
	}

	public void Burn()
	{
		if (weak)
		{
			Break();
		}
		else if (!unbreakable && !broken && !timeSinceBurn.HasValue)
		{
			timeSinceBurn = 0f;
		}
	}

	public void ForceBreak()
	{
		unbreakable = false;
		Break();
	}

	public void Break()
	{
		Debug.Log("Break");
		timeSinceBurn = null;
		if (unbreakable || broken)
		{
			return;
		}
		if (TryGetComponent<SandboxProp>(out var component) && TryGetComponent<Rigidbody>(out var component2) && component2.isKinematic && (bool)MonoSingleton<SandboxNavmesh>.Instance)
		{
			MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(component);
		}
		broken = true;
		if (breakParticle != null)
		{
			Vector3 position = base.transform.position;
			if (particleAtBoundsCenter && ((bool)col || TryGetComponent<Collider>(out col)))
			{
				position = col.bounds.center;
			}
			GameObject gameObject = Object.Instantiate(breakParticle, position, base.transform.rotation);
			if (customPositionRotation != null)
			{
				gameObject.transform.SetPositionAndRotation(customPositionRotation.position, customPositionRotation.rotation);
			}
		}
		if (crate)
		{
			MonoSingleton<CrateCounter>.Instance.AddCrate();
			if ((bool)crateCoin && coinAmount > 0 && ((bool)col || TryGetComponent<Collider>(out col)))
			{
				for (int i = 0; i < coinAmount; i++)
				{
					Object.Instantiate(crateCoin, col.bounds.center + new Vector3(Random.Range(-3f, 3f), 0f, Random.Range(-3f, 3f)), Quaternion.identity, GoreZone.ResolveGoreZone(base.transform).transform);
				}
			}
			if (protectorCrate && MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
			{
				MonoSingleton<PlatformerMovement>.Instance.AddExtraHit();
			}
		}
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		if (componentsInChildren.Length != 0)
		{
			Rigidbody[] array = componentsInChildren;
			foreach (Rigidbody obj in array)
			{
				obj.transform.SetParent(base.transform.parent, worldPositionStays: true);
				obj.isKinematic = false;
				obj.useGravity = true;
			}
		}
		if (activateOnBreak.Length != 0)
		{
			GameObject[] array2 = activateOnBreak;
			foreach (GameObject gameObject2 in array2)
			{
				if (gameObject2 != null)
				{
					gameObject2.SetActive(value: true);
				}
			}
		}
		if (destroyOnBreak.Length != 0)
		{
			GameObject[] array2 = destroyOnBreak;
			foreach (GameObject gameObject3 in array2)
			{
				if (gameObject3 != null)
				{
					Object.Destroy(gameObject3);
				}
			}
		}
		destroyEvent.Invoke();
		Object.Destroy(base.gameObject);
	}
}



public class BreakBreakables : MonoBehaviour
{
	public Breakable[] breakables;

	public float delay;

	private int i;

	private Collider col;

	private void Start()
	{
		if (!TryGetComponent<Collider>(out col) && breakables.Length != 0)
		{
			Break();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player") && breakables.Length != 0)
		{
			Break();
		}
	}

	private void Break()
	{
		if (i < breakables.Length)
		{
			if (breakables[i] != null)
			{
				breakables[i].Break();
			}
			i++;
			if (delay != 0f)
			{
				Invoke("Break", delay);
			}
			else
			{
				Break();
			}
		}
		else
		{
			Object.Destroy(this);
		}
	}
}



public class BreakChunks : MonoBehaviour
{
	public AssetReference[] chunks;

	private void Start()
	{
		if (chunks.Length == 0)
		{
			return;
		}
		GoreZone componentInParent = base.transform.GetComponentInParent<GoreZone>();
		GameObject[] array = chunks.ToAssets();
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = Object.Instantiate(array[i], base.transform.position, Random.rotation);
			Vector3 force = new Vector3(Random.Range(-45, 45), Random.Range(-45, 45), Random.Range(-45, 45));
			gameObject.GetComponent<Rigidbody>()?.AddForce(force, ForceMode.VelocityChange);
			if (componentInParent != null)
			{
				gameObject.transform.SetParent(componentInParent.gibZone);
			}
		}
	}
}



public class BreakOnImpact : MonoBehaviour
{
	[SerializeField]
	private float minImpactForce = 1f;

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.collider.CompareTag("Player") && !(collision.relativeVelocity.magnitude < minImpactForce))
		{
			GetComponent<Breakable>().Break();
		}
	}
}



public class BreakParticle : MonoBehaviour
{
	public GameObject particle;

	private void OnDestroy()
	{
		if (base.gameObject.activeInHierarchy)
		{
			Object.Instantiate(particle, base.transform.position, base.transform.rotation);
		}
	}
}



public class BreakZone : MonoBehaviour
{
	public bool weakOnly;

	public bool countsAsPrecise;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Breakable") && other.TryGetComponent<Breakable>(out var component) && (!weakOnly || component.weak) && (countsAsPrecise || !component.precisionOnly))
		{
			component.Break();
		}
	}
}



public class BrushBlock : SandboxProp, IAlter, IAlterOptions<Vector3>
{
	public Vector3 DataSize;

	public BlockType Type;

	public BoxCollider OverrideCollider;

	public BoxCollider WaterTrigger;

	public string alterKey => "block";

	public string alterCategoryName => "Material Block";

	public AlterOption<Vector3>[] options => new AlterOption<Vector3>[1]
	{
		new AlterOption<Vector3>
		{
			name = "Size",
			key = null,
			value = DataSize,
			callback = delegate(Vector3 value)
			{
				DataSize = value;
				float b = 10000f;
				DataSize.x = Mathf.Min(DataSize.x, b);
				DataSize.y = Mathf.Min(DataSize.y, b);
				DataSize.z = Mathf.Min(DataSize.z, b);
				RegenerateMesh();
			}
		}
	};

	public SavedBlock SaveBrushBlock()
	{
		SavedBlock obj = new SavedBlock
		{
			BlockSize = new SavedVector3(DataSize),
			BlockType = Type
		};
		SavedGeneric saveObject = obj;
		BaseSave(ref saveObject);
		return obj;
	}

	public void RegenerateMesh()
	{
		Mesh mesh = SandboxUtils.GenerateProceduralMesh(DataSize, simple: false);
		GetComponent<MeshFilter>().mesh = mesh;
		BoxCollider obj = (OverrideCollider ? OverrideCollider : GetComponent<BoxCollider>());
		obj.size = DataSize;
		obj.center = obj.size / 2f;
		if ((bool)WaterTrigger)
		{
			WaterTrigger.size = DataSize;
			WaterTrigger.center = WaterTrigger.size / 2f;
		}
		if (MonoSingleton<SandboxNavmesh>.Instance != null && frozen)
		{
			MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(this);
		}
	}
}


public enum BSType
{
	head,
	limb,
	body,
	small,
	smallest,
	splatter,
	underwater,
	sand,
	blessing,
	brainChunk,
	skullChunk,
	eyeball,
	jawChunk,
	gib,
	chestExplosion,
	dontpool,
	unknown
}



public class BulkInstantiate : MonoBehaviour
{
	[SerializeField]
	private int count = 1;

	[SerializeField]
	private bool instantiateOnEnable;

	[SerializeField]
	private bool instantiateOnStart = true;

	[SerializeField]
	private GameObject source;

	[SerializeField]
	private InstantiateObjectMode mode;

	private void OnEnable()
	{
		if (instantiateOnEnable)
		{
			Instantiate();
		}
	}

	private void Start()
	{
		if (instantiateOnStart)
		{
			Instantiate();
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = Color.green;
		Gizmos.DrawWireCube(base.transform.position, base.transform.lossyScale);
	}

	public void Instantiate()
	{
		for (int i = 0; i < count; i++)
		{
			GameObject gameObject = Object.Instantiate(source);
			Vector3 position = base.transform.position;
			Vector3 vector = base.transform.localScale / 2f;
			Vector3 position2 = new Vector3(Random.Range(position.x - vector.x, position.x + vector.x), Random.Range(position.y - vector.y, position.y + vector.y), Random.Range(position.z - vector.z, position.z + vector.z));
			gameObject.transform.position = position2;
			switch (mode)
			{
			case InstantiateObjectMode.ForceDisable:
				gameObject.SetActive(value: false);
				break;
			case InstantiateObjectMode.ForceEnable:
				gameObject.SetActive(value: true);
				break;
			}
		}
	}
}



public class BulletCheck : MonoBehaviour
{
	public CheckerType type;

	private Streetcleaner sc;

	private V2 v2;

	private AudioSource aud;

	private int difficulty;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		switch (type)
		{
		case CheckerType.Streetcleaner:
			sc = GetComponentInParent<Streetcleaner>();
			break;
		case CheckerType.V2:
			v2 = GetComponentInParent<V2>();
			break;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		switch (type)
		{
		case CheckerType.Streetcleaner:
			if (other.gameObject.layer == 14)
			{
				Grenade component2 = other.GetComponent<Grenade>();
				if (component2 != null)
				{
					component2.enemy = true;
					component2.CanCollideWithPlayer();
					sc?.DeflectShot();
					Rigidbody component3 = other.GetComponent<Rigidbody>();
					float magnitude = component3.velocity.magnitude;
					component3.velocity = base.transform.right * magnitude;
					other.transform.forward = base.transform.right;
					aud.Play();
				}
				else
				{
					sc?.Dodge();
				}
			}
			break;
		case CheckerType.V2:
			if (other.gameObject.layer == 14)
			{
				Projectile component = other.GetComponent<Projectile>();
				if (v2 == null)
				{
					v2 = GetComponentInParent<V2>();
				}
				if (component == null || component.safeEnemyType != EnemyType.V2 || difficulty > 2)
				{
					v2?.Dodge(other.transform);
				}
			}
			break;
		}
	}

	public void ForceDodge()
	{
		switch (type)
		{
		case CheckerType.Streetcleaner:
			sc?.Dodge();
			break;
		case CheckerType.V2:
			v2?.Dodge(base.transform);
			break;
		}
	}
}



public class BurningVoxel : MonoBehaviour
{
	private const float BurnTime = 6f;

	private const float ExtinguishTime = 2f;

	private const float KeepPlayerDamageForFraction = 0.5f;

	private const float KeepDamageForFraction = 0.85f;

	[SerializeField]
	[HideInInspector]
	private VoxelProxy proxy;

	private HurtCooldownCollection hurtCooldownCollection;

	[SerializeField]
	[HideInInspector]
	private FireZone fireZone;

	[SerializeField]
	[HideInInspector]
	private Transform fireParticles;

	[SerializeField]
	[HideInInspector]
	private TimeSince timeSinceInitialized;

	private TimeSince? timeSinceStartedExtinguishing;

	public void Initialize(VoxelProxy proxy)
	{
		this.proxy = proxy;
		hurtCooldownCollection = MonoSingleton<StainVoxelManager>.Instance.SharedHurtCooldownCollection;
		GameObject fire = MonoSingleton<FireObjectPool>.Instance.GetFire(isSimple: true);
		fire.transform.SetParent(base.transform, worldPositionStays: false);
		fire.transform.localPosition = new Vector3(0f, 2.0625f, 0f);
		fire.transform.localRotation = Quaternion.identity;
		fireParticles = fire.transform;
		timeSinceInitialized = 0f;
		StartCoroutine(BurningCoroutine());
	}

	private void OnEnable()
	{
		if (!(proxy == null))
		{
			if (!timeSinceStartedExtinguishing.HasValue && (float)timeSinceInitialized > 6f)
			{
				timeSinceStartedExtinguishing = (float)timeSinceInitialized - 6f;
			}
			if (hurtCooldownCollection == null)
			{
				hurtCooldownCollection = MonoSingleton<StainVoxelManager>.Instance.SharedHurtCooldownCollection;
			}
			StopAllCoroutines();
			StartCoroutine(BurningCoroutine());
		}
	}

	public void Refuel()
	{
		StopAllCoroutines();
		timeSinceStartedExtinguishing = null;
		timeSinceInitialized = 0f;
		StartCoroutine(BurningCoroutine());
	}

	private void Remove()
	{
		StopAllCoroutines();
		ReturnFire();
		MonoSingleton<StainVoxelManager>.Instance.DoneBurning(proxy);
	}

	private void ReturnFire()
	{
		if (fireParticles != null && MonoSingleton<FireObjectPool>.Instance != null)
		{
			MonoSingleton<FireObjectPool>.Instance.ReturnFire(fireParticles.gameObject, isSimple: true);
		}
	}

	private IEnumerator BurningCoroutine()
	{
		if (!timeSinceStartedExtinguishing.HasValue)
		{
			if (fireZone == null)
			{
				fireZone = base.gameObject.AddComponent<FireZone>();
				fireZone.source = FlameSource.Napalm;
				fireZone.HurtCooldownCollection = hurtCooldownCollection;
				fireZone.playerDamage = 10;
				BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
				boxCollider.isTrigger = true;
				Vector3 size = new Vector3(2.75f, 5.5f, 2.75f);
				boxCollider.size = size;
				boxCollider.center = new Vector3(0f, 0.5f, 0f);
			}
			SetSize(1f);
			yield return new WaitForSeconds(Mathf.Max(0f, 6f - (float)timeSinceInitialized));
			while (NoWeaponCooldown.NoCooldown)
			{
				yield return null;
			}
			timeSinceStartedExtinguishing = 0f;
		}
		if (!timeSinceStartedExtinguishing.HasValue)
		{
			throw new Exception("timeSinceStartedExtinguishing is null. It shouldn't be.");
		}
		while ((float?)timeSinceStartedExtinguishing < 2f)
		{
			SetSize(1f - (float)timeSinceStartedExtinguishing.Value / 2f);
			if (fireZone.canHurtPlayer && (float?)timeSinceStartedExtinguishing / 2f > 0.5f)
			{
				fireZone.canHurtPlayer = false;
			}
			if (fireZone != null && (float?)timeSinceStartedExtinguishing / 2f > 0.85f)
			{
				UnityEngine.Object.Destroy(fireZone);
			}
			yield return null;
		}
		Remove();
	}

	private void SetSize(float size)
	{
		fireParticles.localScale = Vector3.one * 4f * size;
		proxy.SetStainSize(size);
	}
}



public class ButtonHighlightParent : MonoBehaviour
{
	private Image[] buttons;

	private TMP_Text[] buttonTexts;

	private void Start()
	{
		buttons = GetComponentsInChildren<Image>();
		buttonTexts = new TMP_Text[buttons.Length];
		for (int i = 0; i < buttons.Length; i++)
		{
			buttonTexts[i] = buttons[i].GetComponentInChildren<TMP_Text>();
		}
	}

	public void ChangeButton(Image target)
	{
		for (int i = 0; i < buttons.Length; i++)
		{
			if (!(buttons[i] == null))
			{
				buttons[i].fillCenter = buttons[i] == target;
				if (buttonTexts[i] != null)
				{
					buttonTexts[i].color = ((buttons[i] == target) ? Color.black : Color.white);
				}
			}
		}
	}
}


public enum ButtonState
{
	Selected,
	Unselected,
	Locked
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CameraController : MonoSingleton<CameraController>
{
	public bool invert;

	public float minimumX = -89f;

	public float maximumX = 89f;

	public float minimumY = -360f;

	public float maximumY = 360f;

	public OptionsManager opm;

	public float scroll;

	public Vector3 originalPos;

	public Vector3 defaultPos;

	private Vector3 targetPos;

	public GameObject player;

	public NewMovement pm;

	[HideInInspector]
	public Camera cam;

	public bool activated;

	public int gamepadFreezeCount;

	public float rotationY;

	public float rotationX;

	public bool reverseX;

	public bool reverseY;

	public float cameraShaking;

	public float movementHor;

	public float movementVer;

	public int dodgeDirection;

	public float defaultFov;

	private AudioMixer[] audmix;

	private bool mouseUnlocked;

	public bool slide;

	private AssistController asscon;

	[SerializeField]
	private GameObject parryLight;

	[SerializeField]
	private GameObject parryFlash;

	[SerializeField]
	private Camera hudCamera;

	private float aspectRatio;

	private bool pixeled;

	private bool tilt;

	private float currentStop;

	private bool zooming;

	private float zoomTarget;

	private LayerMask environmentMask;

	public bool platformerCamera;

	protected override void Awake()
	{
		audmix = new AudioMixer[5]
		{
			MonoSingleton<AudioMixerController>.Instance.allSound,
			MonoSingleton<AudioMixerController>.Instance.goreSound,
			MonoSingleton<AudioMixerController>.Instance.musicSound,
			MonoSingleton<AudioMixerController>.Instance.doorSound,
			MonoSingleton<AudioMixerController>.Instance.unfreezeableSound
		};
		base.Awake();
		pm = MonoSingleton<NewMovement>.Instance;
		player = pm.gameObject;
	}

	private void Start()
	{
		cam = GetComponent<Camera>();
		if ((bool)MonoSingleton<StatsManager>.Instance)
		{
			asscon = MonoSingleton<AssistController>.Instance;
		}
		originalPos = base.transform.localPosition;
		defaultPos = base.transform.localPosition;
		targetPos = new Vector3(defaultPos.x, defaultPos.y - 0.2f, defaultPos.z);
		float fieldOfView = MonoSingleton<PrefsManager>.Instance.GetFloat("fieldOfView");
		if (platformerCamera)
		{
			fieldOfView = 105f;
		}
		cam.fieldOfView = fieldOfView;
		defaultFov = cam.fieldOfView;
		if (opm == null && (bool)MonoSingleton<StatsManager>.Instance && (bool)MonoSingleton<OptionsManager>.Instance)
		{
			opm = MonoSingleton<OptionsManager>.Instance;
		}
		AudioMixer[] array = audmix;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetFloat("allPitch", 1f);
		}
		CheckAspectRatio();
		CheckTilt();
		CheckMouseReverse();
		environmentMask = (int)environmentMask | 0x100;
		environmentMask = (int)environmentMask | 0x1000000;
	}

	protected override void OnEnable()
	{
		if (MonoSingleton<OptionsManager>.Instance.frozen || MonoSingleton<OptionsManager>.Instance.paused)
		{
			MonoSingleton<CameraController>.Instance.activated = true;
			activated = false;
		}
		base.OnEnable();
		CheckAspectRatio();
		CheckTilt();
		CheckMouseReverse();
		float fieldOfView = MonoSingleton<PrefsManager>.Instance.GetFloat("fieldOfView");
		if (platformerCamera)
		{
			fieldOfView = 105f;
		}
		cam.fieldOfView = fieldOfView;
		defaultFov = cam.fieldOfView;
	}

	private void Update()
	{
		CheckAspectRatio();
		if (Input.GetKeyDown(KeyCode.F1) && Debug.isDebugBuild)
		{
			if (Cursor.lockState != CursorLockMode.Locked)
			{
				Cursor.lockState = CursorLockMode.Locked;
				Cursor.visible = false;
			}
			else
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}
		if (cameraShaking > 0f)
		{
			if ((bool)MonoSingleton<OptionsManager>.Instance && MonoSingleton<OptionsManager>.Instance.paused)
			{
				base.transform.localPosition = defaultPos;
			}
			else
			{
				Vector3 vector = base.transform.parent.position + defaultPos;
				Vector3 vector2 = vector;
				if (cameraShaking > 1f)
				{
					vector2 += base.transform.right * Random.Range(-1, 2);
					vector2 += base.transform.up * Random.Range(-1, 2);
				}
				else
				{
					vector2 += base.transform.right * (cameraShaking * Random.Range(-1f, 1f));
					vector2 += base.transform.up * (cameraShaking * Random.Range(-1f, 1f));
				}
				if (Physics.Raycast(vector, vector2 - vector, out var hitInfo, Vector3.Distance(vector2, vector) + 0.4f, environmentMask))
				{
					base.transform.position = hitInfo.point - (vector2 - vector).normalized * 0.5f;
				}
				else
				{
					base.transform.position = vector2;
				}
				cameraShaking -= Time.unscaledDeltaTime * 3f;
			}
		}
		if (platformerCamera)
		{
			return;
		}
		if (player == null)
		{
			player = pm.gameObject;
		}
		scroll = Input.GetAxis("Mouse ScrollWheel");
		bool flag = activated;
		if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad && gamepadFreezeCount > 0)
		{
			flag = false;
		}
		if (GameStateManager.Instance.CameraLocked)
		{
			flag = false;
		}
		if (flag)
		{
			float num = 1f;
			Vector2 vector3 = MonoSingleton<InputManager>.Instance.InputSource.Look.ReadValue<Vector2>();
			if (zooming)
			{
				num = cam.fieldOfView / defaultFov;
			}
			if (!reverseY)
			{
				rotationX += vector3.y * (opm.mouseSensitivity / 10f) * num;
			}
			else
			{
				rotationX -= vector3.y * (opm.mouseSensitivity / 10f) * num;
			}
			if (!reverseX)
			{
				rotationY += vector3.x * (opm.mouseSensitivity / 10f) * num;
			}
			else
			{
				rotationY -= vector3.x * (opm.mouseSensitivity / 10f) * num;
			}
		}
		if (rotationY > 180f)
		{
			rotationY -= 360f;
		}
		else if (rotationY < -180f)
		{
			rotationY += 360f;
		}
		rotationX = Mathf.Clamp(rotationX, minimumX, maximumX);
		if (zooming)
		{
			cam.fieldOfView = Mathf.MoveTowards(cam.fieldOfView, zoomTarget, Time.deltaTime * 300f);
		}
		else if (pm.boost && dodgeDirection != 2)
		{
			if (dodgeDirection == 0)
			{
				cam.fieldOfView = defaultFov - defaultFov / 20f;
			}
			else if (dodgeDirection == 1)
			{
				cam.fieldOfView = defaultFov + defaultFov / 10f;
			}
		}
		else
		{
			cam.fieldOfView = Mathf.MoveTowards(cam.fieldOfView, defaultFov, Time.deltaTime * 300f);
		}
		if ((bool)hudCamera)
		{
			if (zooming)
			{
				hudCamera.fieldOfView = Mathf.MoveTowards(hudCamera.fieldOfView, zoomTarget, Time.deltaTime * 300f);
			}
			else if (hudCamera.fieldOfView != 90f)
			{
				hudCamera.fieldOfView = Mathf.MoveTowards(hudCamera.fieldOfView, 90f, Time.deltaTime * 300f);
			}
		}
		if (flag)
		{
			player.transform.localEulerAngles = new Vector3(0f, rotationY, 0f);
		}
		float num2 = 0f;
		float num3 = movementHor * -1f;
		float num4 = base.transform.localEulerAngles.z;
		if (num4 > 180f)
		{
			num4 -= 360f;
		}
		num2 = ((!tilt) ? Mathf.MoveTowards(num4, 0f, Time.deltaTime * 25f * (Mathf.Abs(num4) + 0.01f)) : (pm.boost ? Mathf.MoveTowards(num4, num3 * 5f, Time.deltaTime * 100f * (Mathf.Abs(num4 - num3 * 5f) + 0.01f)) : Mathf.MoveTowards(num4, num3, Time.deltaTime * 25f * (Mathf.Abs(num4 - num3) + 0.01f))));
		if (flag)
		{
			base.transform.localEulerAngles = new Vector3(0f - rotationX, 0f, num2);
		}
		if (!pm.activated || !(cameraShaking <= 0f))
		{
			return;
		}
		if (pm.walking && pm.standing && !pm.rising)
		{
			Vector3 localPosition = base.transform.localPosition;
			base.transform.localPosition = new Vector3(Mathf.MoveTowards(localPosition.x, targetPos.x, Time.deltaTime * 0.5f), Mathf.MoveTowards(localPosition.y, targetPos.y, Time.deltaTime * 0.5f * (Mathf.Min(pm.rb.velocity.magnitude, 15f) / 15f)), Mathf.MoveTowards(localPosition.z, targetPos.z, Time.deltaTime * 0.5f));
			if (base.transform.localPosition == targetPos && targetPos != defaultPos)
			{
				targetPos = defaultPos;
			}
			else if (base.transform.localPosition == targetPos && targetPos == defaultPos)
			{
				targetPos = new Vector3(defaultPos.x, defaultPos.y - 0.1f, defaultPos.z);
			}
		}
		else
		{
			base.transform.localPosition = defaultPos;
			targetPos = new Vector3(defaultPos.x, defaultPos.y - 0.1f, defaultPos.z);
		}
	}

	public void CameraShake(float shakeAmount)
	{
		float @float = MonoSingleton<PrefsManager>.Instance.GetFloat("screenShake");
		if (@float != 0f && cameraShaking < shakeAmount * @float)
		{
			cameraShaking = shakeAmount * @float;
		}
	}

	public void StopShake()
	{
		cameraShaking = 0f;
		base.transform.localPosition = defaultPos;
	}

	public void ResetCamera(float degreesY, float degreesX = 0f)
	{
		rotationY = degreesY;
		rotationX = degreesX;
	}

	public void Zoom(float amount)
	{
		zooming = true;
		zoomTarget = amount;
	}

	public void StopZoom()
	{
		zooming = false;
	}

	public void ResetToDefaultPos()
	{
		base.transform.localPosition = defaultPos;
		targetPos = new Vector3(defaultPos.x, defaultPos.y - 0.1f, defaultPos.z);
	}

	public Vector3 GetDefaultPos()
	{
		return base.transform.parent.position + defaultPos;
	}

	public void CheckAspectRatio()
	{
		if (!cam)
		{
			cam = GetComponent<Camera>();
		}
		if (aspectRatio != cam.aspect)
		{
			aspectRatio = cam.aspect;
			float x = Mathf.Min(aspectRatio / 1.778f, 1f);
			if ((bool)hudCamera)
			{
				hudCamera.transform.localScale = new Vector3(x, 1f, 1f);
			}
		}
	}

	public void CheckTilt()
	{
		tilt = MonoSingleton<PrefsManager>.Instance.GetBool("cameraTilt");
	}

	public void CheckMouseReverse()
	{
		reverseX = MonoSingleton<PrefsManager>.Instance.GetBool("mouseReverseX");
		reverseY = MonoSingleton<PrefsManager>.Instance.GetBool("mouseReverseY");
	}
}



[DisallowMultipleComponent]
[RequireComponent(typeof(Camera))]
[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CameraFrustumTargeter : MonoSingleton<CameraFrustumTargeter>
{
	private const int MaxPotentialTargets = 256;

	[SerializeField]
	private RectTransform crosshair;

	[SerializeField]
	private LayerMask mask;

	[SerializeField]
	private LayerMask occlusionMask;

	[SerializeField]
	private float maximumRange = 1000f;

	public float maxHorAim = 1f;

	private RaycastHit[] occluders;

	private Plane[] frustum;

	private Vector3[] corners;

	private Bounds bounds;

	private Collider[] targets;

	private Camera camera;

	public Collider CurrentTarget { get; private set; }

	public bool IsAutoAimed { get; private set; }

	public static bool IsEnabled
	{
		get
		{
			return MonoSingleton<PrefsManager>.Instance.GetBool("autoAim");
		}
		set
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("autoAim", value);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		frustum = new Plane[6];
		corners = new Vector3[4];
		targets = new Collider[256];
		camera = GetComponent<Camera>();
		occluders = new RaycastHit[16];
	}

	private bool RaycastFromViewportCenter(out RaycastHit hit)
	{
		return Physics.Raycast(camera.ViewportPointToRay(new Vector2(0.5f, 0.5f)), out hit, maximumRange, mask.value);
	}

	private void CalculateFrustumInformation()
	{
		camera.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), maximumRange, Camera.MonoOrStereoscopicEye.Mono, corners);
		bounds = GeometryUtility.CalculateBounds(corners, camera.transform.localToWorldMatrix);
		bounds.size = new Vector3(bounds.size.x, bounds.size.y, maximumRange);
		bounds.center = base.transform.position;
	}

	private void Update()
	{
		if (!IsEnabled || maxHorAim == 0f)
		{
			CurrentTarget = null;
			IsAutoAimed = false;
			return;
		}
		if (RaycastFromViewportCenter(out var hit) && !Physics.Raycast(camera.ViewportPointToRay(new Vector2(0.5f, 0.5f)), hit.distance, occlusionMask) && (!hit.collider.isTrigger || hit.collider.gameObject.layer == 22))
		{
			CurrentTarget = hit.collider;
			IsAutoAimed = false;
			return;
		}
		CalculateFrustumInformation();
		int num = Physics.OverlapBoxNonAlloc(bounds.center, bounds.extents, targets, base.transform.rotation, mask.value);
		float num2 = float.PositiveInfinity;
		Collider currentTarget = null;
		for (int i = 0; i < num; i++)
		{
			Vector3 position = base.transform.position;
			Vector3 direction = targets[i].bounds.center - position;
			if ((targets[i].gameObject.layer != 22 && targets[i].isTrigger) || (targets[i].gameObject.layer == 22 && (!targets[i].TryGetComponent<HookPoint>(out var component) || !component.active)) || (targets[i].gameObject.layer == 10 && !targets[i].TryGetComponent<Coin>(out var _)) || (targets[i].gameObject.layer == 14 && !targets[i].TryGetComponent<Grenade>(out var _)))
			{
				continue;
			}
			int num3 = Physics.RaycastNonAlloc(position, direction, occluders, direction.magnitude, occlusionMask.value, QueryTriggerInteraction.Ignore);
			int num4 = 0;
			while (true)
			{
				if (num4 < num3)
				{
					if (!(occluders[num4].collider == null))
					{
						break;
					}
					num4++;
					continue;
				}
				Vector3 a = camera.WorldToViewportPoint(targets[i].bounds.center);
				float num5 = Vector3.Distance(a, new Vector2(0.5f, 0.5f));
				if (!(a.x > 0.5f + maxHorAim / 2f) && !(a.x < 0.5f - maxHorAim / 2f) && !(a.y > 0.5f + maxHorAim / 2f) && !(a.y < 0.5f - maxHorAim / 2f) && !(a.z < 0f) && num5 < num2)
				{
					num2 = num5;
					currentTarget = targets[i];
				}
				break;
			}
		}
		CurrentTarget = currentTarget;
		IsAutoAimed = true;
	}

	private void LateUpdate()
	{
		if (CurrentTarget == null || !IsAutoAimed)
		{
			crosshair.anchoredPosition = Vector2.zero;
			return;
		}
		Vector2 a = (Vector2)camera.WorldToViewportPoint(CurrentTarget.bounds.center) - new Vector2(0.5f, 0.5f);
		Vector2 referenceResolution = crosshair.GetParentCanvas().GetComponent<CanvasScaler>().referenceResolution;
		crosshair.anchoredPosition = Vector2.Scale(a, referenceResolution);
	}
}



public class CameraShake : MonoBehaviour
{
	public float amount;

	private void Start()
	{
		MonoSingleton<CameraController>.Instance.CameraShake(amount);
		Object.Destroy(this);
	}
}



public class CameraTargetInfo
{
	public Vector3 position;

	public Vector3 rotation;

	public GameObject caller;

	public CameraTargetInfo(Vector3 newPosition, GameObject newCaller)
	{
		position = newPosition;
		rotation = new Vector3(20f, 0f, 0f);
		caller = newCaller;
	}

	public CameraTargetInfo(Vector3 newPosition, Vector3 newRotation, GameObject newCaller)
	{
		position = newPosition;
		rotation = newRotation;
		caller = newCaller;
	}
}



[Serializable]
public class CampaignJson
{
	public string name;

	public string author;

	public string uuid;

	public CampaignLevel[] levels;

	[JsonIgnore]
	public string path;
}



[Serializable]
public class CampaignLevel
{
	public string uuid;

	public string file;
}



public class CampaignViewScreen : MonoBehaviour
{
	[SerializeField]
	private Text campaignTitle;

	[SerializeField]
	private CustomLevelButton buttonTemplate;

	[SerializeField]
	private Texture2D placeholderThumbnail;

	[SerializeField]
	private GameObject grid;

	public void Show(CustomCampaign campaign)
	{
	}

	public void Close()
	{
	}

	private void ResetGrid()
	{
		for (int i = 1; i < grid.transform.childCount; i++)
		{
			Object.Destroy(grid.transform.GetChild(i).gameObject);
		}
	}
}



public class CancerousRodent : MonoBehaviour
{
	private Rigidbody rb;

	private Machine mach;

	private Statue stat;

	private EnemyIdentifier eid;

	public bool harmless;

	public GameObject[] activateOnDeath;

	public Transform shootPoint;

	public GameObject projectile;

	private float coolDown = 2f;

	public int projectileAmount;

	private int currentProjectiles;

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		GetComponent<Collider>();
		if (harmless)
		{
			mach = GetComponent<Machine>();
		}
		else
		{
			stat = GetComponent<Statue>();
		}
		eid = GetComponent<EnemyIdentifier>();
	}

	private void OnDisable()
	{
		if (harmless || ((bool)stat && !(stat.health <= 0f)))
		{
			return;
		}
		GameObject[] array = activateOnDeath;
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: true);
			}
		}
	}

	private void Update()
	{
		if (rb != null)
		{
			if (eid.target == null)
			{
				rb.velocity = Vector3.zero;
			}
			else if (eid.target != null)
			{
				base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
				rb.velocity = base.transform.forward * Time.deltaTime * 100f * eid.totalSpeedModifier;
			}
		}
		if (harmless)
		{
			if (!(mach.health <= 0f))
			{
				return;
			}
			GameObject[] array = activateOnDeath;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: true);
				}
			}
			Object.Destroy(GetComponentInChildren<Light>().gameObject);
			Object.Destroy(this);
		}
		else if (stat.health > 0f && eid.target != null)
		{
			if (coolDown != 0f)
			{
				coolDown = Mathf.MoveTowards(coolDown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			else if (!Physics.Raycast(shootPoint.position, eid.target.position - shootPoint.position, Vector3.Distance(eid.target.position, shootPoint.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				coolDown = 3f;
				currentProjectiles = projectileAmount;
				FireBurst();
			}
		}
	}

	private void FireBurst()
	{
		GameObject obj = Object.Instantiate(projectile, shootPoint.position, shootPoint.rotation);
		obj.GetComponent<Rigidbody>().AddForce(shootPoint.forward * 2f, ForceMode.VelocityChange);
		if (obj.TryGetComponent<Projectile>(out var component))
		{
			component.target = eid.target;
			component.damage *= eid.totalDamageModifier;
		}
		currentProjectiles--;
		if (currentProjectiles > 0)
		{
			Invoke("FireBurst", 0.1f * eid.totalSpeedModifier);
		}
	}
}



public class Cannonball : MonoBehaviour
{
	public bool launchable = true;

	[SerializeField]
	public bool launched;

	private Rigidbody rb;

	private Collider col;

	[SerializeField]
	private GameObject breakEffect;

	private bool checkingForBreak;

	private bool broken;

	public float damage;

	public float speed;

	public bool parry;

	[HideInInspector]
	public Sisyphus sisy;

	public bool ghostCollider;

	public bool canBreakBeforeLaunched;

	[Header("Physics Cannonball Settings")]
	public bool physicsCannonball;

	public AudioSource bounceSound;

	[HideInInspector]
	public List<EnemyIdentifier> hitEnemies = new List<EnemyIdentifier>();

	public int maxBounces;

	private int currentBounces;

	[HideInInspector]
	public bool hasBounced;

	[HideInInspector]
	public bool forceMaxSpeed;

	public int durability = 99;

	[SerializeField]
	private GameObject interruptionExplosion;

	[SerializeField]
	private GameObject groundHitShockwave;

	[HideInInspector]
	public GameObject sourceWeapon;

	private TimeSince instaBreakDefence;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		col = GetComponent<Collider>();
		instaBreakDefence = 1f;
		if (physicsCannonball)
		{
			MonoSingleton<ObjectTracker>.Instance.AddCannonball(this);
		}
	}

	private void OnDestroy()
	{
		if (physicsCannonball && (bool)MonoSingleton<ObjectTracker>.Instance)
		{
			MonoSingleton<ObjectTracker>.Instance.RemoveCannonball(this);
		}
	}

	private void FixedUpdate()
	{
		if (launched)
		{
			rb.velocity = base.transform.forward * speed;
		}
		if (physicsCannonball && (bool)groundHitShockwave && rb.velocity.magnitude > 0f && rb.SweepTest(rb.velocity.normalized, out var hitInfo, rb.velocity.magnitude * Time.fixedDeltaTime) && (hitInfo.transform.gameObject.layer == 8 || hitInfo.transform.gameObject.layer == 24) && Vector3.Angle(hitInfo.normal, Vector3.up) < 45f)
		{
			GameObject obj = Object.Instantiate(groundHitShockwave, hitInfo.point + hitInfo.normal * 0.1f, Quaternion.identity);
			obj.transform.up = hitInfo.normal;
			if (obj.TryGetComponent<PhysicalShockwave>(out var component))
			{
				component.force = 10000f + rb.velocity.magnitude * 80f;
			}
			Break();
		}
		if (hitEnemies.Count <= 0)
		{
			return;
		}
		for (int num = hitEnemies.Count - 1; num >= 0; num--)
		{
			if (hitEnemies[num] == null || Vector3.Distance(base.transform.position, hitEnemies[num].transform.position) > 20f)
			{
				hitEnemies.RemoveAt(num);
			}
		}
	}

	public void Launch()
	{
		if (launchable)
		{
			launched = true;
			rb.isKinematic = false;
			rb.useGravity = false;
			col.isTrigger = true;
			hitEnemies.Clear();
			InstaBreakDefenceCancel();
			if (currentBounces == 1 && hasBounced)
			{
				damage += 2f;
			}
			currentBounces++;
			if ((bool)sisy)
			{
				sisy.GotParried();
			}
		}
	}

	public void Unlaunch(bool relaunchable = true)
	{
		launchable = relaunchable;
		launched = false;
		if ((bool)rb)
		{
			rb.isKinematic = !physicsCannonball;
			rb.useGravity = physicsCannonball;
			rb.velocity = Vector3.zero;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!ghostCollider || (launched && (other.gameObject.layer == 10 || other.gameObject.layer == 11 || other.gameObject.layer == 12)))
		{
			Collide(other);
		}
	}

	public void Collide(Collider other)
	{
		if ((launched || canBreakBeforeLaunched) && !other.isTrigger && (other.gameObject.layer == 8 || other.gameObject.layer == 24 || (launched && other.gameObject.layer == 0 && (!other.gameObject.CompareTag("Player") || !col.isTrigger))))
		{
			Break();
		}
		else
		{
			if ((!launched && !physicsCannonball) || (other.gameObject.layer != 10 && other.gameObject.layer != 11 && other.gameObject.layer != 12) || checkingForBreak)
			{
				return;
			}
			checkingForBreak = true;
			EnemyIdentifierIdentifier component = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
			EnemyIdentifier enemyIdentifier = ((!component || !component.eid) ? other.gameObject.GetComponent<EnemyIdentifier>() : component.eid);
			if ((bool)enemyIdentifier && !hitEnemies.Contains(enemyIdentifier))
			{
				if (physicsCannonball && (float)instaBreakDefence < 1f)
				{
					hitEnemies.Add(enemyIdentifier);
					return;
				}
				bool flag = true;
				if (!enemyIdentifier.dead)
				{
					flag = false;
				}
				enemyIdentifier.hitter = "cannonball";
				if (!physicsCannonball)
				{
					enemyIdentifier.DeliverDamage(other.gameObject, (other.transform.position - base.transform.position).normalized * 100f, base.transform.position, damage, tryForExplode: true);
				}
				else if (forceMaxSpeed)
				{
					enemyIdentifier.DeliverDamage(other.gameObject, base.transform.forward.normalized * 1000f, base.transform.position, damage, tryForExplode: true);
				}
				else if (rb.velocity.magnitude > 10f)
				{
					enemyIdentifier.DeliverDamage(other.gameObject, rb.velocity.normalized * rb.velocity.magnitude * 1000f, base.transform.position, Mathf.Min(damage, rb.velocity.magnitude * 0.15f), tryForExplode: true);
				}
				hitEnemies.Add(enemyIdentifier);
				if (physicsCannonball && launched && !flag)
				{
					if (hasBounced)
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(150, "ultrakill.cannonballedfrombounce", sourceWeapon, enemyIdentifier);
					}
					else
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.cannonboost", sourceWeapon, enemyIdentifier);
					}
				}
				if (!enemyIdentifier || enemyIdentifier.dead)
				{
					if (!flag)
					{
						durability--;
						if (durability <= 0)
						{
							Break();
						}
					}
					if (physicsCannonball && !launched && (!flag || other.gameObject.layer == 11))
					{
						Bounce();
					}
					if ((bool)enemyIdentifier)
					{
						enemyIdentifier.Explode();
					}
					checkingForBreak = false;
				}
				else
				{
					if (!physicsCannonball || rb.velocity.magnitude < 15f)
					{
						Break();
					}
					else
					{
						Bounce();
					}
					if (enemyIdentifier.enemyType == EnemyType.Sisyphus && enemyIdentifier.TryGetComponent<Sisyphus>(out var component2))
					{
						component2.Knockdown(base.transform.position);
					}
				}
			}
			else
			{
				checkingForBreak = false;
			}
		}
	}

	public void Break()
	{
		if ((bool)sisy)
		{
			checkingForBreak = false;
			launched = false;
			launchable = false;
			rb.useGravity = true;
			rb.velocity = Vector3.up * 25f;
			MonoSingleton<CameraController>.Instance.CameraShake(1f);
			if ((bool)breakEffect)
			{
				Object.Instantiate(breakEffect, base.transform.position, base.transform.rotation);
			}
			sisy.SwingStop();
		}
		else if (!broken)
		{
			broken = true;
			if ((bool)breakEffect)
			{
				Object.Instantiate(breakEffect, base.transform.position, base.transform.rotation);
			}
			Object.Destroy(base.gameObject);
		}
	}

	private void Bounce()
	{
		if (currentBounces >= maxBounces)
		{
			Break();
			return;
		}
		instaBreakDefence = 0f;
		currentBounces++;
		durability = 99;
		hasBounced = true;
		launched = false;
		launchable = true;
		checkingForBreak = false;
		rb.useGravity = true;
		rb.velocity = Vector3.up * rb.velocity.magnitude * 0.15f + rb.velocity.normalized * -5f;
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
		if ((bool)bounceSound)
		{
			Object.Instantiate(bounceSound, base.transform.position, Quaternion.identity);
		}
	}

	public void Explode()
	{
		if ((bool)interruptionExplosion)
		{
			Object.Instantiate(interruptionExplosion, base.transform.position, Quaternion.identity);
		}
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleExplosions"))
		{
			breakEffect = null;
		}
		Break();
	}

	public void InstaBreakDefenceCancel()
	{
		instaBreakDefence = 1f;
	}
}



public class CannonballExtraCollider : MonoBehaviour
{
	public Cannonball source;

	private void OnTriggerEnter(Collider other)
	{
		if (source.launched)
		{
			source.Collide(other);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CanvasController : MonoSingleton<CanvasController>
{
	protected override void Awake()
	{
		if ((bool)MonoSingleton<CanvasController>.Instance && MonoSingleton<CanvasController>.Instance != this)
		{
			Object.DestroyImmediate(base.gameObject);
		}
		else
		{
			base.Awake();
		}
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		base.transform.SetParent(null);
	}
}



public class Chainsaw : MonoBehaviour
{
	[HideInInspector]
	public Rigidbody rb;

	public float damage;

	public Transform attachedTransform;

	[HideInInspector]
	public Transform lineStartTransform;

	[SerializeField]
	private AudioSource ropeSnapSound;

	private AudioSource aud;

	public AudioSource stoppedAud;

	[SerializeField]
	private GameObject ricochetEffect;

	[SerializeField]
	private AudioClip enemyHitSound;

	[SerializeField]
	private GameObject enemyHitParticle;

	private LineRenderer lr;

	[HideInInspector]
	public bool stopped;

	public bool heated;

	public int hitAmount = 1;

	private int currentHitAmount;

	private Transform hitTarget;

	private List<Transform> hitLimbs = new List<Transform>();

	private EnemyIdentifier currentHitEnemy;

	private float multiHitCooldown;

	private float sameEnemyHitCooldown;

	[HideInInspector]
	public Vector3 originalVelocity;

	[HideInInspector]
	public bool beingPunched;

	private bool beenPunched;

	private bool inPlayer;

	private float playerHitTimer;

	private TimeSince ignorePlayerTimer;

	private float raycastBlockedTimer;

	[HideInInspector]
	public string weaponType;

	[HideInInspector]
	public GameObject sourceWeapon;

	public Nail sawbladeVersion;

	[SerializeField]
	private Renderer model;

	[SerializeField]
	private Transform sprite;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		lr = GetComponent<LineRenderer>();
		if (lineStartTransform == null)
		{
			lineStartTransform = attachedTransform;
		}
		ignorePlayerTimer = 0f;
		Invoke("SlowUpdate", 2f);
	}

	private void OnEnable()
	{
		MonoSingleton<WeaponCharges>.Instance.shoSawAmount++;
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<WeaponCharges>.Instance)
		{
			MonoSingleton<WeaponCharges>.Instance.shoSawAmount--;
		}
	}

	private void SlowUpdate()
	{
		if (Vector3.Distance(base.transform.position, attachedTransform.position) > 1000f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			Invoke("SlowUpdate", 2f);
		}
	}

	private void Update()
	{
		lr.SetPosition(0, lineStartTransform.position);
		lr.SetPosition(1, base.transform.position);
		if ((bool)rb)
		{
			if (inPlayer)
			{
				base.transform.forward = MonoSingleton<CameraController>.Instance.transform.forward * -1f;
			}
			else
			{
				base.transform.LookAt(base.transform.position + (base.transform.position - attachedTransform.position));
			}
		}
		if (sameEnemyHitCooldown > 0f && !stopped)
		{
			sameEnemyHitCooldown = Mathf.MoveTowards(sameEnemyHitCooldown, 0f, Time.deltaTime);
			if (sameEnemyHitCooldown <= 0f)
			{
				currentHitEnemy = null;
			}
		}
		if (inPlayer)
		{
			base.transform.position = attachedTransform.position;
			playerHitTimer = Mathf.MoveTowards(playerHitTimer, 0.25f, Time.deltaTime);
			stoppedAud.pitch = 0.5f;
			stoppedAud.volume = 0.75f;
			if (playerHitTimer >= 0.25f && !beingPunched)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else
		{
			if (hitAmount <= 1)
			{
				return;
			}
			if (multiHitCooldown > 0f)
			{
				multiHitCooldown = Mathf.MoveTowards(multiHitCooldown, 0f, Time.deltaTime);
			}
			else if (stopped)
			{
				if (!currentHitEnemy.dead && currentHitAmount > 0)
				{
					currentHitAmount--;
					DamageEnemy(hitTarget, currentHitEnemy);
				}
				if (currentHitEnemy.dead || currentHitAmount <= 0)
				{
					stopped = false;
					rb.velocity = originalVelocity.normalized * Mathf.Max(originalVelocity.magnitude, 35f);
					return;
				}
				multiHitCooldown = 0.05f;
			}
			if ((bool)stoppedAud)
			{
				if (stopped)
				{
					stoppedAud.pitch = 1.1f;
					stoppedAud.volume = 0.75f;
				}
				else
				{
					stoppedAud.pitch = 0.85f;
					stoppedAud.volume = 0.5f;
				}
			}
		}
	}

	private void FixedUpdate()
	{
		if (stopped)
		{
			rb.velocity = Vector3.zero;
			return;
		}
		if (Vector3.Dot(rb.velocity.normalized, (attachedTransform.position - base.transform.position).normalized) < 0.5f)
		{
			rb.velocity = Vector3.MoveTowards(rb.velocity, (attachedTransform.position - base.transform.position).normalized * 100f, Time.fixedDeltaTime * Vector3.Distance(attachedTransform.position, base.transform.position) * 10f);
		}
		else
		{
			rb.velocity = (attachedTransform.position - base.transform.position).normalized * Mathf.Min(100f, Mathf.MoveTowards(rb.velocity.magnitude, 100f, Time.fixedDeltaTime * Mathf.Max(10f, Vector3.Distance(attachedTransform.position, base.transform.position)) * 10f));
		}
		if ((float)ignorePlayerTimer > 0.66f && !inPlayer && Vector3.Distance(base.transform.position, attachedTransform.position) < 1f)
		{
			TouchPlayer();
			return;
		}
		if (Physics.Raycast(base.transform.position, attachedTransform.position - base.transform.position, Vector3.Distance(base.transform.position, attachedTransform.position), LayerMaskDefaults.Get(LMD.Environment)))
		{
			raycastBlockedTimer += Time.fixedDeltaTime;
		}
		else
		{
			raycastBlockedTimer = 0f;
		}
		if (raycastBlockedTimer >= 0.25f)
		{
			TurnIntoSawblade();
			return;
		}
		RaycastHit[] array = rb.SweepTestAll(rb.velocity.normalized, rb.velocity.magnitude * 5f * Time.fixedDeltaTime, QueryTriggerInteraction.Ignore);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Array.Sort(array, (RaycastHit x, RaycastHit y) => x.distance.CompareTo(y.distance));
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = array[i].transform.gameObject;
			if (gameObject.gameObject == MonoSingleton<NewMovement>.Instance.gameObject && (float)ignorePlayerTimer > 0.66f)
			{
				TouchPlayer();
			}
			else if ((gameObject.layer == 10 || gameObject.layer == 11) && (gameObject.gameObject.CompareTag("Head") || gameObject.gameObject.CompareTag("Body") || gameObject.gameObject.CompareTag("Limb") || gameObject.gameObject.CompareTag("EndLimb") || gameObject.gameObject.CompareTag("Enemy")))
			{
				TouchEnemy(gameObject.transform);
			}
			else
			{
				if (gameObject.layer != 8 && gameObject.layer != 24 && gameObject.layer != 26 && !gameObject.CompareTag("Armor"))
				{
					continue;
				}
				if (gameObject.TryGetComponent<Breakable>(out var component) && component.weak)
				{
					component.Break();
					return;
				}
				base.transform.position = array[i].point;
				rb.velocity = Vector3.Reflect(rb.velocity.normalized, array[i].normal) * (rb.velocity.magnitude / 2f);
				flag = true;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(ricochetEffect, array[i].point, Quaternion.LookRotation(array[i].normal));
				if (flag2 && gameObject2.TryGetComponent<AudioSource>(out var component2))
				{
					component2.enabled = false;
				}
				else
				{
					flag2 = true;
				}
				ignorePlayerTimer = 1f;
				break;
			}
		}
		if (flag)
		{
			CheckMultipleRicochets();
		}
	}

	private void TouchPlayer()
	{
		inPlayer = true;
		stopped = true;
		originalVelocity = rb.velocity;
		base.transform.position = MonoSingleton<NewMovement>.Instance.transform.position;
		model.gameObject.SetActive(value: false);
		sprite.localScale = Vector3.one * 20f;
	}

	private void TouchEnemy(Transform other)
	{
		if (hitAmount > 1)
		{
			if (!stopped && other.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid)
			{
				if (component.eid.dead)
				{
					HitEnemy(other, component);
				}
				else if (!(sameEnemyHitCooldown > 0f) || !(currentHitEnemy != null) || !(currentHitEnemy == component.eid))
				{
					stopped = true;
					currentHitAmount = hitAmount;
					hitTarget = other;
					currentHitEnemy = component.eid;
					originalVelocity = rb.velocity;
					sameEnemyHitCooldown = 0.25f;
				}
			}
		}
		else
		{
			HitEnemy(other);
		}
	}

	private void HitEnemy(Transform other, EnemyIdentifierIdentifier eidid = null)
	{
		if (((bool)eidid || other.TryGetComponent<EnemyIdentifierIdentifier>(out eidid)) && (bool)eidid.eid && (!(sameEnemyHitCooldown > 0f) || !(currentHitEnemy != null) || !(currentHitEnemy == eidid.eid)) && !hitLimbs.Contains(other))
		{
			if (!eidid.eid.dead)
			{
				sameEnemyHitCooldown = 0.25f;
				currentHitEnemy = eidid.eid;
				currentHitAmount--;
			}
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = enemyHitSound;
			aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			aud.volume = 0.2f;
			aud.Play();
			if ((bool)eidid && (bool)eidid.eid)
			{
				DamageEnemy(other, eidid.eid);
			}
		}
	}

	private void DamageEnemy(Transform other, EnemyIdentifier eid)
	{
		eid.hitter = (beenPunched ? "chainsawbounce" : "chainsaw");
		if (!eid.hitterWeapons.Contains(weaponType))
		{
			eid.hitterWeapons.Add(weaponType);
		}
		if (enemyHitParticle != null)
		{
			UnityEngine.Object.Instantiate(enemyHitParticle, other.transform.position, Quaternion.identity).transform.localScale *= 3f;
		}
		bool dead = eid.dead;
		eid.DeliverDamage(other.gameObject, (other.transform.position - base.transform.position).normalized * 3000f, base.transform.position, damage, tryForExplode: false, 0f, sourceWeapon);
		if (dead)
		{
			hitLimbs.Add(other);
		}
		if (heated)
		{
			Flammable componentInChildren = eid.GetComponentInChildren<Flammable>();
			if (componentInChildren != null)
			{
				componentInChildren.Burn(2f, componentInChildren.burning);
			}
		}
	}

	public void CheckMultipleRicochets(bool onStart = false)
	{
		if (!rb)
		{
			rb = GetComponent<Rigidbody>();
		}
		bool flag = false;
		for (int i = 0; i < 3; i++)
		{
			if (!Physics.Raycast(base.transform.position, rb.velocity.normalized, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				break;
			}
			if (hitInfo.transform.TryGetComponent<Breakable>(out var component) && component.weak)
			{
				component.Break();
				continue;
			}
			base.transform.position = hitInfo.point;
			rb.velocity = Vector3.Reflect(rb.velocity.normalized, hitInfo.normal) * (rb.velocity.magnitude / 2f);
			GameObject gameObject = UnityEngine.Object.Instantiate(ricochetEffect, hitInfo.point, Quaternion.LookRotation(hitInfo.normal));
			if (flag && gameObject.TryGetComponent<AudioSource>(out var component2))
			{
				component2.enabled = false;
			}
			else
			{
				flag = true;
			}
		}
		if (onStart)
		{
			Collider[] array = Physics.OverlapSphere(base.transform.position, 1.5f, LayerMaskDefaults.Get(LMD.Enemies));
			if (array.Length != 0)
			{
				TouchEnemy(array[0].transform);
			}
		}
	}

	public void GetPunched()
	{
		beenPunched = true;
		beingPunched = false;
		inPlayer = false;
		stopped = false;
		playerHitTimer = 0f;
		ignorePlayerTimer = 0f;
		sameEnemyHitCooldown = 0f;
		sprite.localScale = Vector3.one * 100f;
		model.gameObject.SetActive(value: true);
		if (hitAmount < 3)
		{
			hitAmount++;
			if (hitAmount == 3)
			{
				heated = true;
			}
		}
	}

	public void TurnIntoSawblade()
	{
		Nail nail = UnityEngine.Object.Instantiate(sawbladeVersion, base.transform.position, base.transform.rotation);
		nail.sourceWeapon = sourceWeapon;
		nail.weaponType = weaponType;
		nail.heated = heated;
		nail.rb.velocity = ((rb.velocity == Vector3.zero) ? base.transform.forward : (stopped ? originalVelocity : rb.velocity)).normalized * 105f;
		UnityEngine.Object.Instantiate(ropeSnapSound, base.transform.position, Quaternion.identity).volume /= 2f;
		base.gameObject.SetActive(value: false);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}


[ConfigureSingleton(SingletonFlags.DestroyDuplicates)]
public class ChallengeDoneByDefault : MonoSingleton<ChallengeDoneByDefault>
{
	private bool prepared;

	private void Start()
	{
		if (!prepared)
		{
			Prepare();
		}
	}

	public void Prepare()
	{
		if (!prepared)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
			prepared = true;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ChallengeManager : MonoSingleton<ChallengeManager>
{
	public GameObject challengePanel;

	public FinalRank fr;

	private bool completedCheck;

	private bool startCheckingForChallenge;

	public bool challengeDone;

	public bool challengeFailed;

	public bool challengeFailedPermanently;

	protected override void Awake()
	{
		base.Awake();
		if (fr == null)
		{
			fr = GetComponentInParent<FinalRank>();
		}
		SendMessage("OnDisable", base.gameObject);
		base.gameObject.SetActive(value: false);
		startCheckingForChallenge = true;
	}

	private new void OnEnable()
	{
		if (startCheckingForChallenge)
		{
			StatsManager obj = (MonoSingleton<StatsManager>.Instance ? MonoSingleton<StatsManager>.Instance : Object.FindObjectOfType<StatsManager>());
			if (challengeDone && !completedCheck && !challengeFailed)
			{
				ChallengeDone();
			}
			if (obj.challengeComplete && (!challengeDone || challengeFailed))
			{
				challengePanel.GetComponent<Image>().color = new Color(1f, 0.696f, 0f, 0.5f);
				challengePanel.GetComponent<AudioSource>().volume = 0f;
				challengePanel.SetActive(value: true);
			}
		}
	}

	public void ChallengeDone()
	{
		if (!challengeFailed)
		{
			if (fr == null)
			{
				fr = GetComponentInParent<FinalRank>();
			}
			challengeDone = true;
			Debug.Log("! CHALLENGE COMPLETE !");
			challengePanel.GetComponent<Image>().color = new Color(1f, 0.696f, 0f, 1f);
			challengePanel.SetActive(value: true);
			GameProgressSaver.ChallengeComplete();
			completedCheck = true;
			if (fr != null)
			{
				fr.FlashPanel(challengePanel.transform.parent.GetChild(2).gameObject);
			}
		}
	}

	public void ChallengeFailed()
	{
		challengeFailed = true;
	}
}



public class ChallengeTrigger : MonoBehaviour
{
	public ChallengeType type;

	public bool checkForNoEnemies;

	public bool evenIfPlayerDead;

	private bool colliderless;

	public bool disableOnExit;

	private void Start()
	{
		if (type == ChallengeType.Fail)
		{
			MonoSingleton<ChallengeDoneByDefault>.Instance.Prepare();
		}
		colliderless = GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null;
		if (colliderless && (evenIfPlayerDead || !MonoSingleton<NewMovement>.Instance.dead))
		{
			Entered();
		}
	}

	private void OnEnable()
	{
		if (colliderless && (evenIfPlayerDead || !MonoSingleton<NewMovement>.Instance.dead))
		{
			Entered();
		}
	}

	private void OnDisable()
	{
		if (colliderless && disableOnExit && base.gameObject.scene.isLoaded)
		{
			Exited();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player") && (!checkForNoEnemies || !DisableEnemySpawns.DisableArenaTriggers) && (evenIfPlayerDead || !MonoSingleton<NewMovement>.Instance.dead))
		{
			Entered();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (disableOnExit && other.gameObject.CompareTag("Player") && (!checkForNoEnemies || !DisableEnemySpawns.DisableArenaTriggers))
		{
			Exited();
		}
	}

	public void Entered()
	{
		if (type == ChallengeType.Fail)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = true;
			MonoSingleton<ChallengeManager>.Instance.challengeDone = false;
		}
		else if (type == ChallengeType.Succeed)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = false;
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
		Debug.Log("Player has entered " + base.gameObject.name);
	}

	public void Exited()
	{
		if (type == ChallengeType.Fail)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = false;
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
		else if (type == ChallengeType.Succeed)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = true;
			MonoSingleton<ChallengeManager>.Instance.challengeDone = false;
		}
		Debug.Log("Player has exited " + base.gameObject.name);
	}
}


public enum ChallengeType
{
	Succeed,
	Fail
}



public class ChangeLayer : MonoBehaviour
{
	public GameObject target;

	public int layer;

	public float delay;

	private void Start()
	{
		Invoke("Change", delay);
	}

	private void Change()
	{
		if (target != null)
		{
			target.layer = layer;
		}
		else
		{
			base.gameObject.layer = layer;
		}
		Object.Destroy(this);
	}
}



public class ChangeMaterials : MonoBehaviour
{
	public Material[] materials;

	private SkinnedMeshRenderer smr;

	private MeshRenderer mr;

	private Material[] oldMaterials;

	public bool enemySimplifierOverride;

	public bool enraged;

	public void Activate()
	{
		if (!smr)
		{
			smr = GetComponentInParent<SkinnedMeshRenderer>();
		}
		if ((bool)smr)
		{
			if (oldMaterials == null || oldMaterials.Length == 0)
			{
				oldMaterials = smr.materials;
			}
			smr.materials = materials;
			if (!enemySimplifierOverride || !TryGetComponent<EnemySimplifier>(out var component))
			{
				return;
			}
			EnemySimplifier.MaterialState stateToTarget = (enraged ? EnemySimplifier.MaterialState.enraged : EnemySimplifier.MaterialState.normal);
			for (int i = 0; i < smr.materials.Length; i++)
			{
				if (oldMaterials[i] != smr.materials[i])
				{
					component.ChangeMaterialNew(stateToTarget, materials[i]);
				}
			}
			return;
		}
		if (!mr)
		{
			mr = GetComponentInParent<MeshRenderer>();
		}
		if (!mr)
		{
			return;
		}
		if (oldMaterials == null || oldMaterials.Length == 0)
		{
			oldMaterials = mr.materials;
		}
		mr.materials = materials;
		if (!enemySimplifierOverride || !TryGetComponent<EnemySimplifier>(out var component2))
		{
			return;
		}
		EnemySimplifier.MaterialState stateToTarget2 = (enraged ? EnemySimplifier.MaterialState.enraged : EnemySimplifier.MaterialState.normal);
		for (int j = 0; j < mr.materials.Length; j++)
		{
			if (oldMaterials[j] != mr.materials[j])
			{
				component2.ChangeMaterialNew(stateToTarget2, materials[j]);
			}
		}
	}

	public void Reverse()
	{
		if (oldMaterials == null || oldMaterials.Length == 0)
		{
			return;
		}
		if ((bool)smr)
		{
			smr.materials = oldMaterials;
			if (!enemySimplifierOverride || !TryGetComponent<EnemySimplifier>(out var component))
			{
				return;
			}
			for (int i = 0; i < smr.materials.Length; i++)
			{
				if (materials[i] != smr.materials[i])
				{
					component.ChangeMaterial(materials[i], oldMaterials[i]);
				}
			}
		}
		else
		{
			if (!mr)
			{
				return;
			}
			mr.materials = oldMaterials;
			if (!enemySimplifierOverride || !TryGetComponent<EnemySimplifier>(out var component2))
			{
				return;
			}
			for (int j = 0; j < mr.materials.Length; j++)
			{
				if (materials[j] != mr.materials[j])
				{
					component2.ChangeMaterial(materials[j], oldMaterials[j]);
				}
			}
		}
	}
}



public class ChapterSelectButton : MonoBehaviour
{
	public LayerSelect[] layersInChapter;

	public TMP_Text rankText;

	private Image buttonBg;

	public int totalScore;

	public bool notComplete;

	public int golds;

	public int allPerfects;

	private void OnEnable()
	{
		CheckScore();
	}

	private void OnDisable()
	{
		totalScore = 0;
		notComplete = false;
		golds = 0;
		allPerfects = 0;
		if (buttonBg == null)
		{
			buttonBg = GetComponent<Image>();
		}
		buttonBg.color = Color.white;
		buttonBg.fillCenter = false;
		rankText.text = "";
		Image component = rankText.transform.parent.GetComponent<Image>();
		component.color = Color.white;
		component.fillCenter = false;
	}

	public void CheckScore()
	{
		totalScore = 0;
		notComplete = false;
		golds = 0;
		allPerfects = 0;
		if (buttonBg == null)
		{
			buttonBg = GetComponent<Image>();
		}
		buttonBg.color = Color.white;
		buttonBg.fillCenter = false;
		LayerSelect[] array = layersInChapter;
		foreach (LayerSelect layerSelect in array)
		{
			layerSelect.CheckScore();
			totalScore += layerSelect.trueScore;
			if (!layerSelect.complete)
			{
				notComplete = true;
			}
			if (layerSelect.allPerfects)
			{
				allPerfects++;
			}
			if (layerSelect.gold)
			{
				golds++;
			}
		}
		if (notComplete)
		{
			return;
		}
		if (allPerfects == layersInChapter.Length)
		{
			rankText.text = "<color=#FFFFFF>P</color>";
			Image component = rankText.transform.parent.GetComponent<Image>();
			component.color = new Color(1f, 0.686f, 0f, 1f);
			component.fillCenter = true;
			if (golds == layersInChapter.Length)
			{
				buttonBg.color = new Color(1f, 0.686f, 0f, 0.75f);
				buttonBg.fillCenter = true;
			}
			return;
		}
		totalScore /= layersInChapter.Length;
		switch (totalScore)
		{
		case 1:
			rankText.text = "<color=#4CFF00>C</color>";
			break;
		case 2:
			rankText.text = "<color=#FFD800>B</color>";
			break;
		case 3:
			rankText.text = "<color=#FF6A00>A</color>";
			break;
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			rankText.text = "<color=#FF0000>S</color>";
			break;
		default:
			rankText.text = "<color=#0094FF>D</color>";
			break;
		}
		Image component2 = rankText.transform.parent.GetComponent<Image>();
		component2.color = Color.white;
		component2.fillCenter = false;
	}
}



[CreateAssetMenu(fileName = "Cheat Assets", menuName = "ULTRAKILL/Cheat Asset DB")]
public class CheatAssetObject : ScriptableObject
{
	[Serializable]
	public struct KeyIcon
	{
		public string key;

		public Sprite sprite;
	}

	public new string name;

	[Header("Cheats")]
	[FormerlySerializedAs("GenericIcon")]
	public Sprite genericCheatIcon;

	[FormerlySerializedAs("Icons")]
	public KeyIcon[] cheatIcons;

	[Header("Sandbox")]
	public Sprite genericSandboxToolIcon;

	[FormerlySerializedAs("sandboxToolIcons")]
	public KeyIcon[] sandboxMenuIcons;

	public KeyIcon[] sandboxArmHoloIcons;
}



public class CheatBinds : MonoSingleton<CheatBinds>
{
	public Dictionary<string, InputActionState> registeredCheatBinds;

	public bool isRebinding;

	private readonly Dictionary<string, string> defaultBinds = new Dictionary<string, string>
	{
		{ "ultrakill.flight", "<Keyboard>/b" },
		{ "ultrakill.noclip", "<Keyboard>/v" },
		{ "ultrakill.blind-enemies", "<Keyboard>/m" },
		{ "ultrakill.infinite-wall-jumps", "<Keyboard>/n" },
		{ "ultrakill.no-weapon-cooldown", "<Keyboard>/c" },
		{ "ultrakill.keep-enabled", "<Keyboard>/o" },
		{ "ultrakill.teleport-menu", "<Keyboard>/l" },
		{ "ultrakill.spawner-arm", "<Keyboard>/p" },
		{ "ultrakill.disable-enemy-spawns", "<Keyboard>/i" },
		{ "ultrakill.sandbox.physics", "<Keyboard>/j" },
		{ "ultrakill.sandbox.snapping", "<Keyboard>/h" }
	};

	private readonly string[] bannedBinds = new string[5] { "/Keyboard/home", "/Keyboard/backquote", "/Mouse/press", "/Mouse/leftButton", "/Mouse/rightButton" };

	private InputAction rebindAction;

	private ICheat rebindCheat;

	protected override void Awake()
	{
		base.Awake();
		registeredCheatBinds = new Dictionary<string, InputActionState>();
	}

	public void RestoreBinds(Dictionary<string, List<ICheat>> allRegisteredCheats)
	{
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			foreach (ICheat item in allRegisteredCheat.Value)
			{
				string @string = MonoSingleton<PrefsManager>.Instance.GetString("cheatBinding." + item.Identifier, string.Empty);
				if (string.IsNullOrEmpty(@string))
				{
					if (defaultBinds.ContainsKey(item.Identifier))
					{
						AddBinding(item.Identifier, defaultBinds[item.Identifier]);
					}
				}
				else if (!string.IsNullOrEmpty(@string) && @string != "blank")
				{
					AddBinding(item.Identifier, @string);
				}
			}
		}
	}

	public void ResetCheatBind(string cheatIdentifier)
	{
		if (isRebinding)
		{
			CancelRebind();
		}
		if (registeredCheatBinds.ContainsKey(cheatIdentifier))
		{
			registeredCheatBinds[cheatIdentifier].Action.Disable();
			registeredCheatBinds[cheatIdentifier].Action.Dispose();
			registeredCheatBinds.Remove(cheatIdentifier);
		}
		MonoSingleton<PrefsManager>.Instance.DeleteKey("cheatBinding." + cheatIdentifier);
		if (defaultBinds.ContainsKey(cheatIdentifier))
		{
			AddBinding(cheatIdentifier, defaultBinds[cheatIdentifier]);
		}
	}

	public void CancelRebind()
	{
		rebindAction.Disable();
		rebindAction.Dispose();
		MonoSingleton<OptionsManager>.Instance.dontUnpause = false;
		isRebinding = false;
		MonoSingleton<CheatsManager>.Instance.UpdateCheatState(rebindCheat);
	}

	public void SetupRebind(ICheat targetCheat)
	{
		isRebinding = true;
		MonoSingleton<OptionsManager>.Instance.dontUnpause = true;
		rebindCheat = targetCheat;
		rebindAction = new InputAction(null, InputActionType.Value, "<Keyboard>/*");
		rebindAction.AddBinding("<Mouse>/<Button>");
		rebindAction.performed += RebindHandler;
		rebindAction.Enable();
		void RebindHandler(InputAction.CallbackContext context)
		{
			if (!(context.control.path == "/Keyboard/anyKey"))
			{
				if (context.control.path == "/Keyboard/escape")
				{
					isRebinding = false;
					rebindAction.performed -= RebindHandler;
					MonoSingleton<PrefsManager>.Instance.SetString("cheatBinding." + targetCheat.Identifier, "blank");
					MonoSingleton<OptionsManager>.Instance.dontUnpause = false;
					if (registeredCheatBinds.ContainsKey(targetCheat.Identifier))
					{
						registeredCheatBinds[targetCheat.Identifier].Action.Disable();
						registeredCheatBinds[targetCheat.Identifier].Action.Dispose();
						registeredCheatBinds.Remove(targetCheat.Identifier);
						MonoSingleton<CheatsManager>.Instance.UpdateCheatState(targetCheat);
					}
				}
				else if (!bannedBinds.Contains(context.control.path))
				{
					isRebinding = false;
					Rebind(targetCheat.Identifier, context.control.path);
					MonoSingleton<CheatsManager>.Instance.UpdateCheatState(targetCheat);
					rebindAction.performed -= RebindHandler;
					MonoSingleton<OptionsManager>.Instance.dontUnpause = false;
				}
			}
		}
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		if (registeredCheatBinds == null)
		{
			return;
		}
		foreach (KeyValuePair<string, InputActionState> registeredCheatBind in registeredCheatBinds)
		{
			registeredCheatBind.Value.Action.Disable();
			registeredCheatBind.Value.Action.Dispose();
		}
		registeredCheatBinds.Clear();
	}

	private void Rebind(string cheatIdentifier, string path)
	{
		if (registeredCheatBinds.ContainsKey(cheatIdentifier))
		{
			registeredCheatBinds[cheatIdentifier].Action.Disable();
			registeredCheatBinds[cheatIdentifier].Action.Dispose();
			registeredCheatBinds.Remove(cheatIdentifier);
		}
		AddBinding(cheatIdentifier, path);
		MonoSingleton<PrefsManager>.Instance.SetString("cheatBinding." + cheatIdentifier, path);
	}

	private void AddBinding(string cheatIdentifier, string path)
	{
		registeredCheatBinds.Add(cheatIdentifier, new InputActionState(new InputAction(cheatIdentifier)));
		registeredCheatBinds[cheatIdentifier].Action.AddBinding(path).WithGroup("Keyboard");
		registeredCheatBinds[cheatIdentifier].Action.performed += delegate
		{
			MonoSingleton<CheatsManager>.Instance.HandleCheatBind(cheatIdentifier);
		};
		registeredCheatBinds[cheatIdentifier].Action.Enable();
	}

	public string ResolveCheatKey(string cheatIdentifier)
	{
		if (!registeredCheatBinds.ContainsKey(cheatIdentifier))
		{
			return null;
		}
		return registeredCheatBinds[cheatIdentifier].Action.bindings[0].ToDisplayString();
	}
}



public class CheatMenuItem : MonoBehaviour
{
	public TMP_Text longName;

	public Image iconTarget;

	[Space]
	public Button stateButton;

	public Image stateBackground;

	public TMP_Text stateText;

	[Space]
	public TMP_Text bindButtonText;

	public Button bindButton;

	public Image bindButtonBack;

	[Space]
	public Button resetBindButton;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CheatsController : MonoSingleton<CheatsController>
{
	private static readonly plog.Logger Log = new plog.Logger("CheatsController");

	public GameObject spawnerArm;

	public GameObject fullBrightLight;

	private static readonly KeyCode[] Sequence = new KeyCode[10]
	{
		KeyCode.UpArrow,
		KeyCode.UpArrow,
		KeyCode.DownArrow,
		KeyCode.DownArrow,
		KeyCode.LeftArrow,
		KeyCode.RightArrow,
		KeyCode.LeftArrow,
		KeyCode.RightArrow,
		KeyCode.B,
		KeyCode.A
	};

	[Space]
	[SerializeField]
	private GameObject consentScreen;

	[SerializeField]
	private GameObject cheatsEnabledPanel;

	[SerializeField]
	private GameObject cheatsInfoPanel;

	[SerializeField]
	public GameObject cheatsTeleportPanel;

	public TMP_Text cheatsInfo;

	[Space]
	[SerializeField]
	private AudioSource cheatEnabledSound;

	[SerializeField]
	private AudioSource cheatDisabledSound;

	private int sequenceIndex;

	public bool cheatsEnabled;

	private bool noclip;

	private bool flight;

	private bool infiniteJumps;

	private bool stayEnabled;

	public SandboxArm arm;

	private static bool TryGetKeyboardButton(int sequenceIndex, out ButtonControl button)
	{
		button = null;
		if (Keyboard.current == null)
		{
			return false;
		}
		switch (Sequence[sequenceIndex])
		{
		case KeyCode.UpArrow:
			button = Keyboard.current.upArrowKey;
			break;
		case KeyCode.DownArrow:
			button = Keyboard.current.downArrowKey;
			break;
		case KeyCode.LeftArrow:
			button = Keyboard.current.leftArrowKey;
			break;
		case KeyCode.RightArrow:
			button = Keyboard.current.rightArrowKey;
			break;
		case KeyCode.A:
			button = Keyboard.current.aKey;
			break;
		case KeyCode.B:
			button = Keyboard.current.bKey;
			break;
		}
		return button != null;
	}

	private static bool TryGetGamepadButton(int sequenceIndex, out ButtonControl button)
	{
		button = null;
		if (Gamepad.current == null)
		{
			return false;
		}
		switch (Sequence[sequenceIndex])
		{
		case KeyCode.UpArrow:
			button = Gamepad.current.dpad.up;
			break;
		case KeyCode.DownArrow:
			button = Gamepad.current.dpad.down;
			break;
		case KeyCode.LeftArrow:
			button = Gamepad.current.dpad.left;
			break;
		case KeyCode.RightArrow:
			button = Gamepad.current.dpad.right;
			break;
		case KeyCode.A:
			button = Gamepad.current.buttonSouth;
			break;
		case KeyCode.B:
			button = Gamepad.current.buttonEast;
			break;
		}
		return button != null;
	}

	public void ShowTeleportPanel()
	{
		cheatsTeleportPanel.SetActive(value: true);
		GameStateManager.Instance.RegisterState(new GameState("teleport-menu", cheatsTeleportPanel)
		{
			cursorLock = LockMode.Unlock
		});
		MonoSingleton<OptionsManager>.Instance.Freeze();
	}

	private void Start()
	{
		if (CheatsManager.KeepCheatsEnabled)
		{
			MonoSingleton<AssistController>.Instance.cheatsEnabled = true;
			consentScreen.SetActive(value: false);
			cheatsEnabled = true;
			cheatsEnabledPanel.SetActive(value: true);
		}
	}

	public void PlayToggleSound(bool newState)
	{
		if (newState)
		{
			cheatEnabledSound.Play();
		}
		else
		{
			cheatDisabledSound.Play();
		}
	}

	private void ProcessInput()
	{
		TryGetGamepadButton(sequenceIndex, out var button);
		TryGetKeyboardButton(sequenceIndex, out var button2);
		if ((button2 != null && button2.wasPressedThisFrame) || (button != null && button.wasPressedThisFrame))
		{
			sequenceIndex++;
			if (sequenceIndex == Sequence.Length)
			{
				MonoSingleton<OptionsManager>.Instance.Pause();
				consentScreen.SetActive(value: true);
				sequenceIndex = 0;
			}
		}
		else
		{
			Keyboard current = Keyboard.current;
			if ((current != null && current.anyKey.wasPressedThisFrame) || AnyGamepadButtonPressed())
			{
				sequenceIndex = 0;
			}
		}
	}

	private bool AnyGamepadButtonPressed()
	{
		if (Gamepad.current == null)
		{
			return false;
		}
		foreach (InputControl allControl in Gamepad.current.allControls)
		{
			if (allControl is ButtonControl { wasPressedThisFrame: not false })
			{
				return true;
			}
		}
		return false;
	}

	private bool GamepadCombo()
	{
		if (Gamepad.current == null)
		{
			return false;
		}
		if (Gamepad.current.selectButton.isPressed)
		{
			return Gamepad.current.rightTrigger.wasPressedThisFrame;
		}
		return false;
	}

	public void Update()
	{
		if (!cheatsEnabled)
		{
			ProcessInput();
		}
		cheatsInfoPanel.SetActive(cheatsEnabled);
		if (MonoSingleton<CheatBinds>.Instance.isRebinding || !cheatsEnabled)
		{
			return;
		}
		if (Input.GetKeyDown(KeyCode.Home) || Input.GetKeyDown(KeyCode.Tilde) || Input.GetKeyDown(KeyCode.BackQuote) || GamepadCombo())
		{
			if (MonoSingleton<OptionsManager>.Instance.paused)
			{
				Log.Info("Un-Paused");
				if (SandboxHud.SavesMenuOpen)
				{
					MonoSingleton<SandboxHud>.Instance.HideSavesMenu();
				}
				MonoSingleton<CheatsManager>.Instance.HideMenu();
			}
			else
			{
				Log.Info("Paused");
				MonoSingleton<OptionsManager>.Instance.Pause();
				MonoSingleton<CheatsManager>.Instance.ShowMenu();
			}
		}
		if (HideCheatsStatus.HideStatus)
		{
			cheatsInfoPanel.SetActive(value: false);
		}
		cheatsEnabledPanel.SetActive(cheatsInfoPanel.activeSelf);
	}

	public void ActivateCheats()
	{
		MonoSingleton<AssistController>.Instance.cheatsEnabled = true;
		consentScreen.SetActive(value: false);
		cheatsEnabledPanel.SetActive(value: true);
		cheatsEnabled = true;
	}

	public void Cancel()
	{
		consentScreen.SetActive(value: false);
	}
}



public class CheatsControllerProxy : MonoBehaviour
{
	private CheatsController actualInstance;

	private void OnEnable()
	{
		actualInstance = MonoSingleton<CheatsController>.Instance;
	}

	private void Update()
	{
		actualInstance.Update();
	}
}



public class CheatsEnabler : MonoBehaviour
{
	private void Start()
	{
		MonoSingleton<CheatsController>.Instance.ActivateCheats();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CheatsManager : MonoSingleton<CheatsManager>
{
	[SerializeField]
	private GameObject cheatsManagerMenu;

	[Space]
	[SerializeField]
	private GameObject itemContainer;

	[SerializeField]
	private CheatMenuItem template;

	[Space]
	[SerializeField]
	private CheatMenuItem categoryTemplate;

	[Space]
	[SerializeField]
	private Color enabledColor = Color.green;

	[SerializeField]
	private Color disabledColor = Color.red;

	private Dictionary<ICheat, CheatMenuItem> menuItems;

	private Dictionary<string, ICheat> idToCheat;

	private Dictionary<string, List<ICheat>> allRegisteredCheats = new Dictionary<string, List<ICheat>>();

	private Dictionary<string, Sprite> spriteIcons;

	public static bool KeepCheatsEnabled
	{
		get
		{
			if (!MonoSingleton<PrefsManager>.Instance.GetBool("cheat.ultrakill.keep-enabled"))
			{
				if ((bool)MapInfoBase.InstanceAnyType)
				{
					return MapInfoBase.InstanceAnyType.sandboxTools;
				}
				return false;
			}
			return true;
		}
	}

	public void ShowMenu()
	{
		cheatsManagerMenu.SetActive(value: true);
		GameStateManager.Instance.RegisterState(new GameState("cheats-menu", cheatsManagerMenu)
		{
			cursorLock = LockMode.Unlock,
			playerInputLock = LockMode.Lock,
			cameraInputLock = LockMode.Lock
		});
	}

	public void HideMenu()
	{
		cheatsManagerMenu.SetActive(value: false);
	}

	public void RegisterCheat(ICheat cheat, string category = null)
	{
		if (string.IsNullOrEmpty(category))
		{
			category = "misc";
		}
		category = category.ToUpper();
		if (GetStartCheatState(cheat))
		{
			cheat.Enable();
		}
		if (allRegisteredCheats.ContainsKey(category))
		{
			allRegisteredCheats[category].Add(cheat);
			return;
		}
		allRegisteredCheats.Add(category, new List<ICheat> { cheat });
	}

	public void RegisterCheats(ICheat[] cheats, string category = null)
	{
		if (string.IsNullOrEmpty(category))
		{
			category = "misc";
		}
		category = category.ToUpper();
		foreach (ICheat cheat in cheats)
		{
			if (GetStartCheatState(cheat))
			{
				cheat.Enable();
			}
		}
		if (allRegisteredCheats.ContainsKey(category))
		{
			allRegisteredCheats[category].AddRange(cheats);
		}
		else
		{
			allRegisteredCheats.Add(category, cheats.ToList());
		}
	}

	public void RegisterExternalCheat(ICheat cheat)
	{
		RegisterCheat(cheat, "external");
	}

	public void ToggleCheat(ICheat targetCheat)
	{
		if (menuItems.ContainsKey(targetCheat))
		{
			MonoSingleton<CheatsController>.Instance.PlayToggleSound(!targetCheat.IsActive);
			WrappedSetState(targetCheat, !targetCheat.IsActive);
			UpdateCheatState(menuItems[targetCheat], targetCheat);
		}
	}

	public void RefreshCheatStates()
	{
		foreach (ICheat key in menuItems.Keys)
		{
			UpdateCheatState(menuItems[key], key);
		}
	}

	public void WrappedSetState(ICheat targetCheat, bool enable)
	{
		if (targetCheat.IsActive)
		{
			if (!enable)
			{
				targetCheat.Disable();
				SaveCheatState(targetCheat);
			}
		}
		else if (enable)
		{
			targetCheat.Enable();
			SaveCheatState(targetCheat);
		}
	}

	public bool GetCheatState(string id)
	{
		if (idToCheat == null || !idToCheat.ContainsKey(id))
		{
			return false;
		}
		if (idToCheat.ContainsKey(id))
		{
			return idToCheat[id].IsActive;
		}
		return false;
	}

	public void DisableCheat(string id)
	{
		if (idToCheat.ContainsKey(id))
		{
			DisableCheat(idToCheat[id]);
		}
	}

	public void DisableCheat(ICheat targetCheat)
	{
		if (menuItems.ContainsKey(targetCheat) && targetCheat.IsActive)
		{
			MonoSingleton<CheatsController>.Instance.PlayToggleSound(newState: false);
			WrappedSetState(targetCheat, enable: false);
			UpdateCheatState(menuItems[targetCheat], targetCheat);
		}
	}

	public T GetCheatInstance<T>() where T : ICheat
	{
		return allRegisteredCheats.Values.SelectMany((List<ICheat> cheats) => cheats).OfType<T>().FirstOrDefault();
	}

	public void RebuildIcons()
	{
		spriteIcons = new Dictionary<string, Sprite>();
		if (!(MonoSingleton<IconManager>.Instance == null) && !(MonoSingleton<IconManager>.Instance.CurrentIcons == null))
		{
			CheatAssetObject.KeyIcon[] cheatIcons = MonoSingleton<IconManager>.Instance.CurrentIcons.cheatIcons;
			for (int i = 0; i < cheatIcons.Length; i++)
			{
				CheatAssetObject.KeyIcon keyIcon = cheatIcons[i];
				spriteIcons.Add(keyIcon.key, keyIcon.sprite);
			}
		}
	}

	private void Start()
	{
		RebuildIcons();
		RegisterCheat(new KeepEnabled(), "meta");
		if (MapInfoBase.InstanceAnyType.sandboxTools)
		{
			if (Debug.isDebugBuild)
			{
				RegisterCheat(new ExperimentalArmRotation(), "sandbox");
			}
			RegisterCheat(new QuickSave(), "sandbox");
			RegisterCheat(new QuickLoad(), "sandbox");
			RegisterCheat(new ManageSaves(), "sandbox");
			RegisterCheat(new ClearMap(), "sandbox");
			if ((bool)MonoSingleton<SandboxNavmesh>.Instance)
			{
				RegisterCheat(new RebuildNavmesh(), "sandbox");
			}
			RegisterCheats(new ICheat[2]
			{
				new ULTRAKILL.Cheats.Snapping(),
				new SpawnPhysics()
			}, "sandbox");
		}
		RegisterCheats(new ICheat[4]
		{
			new SummonSandboxArm(),
			new TeleportMenu(),
			new FullBright(),
			new Invincibility()
		}, "general");
		RegisterCheats(new ICheat[3]
		{
			new Noclip(),
			new Flight(),
			new InfiniteWallJumps()
		}, "movement");
		RegisterCheats(new ICheat[2]
		{
			new NoWeaponCooldown(),
			new InfinitePowerUps()
		}, "weapons");
		RegisterCheats(new ICheat[6]
		{
			new BlindEnemies(),
			new EnemiesHateEnemies(),
			new EnemyIgnorePlayer(),
			new DisableEnemySpawns(),
			new InvincibleEnemies(),
			new KillAllEnemies()
		}, "enemies");
		RegisterCheats(new ICheat[2]
		{
			new HideWeapons(),
			new HideUI()
		}, "visual");
		if (GameProgressSaver.GetClashModeUnlocked())
		{
			RegisterCheat(new CrashMode(), "special");
		}
		if (GameProgressSaver.GetGhostDroneModeUnlocked())
		{
			RegisterCheat(new GhostDroneMode(), "special");
		}
		if (Debug.isDebugBuild)
		{
			RegisterCheats(new ICheat[9]
			{
				new NonConvexJumpDebug(),
				new HideCheatsStatus(),
				new PlayerParentingDebug(),
				new StateDebug(),
				new GunControlDebug(),
				new SandboxArmDebug(),
				new EnemyIdentifierDebug(),
				new ForceBossBars(),
				new SpreadGasoline()
			}, "debug");
			RegisterCheat(new PauseTimedBombs(), "debug");
		}
		MonoSingleton<CheatBinds>.Instance.RestoreBinds(allRegisteredCheats);
		RebuildMenu();
	}

	public void CancelRebindIfNecessary()
	{
		if (MonoSingleton<CheatBinds>.Instance.isRebinding)
		{
			MonoSingleton<CheatBinds>.Instance.CancelRebind();
		}
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			foreach (ICheat item in allRegisteredCheat.Value)
			{
				if (item.IsActive)
				{
					try
					{
						item.Disable();
					}
					catch
					{
					}
				}
			}
		}
		allRegisteredCheats.Clear();
	}

	public void HandleCheatBind(string identifier)
	{
		if (MonoSingleton<CheatsController>.Instance.cheatsEnabled && !MonoSingleton<CheatBinds>.Instance.isRebinding && !SandboxHud.SavesMenuOpen && !Console.IsOpen && !GameStateManager.Instance.IsStateActive("alter-menu") && !GameStateManager.Instance.IsStateActive("agony-menu"))
		{
			MonoSingleton<CheatsController>.Instance.PlayToggleSound(!idToCheat[identifier].IsActive);
			ToggleCheat(idToCheat[identifier]);
			UpdateCheatState(idToCheat[identifier]);
		}
	}

	private void Update()
	{
		if (!MonoSingleton<CheatsController>.Instance.cheatsEnabled)
		{
			return;
		}
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			foreach (ICheat item in allRegisteredCheat.Value)
			{
				if (item.IsActive)
				{
					item.Update();
				}
			}
		}
	}

	private void OnGUI()
	{
		if (!MonoSingleton<CheatsController>.Instance.cheatsEnabled)
		{
			return;
		}
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			foreach (ICheat item in allRegisteredCheat.Value)
			{
				if (item.IsActive && item is ICheatGUI cheatGUI)
				{
					cheatGUI.OnGUI();
				}
			}
		}
	}

	private bool GetStartCheatState(ICheat cheat)
	{
		if (cheat.Identifier == "ultrakill.spawner-arm" && (bool)MapInfoBase.InstanceAnyType && MapInfoBase.InstanceAnyType.sandboxTools)
		{
			return true;
		}
		if (cheat.PersistenceMode == StatePersistenceMode.NotPersistent)
		{
			return cheat.DefaultState;
		}
		if (!KeepCheatsEnabled)
		{
			MonoSingleton<PrefsManager>.Instance.DeleteKey("cheat." + cheat.Identifier);
			return cheat.DefaultState;
		}
		return MonoSingleton<PrefsManager>.Instance.GetBool("cheat." + cheat.Identifier, cheat.DefaultState);
	}

	private void SaveCheatState(ICheat cheat)
	{
		if (cheat.PersistenceMode != 0)
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("cheat." + cheat.Identifier, cheat.IsActive);
		}
	}

	public void RenderCheatsInfo()
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((bool)MonoSingleton<SandboxNavmesh>.Instance && MonoSingleton<SandboxNavmesh>.Instance.isDirty)
		{
			stringBuilder.AppendLine("<color=red>NAVMESH OUT OF DATE<size=12>\n(Rebuild navigation in cheats menu)</size>\n</color>");
		}
		if (GetCheatState("ultrakill.spawner-arm"))
		{
			stringBuilder.AppendLine("<color=#C2D7FF>Spawner Arm in slot 6\n</color>");
		}
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			foreach (ICheat item in allRegisteredCheat.Value)
			{
				if (item.IsActive)
				{
					string text = MonoSingleton<CheatBinds>.Instance.ResolveCheatKey(item.Identifier);
					if (!string.IsNullOrEmpty(text))
					{
						stringBuilder.Append("[<color=orange>" + text.ToUpper() + "</color>] ");
					}
					else
					{
						stringBuilder.Append("[ ] ");
					}
					stringBuilder.Append("<color=white>" + item.LongName + "</color>\n");
				}
			}
		}
		MonoSingleton<CheatsController>.Instance.cheatsInfo.text = stringBuilder.ToString();
	}

	public void UpdateCheatState(ICheat cheat)
	{
		if (menuItems.ContainsKey(cheat))
		{
			UpdateCheatState(menuItems[cheat], cheat);
		}
	}

	private void UpdateCheatState(CheatMenuItem item, ICheat cheat)
	{
		item.longName.text = cheat.LongName;
		item.stateBackground.color = (cheat.IsActive ? enabledColor : disabledColor);
		item.stateText.text = (cheat.IsActive ? (cheat.ButtonEnabledOverride ?? "ENABLED") : (cheat.ButtonDisabledOverride ?? "DISABLED"));
		item.bindButtonBack.gameObject.SetActive(value: false);
		string text = MonoSingleton<CheatBinds>.Instance.ResolveCheatKey(cheat.Identifier);
		if (string.IsNullOrEmpty(text))
		{
			item.bindButtonText.text = "Press to Bind";
		}
		else
		{
			item.bindButtonText.text = text.ToUpper();
		}
		RenderCheatsInfo();
	}

	private void ResetMenu()
	{
		menuItems = new Dictionary<ICheat, CheatMenuItem>();
		idToCheat = new Dictionary<string, ICheat>();
		for (int i = 2; i < itemContainer.transform.childCount; i++)
		{
			Object.Destroy(itemContainer.transform.GetChild(i).gameObject);
		}
	}

	private void StartRebind(ICheat cheat)
	{
		if (MonoSingleton<CheatBinds>.Instance.isRebinding)
		{
			MonoSingleton<CheatBinds>.Instance.CancelRebind();
			return;
		}
		menuItems[cheat].bindButtonBack.gameObject.SetActive(value: true);
		menuItems[cheat].bindButtonText.text = "Press any key";
		MonoSingleton<CheatBinds>.Instance.SetupRebind(cheat);
	}

	public void RebuildMenu()
	{
		ResetMenu();
		template.gameObject.SetActive(value: false);
		categoryTemplate.gameObject.SetActive(value: false);
		foreach (KeyValuePair<string, List<ICheat>> allRegisteredCheat in allRegisteredCheats)
		{
			CheatMenuItem cheatMenuItem = Object.Instantiate(categoryTemplate, itemContainer.transform, worldPositionStays: false);
			cheatMenuItem.gameObject.SetActive(value: true);
			cheatMenuItem.longName.text = allRegisteredCheat.Key;
			foreach (ICheat cheat in allRegisteredCheat.Value)
			{
				CheatMenuItem item = Object.Instantiate(template, itemContainer.transform, worldPositionStays: false);
				item.gameObject.SetActive(value: true);
				if (!string.IsNullOrEmpty(cheat.Icon))
				{
					if (spriteIcons.ContainsKey(cheat.Icon))
					{
						item.iconTarget.sprite = spriteIcons[cheat.Icon];
					}
					else if ((bool)MonoSingleton<IconManager>.Instance && (bool)MonoSingleton<IconManager>.Instance.CurrentIcons)
					{
						item.iconTarget.sprite = MonoSingleton<IconManager>.Instance.CurrentIcons.genericCheatIcon;
					}
				}
				item.stateButton.onClick.AddListener(delegate
				{
					ToggleCheat(cheat);
				});
				item.bindButton.onClick.AddListener(delegate
				{
					StartRebind(cheat);
				});
				item.resetBindButton.onClick.AddListener(delegate
				{
					MonoSingleton<CheatBinds>.Instance.ResetCheatBind(cheat.Identifier);
					UpdateCheatState(item, cheat);
				});
				UpdateCheatState(item, cheat);
				menuItems[cheat] = item;
				idToCheat[cheat.Identifier] = cheat;
			}
		}
	}
}


public enum CheckerType
{
	Streetcleaner,
	V2
}



public class CheckForOtherObject : MonoBehaviour
{
	public GameObject target;

	public bool disableSelf;

	public UnityEvent onOtherObjectFound;

	private void Start()
	{
		if (target != null && target.activeInHierarchy)
		{
			if (disableSelf)
			{
				base.gameObject.SetActive(value: false);
			}
			onOtherObjectFound?.Invoke();
		}
	}
}



public class CheckForScroller : MonoBehaviour
{
	public bool checkOnStart = true;

	public bool checkOnCollision = true;

	private ScrollingTexture scroller;

	public bool asRigidbody;

	private Rigidbody rb;

	private ComponentsDatabase cdat;

	private void Start()
	{
		cdat = MonoSingleton<ComponentsDatabase>.Instance;
		if (!checkOnStart)
		{
			return;
		}
		if ((bool)cdat && cdat.scrollers.Count > 0)
		{
			Collider[] array = Physics.OverlapSphere(base.transform.position, 1f, LayerMaskDefaults.Get(LMD.Environment));
			if (array.Length != 0)
			{
				Collider[] array2 = array;
				foreach (Collider collider in array2)
				{
					if (cdat.scrollers.Contains(collider.transform) && collider.transform.TryGetComponent<ScrollingTexture>(out var component))
					{
						component.attachedObjects.Add(base.transform);
					}
				}
			}
		}
		if (!checkOnCollision)
		{
			Object.Destroy(this);
		}
	}

	private void OnCollisionEnter(Collision col)
	{
		if (!checkOnCollision || !cdat || cdat.scrollers.Count <= 0 || !cdat.scrollers.Contains(col.transform) || !col.transform.TryGetComponent<ScrollingTexture>(out var component))
		{
			return;
		}
		scroller = component;
		if (asRigidbody)
		{
			if (!rb)
			{
				rb = GetComponent<Rigidbody>();
			}
			component.touchingRbs.Add(rb);
			Vector3 force = component.force;
			if (component.relativeDirection)
			{
				force = new Vector3(component.force.x * component.transform.forward.x, component.force.y * component.transform.forward.y, component.force.z * component.transform.forward.z);
			}
			rb.AddForce(force, ForceMode.VelocityChange);
		}
		else
		{
			component.attachedObjects.Add(base.transform);
		}
	}

	private void OnCollisionExit(Collision col)
	{
		if (!checkOnCollision || !scroller || !(col.transform == scroller.transform))
		{
			return;
		}
		if (asRigidbody)
		{
			if (!rb)
			{
				rb = GetComponent<Rigidbody>();
			}
			scroller.touchingRbs.Remove(rb);
		}
		else
		{
			scroller.attachedObjects.Remove(base.transform);
		}
	}
}



public class CheckLevelRank : MonoBehaviour
{
	public UltrakillEvent onSuccess;

	public UltrakillEvent onFail;

	private void Start()
	{
		if (CheckLevelStatus())
		{
			onSuccess?.Invoke();
		}
		else
		{
			onFail?.Invoke();
		}
	}

	public static bool CheckLevelStatus()
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return true;
		}
		if (MonoSingleton<StatsManager>.Instance.levelNumber == 0)
		{
			return true;
		}
		RankData rank = GameProgressSaver.GetRank(returnNull: true);
		if (rank != null && rank.levelNumber == MonoSingleton<StatsManager>.Instance.levelNumber && rank.ranks != null && rank.ranks.Length != 0)
		{
			int[] ranks = rank.ranks;
			for (int i = 0; i < ranks.Length; i++)
			{
				if (ranks[i] != -1)
				{
					return true;
				}
			}
			return false;
		}
		return false;
	}
}



public class CheckPoint : MonoBehaviour
{
	[HideInInspector]
	public StatsManager sm;

	[HideInInspector]
	public bool activated;

	public bool forceOff;

	private bool notFirstTime;

	public GameObject toActivate;

	public GameObject[] rooms;

	public List<GameObject> roomsToInherit = new List<GameObject>();

	private List<string> inheritNames = new List<string>();

	private List<Transform> inheritParents = new List<Transform>();

	[HideInInspector]
	public List<GameObject> defaultRooms = new List<GameObject>();

	public Door[] doorsToUnlock;

	[HideInInspector]
	public List<GameObject> newRooms = new List<GameObject>();

	private int i;

	private GameObject player;

	private NewMovement nm;

	private float tempRot;

	public GameObject graphic;

	public AssetReference activateEffect;

	[HideInInspector]
	public int restartKills;

	[HideInInspector]
	public int stylePoints;

	[HideInInspector]
	public bool challengeAlreadyFailed;

	[HideInInspector]
	public bool challengeAlreadyDone;

	private StyleHUD shud;

	public bool multiUse;

	public bool dontAutoReset;

	public bool startOff;

	public bool unteleportable;

	public bool invisible;

	[HideInInspector]
	public List<int> succesfulHitters = new List<int>();

	[Space]
	public UnityEvent onRestart;

	[HideInInspector]
	public float additionalSpawnRotation;

	private void Start()
	{
		GameObject[] array = rooms;
		foreach (GameObject item in array)
		{
			defaultRooms.Add(item);
		}
		for (int j = 0; j < defaultRooms.Count; j++)
		{
			if (!defaultRooms[j].TryGetComponent<GoreZone>(out var component))
			{
				component = defaultRooms[j].AddComponent<GoreZone>();
			}
			component.checkpoint = this;
			newRooms.Add(Object.Instantiate(defaultRooms[j], defaultRooms[j].transform.position, defaultRooms[j].transform.rotation, defaultRooms[j].transform.parent));
			defaultRooms[j].gameObject.SetActive(value: false);
			newRooms[j].gameObject.SetActive(value: true);
			Bonus[] componentsInChildren = newRooms[j].GetComponentsInChildren<Bonus>(includeInactive: true);
			if (componentsInChildren != null && componentsInChildren.Length != 0)
			{
				Bonus[] array2 = componentsInChildren;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].UpdateStatsManagerReference();
				}
			}
			defaultRooms[j].transform.position = new Vector3(defaultRooms[j].transform.position.x + 10000f, defaultRooms[j].transform.position.y, defaultRooms[j].transform.position.z);
		}
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		sm = MonoSingleton<StatsManager>.Instance;
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		for (int k = 0; k < roomsToInherit.Count; k++)
		{
			inheritNames.Add(roomsToInherit[k].name);
			inheritParents.Add(roomsToInherit[k].transform.parent);
		}
		MonoSingleton<CheckPointsController>.Instance.AddCheckpoint(this);
		if (!startOff)
		{
			return;
		}
		if (multiUse)
		{
			activated = true;
			graphic?.SetActive(value: false);
			if (TryGetComponent<ModifyMaterial>(out var component2))
			{
				component2.ChangeEmissionIntensity(0f);
			}
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (multiUse && activated && !dontAutoReset && Vector3.Distance(MonoSingleton<PlayerTracker>.Instance.GetPlayer().position, base.transform.position) > 15f)
		{
			ReactivateCheckpoint();
		}
		if (!activated && (bool)graphic)
		{
			if ((forceOff || invisible) && graphic.activeSelf)
			{
				graphic.SetActive(value: false);
			}
			else if (!forceOff && !invisible && !graphic.activeSelf)
			{
				graphic.SetActive(value: true);
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!activated && !forceOff && other.gameObject.CompareTag("Player"))
		{
			ActivateCheckPoint();
		}
	}

	public void ActivateCheckPoint()
	{
		sm = MonoSingleton<StatsManager>.Instance;
		sm.currentCheckPoint = this;
		activated = true;
		if (!invisible && activateEffect.RuntimeKeyIsValid())
		{
			Object.Instantiate(activateEffect.ToAsset(), MonoSingleton<PlayerTracker>.Instance.GetPlayer().position, Quaternion.identity);
		}
		if (!multiUse || !notFirstTime)
		{
			MonoSingleton<NewMovement>.Instance.sameCheckpointRestarts = 0;
		}
		if ((bool)graphic)
		{
			if (multiUse)
			{
				graphic.SetActive(value: false);
			}
			else
			{
				Object.Destroy(graphic);
			}
		}
		if ((bool)MonoSingleton<PlatformerMovement>.Instance)
		{
			MonoSingleton<CrateCounter>.Instance.SaveStuff();
		}
		if ((bool)MonoSingleton<MapVarManager>.Instance)
		{
			MonoSingleton<MapVarManager>.Instance.StashStore();
		}
		stylePoints = sm.stylePoints;
		restartKills = 0;
		if ((bool)MonoSingleton<ChallengeManager>.Instance)
		{
			challengeAlreadyFailed = MonoSingleton<ChallengeManager>.Instance.challengeFailed;
		}
		if ((bool)MonoSingleton<ChallengeManager>.Instance)
		{
			challengeAlreadyDone = MonoSingleton<ChallengeManager>.Instance.challengeDone;
		}
		if (notFirstTime)
		{
			defaultRooms.Clear();
			newRooms.Clear();
			if (rooms.Length != 0)
			{
				GameObject[] array = rooms;
				foreach (GameObject gameObject in array)
				{
					roomsToInherit.Add(gameObject);
					inheritNames.Add(gameObject.name);
					inheritParents.Add(gameObject.transform.parent);
				}
				rooms = new GameObject[0];
			}
		}
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		if (roomsToInherit.Count != 0)
		{
			for (int j = 0; j < roomsToInherit.Count; j++)
			{
				string text = inheritNames[j];
				text = text.Replace("(Clone)", "");
				GameObject gameObject2 = null;
				for (int num = inheritParents[j].childCount - 1; num >= 0; num--)
				{
					GameObject gameObject3 = inheritParents[j].GetChild(num).gameObject;
					if (gameObject3.name.Replace("(Clone)", "") == text)
					{
						if (gameObject2 == null)
						{
							gameObject2 = gameObject3;
						}
						else
						{
							Object.Destroy(gameObject3);
						}
					}
				}
				InheritRoom(gameObject2);
			}
		}
		MonoSingleton<BloodsplatterManager>.Instance.SaveBloodstains();
		notFirstTime = true;
	}

	public void OnRespawn()
	{
		MonoSingleton<BloodsplatterManager>.Instance.LoadBloodstains();
		if (player == null)
		{
			player = MonoSingleton<NewMovement>.Instance.gameObject;
		}
		if (!base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: true);
		}
		if (player.GetComponentInParent<GoreZone>() != null)
		{
			player.transform.parent = null;
		}
		player.transform.position = Vector3.one * -1000f;
		if ((bool)MonoSingleton<PlatformerMovement>.Instance)
		{
			if (MonoSingleton<PlatformerMovement>.Instance.GetComponentInParent<GoreZone>() != null)
			{
				MonoSingleton<PlatformerMovement>.Instance.transform.parent = null;
			}
			MonoSingleton<PlatformerMovement>.Instance.transform.position = Vector3.one * -1000f;
		}
		if ((bool)MonoSingleton<MapVarManager>.Instance)
		{
			MonoSingleton<MapVarManager>.Instance.RestoreStashedStore();
		}
		this.i = 0;
		if ((bool)SandboxArm.debugZone && !MapInfoBase.InstanceAnyType.sandboxTools)
		{
			Object.Destroy(SandboxArm.debugZone.gameObject);
		}
		if (!activated && multiUse)
		{
			activated = true;
			if (graphic != null)
			{
				graphic.SetActive(value: false);
			}
		}
		sm.kills -= restartKills;
		restartKills = 0;
		sm.stylePoints = stylePoints;
		if ((bool)MonoSingleton<ChallengeManager>.Instance)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = challengeAlreadyDone && !MonoSingleton<ChallengeManager>.Instance.challengeFailedPermanently;
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = challengeAlreadyFailed || MonoSingleton<ChallengeManager>.Instance.challengeFailedPermanently;
		}
		if (succesfulHitters.Count > 0)
		{
			KillHitterCache instance = MonoSingleton<KillHitterCache>.Instance;
			if ((bool)instance && !instance.ignoreRestarts)
			{
				foreach (int succesfulHitter in succesfulHitters)
				{
					instance.RemoveId(succesfulHitter);
				}
			}
		}
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		shud.ComboOver();
		shud.ResetAllFreshness();
		MonoSingleton<FistControl>.Instance.fistCooldown = 0f;
		MonoSingleton<FistControl>.Instance.weightCooldown = 0f;
		if (doorsToUnlock.Length != 0)
		{
			Door[] array = doorsToUnlock;
			foreach (Door door in array)
			{
				if (door.locked)
				{
					door.Unlock();
				}
				if (door.startOpen)
				{
					door.Open();
				}
			}
		}
		DestroyOnCheckpointRestart[] array2 = Object.FindObjectsOfType<DestroyOnCheckpointRestart>();
		if (array2 != null && array2.Length != 0)
		{
			DestroyOnCheckpointRestart[] array3 = array2;
			foreach (DestroyOnCheckpointRestart destroyOnCheckpointRestart in array3)
			{
				if (destroyOnCheckpointRestart.gameObject.activeInHierarchy && !destroyOnCheckpointRestart.dontDestroy)
				{
					Object.Destroy(destroyOnCheckpointRestart.gameObject);
				}
			}
		}
		Harpoon[] array4 = Object.FindObjectsOfType<Harpoon>();
		if (array4 != null && array4.Length != 0)
		{
			Harpoon[] array5 = array4;
			foreach (Harpoon harpoon in array5)
			{
				if (harpoon.gameObject.activeInHierarchy)
				{
					TimeBomb componentInChildren = harpoon.GetComponentInChildren<TimeBomb>();
					if ((bool)componentInChildren)
					{
						componentInChildren.dontExplode = true;
					}
					Object.Destroy(harpoon.gameObject);
				}
			}
		}
		DoorController[] array6 = Object.FindObjectsOfType<DoorController>();
		if (array6 != null && array6.Length != 0)
		{
			DoorController[] array7 = array6;
			for (int i = 0; i < array7.Length; i++)
			{
				array7[i].ForcePlayerOut();
			}
		}
		HookPoint[] array8 = Object.FindObjectsOfType<HookPoint>();
		if (array8 != null && array8.Length != 0)
		{
			HookPoint[] array9 = array8;
			foreach (HookPoint hookPoint in array9)
			{
				if (hookPoint.timer > 0f)
				{
					hookPoint.TimerStop();
				}
			}
		}
		if ((bool)MonoSingleton<CoinList>.Instance && MonoSingleton<CoinList>.Instance.revolverCoinsList.Count > 0)
		{
			for (int num = MonoSingleton<CoinList>.Instance.revolverCoinsList.Count - 1; num >= 0; num--)
			{
				if (!MonoSingleton<CoinList>.Instance.revolverCoinsList[num].dontDestroyOnPlayerRespawn)
				{
					Object.Destroy(MonoSingleton<CoinList>.Instance.revolverCoinsList[num].gameObject);
					MonoSingleton<CoinList>.Instance.revolverCoinsList.RemoveAt(num);
				}
			}
		}
		if (newRooms.Count > 0)
		{
			ResetRoom();
		}
	}

	public void ResetRoom()
	{
		Vector3 position = newRooms[this.i].transform.position;
		newRooms[this.i].SetActive(value: false);
		Object.Destroy(newRooms[this.i]);
		newRooms[this.i] = Object.Instantiate(defaultRooms[this.i], position, defaultRooms[this.i].transform.rotation, defaultRooms[this.i].transform.parent);
		newRooms[this.i].SetActive(value: true);
		Bonus[] componentsInChildren = newRooms[this.i].GetComponentsInChildren<Bonus>(includeInactive: true);
		if (componentsInChildren != null && componentsInChildren.Length != 0)
		{
			Bonus[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateStatsManagerReference();
			}
		}
		if (this.i + 1 < defaultRooms.Count)
		{
			this.i++;
			ResetRoom();
			return;
		}
		if ((bool)toActivate)
		{
			toActivate.SetActive(value: true);
		}
		onRestart?.Invoke();
		if (!activated && multiUse)
		{
			activated = true;
			if ((bool)graphic)
			{
				graphic.SetActive(value: false);
			}
		}
		player.transform.position = base.transform.position + base.transform.right * 0.1f + Vector3.up * 1.25f;
		player.GetComponent<Rigidbody>().velocity = Vector3.zero;
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
		}
		float num = base.transform.rotation.eulerAngles.y + 0.1f + additionalSpawnRotation;
		if ((bool)player && (bool)player.transform.parent && player.transform.parent.gameObject.CompareTag("Moving"))
		{
			num -= player.transform.parent.rotation.eulerAngles.y;
		}
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
		{
			nm.cc.ResetCamera(num);
		}
		else
		{
			MonoSingleton<PlatformerMovement>.Instance.ResetCamera(num);
		}
		MonoSingleton<CameraController>.Instance.activated = true;
		if (!nm.enabled)
		{
			nm.enabled = true;
		}
		nm.Respawn();
		nm.GetHealth(0, silent: true);
		nm.cc.StopShake();
		nm.ActivatePlayer();
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			MonoSingleton<PlatformerMovement>.Instance.transform.position = base.transform.position;
			MonoSingleton<PlatformerMovement>.Instance.rb.velocity = Vector3.zero;
			MonoSingleton<PlatformerMovement>.Instance.playerModel.rotation = base.transform.rotation;
			if (additionalSpawnRotation != 0f)
			{
				MonoSingleton<PlatformerMovement>.Instance.playerModel.Rotate(Vector3.up, additionalSpawnRotation);
			}
			MonoSingleton<PlatformerMovement>.Instance.gameObject.SetActive(value: true);
			MonoSingleton<PlatformerMovement>.Instance.SnapCamera();
			MonoSingleton<PlatformerMovement>.Instance.Respawn();
			MonoSingleton<CrateCounter>.Instance.ResetUnsavedStuff();
		}
	}

	public void UpdateRooms()
	{
		Vector3 position = newRooms[this.i].transform.position;
		Object.Destroy(newRooms[this.i]);
		newRooms[this.i] = Object.Instantiate(defaultRooms[this.i], position, defaultRooms[this.i].transform.rotation, defaultRooms[this.i].transform.parent);
		newRooms[this.i].SetActive(value: true);
		Bonus[] componentsInChildren = newRooms[this.i].GetComponentsInChildren<Bonus>(includeInactive: true);
		if (componentsInChildren != null && componentsInChildren.Length != 0)
		{
			Bonus[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateStatsManagerReference();
			}
		}
		if (this.i + 1 < defaultRooms.Count)
		{
			this.i++;
			UpdateRooms();
		}
		else
		{
			this.i = 0;
		}
	}

	public void InheritRoom(GameObject targetRoom)
	{
		new List<GameObject>();
		new List<GameObject>();
		defaultRooms.Add(targetRoom);
		int index = defaultRooms.IndexOf(targetRoom);
		defaultRooms[index].GetComponent<GoreZone>().checkpoint = this;
		RemoveOnTime[] componentsInChildren = defaultRooms[index].GetComponentsInChildren<RemoveOnTime>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.SetActive(value: false);
		}
		newRooms.Add(Object.Instantiate(defaultRooms[index], defaultRooms[index].transform.position, defaultRooms[index].transform.rotation, defaultRooms[index].transform.parent));
		Flammable[] componentsInChildren2 = defaultRooms[index].GetComponentsInChildren<Flammable>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].CancelInvoke("Pulse");
		}
		defaultRooms[index].gameObject.SetActive(value: false);
		newRooms[index].gameObject.SetActive(value: true);
		Bonus[] componentsInChildren3 = newRooms[index].GetComponentsInChildren<Bonus>(includeInactive: true);
		if (componentsInChildren3 != null && componentsInChildren3.Length != 0)
		{
			Bonus[] array = componentsInChildren3;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateStatsManagerReference();
			}
		}
		defaultRooms[index].transform.position = new Vector3(defaultRooms[index].transform.position.x + 10000f, defaultRooms[index].transform.position.y, defaultRooms[index].transform.position.z);
	}

	public void ReactivateCheckpoint()
	{
		if (multiUse)
		{
			activated = false;
			notFirstTime = true;
			ReactivationEffect();
		}
	}

	public void ReactivationEffect()
	{
		if (multiUse && !activated && (bool)graphic)
		{
			graphic.SetActive(value: true);
			if (graphic.TryGetComponent<ScaleTransform>(out var _))
			{
				graphic.transform.localScale = new Vector3(graphic.transform.localScale.x, 0f, graphic.transform.localScale.z);
			}
			if (graphic.TryGetComponent<AudioSource>(out var component2))
			{
				component2.Play();
			}
		}
	}

	public void ApplyCurrentStyleAndKills()
	{
		ApplyCurrentKills();
		ApplyCurrentStyle();
	}

	public void ApplyCurrentKills()
	{
		restartKills = 0;
	}

	public void ApplyCurrentStyle()
	{
		stylePoints = sm.stylePoints;
	}

	public void AddCustomKill()
	{
		MonoSingleton<StatsManager>.Instance.kills++;
		restartKills++;
	}

	public void ChangeSpawnRotation(float degrees)
	{
		additionalSpawnRotation = degrees;
	}

	public void SetInvisibility(bool state)
	{
		invisible = state;
	}

	public void SetForceOff(bool state)
	{
		forceOff = state;
	}
}



public class CheckPointsController : MonoSingleton<CheckPointsController>
{
	private int requests;

	public List<CheckPoint> cps = new List<CheckPoint>();

	private List<ShopZone> shops = new List<ShopZone>();

	public void DisableCheckpoints()
	{
		if (requests == 0)
		{
			foreach (CheckPoint cp in cps)
			{
				cp.forceOff = true;
			}
			foreach (ShopZone shop in shops)
			{
				shop.ForceOff();
			}
		}
		requests++;
	}

	public void EnableCheckpoints()
	{
		requests--;
		if (requests > 0)
		{
			return;
		}
		foreach (CheckPoint cp in cps)
		{
			cp.forceOff = false;
			cp.ReactivationEffect();
		}
		foreach (ShopZone shop in shops)
		{
			shop.StopForceOff();
		}
		requests = 0;
	}

	public void AddCheckpoint(CheckPoint cp)
	{
		if (!cps.Contains(cp))
		{
			cps.Add(cp);
			if (requests > 0)
			{
				cp.forceOff = true;
			}
			else if (cp.forceOff)
			{
				cp.forceOff = false;
				cp.ReactivationEffect();
			}
		}
	}

	public void RemoveCheckpoint(CheckPoint cp)
	{
		if (cps.Contains(cp))
		{
			cps.Remove(cp);
			if (cp.forceOff)
			{
				cp.forceOff = false;
				cp.ReactivationEffect();
			}
		}
	}

	public void AddShop(ShopZone shop)
	{
		if (!shops.Contains(shop))
		{
			shops.Add(shop);
			if (requests > 0)
			{
				shop.ForceOff();
			}
			else if (shop.forcedOff)
			{
				shop.StopForceOff();
			}
		}
	}

	public void RemoveShop(ShopZone shop)
	{
		if (shops.Contains(shop))
		{
			shops.Remove(shop);
			if (shop.forcedOff)
			{
				shop.StopForceOff();
			}
		}
	}
}



public class CheckpointsDisabler : MonoBehaviour
{
	private bool activated;

	private void Start()
	{
		if (!activated)
		{
			activated = true;
			MonoSingleton<CheckPointsController>.Instance.DisableCheckpoints();
		}
	}

	private void OnEnable()
	{
		if (!activated)
		{
			activated = true;
			MonoSingleton<CheckPointsController>.Instance.DisableCheckpoints();
		}
	}

	private void OnDisable()
	{
		if (activated && base.gameObject.scene.isLoaded)
		{
			activated = false;
			MonoSingleton<CheckPointsController>.Instance.EnableCheckpoints();
		}
	}

	private void OnDestroy()
	{
		if (activated && base.gameObject.scene.isLoaded)
		{
			activated = false;
			MonoSingleton<CheckPointsController>.Instance.EnableCheckpoints();
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ChessManager : MonoSingleton<ChessManager>
{
	public enum SpecialMove
	{
		None,
		ShortCastle,
		LongCastle,
		PawnTwoStep,
		PawnPromotion,
		EnPassantCapture
	}

	public struct MoveData
	{
		public int2 StartPosition;

		public ChessPieceData PieceToMove;

		public int2 EndPosition;

		public ChessPieceData CapturePiece;

		public SpecialMove SpecialMove;

		public int2 LastEnPassantPos;

		public ChessPieceData.PieceType PromotionType;

		public MoveData(ChessPieceData pieceToMove, int2 startPosition, ChessPieceData capturePiece, int2 endPosition, int2 lastEPPos, SpecialMove specialMove = SpecialMove.None, ChessPieceData.PieceType promotionType = ChessPieceData.PieceType.Pawn)
		{
			PieceToMove = pieceToMove;
			StartPosition = startPosition;
			EndPosition = endPosition;
			CapturePiece = capturePiece;
			SpecialMove = specialMove;
			LastEnPassantPos = lastEPPos;
			PromotionType = promotionType;
		}
	}

	public GameObject originalPieces;

	public GameObject originalExtras;

	public GameObject blackWinner;

	public GameObject whiteWinner;

	public GameObject blackOpponent;

	public GameObject whiteOpponent;

	public GameObject draw;

	public Transform helperTileGroup;

	private Renderer[] helperTiles = new Renderer[64];

	private MaterialPropertyBlock colorSetter;

	private Bounds colBounds;

	private GameObject clonedPieces;

	private ChessPieceData[] chessBoard = new ChessPieceData[64];

	private Dictionary<ChessPieceData, ChessPiece> allPieces = new Dictionary<ChessPieceData, ChessPiece>();

	private ChessPieceData whiteKing;

	private ChessPieceData blackKing;

	private int2 enPassantPos = new int2(-1, -1);

	private List<MoveData> legalMoves = new List<MoveData>(27);

	private List<MoveData> pseudoLegalMoves = new List<MoveData>(27);

	private List<MoveData> allLegalMoves = new List<MoveData>(27);

	private UciChessEngine chessEngine;

	private List<string> UCIMoves = new List<string>();

	[HideInInspector]
	public bool isWhiteTurn = true;

	[HideInInspector]
	public bool whiteIsBot;

	[HideInInspector]
	public bool blackIsBot = true;

	[HideInInspector]
	public bool gameLocked = true;

	private bool tutorialMessageSent;

	private int numMoves;

	public int elo = 1000;

	private static readonly int2[] pawnMoves = new int2[2]
	{
		new int2(0, 1),
		new int2(0, 2)
	};

	private static readonly int2[] pawnCaptures = new int2[2]
	{
		new int2(1, 1),
		new int2(-1, 1)
	};

	private static readonly int2[] rookDirections = new int2[4]
	{
		new int2(1, 0),
		new int2(-1, 0),
		new int2(0, 1),
		new int2(0, -1)
	};

	private static readonly int2[] bishopDirections = new int2[4]
	{
		new int2(1, 1),
		new int2(-1, 1),
		new int2(1, -1),
		new int2(-1, -1)
	};

	private static readonly int2[] queenDirections = rookDirections.Concat(bishopDirections).ToArray();

	private static readonly int2[] knightOffsets = new int2[8]
	{
		new int2(1, 2),
		new int2(2, 1),
		new int2(2, -1),
		new int2(1, -2),
		new int2(-1, -2),
		new int2(-2, -1),
		new int2(-2, 1),
		new int2(-1, 2)
	};

	private static readonly int2[] kingDirections = new int2[8]
	{
		new int2(1, 0),
		new int2(-1, 0),
		new int2(0, 1),
		new int2(0, -1),
		new int2(1, 1),
		new int2(-1, 1),
		new int2(1, -1),
		new int2(-1, -1)
	};

	private new void Awake()
	{
		gameLocked = true;
		colBounds = GetComponent<Collider>().bounds;
		colorSetter = new MaterialPropertyBlock();
		for (int i = 0; i < 8; i++)
		{
			for (int j = 0; j < 8; j++)
			{
				Renderer component = helperTileGroup.GetChild(i).GetChild(j).GetComponent<Renderer>();
				component.SetPropertyBlock(colorSetter);
				helperTiles[i + j * 8] = component;
			}
		}
	}

	private void Start()
	{
		ResetBoard();
	}

	public void SetupNewGame()
	{
		StopAllCoroutines();
		ResetBoard();
		gameLocked = false;
		if (!whiteIsBot || !blackIsBot)
		{
			MonoSingleton<CheatsManager>.Instance.GetCheatInstance<SummonSandboxArm>()?.TryCreateArmType(SpawnableType.MoveHand);
			if (!tutorialMessageSent)
			{
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Chess pieces can be moved with the <color=orange>mover arm</color>.");
				tutorialMessageSent = true;
			}
		}
	}

	public void ToggleWhiteBot(bool isBot)
	{
		whiteIsBot = isBot;
		whiteOpponent.SetActive(whiteIsBot);
	}

	public void ToggleBlackBot(bool isBot)
	{
		blackIsBot = isBot;
		blackOpponent.SetActive(blackIsBot);
	}

	public void ResetBoard()
	{
		numMoves = 0;
		blackWinner.SetActive(value: false);
		whiteWinner.SetActive(value: false);
		HideHelperTiles();
		UCIMoves.Clear();
		if (clonedPieces != null)
		{
			UnityEngine.Object.Destroy(clonedPieces);
		}
		foreach (ChessPiece value in allPieces.Values)
		{
			if (value != null)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
		}
		clonedPieces = null;
		clonedPieces = UnityEngine.Object.Instantiate(originalPieces, base.transform.parent);
		clonedPieces.SetActive(value: true);
		originalPieces.SetActive(value: false);
		allPieces.Clear();
		for (int i = 0; i < chessBoard.Length; i++)
		{
			chessBoard[i] = null;
		}
		isWhiteTurn = true;
		whiteOpponent.SetActive(whiteIsBot);
		blackOpponent.SetActive(blackIsBot);
		if (whiteIsBot || blackIsBot)
		{
			StartEngine();
		}
	}

	public void UpdateGame(MoveData move)
	{
		gameLocked = false;
		string text = ChessStringHandler.UCIMove(move);
		if (UCIMoves.Count > 0 && UCIMoves[UCIMoves.Count - 1].Equals(text))
		{
			Debug.LogError("tried to perform the same move twice");
			return;
		}
		UCIMoves.Add(text);
		if (UCIMoves.Count == 3 && UCIMoves[0] == "e2e4" && UCIMoves[1] == "e7e5" && UCIMoves[2] == "e1e2")
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(100, "<color=green>BONGCLOUD</color>");
		}
		string newMoveData = string.Join(" ", UCIMoves);
		if (isWhiteTurn)
		{
			numMoves++;
		}
		isWhiteTurn = !isWhiteTurn;
		if (IsGameOver())
		{
			if (numMoves == 2)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(1, "<color=red>FOOLS MATE</color>");
			}
		}
		else if ((isWhiteTurn && whiteIsBot) || (!isWhiteTurn && blackIsBot))
		{
			StartCoroutine(SendToBotCoroutine(newMoveData));
		}
	}

	private bool IsGameOver()
	{
		if (!IsSufficientMaterial())
		{
			WinTrigger(null);
			return true;
		}
		allLegalMoves.Clear();
		for (int i = 0; i < chessBoard.Length; i++)
		{
			ChessPieceData chessPieceData = chessBoard[i];
			if (chessPieceData != null && chessPieceData.isWhite == isWhiteTurn)
			{
				GetLegalMoves(new int2(i % 8, i / 8));
				allLegalMoves.AddRange(legalMoves);
			}
		}
		if (allLegalMoves.Count == 0)
		{
			if (IsSquareAttacked(GetPiecePos(isWhiteTurn ? whiteKing : blackKing), isWhiteTurn))
			{
				WinTrigger(!isWhiteTurn);
			}
			else
			{
				WinTrigger(null);
			}
			return true;
		}
		return false;
	}

	public bool IsSufficientMaterial()
	{
		int num = 0;
		int num2 = 0;
		bool flag = false;
		bool flag2 = false;
		int2? @int = null;
		int2? int2 = null;
		for (int i = 0; i < chessBoard.Length; i++)
		{
			ChessPieceData chessPieceData = chessBoard[i];
			if (chessPieceData == null || chessPieceData.type == ChessPieceData.PieceType.King)
			{
				continue;
			}
			int2 value = new int2(i % 8, i / 8);
			if (chessPieceData.isWhite)
			{
				num++;
				if (chessPieceData.type == ChessPieceData.PieceType.Bishop)
				{
					flag = true;
					@int = value;
				}
			}
			else
			{
				num2++;
				if (chessPieceData.type == ChessPieceData.PieceType.Bishop)
				{
					flag2 = true;
					int2 = value;
				}
			}
			if (num > 1 || num2 > 1 || chessPieceData.type == ChessPieceData.PieceType.Pawn || chessPieceData.type == ChessPieceData.PieceType.Rook || chessPieceData.type == ChessPieceData.PieceType.Queen)
			{
				return true;
			}
		}
		if (flag && flag2)
		{
			return (@int.Value.x + @int.Value.y) % 2 != (int2.Value.x + int2.Value.y) % 2;
		}
		return false;
	}

	public void WinTrigger(bool? whiteWin)
	{
		gameLocked = true;
		StopEngine();
		if (!whiteWin.HasValue)
		{
			draw.GetComponent<AudioSource>().Play();
			return;
		}
		GameObject gameObject = (whiteWin.Value ? whiteWinner : blackWinner);
		gameObject.SetActive(value: true);
		AudioSource[] components = gameObject.GetComponents<AudioSource>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].Play();
		}
		gameObject.GetComponent<ParticleSystem>().Play();
		if ((whiteWin == true && !whiteIsBot) || (whiteWin == false && !blackIsBot))
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(5000, "<color=orange>" + ((whiteWin == true) ? "WHITE" : "BLACK") + " WINS</color>");
		}
		if ((whiteWin == true && !whiteIsBot && blackIsBot) || (whiteWin == false && !blackIsBot && whiteIsBot))
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(5000, "<color=red>ULTRAVICTORY</color>");
		}
	}

	public void SetElo(float newElo)
	{
		elo = Mathf.FloorToInt(newElo);
	}

	public void WhiteIsBot(bool isBot)
	{
		whiteIsBot = isBot;
	}

	public void BlackIsBot(bool isBot)
	{
		blackIsBot = isBot;
	}

	private async void StartEngine()
	{
		chessEngine = new UciChessEngine();
		await chessEngine.InitializeUciModeAsync(whiteIsBot, elo);
	}

	public async void StopEngine()
	{
		if (chessEngine != null)
		{
			await chessEngine.StopEngine();
			chessEngine = null;
		}
	}

	public void BotStartGame()
	{
		StartCoroutine(SendToBotCoroutine(""));
	}

	private IEnumerator SendToBotCoroutine(string newMoveData)
	{
		bool isResponseReceived = false;
		string response = "";
		if (elo < 1500)
		{
			int num = elo - 1000;
			chessEngine.SendPlayerMoveAndGetEngineResponseAsync(newMoveData, onReceivedResponse, 250 + num);
		}
		else
		{
			chessEngine.SendPlayerMoveAndGetEngineResponseAsync(newMoveData, onReceivedResponse);
		}
		yield return new WaitUntil(() => isResponseReceived);
		if (response.StartsWith("bestmove"))
		{
			string botMove = ParseBotMove(response);
			MakeBotMove(botMove);
		}
		void onReceivedResponse(string resp)
		{
			response = resp;
			isResponseReceived = true;
		}
	}

	private string ParseBotMove(string engineResponse)
	{
		string[] array = engineResponse.Split(' ');
		if (array.Length >= 2)
		{
			return array[1];
		}
		return string.Empty;
	}

	private IEnumerator LerpBotMove(ChessPiece piece, int2 endIndex, MoveData moveData)
	{
		Transform trans = piece.transform;
		Vector3 startPos = trans.position;
		Vector3 endPos = IndexToWorldPosition(endIndex, piece.boardHeight);
		float duration = UnityEngine.Random.Range(0.5f, 1f);
		float elapsed = 0f;
		if (UnityEngine.Random.Range(0, 1000) == 666)
		{
			duration = 15f;
		}
		piece.dragSound.pitch = UnityEngine.Random.Range(0.75f, 1.25f);
		piece.dragSound.Play();
		while (elapsed < duration)
		{
			elapsed += Time.deltaTime;
			float t = Mathf.Clamp01(elapsed / duration);
			trans.position = Vector3.Lerp(startPos, endPos, t);
			yield return null;
		}
		piece.dragSound.Stop();
		UnityEngine.Object.Instantiate(piece.snapSound, piece.transform.position, Quaternion.identity);
		yield return null;
		MakeMove(moveData, updateVisuals: true);
		yield return null;
	}

	private void MakeBotMove(string botMove)
	{
		(int2, int2, ChessPieceData.PieceType) tuple = ChessStringHandler.ProcessFullMove(botMove);
		int2 item = tuple.Item1;
		int2 endPos = tuple.Item2;
		ChessPieceData.PieceType promotionType = tuple.Item3;
		ChessPieceData pieceAt = GetPieceAt(item);
		if (pieceAt == null)
		{
			Debug.LogError("found no piece for move " + botMove);
		}
		GetLegalMoves(item);
		MoveData moveData = legalMoves.FirstOrDefault((MoveData move) => move.EndPosition.Equals(endPos) && move.PromotionType == promotionType);
		if (moveData.EndPosition.Equals(endPos))
		{
			ChessPiece piece = allPieces[pieceAt];
			StartCoroutine(LerpBotMove(piece, endPos, moveData));
		}
	}

	public int2 WorldPositionToIndex(Vector3 pos)
	{
		Vector3 min = colBounds.min;
		Vector3 max = colBounds.max;
		Vector3 vector = new Vector3((pos.x - min.x) / (max.x - min.x), 0f, (pos.z - min.z) / (max.z - min.z));
		int x = Mathf.FloorToInt(vector.x * 8f);
		int y = Mathf.FloorToInt(vector.z * 8f);
		return new int2(x, y);
	}

	public Vector3 IndexToWorldPosition(int2 index, float height)
	{
		Vector3 min = colBounds.min;
		Vector3 max = colBounds.max;
		float num = (float)Mathf.Clamp(index.x, 0, 7) + 0.5f;
		float num2 = (float)Mathf.Clamp(index.y, 0, 7) + 0.5f;
		return new Vector3(min.x + num * (max.x - min.x) / 8f, height, min.z + num2 * (max.z - min.z) / 8f);
	}

	public void DisplayValidMoves()
	{
		foreach (MoveData legalMove in legalMoves)
		{
			int x = legalMove.EndPosition.x;
			int y = legalMove.EndPosition.y;
			if (x >= 0 && x < 8 && y >= 0 && y < 8)
			{
				Renderer obj = helperTiles[x + y * 8];
				colorSetter.SetColor("_TintColor", (legalMove.CapturePiece != null) ? Color.green : Color.cyan);
				obj.SetPropertyBlock(colorSetter);
			}
			else
			{
				Debug.LogError("Trying to display a move out of range");
			}
		}
	}

	public void HideHelperTiles()
	{
		colorSetter.SetColor("_TintColor", Color.clear);
		for (int i = 0; i < 8; i++)
		{
			for (int j = 0; j < 8; j++)
			{
				helperTiles[i + j * 8].SetPropertyBlock(colorSetter);
			}
		}
	}

	public void FindMoveAtWorldPosition(ChessPiece chessPiece)
	{
		Vector3 position = chessPiece.transform.position;
		int2 tileID = WorldPositionToIndex(position);
		ChessPieceData data = chessPiece.Data;
		if (legalMoves.Count == 0)
		{
			chessPiece.UpdatePosition(GetPiecePos(data));
		}
		else
		{
			MoveData moveData = legalMoves.FirstOrDefault((MoveData move) => move.EndPosition.Equals(tileID));
			if (!moveData.EndPosition.Equals(tileID) || moveData.StartPosition.Equals(moveData.EndPosition))
			{
				chessPiece.UpdatePosition(GetPiecePos(data));
			}
			else
			{
				MakeMove(moveData, updateVisuals: true);
			}
		}
		HideHelperTiles();
	}

	public void InitializePiece(ChessPiece piece)
	{
		ChessPieceData data = piece.Data;
		allPieces.Add(data, piece);
		Vector3 position = piece.transform.position;
		int2 @int = WorldPositionToIndex(position);
		if (data.type == ChessPieceData.PieceType.King)
		{
			if (piece.isWhite)
			{
				whiteKing = data;
			}
			else
			{
				blackKing = data;
			}
		}
		SetPieceAt(@int, data);
		piece.UpdatePosition(@int);
	}

	public ChessPieceData GetPieceAt(int2 index)
	{
		return chessBoard[index.x + index.y * 8];
	}

	public void SetPieceAt(int2 index, ChessPieceData piece)
	{
		chessBoard[index.x + index.y * 8] = piece;
	}

	private int2 GetPiecePos(ChessPieceData piece)
	{
		int num = Array.IndexOf(chessBoard, piece);
		return new int2(num % 8, num / 8);
	}

	public void MakeMove(MoveData moveData, bool updateVisuals = false)
	{
		ChessPieceData pieceToMove = moveData.PieceToMove;
		int2 endPosition = moveData.EndPosition;
		if (moveData.SpecialMove == SpecialMove.EnPassantCapture)
		{
			SetPieceAt(endPosition + new int2(0, (!pieceToMove.isWhite) ? 1 : (-1)), null);
		}
		if (moveData.SpecialMove == SpecialMove.PawnTwoStep)
		{
			enPassantPos = endPosition + new int2(0, (!pieceToMove.isWhite) ? 1 : (-1));
		}
		else
		{
			enPassantPos = new int2(-1, -1);
		}
		pieceToMove.timesMoved++;
		SetPieceAt(moveData.StartPosition, null);
		SetPieceAt(endPosition, pieceToMove);
		if (moveData.SpecialMove == SpecialMove.ShortCastle || moveData.SpecialMove == SpecialMove.LongCastle)
		{
			int x = ((moveData.SpecialMove == SpecialMove.ShortCastle) ? 7 : 0);
			int x2 = ((moveData.SpecialMove == SpecialMove.ShortCastle) ? 5 : 3);
			int2 index = new int2(x, (!pieceToMove.isWhite) ? 7 : 0);
			int2 @int = new int2(x2, (!pieceToMove.isWhite) ? 7 : 0);
			ChessPieceData pieceAt = GetPieceAt(index);
			pieceAt.timesMoved++;
			SetPieceAt(index, null);
			SetPieceAt(@int, pieceAt);
			if (updateVisuals && allPieces.TryGetValue(pieceAt, out var value))
			{
				value.UpdatePosition(@int);
			}
		}
		if (moveData.SpecialMove == SpecialMove.PawnPromotion)
		{
			pieceToMove.type = moveData.PromotionType;
			if (updateVisuals)
			{
				ChessPiece chessPiece = allPieces[pieceToMove];
				if (chessPiece.autoControl)
				{
					chessPiece.PromoteVisualPiece();
				}
				else
				{
					gameLocked = true;
					foreach (KeyValuePair<ChessPieceData, ChessPiece> allPiece in allPieces)
					{
						allPiece.Value.PieceCanMove(canMove: false);
					}
					chessPiece.ShowPromotionGUI(moveData);
				}
			}
		}
		if (updateVisuals && allPieces.TryGetValue(pieceToMove, out var value2))
		{
			value2.UpdatePosition(endPosition);
			if (moveData.SpecialMove == SpecialMove.LongCastle || moveData.SpecialMove == SpecialMove.ShortCastle)
			{
				UnityEngine.Object.Instantiate(value2.teleportEffect, value2.transform.position, Quaternion.identity);
			}
			if (moveData.SpecialMove == SpecialMove.PawnPromotion)
			{
				UnityEngine.Object.Instantiate(value2.promotionEffect, value2.transform.position, Quaternion.identity);
			}
			if (!pieceToMove.autoControl && moveData.SpecialMove != SpecialMove.PawnPromotion)
			{
				StylishMove(moveData);
			}
		}
		if (updateVisuals && moveData.CapturePiece != null && allPieces.TryGetValue(moveData.CapturePiece, out var value3))
		{
			value3.Captured();
		}
		if (updateVisuals && (moveData.SpecialMove != SpecialMove.PawnPromotion || moveData.PieceToMove.autoControl))
		{
			UpdateGame(moveData);
		}
	}

	public void StylishMove(MoveData move)
	{
		if (move.SpecialMove == SpecialMove.LongCastle || move.SpecialMove == SpecialMove.ShortCastle)
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(50, "<color=#00ffffff>CASTLED</color>");
		}
		if (move.SpecialMove == SpecialMove.PawnPromotion)
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(500, "<color=green>" + move.PromotionType.ToString().ToUpper() + " PROMOTION</color>");
		}
		int num = 0;
		string text = "<color=white>";
		if (move.CapturePiece != null)
		{
			switch (move.CapturePiece.type)
			{
			case ChessPieceData.PieceType.Knight:
				num = 100;
				text = "<color=green>";
				break;
			case ChessPieceData.PieceType.Bishop:
				num = 100;
				text = "<color=green>";
				break;
			case ChessPieceData.PieceType.Rook:
				num = 200;
				text = "<color=orange>";
				break;
			case ChessPieceData.PieceType.Queen:
				num = 400;
				text = "<color=red>";
				break;
			}
			if (move.SpecialMove == SpecialMove.EnPassantCapture)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(100, "<color=#00ffffff>EN PASSANT</color>");
			}
			else
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(100 + num, text + move.CapturePiece.type.ToString().ToUpper() + " CAPTURE</color>");
			}
		}
	}

	public void UnmakeMove(MoveData moveData, bool updateVisuals = false)
	{
		enPassantPos = moveData.LastEnPassantPos;
		ChessPieceData pieceToMove = moveData.PieceToMove;
		SetPieceAt(moveData.StartPosition, moveData.PieceToMove);
		int2 endPosition = moveData.EndPosition;
		if (moveData.SpecialMove == SpecialMove.EnPassantCapture)
		{
			SetPieceAt(endPosition, null);
			endPosition += new int2(0, (!pieceToMove.isWhite) ? 1 : (-1));
		}
		SetPieceAt(endPosition, moveData.CapturePiece);
		pieceToMove.timesMoved--;
		if (moveData.SpecialMove == SpecialMove.ShortCastle || moveData.SpecialMove == SpecialMove.LongCastle)
		{
			int x = ((moveData.SpecialMove == SpecialMove.ShortCastle) ? 7 : 0);
			int x2 = ((moveData.SpecialMove == SpecialMove.ShortCastle) ? 5 : 3);
			int2 index = new int2(x, (!pieceToMove.isWhite) ? 7 : 0);
			int2 index2 = new int2(x2, (!pieceToMove.isWhite) ? 7 : 0);
			ChessPieceData pieceAt = GetPieceAt(index2);
			pieceAt.timesMoved--;
			SetPieceAt(index2, null);
			SetPieceAt(index, pieceAt);
		}
		if (moveData.SpecialMove == SpecialMove.PawnPromotion)
		{
			pieceToMove.type = ChessPieceData.PieceType.Pawn;
		}
		if (updateVisuals && allPieces.TryGetValue(pieceToMove, out var value))
		{
			value.UpdatePosition(moveData.StartPosition);
		}
		if (updateVisuals && moveData.CapturePiece != null && allPieces.TryGetValue(moveData.CapturePiece, out var value2))
		{
			value2.UpdatePosition(endPosition);
		}
	}

	private bool IsValidPosition(int2 index)
	{
		if (index.x >= 0 && index.x < 8 && index.y >= 0)
		{
			return index.y < 8;
		}
		return false;
	}

	public void GetLegalMoves(int2 index)
	{
		ChessPieceData pieceAt = GetPieceAt(index);
		if (pieceAt == null)
		{
			Debug.LogError("Found no piece at " + index);
		}
		pseudoLegalMoves.Clear();
		legalMoves.Clear();
		switch (pieceAt.type)
		{
		case ChessPieceData.PieceType.Pawn:
			GetPawnMoves(pieceAt, index, pseudoLegalMoves);
			break;
		case ChessPieceData.PieceType.Knight:
		case ChessPieceData.PieceType.King:
			GetKnightKingMoves(pieceAt, index, pseudoLegalMoves);
			break;
		case ChessPieceData.PieceType.Rook:
		case ChessPieceData.PieceType.Bishop:
		case ChessPieceData.PieceType.Queen:
			GetSlidingMoves(pieceAt, index, pseudoLegalMoves);
			break;
		}
		int2 position = GetPiecePos(pieceAt.isWhite ? whiteKing : blackKing);
		foreach (MoveData pseudoLegalMove in pseudoLegalMoves)
		{
			MakeMove(pseudoLegalMove);
			if (pseudoLegalMove.PieceToMove.type == ChessPieceData.PieceType.King)
			{
				position = pseudoLegalMove.EndPosition;
			}
			if (!IsSquareAttacked(position, pieceAt.isWhite))
			{
				legalMoves.Add(pseudoLegalMove);
			}
			UnmakeMove(pseudoLegalMove);
		}
	}

	private void GetPawnMoves(ChessPieceData pawn, int2 startPos, List<MoveData> validMoves)
	{
		int num = (pawn.isWhite ? 1 : (-1));
		int2 @int = startPos + pawnMoves[0] * num;
		if (GetPieceAt(@int) == null)
		{
			if (@int.y == (pawn.isWhite ? 7 : 0))
			{
				validMoves.Add(new MoveData(pawn, startPos, null, @int, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Queen));
				validMoves.Add(new MoveData(pawn, startPos, null, @int, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Rook));
				validMoves.Add(new MoveData(pawn, startPos, null, @int, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Bishop));
				validMoves.Add(new MoveData(pawn, startPos, null, @int, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Knight));
			}
			else
			{
				validMoves.Add(new MoveData(pawn, startPos, null, @int, enPassantPos));
			}
			if (pawn.timesMoved == 0)
			{
				int2 int2 = startPos + pawnMoves[1] * num;
				if (GetPieceAt(int2) == null)
				{
					validMoves.Add(new MoveData(pawn, startPos, null, int2, enPassantPos, SpecialMove.PawnTwoStep));
				}
			}
		}
		int2[] array = pawnCaptures;
		foreach (int2 int3 in array)
		{
			int2 int4 = startPos + int3 * num;
			if (!IsValidPosition(int4))
			{
				continue;
			}
			ChessPieceData pieceAt = GetPieceAt(int4);
			if (pieceAt != null && pieceAt.isWhite != pawn.isWhite)
			{
				if (@int.y == (pawn.isWhite ? 7 : 0))
				{
					validMoves.Add(new MoveData(pawn, startPos, pieceAt, int4, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Queen));
					validMoves.Add(new MoveData(pawn, startPos, pieceAt, int4, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Rook));
					validMoves.Add(new MoveData(pawn, startPos, pieceAt, int4, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Bishop));
					validMoves.Add(new MoveData(pawn, startPos, pieceAt, int4, enPassantPos, SpecialMove.PawnPromotion, ChessPieceData.PieceType.Knight));
				}
				else
				{
					validMoves.Add(new MoveData(pawn, startPos, pieceAt, int4, enPassantPos));
				}
			}
			if (enPassantPos.Equals(int4))
			{
				int2 index = new int2(enPassantPos.x, enPassantPos.y - num);
				ChessPieceData pieceAt2 = GetPieceAt(index);
				if (pieceAt2 != null && pieceAt2.isWhite != pawn.isWhite)
				{
					validMoves.Add(new MoveData(pawn, startPos, pieceAt2, enPassantPos, enPassantPos, SpecialMove.EnPassantCapture));
				}
			}
		}
	}

	private void GetSlidingMoves(ChessPieceData slidingPiece, int2 startPos, List<MoveData> validMoves)
	{
		int2[] array;
		switch (slidingPiece.type)
		{
		case ChessPieceData.PieceType.Bishop:
			array = bishopDirections;
			break;
		case ChessPieceData.PieceType.Rook:
			array = rookDirections;
			break;
		case ChessPieceData.PieceType.Queen:
			array = queenDirections;
			break;
		default:
			Debug.LogError("Invalid piece type for sliding moves");
			array = new int2[1];
			break;
		}
		int2[] array2 = array;
		foreach (int2 @int in array2)
		{
			int2 int2 = startPos;
			while (true)
			{
				int2 += @int;
				if (!IsValidPosition(int2))
				{
					break;
				}
				ChessPieceData pieceAt = GetPieceAt(int2);
				if (pieceAt != null)
				{
					if (pieceAt.isWhite != slidingPiece.isWhite)
					{
						validMoves.Add(new MoveData(slidingPiece, startPos, pieceAt, int2, enPassantPos));
					}
					break;
				}
				validMoves.Add(new MoveData(slidingPiece, startPos, null, int2, enPassantPos));
			}
		}
	}

	private void GetKnightKingMoves(ChessPieceData piece, int2 startPos, List<MoveData> validMoves)
	{
		int2[] array = ((piece.type == ChessPieceData.PieceType.Knight) ? knightOffsets : kingDirections);
		foreach (int2 @int in array)
		{
			int2 int2 = startPos + @int;
			if (IsValidPosition(int2))
			{
				ChessPieceData pieceAt = GetPieceAt(int2);
				if (pieceAt == null || pieceAt.isWhite != piece.isWhite)
				{
					validMoves.Add(new MoveData(piece, startPos, pieceAt, int2, enPassantPos));
				}
			}
		}
		if (piece.type == ChessPieceData.PieceType.King)
		{
			TryCastle(piece, startPos, isKingSide: true, validMoves);
			TryCastle(piece, startPos, isKingSide: false, validMoves);
		}
	}

	private void TryCastle(ChessPieceData king, int2 startPos, bool isKingSide, List<MoveData> validMoves)
	{
		if (king.timesMoved > 0 || IsSquareAttacked(startPos, king.isWhite))
		{
			return;
		}
		int num = (isKingSide ? 7 : 0);
		int2 index = new int2(num, startPos.y);
		ChessPieceData pieceAt = GetPieceAt(index);
		if (pieceAt == null || pieceAt.isWhite != king.isWhite || pieceAt.type != ChessPieceData.PieceType.Rook || pieceAt.timesMoved > 0)
		{
			return;
		}
		int num2 = (isKingSide ? 1 : (-1));
		for (int i = startPos.x + num2; i != num; i += num2)
		{
			int2 index2 = new int2(i, startPos.y);
			if (GetPieceAt(index2) != null)
			{
				return;
			}
		}
		int2 position = new int2(startPos.x + num2, startPos.y);
		if (!IsSquareAttacked(position, king.isWhite))
		{
			SpecialMove specialMove = (isKingSide ? SpecialMove.ShortCastle : SpecialMove.LongCastle);
			validMoves.Add(new MoveData(king, startPos, null, new int2(isKingSide ? 6 : 2, startPos.y), enPassantPos, specialMove));
		}
	}

	public bool IsSquareAttacked(int2 position, bool isWhite)
	{
		int2[] array = kingDirections;
		foreach (int2 @int in array)
		{
			if (IsPieceAtPositionOfType(position + @int, isWhite, ChessPieceData.PieceType.King))
			{
				return true;
			}
		}
		if (IsSlidingPieceAttacking(position, isWhite, isRookMovement: true))
		{
			return true;
		}
		if (IsSlidingPieceAttacking(position, isWhite, isRookMovement: false))
		{
			return true;
		}
		array = knightOffsets;
		foreach (int2 int2 in array)
		{
			if (IsPieceAtPositionOfType(position + int2, isWhite, ChessPieceData.PieceType.Knight))
			{
				return true;
			}
		}
		int y = (isWhite ? 1 : (-1));
		array = pawnCaptures;
		foreach (int2 int3 in array)
		{
			if (IsPieceAtPositionOfType(position + int3 * new int2(1, y), isWhite, ChessPieceData.PieceType.Pawn))
			{
				return true;
			}
		}
		return false;
	}

	private bool IsSlidingPieceAttacking(int2 position, bool isWhite, bool isRookMovement)
	{
		int2[] array = (isRookMovement ? rookDirections : bishopDirections);
		foreach (int2 @int in array)
		{
			for (int2 index = position + @int; IsValidPosition(index); index += @int)
			{
				ChessPieceData pieceAt = GetPieceAt(index);
				if (pieceAt != null)
				{
					if (pieceAt.isWhite == isWhite)
					{
						break;
					}
					if (pieceAt.type == ChessPieceData.PieceType.Queen)
					{
						return true;
					}
					if ((isRookMovement ? 1 : 3) != (int)pieceAt.type)
					{
						break;
					}
					return true;
				}
			}
		}
		return false;
	}

	private bool IsPieceAtPositionOfType(int2 position, bool isWhite, ChessPieceData.PieceType type)
	{
		if (IsValidPosition(position))
		{
			ChessPieceData pieceAt = GetPieceAt(position);
			if (pieceAt != null && pieceAt.isWhite != isWhite && pieceAt.type == type)
			{
				return true;
			}
		}
		return false;
	}
}



public class ChessPiece : MonoBehaviour
{
	public ChessPieceData Data;

	public ChessPieceData.PieceType type;

	public bool isWhite = true;

	public bool queenSide;

	private bool positionDirty;

	private Quaternion startRot;

	private Rigidbody rb;

	private SandboxProp sbp;

	public AudioSource snapSound;

	[HideInInspector]
	public AudioSource dragSound;

	public GameObject breakEffect;

	public GameObject teleportEffect;

	public GameObject promotionEffect;

	public int timesMoved;

	public bool autoControl;

	public bool initialized;

	public GameObject promotionPanel;

	public float boardHeight = -900f;

	private ChessManager chessMan;

	private ChessManager.MoveData promotionMove;

	private void Awake()
	{
		chessMan = MonoSingleton<ChessManager>.Instance;
		sbp = GetComponent<SandboxProp>();
		if (!dragSound)
		{
			dragSound = GetComponent<AudioSource>();
		}
	}

	private void Start()
	{
		if (promotionPanel != null)
		{
			promotionPanel.SetActive(value: false);
		}
		float y = chessMan.GetComponent<Collider>().bounds.max.y;
		float y2 = base.transform.GetChild(0).GetComponent<Collider>().bounds.min.y;
		boardHeight = base.transform.position.y + (y - y2);
		base.transform.position = new Vector3(base.transform.position.x, boardHeight, base.transform.position.z);
		if (!initialized)
		{
			rb = GetComponent<Rigidbody>();
			startRot = base.transform.rotation;
			Data = new ChessPieceData(type, isWhite, queenSide)
			{
				timesMoved = timesMoved,
				autoControl = autoControl
			};
			if (isWhite)
			{
				SetAutoControl(chessMan.whiteIsBot);
			}
			if (!isWhite)
			{
				SetAutoControl(chessMan.blackIsBot);
			}
			chessMan.InitializePiece(this);
			PieceCanMove(canMove: false);
			initialized = true;
		}
	}

	public void SetAutoControl(bool useAutoControl)
	{
		autoControl = useAutoControl;
		Data.autoControl = autoControl;
		sbp.disallowManipulation = autoControl;
	}

	private void Update()
	{
		if (!autoControl)
		{
			if (chessMan.gameLocked)
			{
				PieceCanMove(canMove: false);
			}
			else
			{
				PieceCanMove(isWhite == chessMan.isWhiteTurn);
			}
			if (sbp.frozen && !positionDirty)
			{
				int2 index = chessMan.WorldPositionToIndex(base.transform.position);
				chessMan.GetLegalMoves(index);
				chessMan.DisplayValidMoves();
				positionDirty = true;
			}
			if (positionDirty && !sbp.frozen)
			{
				rb.isKinematic = false;
			}
		}
	}

	public void PieceCanMove(bool canMove)
	{
		sbp.disallowManipulation = !canMove;
	}

	private void OnCollisionEnter(Collision collider)
	{
		if (!autoControl && (!isWhite || !chessMan.whiteIsBot) && (isWhite || !chessMan.blackIsBot) && !sbp.frozen)
		{
			if (positionDirty && collider.gameObject.TryGetComponent<ChessManager>(out var _))
			{
				chessMan.FindMoveAtWorldPosition(this);
				Object.Instantiate(snapSound, base.transform.position, Quaternion.identity);
			}
			if (positionDirty && collider.gameObject.TryGetComponent<ChessPiece>(out var _))
			{
				chessMan.FindMoveAtWorldPosition(this);
				Object.Instantiate(snapSound, base.transform.position, Quaternion.identity);
			}
		}
	}

	public void UpdatePosition(int2 position)
	{
		Vector3 position2 = chessMan.IndexToWorldPosition(position, boardHeight);
		base.transform.SetPositionAndRotation(position2, startRot);
		positionDirty = false;
		rb.isKinematic = true;
	}

	public void ShowPromotionGUI(ChessManager.MoveData move)
	{
		promotionMove = move;
		promotionPanel.SetActive(value: true);
	}

	public void PlayerPromotePiece(int type)
	{
		ChessPieceData.PieceType promotionType = ChessPieceData.PieceType.Pawn;
		switch (type)
		{
		case 0:
			promotionType = ChessPieceData.PieceType.Queen;
			break;
		case 1:
			promotionType = ChessPieceData.PieceType.Rook;
			break;
		case 2:
			promotionType = ChessPieceData.PieceType.Bishop;
			break;
		case 3:
			promotionType = ChessPieceData.PieceType.Knight;
			break;
		}
		Data.type = promotionType;
		promotionPanel.SetActive(value: false);
		PromoteVisualPiece();
		promotionMove.PromotionType = promotionType;
		chessMan.StylishMove(promotionMove);
		chessMan.UpdateGame(promotionMove);
	}

	public void PromoteVisualPiece()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
		int num = ((!Data.isWhite) ? 4 : 0);
		switch (Data.type)
		{
		case ChessPieceData.PieceType.Rook:
			num++;
			break;
		case ChessPieceData.PieceType.Bishop:
			num += 2;
			break;
		case ChessPieceData.PieceType.Knight:
			num += 3;
			break;
		}
		GameObject obj = Object.Instantiate(chessMan.originalExtras.transform.GetChild(num).gameObject, base.transform);
		obj.transform.SetPositionAndRotation(base.transform.position, base.transform.rotation);
		obj.SetActive(value: true);
		CapsuleCollider componentInChildren = obj.GetComponentInChildren<CapsuleCollider>();
		Vector3 position = componentInChildren.transform.TransformPoint(componentInChildren.center);
		CapsuleCollider component = GetComponent<CapsuleCollider>();
		component.height = componentInChildren.height;
		component.radius = componentInChildren.radius;
		component.center = component.transform.InverseTransformPoint(position);
		Object.Destroy(componentInChildren);
	}

	public void Captured()
	{
		Object.Instantiate(breakEffect, base.transform.position, Quaternion.identity);
		base.gameObject.SetActive(value: false);
	}
}


public class ChessPieceData
{
	public enum PieceType
	{
		Pawn,
		Rook,
		Knight,
		Bishop,
		Queen,
		King
	}

	public bool isWhite = true;

	public int timesMoved;

	public bool queenSide;

	public bool autoControl;

	public PieceType type;

	public ChessPieceData(PieceType type, bool isWhite, bool queenSide)
	{
		this.type = type;
		this.isWhite = isWhite;
		this.queenSide = queenSide;
	}
}



public static class ChessStringHandler
{
	public static void LogMatchHistory(List<string> matchHistory)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string item in matchHistory)
		{
			stringBuilder.AppendLine(item);
		}
		Debug.Log(stringBuilder.ToString());
	}

	public static string GenerateFenString(ChessPieceData[] board, bool isWhiteTurn, string castlingAvailability, string enPassantTarget, int halfmoveClock, int fullmoveNumber)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int num = 7; num >= 0; num--)
		{
			int num2 = 0;
			for (int i = 0; i < 8; i++)
			{
				int num3 = num * 8 + i;
				ChessPieceData chessPieceData = board[num3];
				if (chessPieceData == null)
				{
					num2++;
					continue;
				}
				if (num2 != 0)
				{
					stringBuilder.Append(num2);
					num2 = 0;
				}
				char fenCharForPiece = GetFenCharForPiece(chessPieceData);
				stringBuilder.Append(fenCharForPiece);
			}
			if (num2 != 0)
			{
				stringBuilder.Append(num2);
			}
			if (num > 0)
			{
				stringBuilder.Append('/');
			}
		}
		stringBuilder.Append(isWhiteTurn ? " w " : " b ");
		stringBuilder.Append(castlingAvailability);
		stringBuilder.Append(" ");
		stringBuilder.Append(string.IsNullOrWhiteSpace(enPassantTarget) ? "-" : enPassantTarget);
		stringBuilder.Append(" ");
		stringBuilder.Append(halfmoveClock);
		stringBuilder.Append(" ");
		stringBuilder.Append(fullmoveNumber);
		return stringBuilder.ToString();
	}

	private static char GetFenCharForPiece(ChessPieceData piece)
	{
		char c = '0';
		switch (piece.type)
		{
		case ChessPieceData.PieceType.Pawn:
			c = 'p';
			break;
		case ChessPieceData.PieceType.Rook:
			c = 'r';
			break;
		case ChessPieceData.PieceType.Knight:
			c = 'n';
			break;
		case ChessPieceData.PieceType.Bishop:
			c = 'b';
			break;
		case ChessPieceData.PieceType.Queen:
			c = 'q';
			break;
		case ChessPieceData.PieceType.King:
			c = 'k';
			break;
		default:
			Debug.LogError("Received an invalid piece type from the chess engine");
			break;
		}
		if (!piece.isWhite)
		{
			return c;
		}
		return char.ToUpper(c);
	}

	public static string CalculateCastlingAvailability(ChessPieceData[] board)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = true;
		bool flag4 = true;
		bool flag5 = true;
		bool flag6 = true;
		foreach (ChessPieceData chessPieceData in board)
		{
			if (chessPieceData == null)
			{
				continue;
			}
			if (chessPieceData.type == ChessPieceData.PieceType.King)
			{
				if (chessPieceData.isWhite)
				{
					flag = chessPieceData.timesMoved != 0;
				}
				else
				{
					flag2 = chessPieceData.timesMoved != 0;
				}
			}
			else
			{
				if (chessPieceData.type != ChessPieceData.PieceType.Rook)
				{
					continue;
				}
				if (chessPieceData.isWhite)
				{
					if (chessPieceData.queenSide)
					{
						flag4 = chessPieceData.timesMoved == 0;
					}
					else
					{
						flag3 = chessPieceData.timesMoved == 0;
					}
				}
				else if (chessPieceData.queenSide)
				{
					flag6 = chessPieceData.timesMoved == 0;
				}
				else
				{
					flag5 = chessPieceData.timesMoved == 0;
				}
			}
		}
		StringBuilder stringBuilder = new StringBuilder();
		if (!flag)
		{
			if (flag3)
			{
				stringBuilder.Append("K");
			}
			if (flag4)
			{
				stringBuilder.Append("Q");
			}
		}
		if (!flag2)
		{
			if (flag5)
			{
				stringBuilder.Append("k");
			}
			if (flag6)
			{
				stringBuilder.Append("q");
			}
		}
		if (stringBuilder.Length <= 0)
		{
			return "-";
		}
		return stringBuilder.ToString();
	}

	public static string ConvertToChessNotation(int2 position)
	{
		char c = (char)(97 + position.x);
		int num = position.y + 1;
		return $"{c}{num}";
	}

	public static int2 ConvertFromChessNotation(string notation)
	{
		if (notation.Length < 2)
		{
			Debug.LogError("Invalid chess notation");
		}
		char num = notation[0];
		int num2 = int.Parse(notation.Substring(1));
		int x = num - 97;
		int y = num2 - 1;
		return new int2(x, y);
	}

	public static (int2 start, int2 end, ChessPieceData.PieceType promotionType) ProcessFullMove(string move)
	{
		if (string.IsNullOrWhiteSpace(move) || move.Length < 4)
		{
			Debug.LogError("Got invalid move from bot");
		}
		string notation = move.Substring(0, 2);
		string notation2 = move.Substring(2, 2);
		if (move.Contains("none"))
		{
			Debug.LogError("Bot found move: " + move);
		}
		int2 item = ConvertFromChessNotation(notation);
		int2 item2 = ConvertFromChessNotation(notation2);
		ChessPieceData.PieceType item3 = ChessPieceData.PieceType.Pawn;
		if (move.Length > 4)
		{
			switch (move[4])
			{
			case 'q':
				item3 = ChessPieceData.PieceType.Queen;
				break;
			case 'r':
				item3 = ChessPieceData.PieceType.Rook;
				break;
			case 'b':
				item3 = ChessPieceData.PieceType.Bishop;
				break;
			case 'n':
				item3 = ChessPieceData.PieceType.Knight;
				break;
			}
		}
		return (start: item, end: item2, promotionType: item3);
	}

	public static string UCIMove(ChessManager.MoveData moveData)
	{
		string text = ConvertToChessNotation(moveData.StartPosition) + ConvertToChessNotation(moveData.EndPosition);
		char c = 'p';
		switch (moveData.PromotionType)
		{
		case ChessPieceData.PieceType.Knight:
			c = 'n';
			break;
		case ChessPieceData.PieceType.Rook:
			c = 'r';
			break;
		case ChessPieceData.PieceType.Bishop:
			c = 'b';
			break;
		case ChessPieceData.PieceType.Queen:
			c = 'q';
			break;
		}
		if (moveData.PromotionType != 0)
		{
			text += c;
		}
		return text;
	}

	public static string LogPerft(ChessManager.MoveData moveData, int subsequentMoves = 0)
	{
		string text = ConvertToChessNotation(moveData.StartPosition) + ConvertToChessNotation(moveData.EndPosition);
		char c = 'p';
		switch (moveData.PromotionType)
		{
		case ChessPieceData.PieceType.Knight:
			c = 'n';
			break;
		case ChessPieceData.PieceType.Rook:
			c = 'r';
			break;
		case ChessPieceData.PieceType.Bishop:
			c = 'b';
			break;
		case ChessPieceData.PieceType.Queen:
			c = 'q';
			break;
		}
		if (moveData.PromotionType != 0)
		{
			text += c;
		}
		return text + $": {subsequentMoves}";
	}

	public static void LogMoveData(ChessManager.MoveData moveData, int subsequentMoves = 0)
	{
		string text = ConvertToChessNotation(moveData.StartPosition) + ConvertToChessNotation(moveData.EndPosition);
		if (subsequentMoves > 0)
		{
			text += $" {subsequentMoves}";
		}
		Debug.Log(text + "\nMove Data:\n" + $"Piece Type: {moveData.PieceToMove.type}\n" + $"Start Position: {moveData.StartPosition}\n" + "Color: " + (moveData.PieceToMove.isWhite ? "White" : "Black") + "\n" + $"End Position: {moveData.EndPosition}\n" + "Capture Piece: " + ((moveData.CapturePiece != null) ? moveData.CapturePiece.type.ToString() : "None") + "\n" + $"Castle State: {moveData.SpecialMove}");
	}
}



public class ClashModePickup : MonoBehaviour
{
	private bool activated;

	[SerializeField]
	private GameObject dancer;

	private void OnTriggerEnter(Collider other)
	{
		if (!activated)
		{
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && (bool)MonoSingleton<PlatformerMovement>.Instance && other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject)
			{
				activated = true;
				Activate();
			}
			else if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS && (bool)MonoSingleton<NewMovement>.Instance && other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
			{
				MonoSingleton<PlayerTracker>.Instance.ChangeToPlatformer();
			}
		}
	}

	private void Activate()
	{
		MonoSingleton<PlatformerMovement>.Instance.gameObject.SetActive(value: false);
		MonoSingleton<PlatformerMovement>.Instance.SnapCamera(new Vector3(0f, 5f, -5.5f), new Vector3(20f, 0f, 0f));
		MonoSingleton<PlatformerMovement>.Instance.platformerCamera.position = dancer.transform.position + new Vector3(0f, 5f, -5.5f);
		dancer.SetActive(value: true);
		GameProgressSaver.SetClashModeUnlocked(unlocked: true);
		base.gameObject.SetActive(value: false);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ClimbStep : MonoSingleton<ClimbStep>
{
	private InputManager inman;

	private Rigidbody rb;

	private int layerMask;

	private NewMovement newMovement;

	private float step = 2.1f;

	private float allowedAngle = 0.1f;

	private float allowedSpeed = 0.1f;

	private float allowedInput = 0.5f;

	private float cooldown;

	private float cooldownMax = 0.1f;

	private float deltaVertical;

	private float deltaHorizontal = 0.6f;

	private Vector3 position;

	private Vector3 gizmoPosition1;

	private Vector3 gizmoPosition2;

	private Vector3 movementDirection;

	private new void Awake()
	{
		rb = GetComponent<Rigidbody>();
		layerMask = LayerMask.GetMask("Environment", "Outdoors");
	}

	private void Start()
	{
		newMovement = MonoSingleton<NewMovement>.Instance;
		inman = MonoSingleton<InputManager>.Instance;
	}

	private void FixedUpdate()
	{
		if (cooldown <= 0f)
		{
			cooldown = 0f;
		}
		else
		{
			cooldown -= Time.deltaTime;
		}
		Vector2 vector = MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>();
		movementDirection = Vector3.ClampMagnitude(vector.x * base.transform.right + vector.y * base.transform.forward, 1f);
	}

	private void OnCollisionStay(Collision collisionInfo)
	{
		if (MonoSingleton<NewMovement>.Instance.gc.forcedOff > 0 || layerMask != (layerMask | (1 << collisionInfo.collider.gameObject.layer)) || cooldown != 0f)
		{
			return;
		}
		ContactPoint[] contacts = collisionInfo.contacts;
		for (int i = 0; i < contacts.Length; i++)
		{
			ContactPoint contactPoint = contacts[i];
			if ((!(rb.velocity.y < allowedSpeed) && allowedSpeed != 0f) || cooldown != 0f || ((!(Vector3.Dot(movementDirection, -Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up).normalized) > allowedInput) || newMovement.boost) && (!(Vector3.Dot(newMovement.dodgeDirection, -Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up).normalized) > allowedInput) || !newMovement.boost)) || !(Mathf.Abs(Vector3.Dot(Vector3.up, contactPoint.normal)) < allowedAngle))
			{
				continue;
			}
			position = base.transform.position + Vector3.up * step + Vector3.up * 0.25f;
			if (newMovement.sliding)
			{
				position += Vector3.up * 1.125f;
			}
			Collider[] array = Physics.OverlapCapsule(position - Vector3.up * step, position + Vector3.up * 1.25f, 0.499999f, layerMask, QueryTriggerInteraction.Ignore);
			Collider[] array2 = Physics.OverlapCapsule(position - Vector3.up * 1.25f - Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up) * 0.5f, position + Vector3.up * 1.25f - Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up) * 0.5f, 0.5f, layerMask, QueryTriggerInteraction.Ignore);
			if (array.Length == 0 && array2.Length == 0)
			{
				cooldown = cooldownMax;
				Vector3 vector = MonoSingleton<CameraController>.Instance.transform.position;
				bool flag = true;
				if (!newMovement.rising)
				{
					newMovement.rising = true;
					flag = true;
				}
				float num = 1.75f;
				if (Physics.Raycast(position - Vector3.up * num - Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up).normalized * deltaHorizontal, -Vector3.up, out var hitInfo, step, layerMask, QueryTriggerInteraction.Ignore))
				{
					rb.velocity -= new Vector3(0f, rb.velocity.y, 0f);
					base.transform.position += Vector3.up * (step + deltaVertical - hitInfo.distance) - Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up).normalized * deltaHorizontal;
					rb.velocity = -collisionInfo.relativeVelocity;
				}
				else
				{
					base.transform.position += Vector3.up * (step + deltaVertical) - Vector3.ProjectOnPlane(contactPoint.normal, Vector3.up).normalized * deltaHorizontal;
					rb.velocity = -collisionInfo.relativeVelocity;
				}
				if (flag)
				{
					MonoSingleton<CameraController>.Instance.transform.position = vector;
					MonoSingleton<CameraController>.Instance.defaultPos = MonoSingleton<CameraController>.Instance.transform.localPosition;
				}
			}
		}
	}
}



public class Clock : MonoBehaviour
{
	public Transform hour;

	public Transform minute;

	private void Update()
	{
		float num = DateTime.Now.Hour;
		float num2 = DateTime.Now.Minute;
		float num3 = DateTime.Now.Second;
		hour.localRotation = Quaternion.Euler(0f, (num % 12f / 12f + num2 / 1440f) * 360f, 0f);
		minute.localRotation = Quaternion.Euler(0f, (num2 / 60f + num3 / 3600f) * 360f, 0f);
	}
}



public class ClockChime : MonoBehaviour
{
	private int lastHour;

	private void Start()
	{
		lastHour = DateTime.Now.Hour;
	}

	private void Update()
	{
		int hour = DateTime.Now.Hour;
		if (lastHour != hour && hour % 12 == 4)
		{
			GetComponent<AudioSource>().Play();
		}
		lastHour = hour;
	}
}


public enum ClungMannequinMovementDirection
{
	Horizontal,
	Vertical
}



public class Coin : MonoBehaviour
{
	public EnemyTarget customTarget;

	public GameObject sourceWeapon;

	private Rigidbody rb;

	private bool checkingSpeed;

	private float timeToDelete = 1f;

	public LayerMask lmask;

	public GameObject refBeam;

	public Vector3 hitPoint = Vector3.zero;

	private Collider[] cols;

	public bool shot;

	[HideInInspector]
	public bool shotByEnemy;

	private bool wasShotByEnemy;

	public GameObject coinBreak;

	public float power;

	private EnemyIdentifier eid;

	public bool quickDraw;

	public Material uselessMaterial;

	private GameObject altBeam;

	public GameObject coinHitSound;

	[HideInInspector]
	public int hitTimes = 1;

	public bool doubled;

	public GameObject flash;

	public GameObject enemyFlash;

	public GameObject chargeEffect;

	private GameObject currentCharge;

	private StyleHUD shud;

	public CoinChainCache ccc;

	public int ricochets;

	[HideInInspector]
	public int difficulty = -1;

	public bool dontDestroyOnPlayerRespawn;

	public bool ignoreBlessedEnemies;

	private void Start()
	{
		MonoSingleton<CoinList>.Instance.AddCoin(this);
		shud = MonoSingleton<StyleHUD>.Instance;
		doubled = false;
		Invoke("GetDeleted", 5f);
		Invoke("StartCheckingSpeed", 0.1f);
		Invoke("TripleTime", 0.35f);
		Invoke("TripleTimeEnd", 0.417f);
		Invoke("DoubleTime", 1f);
		rb = GetComponent<Rigidbody>();
		cols = GetComponents<Collider>();
		Collider[] array = cols;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
	}

	private void Update()
	{
		if (!shot)
		{
			if (checkingSpeed && rb.velocity.magnitude < 1f)
			{
				timeToDelete -= Time.deltaTime * 10f;
			}
			else
			{
				timeToDelete = 1f;
			}
			if (timeToDelete <= 0f)
			{
				GetDeleted();
			}
		}
	}

	private void OnDestroy()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<CoinList>.Instance.RemoveCoin(this);
		}
	}

	private void TripleTime()
	{
		if (!shot)
		{
			hitTimes = 2;
			doubled = true;
			if ((bool)currentCharge)
			{
				Object.Destroy(currentCharge);
			}
			if ((bool)flash)
			{
				currentCharge = Object.Instantiate(flash, base.transform.position, Quaternion.identity);
				currentCharge.transform.SetParent(base.transform, worldPositionStays: true);
			}
		}
	}

	private void TripleTimeEnd()
	{
		if (!shot)
		{
			hitTimes = 1;
			doubled = true;
		}
	}

	private void DoubleTime()
	{
		if (!shot)
		{
			hitTimes = 2;
			doubled = true;
			if ((bool)currentCharge)
			{
				Object.Destroy(currentCharge);
			}
			if ((bool)chargeEffect)
			{
				currentCharge = Object.Instantiate(chargeEffect, base.transform.position, base.transform.rotation);
				currentCharge.transform.SetParent(base.transform, worldPositionStays: true);
			}
		}
	}

	public void DelayedReflectRevolver(Vector3 hitp, GameObject beam = null)
	{
		if (checkingSpeed)
		{
			if (shotByEnemy)
			{
				CancelInvoke("EnemyReflect");
				CancelInvoke("ShootAtPlayer");
				shotByEnemy = false;
			}
			ricochets++;
			CancelInvoke("TripleTime");
			CancelInvoke("TripleTimeEnd");
			CancelInvoke("DoubleTime");
			if (!ccc && altBeam == null)
			{
				GameObject gameObject = new GameObject();
				ccc = gameObject.AddComponent<CoinChainCache>();
				gameObject.AddComponent<RemoveOnTime>().time = 5f;
			}
			rb.isKinematic = true;
			shot = true;
			hitPoint = hitp;
			altBeam = beam;
			Invoke("ReflectRevolver", 0.1f);
		}
	}

	public void ReflectRevolver()
	{
		GameObject gameObject = null;
		float num = float.PositiveInfinity;
		Vector3 position = base.transform.position;
		GetComponent<SphereCollider>().enabled = false;
		bool flag = false;
		bool flag2 = false;
		if (MonoSingleton<CoinList>.Instance.revolverCoinsList.Count > 1)
		{
			foreach (Coin revolverCoins in MonoSingleton<CoinList>.Instance.revolverCoinsList)
			{
				if (revolverCoins != this && (!revolverCoins.shot || revolverCoins.shotByEnemy))
				{
					float sqrMagnitude = (revolverCoins.transform.position - position).sqrMagnitude;
					if (sqrMagnitude < num && !Physics.Raycast(base.transform.position, revolverCoins.transform.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, revolverCoins.transform.position) - 0.5f, lmask))
					{
						gameObject = revolverCoins.gameObject;
						num = sqrMagnitude;
					}
				}
			}
			if (gameObject != null)
			{
				flag = true;
				Coin component = gameObject.GetComponent<Coin>();
				component.power = power + 1f;
				component.ricochets += ricochets;
				if (quickDraw)
				{
					component.quickDraw = true;
				}
				if (component.shotByEnemy)
				{
					component.CancelInvoke("EnemyReflect");
					component.CancelInvoke("ShootAtPlayer");
					component.shotByEnemy = false;
				}
				AudioSource[] array = null;
				if (altBeam == null)
				{
					if ((bool)ccc)
					{
						component.ccc = ccc;
					}
					else
					{
						GameObject gameObject2 = new GameObject();
						ccc = gameObject2.AddComponent<CoinChainCache>();
						component.ccc = ccc;
						gameObject2.AddComponent<RemoveOnTime>().time = 5f;
					}
					component.DelayedReflectRevolver(gameObject.transform.position);
					LineRenderer component2 = SpawnBeam().GetComponent<LineRenderer>();
					array = component2.GetComponents<AudioSource>();
					if (hitPoint == Vector3.zero)
					{
						component2.SetPosition(0, base.transform.position);
					}
					else
					{
						component2.SetPosition(0, hitPoint);
					}
					component2.SetPosition(1, gameObject.transform.position);
					if (power > 2f)
					{
						AudioSource[] array2 = array;
						foreach (AudioSource obj in array2)
						{
							obj.pitch = 1f + (power - 2f) / 5f;
							obj.Play();
						}
					}
				}
			}
		}
		if (!flag)
		{
			List<Transform> list = new List<Transform>();
			foreach (Grenade grenade in MonoSingleton<ObjectTracker>.Instance.grenadeList)
			{
				if (!grenade.playerRiding && !grenade.enemy)
				{
					list.Add(grenade.transform);
				}
			}
			foreach (Cannonball cannonball in MonoSingleton<ObjectTracker>.Instance.cannonballList)
			{
				list.Add(cannonball.transform);
			}
			Transform transform = null;
			gameObject = null;
			num = float.PositiveInfinity;
			position = base.transform.position;
			foreach (Transform item3 in list)
			{
				float magnitude = (item3.transform.position - position).magnitude;
				if (magnitude < num && Vector3.Distance(MonoSingleton<PlayerTracker>.Instance.GetPlayer().transform.position, item3.transform.position) < 100f && !Physics.Raycast(base.transform.position, item3.transform.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, item3.transform.position) - 0.5f, lmask))
				{
					gameObject = item3.gameObject;
					transform = item3;
					num = magnitude;
				}
			}
			if (gameObject != null && transform != null && !altBeam)
			{
				LineRenderer component3 = SpawnBeam().GetComponent<LineRenderer>();
				component3.GetComponents<AudioSource>();
				if (hitPoint == Vector3.zero)
				{
					component3.SetPosition(0, base.transform.position);
				}
				else
				{
					component3.SetPosition(0, hitPoint);
				}
				component3.SetPosition(1, gameObject.transform.position);
				Cannonball component5;
				if (transform.TryGetComponent<Grenade>(out var component4))
				{
					component4.Explode(component4.rocket, harmless: false, !component4.rocket);
				}
				else if (transform.TryGetComponent<Cannonball>(out component5))
				{
					component5.Explode();
				}
			}
			if (gameObject == null)
			{
				GameObject[] array3 = GameObject.FindGameObjectsWithTag("Enemy");
				foreach (GameObject gameObject3 in array3)
				{
					float sqrMagnitude2 = (gameObject3.transform.position - position).sqrMagnitude;
					if (!(sqrMagnitude2 < num))
					{
						continue;
					}
					eid = gameObject3.GetComponent<EnemyIdentifier>();
					if (eid != null && !eid.dead && (!ccc || !ccc.beenHit.Contains(eid.gameObject)) && (!eid.blessed || !ignoreBlessedEnemies))
					{
						Transform transform2;
						if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy)
						{
							transform2 = eid.weakPoint.transform;
						}
						else
						{
							EnemyIdentifierIdentifier componentInChildren = eid.GetComponentInChildren<EnemyIdentifierIdentifier>();
							transform2 = ((!componentInChildren) ? eid.transform : componentInChildren.transform);
						}
						if (!Physics.Raycast(base.transform.position, transform2.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, transform2.position) - 0.5f, lmask))
						{
							gameObject = gameObject3;
							num = sqrMagnitude2;
						}
						else
						{
							eid = null;
						}
					}
					else
					{
						eid = null;
					}
				}
				if (gameObject != null)
				{
					if (eid == null)
					{
						eid = gameObject.GetComponent<EnemyIdentifier>();
					}
					flag2 = true;
					if (altBeam == null)
					{
						if ((bool)ccc)
						{
							ccc.beenHit.Add(eid.gameObject);
						}
						LineRenderer component6 = SpawnBeam().GetComponent<LineRenderer>();
						AudioSource[] components = component6.GetComponents<AudioSource>();
						if (hitPoint == Vector3.zero)
						{
							component6.SetPosition(0, base.transform.position);
						}
						else
						{
							component6.SetPosition(0, hitPoint);
						}
						Vector3 zero = Vector3.zero;
						zero = ((!(eid.weakPoint != null) || !eid.weakPoint.activeInHierarchy) ? eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position : eid.weakPoint.transform.position);
						component6.SetPosition(1, zero);
						if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy && eid.weakPoint.GetComponent<EnemyIdentifierIdentifier>() != null)
						{
							bool flag3 = false;
							if (eid.enemyType == EnemyType.Streetcleaner && Physics.Raycast(base.transform.position, eid.weakPoint.transform.position - base.transform.position, out var hitInfo4, Vector3.Distance(base.transform.position, eid.weakPoint.transform.position), LayerMaskDefaults.Get(LMD.Enemies)) && hitInfo4.transform != eid.weakPoint.transform)
							{
								EnemyIdentifierIdentifier component7 = hitInfo4.transform.GetComponent<EnemyIdentifierIdentifier>();
								if ((bool)component7 && (bool)component7.eid && component7.eid == eid)
								{
									eid.DeliverDamage(hitInfo4.transform.gameObject, (hitInfo4.transform.position - base.transform.position).normalized * 10000f, hitInfo4.transform.position, power, tryForExplode: false, 1f, sourceWeapon);
								}
								flag3 = true;
							}
							if (!eid.blessed && !eid.puppet)
							{
								RicoshotPointsCheck();
								if (quickDraw)
								{
									shud.AddPoints(50, "ultrakill.quickdraw", sourceWeapon, eid);
								}
							}
							eid.hitter = "revolver";
							if (!eid.hitterWeapons.Contains("revolver1"))
							{
								eid.hitterWeapons.Add("revolver1");
							}
							if (!flag3)
							{
								eid.DeliverDamage(eid.weakPoint, (eid.weakPoint.transform.position - base.transform.position).normalized * 10000f, zero, power, tryForExplode: false, 1f, sourceWeapon);
							}
						}
						else if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy && eid.weakPoint.GetComponentInChildren<Breakable>() != null)
						{
							Breakable componentInChildren2 = eid.weakPoint.GetComponentInChildren<Breakable>();
							RicoshotPointsCheck();
							if (componentInChildren2.precisionOnly)
							{
								shud.AddPoints(100, "ultrakill.interruption", sourceWeapon, eid);
								MonoSingleton<TimeController>.Instance.ParryFlash();
								if ((bool)componentInChildren2.interruptEnemy && !componentInChildren2.interruptEnemy.blessed)
								{
									componentInChildren2.interruptEnemy.Explode(fromExplosion: true);
								}
							}
							componentInChildren2.Break();
						}
						else
						{
							RicoshotPointsCheck();
							eid.hitter = "revolver";
							eid.DeliverDamage(eid.GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, (eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position - base.transform.position).normalized * 10000f, zero, power, tryForExplode: false, 1f, sourceWeapon);
						}
						if (power > 2f)
						{
							AudioSource[] array2 = components;
							foreach (AudioSource obj2 in array2)
							{
								obj2.pitch = 1f + (power - 2f) / 5f;
								obj2.Play();
							}
						}
						eid = null;
					}
				}
				else
				{
					gameObject = null;
					List<GameObject> list2 = new List<GameObject>();
					array3 = GameObject.FindGameObjectsWithTag("Glass");
					foreach (GameObject item in array3)
					{
						list2.Add(item);
					}
					array3 = GameObject.FindGameObjectsWithTag("GlassFloor");
					foreach (GameObject item2 in array3)
					{
						list2.Add(item2);
					}
					if (list2.Count > 0)
					{
						gameObject = null;
						num = float.PositiveInfinity;
						position = base.transform.position;
						foreach (GameObject item4 in list2)
						{
							float sqrMagnitude3 = (item4.transform.position - position).sqrMagnitude;
							if (!(sqrMagnitude3 < num))
							{
								continue;
							}
							Glass componentInChildren3 = item4.GetComponentInChildren<Glass>();
							if (componentInChildren3 != null && !componentInChildren3.broken && (!ccc || !ccc.beenHit.Contains(componentInChildren3.gameObject)))
							{
								Transform transform3 = item4.transform;
								if (!Physics.Raycast(base.transform.position, transform3.position - base.transform.position, out var hitInfo5, Vector3.Distance(base.transform.position, transform3.position) - 0.5f, lmask) || hitInfo5.transform.gameObject.CompareTag("Glass") || hitInfo5.transform.gameObject.CompareTag("GlassFloor"))
								{
									gameObject = item4;
									num = sqrMagnitude3;
								}
							}
						}
						if (gameObject != null && altBeam == null)
						{
							gameObject.GetComponentInChildren<Glass>().Shatter();
							if ((bool)ccc)
							{
								ccc.beenHit.Add(gameObject);
							}
							LineRenderer component8 = SpawnBeam().GetComponent<LineRenderer>();
							if (power > 2f)
							{
								AudioSource[] array2 = component8.GetComponents<AudioSource>();
								foreach (AudioSource obj3 in array2)
								{
									obj3.pitch = 1f + (power - 2f) / 5f;
									obj3.Play();
								}
							}
							if (hitPoint == Vector3.zero)
							{
								component8.SetPosition(0, base.transform.position);
							}
							else
							{
								component8.SetPosition(0, hitPoint);
							}
							component8.SetPosition(1, gameObject.transform.position);
						}
					}
					if ((list2.Count == 0 || gameObject == null) && altBeam == null)
					{
						Vector3 normalized = Random.insideUnitSphere.normalized;
						LineRenderer component9 = SpawnBeam().GetComponent<LineRenderer>();
						if (power > 2f)
						{
							AudioSource[] array2 = component9.GetComponents<AudioSource>();
							foreach (AudioSource obj4 in array2)
							{
								obj4.pitch = 1f + (power - 2f) / 5f;
								obj4.Play();
							}
						}
						if (hitPoint == Vector3.zero)
						{
							component9.SetPosition(0, base.transform.position);
						}
						else
						{
							component9.SetPosition(0, hitPoint);
						}
						if (Physics.Raycast(base.transform.position, normalized, out var hitInfo6, float.PositiveInfinity, lmask))
						{
							component9.SetPosition(1, hitInfo6.point);
						}
						else
						{
							component9.SetPosition(1, base.transform.position + normalized * 1000f);
						}
					}
				}
			}
		}
		if (altBeam != null)
		{
			AudioSource[] components2 = Object.Instantiate(coinHitSound, base.transform.position, Quaternion.identity).GetComponents<AudioSource>();
			RevolverBeam component10 = altBeam.GetComponent<RevolverBeam>();
			altBeam.transform.position = base.transform.position;
			if (component10.beamType == BeamType.Revolver && hitTimes > 1 && component10.strongAlt && component10.hitAmount < 99)
			{
				component10.hitAmount++;
				component10.maxHitsPerTarget = component10.hitAmount;
			}
			if (flag2)
			{
				if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy)
				{
					altBeam.transform.LookAt(eid.weakPoint.transform.position);
				}
				else
				{
					altBeam.transform.LookAt(eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position);
				}
				if (!eid.blessed && !eid.puppet)
				{
					RicoshotPointsCheck();
					if (quickDraw)
					{
						shud.AddPoints(50, "ultrakill.quickdraw", sourceWeapon, eid);
					}
				}
				if (component10.beamType == BeamType.Revolver)
				{
					eid.hitter = "revolver";
					if (!eid.hitterWeapons.Contains("revolver" + component10.gunVariation))
					{
						eid.hitterWeapons.Add("revolver" + component10.gunVariation);
					}
				}
				else
				{
					eid.hitter = "railcannon";
					if (!eid.hitterWeapons.Contains("railcannon0"))
					{
						eid.hitterWeapons.Add("railcannon0");
					}
				}
			}
			else if (gameObject != null)
			{
				altBeam.transform.LookAt(gameObject.transform.position);
			}
			else
			{
				altBeam.transform.forward = Random.insideUnitSphere.normalized;
			}
			if (!flag)
			{
				if (component10.beamType == BeamType.Revolver && component10.hasBeenRicocheter)
				{
					if (component10.maxHitsPerTarget < (component10.strongAlt ? 4 : 3))
					{
						component10.maxHitsPerTarget = Mathf.Min(component10.maxHitsPerTarget + 2, component10.strongAlt ? 4 : 3);
					}
				}
				else
				{
					component10.addedDamage += power / 4f;
					component10.damage += power / 4f;
				}
			}
			if (power > 2f)
			{
				AudioSource[] array2 = components2;
				foreach (AudioSource obj5 in array2)
				{
					obj5.pitch = 1f + (power - 2f) / 5f;
					obj5.Play();
				}
			}
			altBeam.SetActive(value: true);
		}
		hitTimes--;
		if (hitTimes > 0 && altBeam == null)
		{
			Invoke("ReflectRevolver", 0.05f);
			return;
		}
		base.gameObject.SetActive(value: false);
		new GameObject().AddComponent<CoinCollector>().coin = base.gameObject;
		CancelInvoke("GetDeleted");
	}

	public void DelayedPunchflection()
	{
		if (checkingSpeed && (!shot || shotByEnemy))
		{
			if (shotByEnemy)
			{
				CancelInvoke("EnemyReflect");
				CancelInvoke("ShootAtPlayer");
				shotByEnemy = false;
			}
			CancelInvoke("TripleTime");
			CancelInvoke("TripleTimeEnd");
			CancelInvoke("DoubleTime");
			ricochets++;
			if ((bool)currentCharge)
			{
				Object.Destroy(currentCharge);
			}
			rb.isKinematic = true;
			shot = true;
			Punchflection();
		}
	}

	public async void Punchflection()
	{
		bool flag = false;
		bool flag2 = false;
		GameObject gameObject = null;
		float num = float.PositiveInfinity;
		Vector3 position = base.transform.position;
		GameObject gameObject2 = Object.Instantiate(base.gameObject, base.transform.position, Quaternion.identity);
		gameObject2.SetActive(value: false);
		Vector3 position2 = base.transform.position;
		GetComponent<SphereCollider>().enabled = false;
		GameObject[] array = GameObject.FindGameObjectsWithTag("Enemy");
		foreach (GameObject gameObject3 in array)
		{
			float sqrMagnitude = (gameObject3.transform.position - position).sqrMagnitude;
			if (!(sqrMagnitude < num))
			{
				continue;
			}
			eid = gameObject3.GetComponent<EnemyIdentifier>();
			if (eid != null && !eid.dead)
			{
				Transform transform = ((!(eid.weakPoint != null) || !eid.weakPoint.activeInHierarchy) ? eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform : eid.weakPoint.transform);
				if (!Physics.Raycast(base.transform.position, transform.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, transform.position) - 0.5f, lmask))
				{
					gameObject = gameObject3;
					num = sqrMagnitude;
				}
				else
				{
					eid = null;
				}
			}
			else
			{
				eid = null;
			}
		}
		if (gameObject != null)
		{
			if (eid == null)
			{
				eid = gameObject.GetComponent<EnemyIdentifier>();
			}
			LineRenderer component = SpawnBeam().GetComponent<LineRenderer>();
			AudioSource[] components = component.GetComponents<AudioSource>();
			if (hitPoint == Vector3.zero)
			{
				component.SetPosition(0, base.transform.position);
			}
			else
			{
				component.SetPosition(0, hitPoint);
			}
			_ = Vector3.zero;
			Vector3 vector = ((!(eid.weakPoint != null) || !eid.weakPoint.activeInHierarchy) ? eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position : eid.weakPoint.transform.position);
			if (eid.blessed)
			{
				flag2 = true;
			}
			component.SetPosition(1, vector);
			position2 = vector;
			if (!eid.puppet && !eid.blessed)
			{
				shud.AddPoints(50, "ultrakill.fistfullofdollar", sourceWeapon, eid);
			}
			if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy && eid.weakPoint.GetComponent<EnemyIdentifierIdentifier>() != null)
			{
				eid.hitter = "coin";
				if (!eid.hitterWeapons.Contains("coin"))
				{
					eid.hitterWeapons.Add("coin");
				}
				eid.DeliverDamage(eid.weakPoint, (eid.weakPoint.transform.position - base.transform.position).normalized * 10000f, vector, power, tryForExplode: false, 1f, sourceWeapon);
			}
			else if (eid.weakPoint != null && eid.weakPoint.activeInHierarchy)
			{
				Breakable componentInChildren = eid.weakPoint.GetComponentInChildren<Breakable>();
				if (componentInChildren.precisionOnly)
				{
					shud.AddPoints(100, "ultrakill.interruption", sourceWeapon, eid);
					MonoSingleton<TimeController>.Instance.ParryFlash();
					if ((bool)componentInChildren.interruptEnemy && !componentInChildren.interruptEnemy.blessed)
					{
						componentInChildren.interruptEnemy.Explode(fromExplosion: true);
					}
				}
				componentInChildren.Break();
			}
			else
			{
				eid.hitter = "coin";
				eid.DeliverDamage(eid.GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, (eid.GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position - base.transform.position).normalized * 10000f, hitPoint, power, tryForExplode: false, 1f, sourceWeapon);
			}
			if (power > 2f)
			{
				AudioSource[] array2 = components;
				foreach (AudioSource obj in array2)
				{
					obj.pitch = 1f + (power - 2f) / 5f;
					obj.Play();
				}
				eid = null;
			}
		}
		else
		{
			flag = true;
			Vector3 forward = MonoSingleton<CameraController>.Instance.transform.forward;
			LineRenderer component2 = SpawnBeam().GetComponent<LineRenderer>();
			if (power > 2f)
			{
				AudioSource[] array2 = component2.GetComponents<AudioSource>();
				foreach (AudioSource obj2 in array2)
				{
					obj2.pitch = 1f + (power - 2f) / 5f;
					obj2.Play();
				}
			}
			if (hitPoint == Vector3.zero)
			{
				component2.SetPosition(0, base.transform.position);
			}
			else
			{
				component2.SetPosition(0, hitPoint);
			}
			if (Physics.Raycast(MonoSingleton<CameraController>.Instance.transform.position, forward, out var hitInfo2, float.PositiveInfinity, lmask))
			{
				component2.SetPosition(1, hitInfo2.point);
				position2 = hitInfo2.point - forward;
			}
			else
			{
				component2.SetPosition(1, MonoSingleton<CameraController>.Instance.transform.position + forward * 1000f);
				Object.Destroy(gameObject2);
			}
		}
		if ((bool)gameObject2)
		{
			gameObject2.transform.position = position2;
			gameObject2.SetActive(value: true);
			Coin component3 = gameObject2.GetComponent<Coin>();
			if ((bool)component3)
			{
				component3.shot = false;
				if (component3.power < 5f || (!flag && !flag2))
				{
					component3.power += 1f;
				}
				gameObject2.name = "NewCoin+" + (component3.power - 2f);
			}
			Rigidbody component4 = gameObject2.GetComponent<Rigidbody>();
			if ((bool)component4)
			{
				component4.isKinematic = false;
				component4.velocity = Vector3.zero;
				component4.AddForce(Vector3.up * 25f, ForceMode.VelocityChange);
			}
		}
		base.gameObject.SetActive(value: false);
		new GameObject().AddComponent<CoinCollector>().coin = base.gameObject;
		CancelInvoke("GetDeleted");
	}

	public void Bounce()
	{
		if (!shot)
		{
			if ((bool)currentCharge)
			{
				Object.Destroy(currentCharge);
			}
			GameObject obj = Object.Instantiate(base.gameObject, base.transform.position, Quaternion.identity);
			obj.name = "NewCoin+" + (power - 2f);
			obj.SetActive(value: false);
			Vector3 position = base.transform.position;
			obj.transform.position = position;
			obj.SetActive(value: true);
			GetComponent<SphereCollider>().enabled = false;
			shot = true;
			Coin component = obj.GetComponent<Coin>();
			if ((bool)component)
			{
				component.shot = false;
			}
			Rigidbody component2 = obj.GetComponent<Rigidbody>();
			if ((bool)component2)
			{
				component2.isKinematic = false;
				component2.velocity = Vector3.zero;
				component2.AddForce(Vector3.up * 25f, ForceMode.VelocityChange);
			}
			base.gameObject.SetActive(value: false);
			new GameObject().AddComponent<CoinCollector>().coin = base.gameObject;
			CancelInvoke("GetDeleted");
		}
	}

	public void DelayedEnemyReflect()
	{
		if (!shot)
		{
			shotByEnemy = true;
			wasShotByEnemy = true;
			CancelInvoke("TripleTime");
			CancelInvoke("TripleTimeEnd");
			CancelInvoke("DoubleTime");
			ricochets++;
			if (!ccc)
			{
				GameObject gameObject = new GameObject();
				ccc = gameObject.AddComponent<CoinChainCache>();
				ccc.target = customTarget;
				gameObject.AddComponent<RemoveOnTime>().time = 5f;
			}
			rb.isKinematic = true;
			shot = true;
			Invoke("EnemyReflect", 0.1f);
		}
	}

	public void EnemyReflect()
	{
		bool flag = false;
		if (MonoSingleton<CoinList>.Instance.revolverCoinsList.Count > 1)
		{
			GameObject gameObject = null;
			float num = float.PositiveInfinity;
			Vector3 position = base.transform.position;
			foreach (Coin revolverCoins in MonoSingleton<CoinList>.Instance.revolverCoinsList)
			{
				if (revolverCoins != this && !revolverCoins.shot)
				{
					float sqrMagnitude = (revolverCoins.transform.position - position).sqrMagnitude;
					if (sqrMagnitude < num && !Physics.Raycast(base.transform.position, revolverCoins.transform.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, revolverCoins.transform.position) - 0.5f, lmask))
					{
						gameObject = revolverCoins.gameObject;
						num = sqrMagnitude;
					}
				}
			}
			if (gameObject != null)
			{
				flag = true;
				Coin component = gameObject.GetComponent<Coin>();
				component.power = power + 1f;
				component.ricochets += ricochets;
				if (quickDraw)
				{
					component.quickDraw = true;
				}
				AudioSource[] array = null;
				if ((bool)ccc)
				{
					component.ccc = ccc;
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					ccc = gameObject2.AddComponent<CoinChainCache>();
					component.ccc = ccc;
					gameObject2.AddComponent<RemoveOnTime>().time = 5f;
				}
				component.DelayedEnemyReflect();
				LineRenderer component2 = SpawnBeam().GetComponent<LineRenderer>();
				array = component2.GetComponents<AudioSource>();
				if (hitPoint == Vector3.zero)
				{
					component2.SetPosition(0, base.transform.position);
				}
				else
				{
					component2.SetPosition(0, hitPoint);
				}
				component2.SetPosition(1, gameObject.transform.position);
				Gradient gradient = new Gradient();
				gradient.SetKeys(new GradientColorKey[2]
				{
					new GradientColorKey(Color.red, 0f),
					new GradientColorKey(Color.red, 1f)
				}, new GradientAlphaKey[2]
				{
					new GradientAlphaKey(1f, 0f),
					new GradientAlphaKey(1f, 1f)
				});
				component2.colorGradient = gradient;
				if (power > 2f)
				{
					AudioSource[] array2 = array;
					foreach (AudioSource obj in array2)
					{
						obj.pitch = 1f + (power - 2f) / 5f;
						obj.Play();
					}
				}
			}
		}
		if (!flag)
		{
			Invoke("ShootAtPlayer", 0.5f);
			if (TryGetComponent<SphereCollider>(out var component3))
			{
				component3.radius = 20f;
			}
			if ((bool)enemyFlash)
			{
				Object.Instantiate(enemyFlash, base.transform.position, Quaternion.identity).transform.SetParent(base.transform, worldPositionStays: true);
			}
		}
		else
		{
			shotByEnemy = false;
			base.gameObject.SetActive(value: false);
			new GameObject().AddComponent<CoinCollector>().coin = base.gameObject;
			CancelInvoke("GetDeleted");
			GetComponent<SphereCollider>().enabled = false;
		}
	}

	private void ShootAtPlayer()
	{
		if (customTarget == null && ccc != null)
		{
			customTarget = ccc.target;
		}
		GetComponent<SphereCollider>().enabled = false;
		Vector3 zero = Vector3.zero;
		Vector3 vector = ((customTarget == null) ? MonoSingleton<CameraController>.Instance.GetDefaultPos() : customTarget.position);
		if (difficulty < 0)
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (difficulty <= 2)
		{
			Vector3 vector2 = ((customTarget == null) ? MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().normalized : customTarget.GetVelocity());
			vector -= vector2 * ((float)(3 - difficulty) / 1.5f);
		}
		zero = ((!Physics.Raycast(base.transform.position, vector - base.transform.position, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment))) ? (base.transform.position + (vector - base.transform.position) * 999f) : hitInfo.point);
		RaycastHit hitInfo2;
		if (customTarget == null || customTarget.isPlayer)
		{
			if (MonoSingleton<NewMovement>.Instance.gameObject.layer != 15 && Physics.Raycast(base.transform.position, vector - base.transform.position, hitInfo.distance, 4))
			{
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(7.5f * power), invincible: true);
			}
		}
		else if (Physics.Raycast(base.transform.position, vector - base.transform.position, out hitInfo2, hitInfo.distance, 1024))
		{
			EnemyIdentifierIdentifier component = hitInfo2.collider.GetComponent<EnemyIdentifierIdentifier>();
			if (component != null && component.eid == customTarget.enemyIdentifier)
			{
				customTarget.enemyIdentifier.SimpleDamage(Mathf.RoundToInt(7.5f * power));
			}
		}
		LineRenderer component2 = SpawnBeam().GetComponent<LineRenderer>();
		AudioSource[] components = component2.GetComponents<AudioSource>();
		if (hitPoint == Vector3.zero)
		{
			component2.SetPosition(0, base.transform.position);
		}
		else
		{
			component2.SetPosition(0, hitPoint);
		}
		component2.SetPosition(1, zero);
		Gradient gradient = new Gradient();
		gradient.SetKeys(new GradientColorKey[2]
		{
			new GradientColorKey(Color.red, 0f),
			new GradientColorKey(Color.red, 1f)
		}, new GradientAlphaKey[2]
		{
			new GradientAlphaKey(1f, 0f),
			new GradientAlphaKey(1f, 1f)
		});
		component2.colorGradient = gradient;
		component2.widthMultiplier *= 2f;
		if (power > 2f)
		{
			AudioSource[] array = components;
			foreach (AudioSource obj in array)
			{
				obj.pitch = 1f + (power - 2f) / 5f;
				obj.Play();
			}
		}
		base.gameObject.SetActive(value: false);
		new GameObject().AddComponent<CoinCollector>().coin = base.gameObject;
		CancelInvoke("GetDeleted");
		shotByEnemy = false;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.layer == 8 || collision.gameObject.layer == 24)
		{
			GoreZone componentInParent = collision.transform.GetComponentInParent<GoreZone>();
			if (componentInParent != null)
			{
				base.transform.SetParent(componentInParent.gibZone, worldPositionStays: true);
			}
			GetDeleted();
		}
	}

	public void GetDeleted()
	{
		if (base.gameObject.activeInHierarchy)
		{
			Object.Instantiate(coinBreak, base.transform.position, Quaternion.identity);
		}
		GetComponent<MeshRenderer>().material = uselessMaterial;
		AudioLowPassFilter[] componentsInChildren = GetComponentsInChildren<AudioLowPassFilter>();
		if (componentsInChildren != null && componentsInChildren.Length != 0)
		{
			AudioLowPassFilter[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				Object.Destroy(array[i]);
			}
		}
		Object.Destroy(GetComponent<AudioSource>());
		Object.Destroy(base.transform.GetChild(0).GetComponent<AudioSource>());
		Object.Destroy(GetComponent<TrailRenderer>());
		Object.Destroy(GetComponent<SphereCollider>());
		if (TryGetComponent<Zappable>(out var component))
		{
			Object.Destroy(component);
		}
		base.gameObject.AddComponent<RemoveOnTime>().time = 5f;
		if ((bool)currentCharge)
		{
			Object.Destroy(currentCharge);
		}
		Object.Destroy(this);
	}

	private void StartCheckingSpeed()
	{
		Collider[] array = cols;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		checkingSpeed = true;
	}

	private GameObject SpawnBeam()
	{
		GameObject obj = Object.Instantiate(refBeam, base.transform.position, Quaternion.identity);
		obj.GetComponent<RevolverBeam>().sourceWeapon = sourceWeapon;
		return obj;
	}

	public void RicoshotPointsCheck()
	{
		string text = "";
		int num = 50;
		if (altBeam != null && altBeam.TryGetComponent<RevolverBeam>(out var component) && component.ultraRicocheter)
		{
			text = "<color=orange>ULTRA</color>";
			num += 50;
		}
		if (wasShotByEnemy)
		{
			text += "<color=red>COUNTER</color>";
			num += 50;
		}
		if (ricochets > 1)
		{
			num += ricochets * 15;
		}
		StyleHUD styleHUD = shud;
		int points = num;
		string prefix = text;
		styleHUD.AddPoints(points, "ultrakill.ricoshot", sourceWeapon, eid, ricochets, prefix);
	}
}



public class CoinActivated : MonoBehaviour
{
	public bool disableCoin;

	public UltrakillEvent events;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Coin"))
		{
			events.Invoke();
			if (disableCoin)
			{
				other.gameObject.SetActive(value: false);
			}
			GetComponent<Collider>().enabled = false;
		}
	}
}



public class CoinChainCache : MonoBehaviour
{
	public List<GameObject> beenHit = new List<GameObject>();

	public EnemyTarget target;
}



public class CoinCollector : MonoBehaviour
{
	public GameObject coin;

	private void Start()
	{
		Invoke("Removal", 10f);
	}

	private void Removal()
	{
		Object.Destroy(coin);
		Object.Destroy(base.gameObject);
	}
}



public class CoinList : MonoSingleton<CoinList>
{
	public List<Coin> revolverCoinsList = new List<Coin>();

	public void AddCoin(Coin coin)
	{
		if (!revolverCoinsList.Contains(coin))
		{
			revolverCoinsList.Add(coin);
		}
	}

	public void RemoveCoin(Coin coin)
	{
		if (revolverCoinsList.Contains(coin))
		{
			revolverCoinsList.Remove(coin);
		}
	}

	private void Start()
	{
		Invoke("SlowUpdate", 30f);
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 30f);
		for (int num = revolverCoinsList.Count - 1; num >= 0; num--)
		{
			if (revolverCoinsList[num] == null)
			{
				revolverCoinsList.RemoveAt(num);
			}
		}
	}
}



public static class ColliderUtility
{
	private static readonly List<Vector3> s_Vertices = new List<Vector3>();

	private static readonly List<int> s_Triangles = new List<int>();

	private static Triangle<Vector3> GetTriangle(int index)
	{
		Vector3 index2 = s_Vertices[s_Triangles[3 * index]];
		Vector3 index3 = s_Vertices[s_Triangles[3 * index + 1]];
		Vector3 index4 = s_Vertices[s_Triangles[3 * index + 2]];
		return new Triangle<Vector3>(index2, index3, index4);
	}

	private static Plane GetTrianglePlane(Transform collider, int index)
	{
		return GetTrianglePlane(GetTriangle(index));
	}

	private static Plane GetTrianglePlane(Triangle<Vector3> source)
	{
		return new Plane(source.Index0, source.Index1, source.Index2);
	}

	private static bool InTriangle(Vector3 a, Vector3 b, Vector3 c, Vector3 p)
	{
		Vector3 vector = b - a;
		Vector3 vector2 = c - a;
		Vector3 rhs = p - a;
		float num = Vector3.Dot(vector, vector);
		float num2 = Vector3.Dot(vector, vector2);
		float num3 = Vector3.Dot(vector, rhs);
		float num4 = Vector3.Dot(vector2, vector2);
		float num5 = Vector3.Dot(vector2, rhs);
		float num6 = 1f / (num * num4 - num2 * num2);
		float num7 = (num4 * num3 - num2 * num5) * num6;
		float num8 = (num * num5 - num2 * num3) * num6;
		if (num7 >= 0f && num8 >= 0f)
		{
			return num7 + num8 < 1f;
		}
		return false;
	}

	public static Vector3 FindClosestPoint(Collider collider, Vector3 position)
	{
		return FindClosestPoint(collider, position, ignoreVerticalTriangles: false);
	}

	public static Vector3 FindClosestPoint(Collider collider, Vector3 position, bool ignoreVerticalTriangles)
	{
		if (NonConvexJumpDebug.Active)
		{
			NonConvexJumpDebug.Reset();
		}
		if (collider is MeshCollider { convex: false, sharedMesh: var sharedMesh } meshCollider)
		{
			sharedMesh.GetVertices(s_Vertices);
			Vector3 position2 = Vector3.zero;
			float num = float.PositiveInfinity;
			Transform transform = meshCollider.transform;
			position = transform.InverseTransformPoint(position);
			Vector3 rhs = transform.InverseTransformDirection(Vector3.up);
			for (int i = 0; i < sharedMesh.subMeshCount; i++)
			{
				sharedMesh.GetTriangles(s_Triangles, i);
				int j = 0;
				for (int num2 = s_Triangles.Count / 3; j < num2; j++)
				{
					Triangle<Vector3> triangle = GetTriangle(j);
					Vector3 vector = Vector3.Normalize(Vector3.Cross(triangle.Index1 - triangle.Index0, triangle.Index2 - triangle.Index0));
					float num3 = 0f - Vector3.Dot(vector, triangle.Index0);
					if (ignoreVerticalTriangles && Mathf.Abs(Vector3.Dot(vector, rhs)) >= 0.9f)
					{
						continue;
					}
					float num4 = Vector3.Dot(vector, position) + num3;
					float num5 = Mathf.Abs(num4);
					if (!(num5 >= num))
					{
						Vector3 vector2 = position - vector * num4;
						bool flag = InTriangle(triangle.Index0, triangle.Index1, triangle.Index2, vector2);
						if (NonConvexJumpDebug.Active)
						{
							Triangle<Vector3> triangle2 = new Triangle<Vector3>(transform.TransformPoint(triangle.Index0), transform.TransformPoint(triangle.Index1), transform.TransformPoint(triangle.Index2));
							NonConvexJumpDebug.CreateTri(vector, triangle2, flag ? new Color(0f, 0f, 1f) : new Color(0f, 0f, Random.Range(0.1f, 0.4f)));
						}
						if (flag)
						{
							position2 = vector2;
							num = num5;
						}
					}
				}
			}
			position2 = transform.TransformPoint(position2);
			if (NonConvexJumpDebug.Active)
			{
				NonConvexJumpDebug.CreateBall(Color.green, position2);
			}
			return position2;
		}
		return collider.ClosestPoint(position);
	}
}



[DisallowMultipleComponent]
public sealed class CollisionEnterMessage : MessageDispatcher<Collision>.Callback<UnityEventCollision>
{
	private void OnCollisionEnter(Collision collision)
	{
		Handler.Invoke(collision);
	}
}



[DisallowMultipleComponent]
public sealed class CollisionExitMessage : MessageDispatcher<Collision>.Callback<UnityEventCollision>
{
	private void OnCollisionExit(Collision collision)
	{
		Handler.Invoke(collision);
	}
}



[DisallowMultipleComponent]
public sealed class CollisionStayMessage : MessageDispatcher<Collision>.Callback<UnityEventCollision>
{
	private void OnCollisionStay(Collision collision)
	{
		Handler.Invoke(collision);
	}
}



public class ColorBlindActivator : MonoBehaviour
{
	public Transform parentOfSetters;

	private ColorBlindSetter[] cbss;

	private void Start()
	{
		if (cbss == null || cbss.Length == 0)
		{
			cbss = GetComponentsInChildren<ColorBlindSetter>(includeInactive: true);
		}
		ColorBlindSetter[] array = cbss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Prepare();
		}
	}

	public void ResetToDefault()
	{
		if (cbss == null || cbss.Length == 0)
		{
			cbss = GetComponentsInChildren<ColorBlindSetter>(includeInactive: true);
		}
		ColorBlindSetter[] array = cbss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ResetToDefault();
		}
	}
}



public class ColorBlindGet : MonoBehaviour
{
	public HudColorType hct;

	private Image img;

	private Text txt;

	private Light lit;

	private SpriteRenderer sr;

	private TMP_Text txt2;

	private ParticleSystem ps;

	private bool gotTarget;

	public bool variationColor;

	public int variationNumber;

	public bool customColorRenderer;

	private Renderer rend;

	private MaterialPropertyBlock block;

	private void Start()
	{
		UpdateColor();
	}

	private void OnEnable()
	{
		UpdateColor();
	}

	public void UpdateColor()
	{
		if (!gotTarget)
		{
			GetTarget();
		}
		Color color = (variationColor ? MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationNumber] : MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(hct));
		if ((bool)rend)
		{
			rend.GetPropertyBlock(block);
			block.SetColor("_CustomColor1", color);
			rend.SetPropertyBlock(block);
			return;
		}
		if ((bool)img)
		{
			img.color = color;
		}
		if ((bool)txt)
		{
			txt.color = color;
		}
		if ((bool)txt2)
		{
			txt2.color = color;
		}
		if ((bool)lit)
		{
			lit.color = color;
		}
		if ((bool)sr)
		{
			sr.color = color;
		}
		if ((bool)ps)
		{
			ParticleSystem.MainModule main = ps.main;
			main.startColor = color;
		}
	}

	private void GetTarget()
	{
		gotTarget = true;
		if (customColorRenderer)
		{
			rend = GetComponent<Renderer>();
			block = new MaterialPropertyBlock();
		}
		img = GetComponent<Image>();
		txt = GetComponent<Text>();
		txt2 = GetComponent<TMP_Text>();
		lit = GetComponent<Light>();
		sr = GetComponent<SpriteRenderer>();
		ps = GetComponent<ParticleSystem>();
	}
}



public class ColorBlindSetter : MonoBehaviour
{
	private TMP_Text nameText;

	private string originalName;

	public new string name;

	public bool enemyColor;

	public bool variationColor;

	public HudColorType hct;

	public EnemyType ect;

	public int variationNumber;

	private Color originalColor;

	private Color newColor;

	public Image colorExample;

	private float redAmount;

	private float greenAmount;

	private float blueAmount;

	public Slider redSlider;

	public Slider greenSlider;

	public Slider blueSlider;

	private void OnEnable()
	{
		if ((bool)nameText && enemyColor)
		{
			if (MonoSingleton<BestiaryData>.Instance.GetEnemy(ect) < 1)
			{
				nameText.text = "???";
			}
			else
			{
				nameText.text = originalName;
			}
		}
	}

	public void Prepare()
	{
		if (variationColor)
		{
			originalColor = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationNumber];
		}
		else if (!enemyColor)
		{
			originalColor = MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(hct);
		}
		else
		{
			originalColor = MonoSingleton<ColorBlindSettings>.Instance.GetEnemyColor(ect);
		}
		redAmount = MonoSingleton<PrefsManager>.Instance.GetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".r", originalColor.r);
		greenAmount = MonoSingleton<PrefsManager>.Instance.GetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".g", originalColor.g);
		blueAmount = MonoSingleton<PrefsManager>.Instance.GetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".b", originalColor.b);
		newColor = new Color(redAmount, greenAmount, blueAmount, originalColor.a);
		colorExample.color = newColor;
		if (newColor != originalColor)
		{
			if (variationColor)
			{
				MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationNumber] = newColor;
				MonoSingleton<ColorBlindSettings>.Instance.UpdateWeaponColors();
			}
			else if (!enemyColor)
			{
				MonoSingleton<ColorBlindSettings>.Instance.SetHudColor(hct, newColor);
			}
			else
			{
				MonoSingleton<ColorBlindSettings>.Instance.SetEnemyColor(ect, newColor);
			}
		}
		redSlider.value = redAmount;
		greenSlider.value = greenAmount;
		blueSlider.value = blueAmount;
		nameText = base.transform.GetChild(0).GetComponent<TMP_Text>();
		originalName = nameText.text;
		if (MonoSingleton<BestiaryData>.Instance.GetEnemy(ect) < 1 && enemyColor)
		{
			nameText.text = "???";
		}
	}

	private void UpdateColor()
	{
		_ = newColor;
		if (newColor.a == 0f)
		{
			return;
		}
		bool flag = false;
		if (newColor.r != redAmount)
		{
			newColor.r = redAmount;
			MonoSingleton<PrefsManager>.Instance.SetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".r", redAmount);
			flag = true;
		}
		if (newColor.g != greenAmount)
		{
			newColor.g = greenAmount;
			MonoSingleton<PrefsManager>.Instance.SetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".g", greenAmount);
			flag = true;
		}
		if (newColor.b != blueAmount)
		{
			newColor.b = blueAmount;
			MonoSingleton<PrefsManager>.Instance.SetFloat((enemyColor ? "enemyColor." : "hudColor.") + name + ".b", blueAmount);
			flag = true;
		}
		colorExample.color = newColor;
		if (flag)
		{
			if (variationColor)
			{
				MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationNumber] = newColor;
				MonoSingleton<ColorBlindSettings>.Instance.UpdateWeaponColors();
			}
			else if (!enemyColor)
			{
				MonoSingleton<ColorBlindSettings>.Instance.SetHudColor(hct, newColor);
			}
			else
			{
				MonoSingleton<ColorBlindSettings>.Instance.SetEnemyColor(ect, newColor);
			}
		}
	}

	public void ChangeRed(float amount)
	{
		redAmount = amount;
		UpdateColor();
	}

	public void ChangeGreen(float amount)
	{
		greenAmount = amount;
		UpdateColor();
	}

	public void ChangeBlue(float amount)
	{
		blueAmount = amount;
		UpdateColor();
	}

	public void ResetToDefault()
	{
		redAmount = originalColor.r;
		greenAmount = originalColor.g;
		blueAmount = originalColor.b;
		redSlider.value = redAmount;
		greenSlider.value = greenAmount;
		blueSlider.value = blueAmount;
		UpdateColor();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ColorBlindSettings : MonoSingleton<ColorBlindSettings>
{
	public Color[] variationColors;

	[Header("HUD Colors")]
	public Color healthBarColor;

	public Color healthBarAfterImageColor;

	public Color antiHpColor;

	public Color overHealColor;

	public Color healthBarTextColor;

	public Color staminaColor;

	public Color staminaChargingColor;

	public Color staminaEmptyColor;

	public Color railcannonFullColor;

	public Color railcannonChargingColor;

	[Header("Enemy Colors")]
	public Color filthColor;

	public Color strayColor;

	public Color schismColor;

	public Color shotgunnerColor;

	public Color stalkerColor;

	public Color sisyphusColor;

	public Color ferrymanColor;

	public Color droneColor;

	public Color streetcleanerColor;

	public Color swordsmachineColor;

	public Color mindflayerColor;

	public Color v2Color;

	public Color turretColor;

	public Color guttermanColor;

	public Color guttertankColor;

	public Color maliciousColor;

	public Color cerberusColor;

	public Color idolColor;

	public Color mannequinColor;

	public Color virtueColor;

	public Color enrageColor;

	public void UpdateEnemyColors()
	{
		EnemySimplifier[] array = Object.FindObjectsOfType<EnemySimplifier>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateColors();
		}
	}

	public void UpdateHudColors()
	{
		StaminaMeter[] array = Object.FindObjectsOfType<StaminaMeter>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateColors();
		}
		ColorBlindGet[] array2 = Object.FindObjectsOfType<ColorBlindGet>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].UpdateColor();
		}
	}

	public void UpdateWeaponColors()
	{
		WeaponIcon weaponIcon = Object.FindObjectOfType<WeaponIcon>();
		if ((bool)weaponIcon)
		{
			weaponIcon.UpdateIcon();
		}
		MonoSingleton<FistControl>.Instance.UpdateFistIcon();
		ColorBlindGet[] array = Object.FindObjectsOfType<ColorBlindGet>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateColor();
		}
	}

	public Color GetEnemyColor(EnemyType ect)
	{
		return ect switch
		{
			EnemyType.Cerberus => cerberusColor, 
			EnemyType.Drone => droneColor, 
			EnemyType.Ferryman => ferrymanColor, 
			EnemyType.Filth => filthColor, 
			EnemyType.Gutterman => guttermanColor, 
			EnemyType.Guttertank => guttertankColor, 
			EnemyType.Idol => idolColor, 
			EnemyType.MaliciousFace => maliciousColor, 
			EnemyType.Mannequin => mannequinColor, 
			EnemyType.Mindflayer => mindflayerColor, 
			EnemyType.Schism => schismColor, 
			EnemyType.Sisyphus => sisyphusColor, 
			EnemyType.Soldier => shotgunnerColor, 
			EnemyType.Stalker => stalkerColor, 
			EnemyType.Stray => strayColor, 
			EnemyType.Streetcleaner => streetcleanerColor, 
			EnemyType.Swordsmachine => swordsmachineColor, 
			EnemyType.Turret => turretColor, 
			EnemyType.V2 => v2Color, 
			EnemyType.Virtue => virtueColor, 
			_ => Color.black, 
		};
	}

	public Color GetHudColor(HudColorType hct)
	{
		return hct switch
		{
			HudColorType.antiHp => antiHpColor, 
			HudColorType.health => healthBarColor, 
			HudColorType.healthAfterImage => healthBarAfterImageColor, 
			HudColorType.healthText => healthBarTextColor, 
			HudColorType.overheal => overHealColor, 
			HudColorType.stamina => staminaColor, 
			HudColorType.staminaCharging => staminaChargingColor, 
			HudColorType.staminaEmpty => staminaEmptyColor, 
			HudColorType.railcannonFull => railcannonFullColor, 
			HudColorType.railcannonCharging => railcannonChargingColor, 
			_ => Color.white, 
		};
	}

	public void SetEnemyColor(EnemyType ect, Color color)
	{
		switch (ect)
		{
		case EnemyType.Cerberus:
			cerberusColor = color;
			break;
		case EnemyType.Drone:
			droneColor = color;
			break;
		case EnemyType.Ferryman:
			ferrymanColor = color;
			break;
		case EnemyType.Filth:
			filthColor = color;
			break;
		case EnemyType.Gutterman:
			guttermanColor = color;
			break;
		case EnemyType.Guttertank:
			guttertankColor = color;
			break;
		case EnemyType.Idol:
			idolColor = color;
			break;
		case EnemyType.MaliciousFace:
			maliciousColor = color;
			break;
		case EnemyType.Mannequin:
			mannequinColor = color;
			break;
		case EnemyType.Mindflayer:
			mindflayerColor = color;
			break;
		case EnemyType.Schism:
			schismColor = color;
			break;
		case EnemyType.Sisyphus:
			sisyphusColor = color;
			break;
		case EnemyType.Soldier:
			shotgunnerColor = color;
			break;
		case EnemyType.Stalker:
			stalkerColor = color;
			break;
		case EnemyType.Stray:
			strayColor = color;
			break;
		case EnemyType.Streetcleaner:
			streetcleanerColor = color;
			break;
		case EnemyType.Swordsmachine:
			swordsmachineColor = color;
			break;
		case EnemyType.Turret:
			turretColor = color;
			break;
		case EnemyType.V2:
			v2Color = color;
			break;
		case EnemyType.Virtue:
			virtueColor = color;
			break;
		}
		UpdateEnemyColors();
	}

	public void SetHudColor(HudColorType hct, Color color)
	{
		switch (hct)
		{
		case HudColorType.antiHp:
			antiHpColor = color;
			break;
		case HudColorType.health:
			healthBarColor = color;
			break;
		case HudColorType.healthAfterImage:
			healthBarAfterImageColor = color;
			break;
		case HudColorType.healthText:
			healthBarTextColor = color;
			break;
		case HudColorType.overheal:
			overHealColor = color;
			break;
		case HudColorType.stamina:
			staminaColor = color;
			break;
		case HudColorType.staminaCharging:
			staminaChargingColor = color;
			break;
		case HudColorType.staminaEmpty:
			staminaEmptyColor = color;
			break;
		case HudColorType.railcannonFull:
			railcannonFullColor = color;
			break;
		case HudColorType.railcannonCharging:
			railcannonChargingColor = color;
			break;
		}
		UpdateHudColors();
	}
}



public class ColorSchemeSetter : MonoBehaviour
{
	public bool replaceDitherUserSetting;

	public float ditheringAmount;

	public bool enforceMapColorPalette;

	public Texture mapDefinedPalette;

	public bool applyOnPlayerTriggerEnter;

	public bool applyOnPlayerTriggerExit;

	public bool oneTime;

	public void Apply()
	{
		if (replaceDitherUserSetting)
		{
			Shader.SetGlobalFloat("_DitherStrength", ditheringAmount);
		}
		if (enforceMapColorPalette)
		{
			MonoSingleton<PostProcessV2_Handler>.Instance.ApplyMapColorPalette(mapDefinedPalette);
		}
		if (oneTime)
		{
			Object.Destroy(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (applyOnPlayerTriggerEnter && other.CompareTag("Player"))
		{
			Apply();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (applyOnPlayerTriggerExit && other.CompareTag("Player"))
		{
			Apply();
		}
	}
}



public class CombinedBossBar : MonoBehaviour, IEnemyHealthDetails
{
	public string fullName;

	public EnemyIdentifier[] enemies;

	public string FullName => fullName;

	public float Health => enemies.Sum((EnemyIdentifier x) => (!(x == null)) ? Mathf.Max(0f, x.Health) : 0f);

	public bool Dead => enemies.All((EnemyIdentifier x) => x == null || x.dead);

	public bool Blessed => enemies.All((EnemyIdentifier x) => x == null || x.blessed);

	private void OnEnable()
	{
		if (!TryGetComponent<BossHealthBar>(out var _))
		{
			base.gameObject.AddComponent<BossHealthBar>();
		}
	}

	public void ForceGetHealth()
	{
		if (enemies != null && enemies.Length != 0)
		{
			EnemyIdentifier[] array = enemies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ForceGetHealth();
			}
		}
	}
}



[BurstCompile]
internal struct CommandJob : IJobParticleSystemParallelFor
{
	public Matrix4x4 transform;

	public NativeArray<RaycastCommand> raycasts;

	[ReadOnly]
	public NativeArray<RaycastHit> lastFrameHits;

	public int layerMask;

	public float deltaTime;

	public bool worldSpace;

	public Vector3 center;

	public void Execute(ParticleSystemJobData jobData, int i)
	{
		ParticleSystemNativeArray4 customData = jobData.customData1;
		Vector4 vector = customData[i];
		if (worldSpace && vector == Vector4.zero)
		{
			vector = center;
		}
		int index = (int)vector.w;
		Vector3 point = lastFrameHits[index].point;
		if (point.x != 0f && point.y != 0f && point.z != 0f)
		{
			NativeArray<float> aliveTimePercent = jobData.aliveTimePercent;
			aliveTimePercent[i] = 100f;
		}
		Vector3 vector2 = transform.MultiplyPoint(vector);
		Vector3 vector3 = transform.MultiplyPoint(jobData.positions[i]);
		raycasts[i] = new RaycastCommand(vector2, math.normalize(vector3 - vector2), math.length(vector3 - vector2), layerMask);
		customData[i] = new float4(jobData.positions[i], i);
	}
}



public class ComplexSplasher : MonoBehaviour
{
	[SerializeField]
	private ParticleCluster splashParticles;

	[SerializeField]
	private float maxSplashDistance = 80f;

	[SerializeField]
	private float keepAliveFor = 3f;

	private List<SplashingElement> children;

	private Dictionary<ParticleCluster, TimeSince> currentSplashes;

	private int splashElementIndex;

	private void Awake()
	{
		children = new List<SplashingElement>();
		currentSplashes = new Dictionary<ParticleCluster, TimeSince>();
		SplashingElement previousElement = null;
		SplashingElement[] componentsInChildren = GetComponentsInChildren<SplashingElement>();
		foreach (SplashingElement splashingElement in componentsInChildren)
		{
			children.Add(splashingElement);
			splashingElement.previousElement = previousElement;
			previousElement = splashingElement;
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (children != null)
		{
			Gizmos.color = Color.red;
			for (int i = 0; i < children.Count && i + 1 < children.Count; i++)
			{
				SplashingElement splashingElement = children[i];
				SplashingElement splashingElement2 = children[i + 1];
				Gizmos.color = ((children[i].isSplashing || children[i + 1].isSplashing) ? Color.green : Color.red);
				Gizmos.DrawLine(splashingElement.transform.position, splashingElement2.transform.position);
			}
		}
	}

	private void FixedUpdate()
	{
		List<ParticleCluster> list = new List<ParticleCluster>();
		foreach (KeyValuePair<ParticleCluster, TimeSince> currentSplash in currentSplashes)
		{
			if ((float)currentSplash.Value > keepAliveFor)
			{
				list.Add(currentSplash.Key);
			}
			currentSplash.Key.EmissionOff();
		}
		list.ForEach(delegate(ParticleCluster x)
		{
			Object.Destroy(x.gameObject);
			currentSplashes.Remove(x);
		});
		foreach (SplashingElement child in children)
		{
			if (!child.isSplashing)
			{
				continue;
			}
			ParticleCluster particleCluster = null;
			foreach (KeyValuePair<ParticleCluster, TimeSince> currentSplash2 in currentSplashes)
			{
				if (Vector3.Distance(currentSplash2.Key.transform.position, child.splashPosition) <= maxSplashDistance)
				{
					particleCluster = currentSplash2.Key;
					currentSplashes[particleCluster] = 0f;
					break;
				}
			}
			if (particleCluster == null)
			{
				particleCluster = Object.Instantiate(splashParticles);
				particleCluster.transform.SetParent(GoreZone.ResolveGoreZone(base.transform).transform);
				currentSplashes.Add(particleCluster, 0f);
			}
			particleCluster.EmissionOn();
			particleCluster.transform.position = child.splashPosition + Vector3.up * 3f;
		}
	}
}



[DisallowMultipleComponent]
public sealed class ComponentEvents : MonoBehaviour
{
	[SerializeField]
	private UnityEvent onEnable;

	[SerializeField]
	private UnityEvent onDisable;

	private void OnEnable()
	{
		onEnable?.Invoke();
	}

	private void OnDisable()
	{
		onDisable?.Invoke();
	}
}



public static class ComponentExtensions
{
	public static T GetOrAddComponent<T>(this Component component) where T : Component
	{
		return component.gameObject.GetOrAddComponent<T>();
	}

	public static Component GetOrAddComponent(this Component component, Type componentType)
	{
		return component.gameObject.GetOrAddComponent(componentType);
	}
}



public class ComponentsDatabase : MonoSingleton<ComponentsDatabase>
{
	public HashSet<Transform> scrollers = new HashSet<Transform>();
}


public static class ConfigProperties
{
	public static class Local
	{
		public const string FrameRateLimit = "frameRateLimit";

		public const string Fullscreen = "fullscreen";

		public const string ResolutionWidth = "resolutionWidth";

		public const string ResolutionHeight = "resolutionHeight";

		public const string VSync = "vSync";

		public const string MouseSensitivity = "mouseSensitivity";

		public const string BloodEnabled = "bloodEnabled";

		public const string BloodStainChance = "bloodStainChance";

		public const string BloodStainMax = "bloodStainMax";

		public const string FreezeGore = "freezeGore";

		public const string MaxGore = "maxGore";

		public const string SimpleNailPhysics = "simpleNailPhysics";

		public const string SimpleExplosions = "simpleExplosions";

		public const string SimpleFire = "simpleFire";

		public const string SimpleSpawns = "simpleSpawns";

		public const string DisableEnvironmentParticles = "disableEnvironmentParticles";

		public const string ColorPalette = "colorPalette";

		public const string ColorPaletteTexture = "colorPaletteTexture";

		public const string CyberGrindCustomGlow = "cyberGrind.customGlow_";

		public const string CyberGrindCustomGrid = "cyberGrind.customGrid_";

		public const string CyberGrindCustomSkybox = "cyberGrind.customSkybox";

		public const string CyberGrindGlowIntensity = "cyberGrind.glowIntensity";

		public const string CyberGrindCustomPool = "cyberGrind.customPool";

		public const string CyberGrindEnabledPatterns = "cyberGrind.enabledPatterns";

		public const string LastTimePlayedYear = "lastTimePlayed.year";

		public const string LastTimePlayedMonth = "lastTimePlayed.month";

		public const string AutostartPcon = "pcon.autostart";

		public const string ForceStackTraceExtraction = "forceStackTraceExtraction";
	}

	public const string BindPrefix = "keyBinding.";

	public const string CheatPrefix = "cheat.";

	public const string CheatBindPrefix = "cheatBinding.";

	public const string ConsoleBindPrefix = "consoleBinding.";

	public const string WeaponPrefix = "weapon.";

	public const string CyberGrindPrefix = "cyberGrind.";

	public const string HudColorPrefix = "hudColor.";

	public const string EnemyColorPrefix = "enemyColor.";

	public const string GunColorPrefix = "gunColor.";

	public const string GunColorTypePrefix = "gunColorType.";

	public const string GunColorPresetPrefix = "gunColorPreset.";

	public const string LastTimePlayedPrefix = "lastTimePlayed.";

	public const string OrderPostfix = ".order";

	public const string RumbleIntensityPostfix = ".intensity";

	public const string RumbleDurationPostfix = ".duration";

	public const string TotalRumbleIntensity = "totalRumbleIntensity";

	public const string ScrollEnabled = "scrollEnabled";

	public const string ScrollReversed = "scrollReversed";

	public const string ScrollWeapons = "scrollWeapons";

	public const string ScrollVariations = "scrollVariations";

	public const string MouseReverseX = "mouseReverseX";

	public const string MouseReverseY = "mouseReverseY";

	public const string FieldOfView = "fieldOfView";

	public const string DiscordIntegration = "discordIntegration";

	public const string LevelLeaderboards = "levelLeaderboards";

	public const string SubtitlesEnabled = "subtitlesEnabled";

	public const string SeasonalEvents = "seasonalEvents";

	public const string IconPack = "iconPack";

	public const string Difficulty = "difficulty";

	public const string CyberGrindStartingWave = "cyberGrind.startingWave";

	public const string CyberGrindTheme = "cyberGrind.theme";

	public const string AgonyLocalSortMode = "agonyLocalSortMode";

	public const string AgonyWorkshopTab = "agonyWorkshopTab";

	public const string MajorAssist = "majorAssist";

	public const string GameSpeed = "gameSpeed";

	public const string DamageTaken = "damageTaken";

	public const string InfiniteStamina = "infiniteStamina";

	public const string DisableWhiplashHardDamage = "disableWhiplashHardDamage";

	public const string DisableHardDamage = "disableHardDamage";

	public const string DisableWeaponFreshness = "disableWeaponFreshness";

	public const string AutoAim = "autoAim";

	public const string AutoAimAmount = "autoAimAmount";

	public const string BossDifficultyOverride = "bossDifficultyOverride";

	public const string HideMajorAssistPopup = "hideMajorAssistPopup";

	public const string HideSuperChargePopup = "hideSuperChargePopup";

	public const string HideShopTutorial = "hideShotgunPopup";

	public const string SecretMissionPopup = "secretMissionPopup";

	public const string SFXVolume = "sfxVolume";

	public const string MusicVolume = "musicVolume";

	public const string AllVolume = "allVolume";

	public const string MuffleMusic = "muffleMusic";

	public const string ScreenShake = "screenShake";

	public const string CameraTilt = "cameraTilt";

	public const string Gamma = "gamma";

	public const string ParryFlash = "parryFlash";

	public const string Pixelization = "pixelization";

	public const string TextureWarping = "textureWarping";

	public const string VertexWarping = "vertexWarping";

	public const string ColorCompression = "colorCompression";

	public const string Dithering = "dithering";

	public const string SimplifyEnemies = "simplifyEnemies";

	public const string EnemyOutlinesOnly = "enemyOutlinesOnly";

	public const string SimplifyEnemiesDistance = "simplifyEnemiesDistance";

	public const string OutlineThickness = "outlineThickness";

	public const string CrossHair = "crossHair";

	public const string CrossHairColor = "crossHairColor";

	public const string CrossHairHud = "crossHairHud";

	public const string HudType = "hudType";

	public const string HudBackgroundOpacity = "hudBackgroundOpacity";

	public const string HudAlwaysOnTop = "hudAlwaysOnTop";

	public const string Speedometer = "speedometer";

	public const string WeaponIcons = "weaponIcons";

	public const string ArmIcons = "armIcons";

	public const string RailcannonMeter = "railcannonMeter";

	public const string StyleMeter = "styleMeter";

	public const string StyleInfo = "styleInfo";

	public const string CrossHairHudFade = "crossHairHudFade";

	public const string PowerUpMeter = "powerUpMeter";

	public const string WeaponHoldPosition = "weaponHoldPosition";

	public const string PauseMenuConfirmationDialogs = "pauseMenuConfirmationDialogs";

	public const string SandboxSaveOverwriteWarnings = "sandboxSaveOverwriteWarnings";

	public const string VariationMemory = "variationMemory";

	public const string SelectedSaveSlot = "selectedSaveSlot";

	public const string WeaponRedrawBehaviour = "WeaponRedrawBehaviour";
}



[BaseTypeRequired(typeof(MonoSingleton<>))]
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public sealed class ConfigureSingletonAttribute : Attribute
{
	public SingletonFlags Flags { get; }

	public ConfigureSingletonAttribute(SingletonFlags flags)
	{
		Flags = flags;
	}
}



public class ConsoleTitleBar : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
	[SerializeField]
	private ConsoleWindow consoleWindow;

	public void OnPointerDown(PointerEventData eventData)
	{
		consoleWindow.StartDrag(eventData);
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		consoleWindow.EndDrag(eventData);
	}
}



public class ConsoleWindow : MonoBehaviour
{
	private Vector2 minSize = new Vector2(520f, 480f);

	private Vector2 defaultSize;

	private RectTransform selfFrame;

	private bool isDragging;

	private Vector2 dragOffset;

	private bool isResizing;

	private Vector2 resizeCursorStart;

	private Vector2Int lastResolution;

	private Vector2 position
	{
		get
		{
			return selfFrame.anchoredPosition;
		}
		set
		{
			selfFrame.anchoredPosition = value;
		}
	}

	private Vector2 size
	{
		get
		{
			return selfFrame.sizeDelta;
		}
		set
		{
			selfFrame.sizeDelta = value;
		}
	}

	private void Awake()
	{
		selfFrame = GetComponent<RectTransform>();
		defaultSize = size;
		lastResolution = new Vector2Int(Screen.width, Screen.height);
		ResetWindow();
	}

	public void ResetWindow()
	{
		size = new Vector2(Mathf.Min(defaultSize.x, Screen.width), Mathf.Min(defaultSize.y, Screen.height));
		position = new Vector2((float)Screen.width / 2f - size.x / 2f, (float)(-Screen.height) / 2f + size.y / 2f);
	}

	private void Update()
	{
		if (isResizing)
		{
			Vector2 vector = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
			Vector2 vector2 = vector - resizeCursorStart;
			vector2.y = 0f - vector2.y;
			size = new Vector2(Mathf.Max(minSize.x, size.x + vector2.x), Mathf.Max(minSize.y, size.y + vector2.y));
			if (position.x + size.x > (float)Screen.width)
			{
				size = new Vector2((float)Screen.width - position.x, size.y);
			}
			if (size.y - position.y > (float)Screen.height)
			{
				size = new Vector2(size.x, (float)Screen.height + position.y);
			}
			resizeCursorStart = vector;
		}
		if (isDragging)
		{
			Vector2 vector3 = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
			Vector2 vector4 = vector3 - dragOffset;
			if (position.x + vector4.x < 0f)
			{
				vector4.x = 0f;
				position = new Vector2(0f, position.y);
			}
			else if (position.x + vector4.x > (float)Screen.width - size.x)
			{
				vector4.x = 0f;
				position = new Vector2((float)Screen.width - size.x, position.y);
			}
			if (position.y + vector4.y > 0f)
			{
				vector4.y = 0f;
				position = new Vector2(position.x, 0f);
			}
			else if (position.y + vector4.y < (float)(-Screen.height) + size.y)
			{
				vector4.y = 0f;
				position = new Vector2(position.x, (float)(-Screen.height) + size.y);
			}
			position += vector4;
			dragOffset = vector3;
		}
		if (lastResolution.x != Screen.width || lastResolution.y != Screen.height)
		{
			Debug.Log("Screen resolution changed, resetting console position");
			lastResolution = new Vector2Int(Screen.width, Screen.height);
			ResetWindow();
		}
	}

	public void StartDrag(PointerEventData eventData)
	{
		isDragging = true;
		dragOffset = eventData.position;
	}

	public void EndDrag(PointerEventData eventData)
	{
		isDragging = false;
	}

	public void StartResize(PointerEventData eventData, Vector2Int corner)
	{
		isResizing = true;
		resizeCursorStart = eventData.position;
	}

	public void StopResize(PointerEventData eventData, Vector2Int corner)
	{
		isResizing = false;
	}
}



public class ConsoleWindowCorner : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler
{
	[SerializeField]
	private ConsoleWindow consoleWindow;

	[SerializeField]
	private GameObject feedbackIcon;

	[SerializeField]
	private Vector2Int corner = new Vector2Int(0, 0);

	private bool dragging;

	private bool hovering;

	public void OnPointerDown(PointerEventData eventData)
	{
		consoleWindow.StartResize(eventData, corner);
		dragging = true;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		consoleWindow.StopResize(eventData, corner);
		dragging = false;
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		hovering = true;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		hovering = false;
	}

	private void Update()
	{
		feedbackIcon.SetActive(dragging || hovering);
	}
}



public static class Consts
{
	public const bool STEAM_SUPPORTED = true;

	public const bool DISCORD_SUPPORTED = true;

	public const bool LEADERBOARDS_SUPPORTED = true;

	public const bool UNITY_MANAGED_SAVES = false;

	public const bool ENSURE_NO_FREEZE = false;

	public const bool AGONY_BUILD = false;

	public const bool AMAZON_LUNA_BUILD = false;

	public static bool CONSOLE_ERROR_BADGE => Debug.isDebugBuild;
}



public class ContinuousBeam : MonoBehaviour
{
	public EnemyTarget target;

	private LineRenderer lr;

	private LayerMask environmentMask;

	private LayerMask hitMask;

	public bool canHitPlayer = true;

	public bool canHitEnemy = true;

	public bool ignoreInvincibility;

	public float beamWidth = 0.35f;

	public bool enemy;

	public EnemyType safeEnemyType;

	public float damage;

	private float playerCooldown;

	private List<EnemyIdentifier> hitEnemies = new List<EnemyIdentifier>();

	private List<float> enemyCooldowns = new List<float>();

	public GameObject impactEffect;

	private void Start()
	{
		lr = GetComponent<LineRenderer>();
		environmentMask = (int)environmentMask | 0x100;
		environmentMask = (int)environmentMask | 0x800;
		environmentMask = (int)environmentMask | 0x1000000;
		hitMask = (int)hitMask | (int)environmentMask;
		hitMask = (int)hitMask | 0x400;
		hitMask = (int)hitMask | 4;
		if (ignoreInvincibility)
		{
			hitMask = (int)hitMask | 0x8000;
		}
	}

	private void Update()
	{
		Vector3 zero = Vector3.zero;
		zero = ((!Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, float.PositiveInfinity, environmentMask)) ? (base.transform.position + base.transform.forward * 999f) : hitInfo.point);
		lr.SetPosition(0, base.transform.position);
		lr.SetPosition(1, zero);
		if ((bool)impactEffect)
		{
			impactEffect.transform.position = zero;
		}
		RaycastHit[] array = Physics.SphereCastAll(base.transform.position + base.transform.forward * beamWidth, beamWidth, base.transform.forward, Vector3.Distance(base.transform.position, zero) - beamWidth, hitMask);
		if (array != null && array.Length != 0)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (canHitPlayer && playerCooldown <= 0f && array[i].collider.gameObject.CompareTag("Player"))
				{
					playerCooldown = 0.5f;
					if (!Physics.Raycast(base.transform.position, array[i].point - base.transform.position, array[i].distance, environmentMask))
					{
						MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(damage), invincible: true, 1f, explosion: false, instablack: false, 0.35f, ignoreInvincibility: true);
					}
				}
				else if ((array[i].transform.gameObject.layer == 10 || array[i].transform.gameObject.layer == 11) && canHitEnemy)
				{
					EnemyIdentifierIdentifier component = array[i].transform.GetComponent<EnemyIdentifierIdentifier>();
					if (!component || !component.eid || (enemy && (component.eid.enemyType == safeEnemyType || component.eid.immuneToFriendlyFire || EnemyIdentifier.CheckHurtException(safeEnemyType, component.eid.enemyType, target))))
					{
						continue;
					}
					EnemyIdentifier eid = component.eid;
					bool flag = false;
					if (hitEnemies.Contains(eid))
					{
						Debug.Log("hit hit hit");
						flag = true;
					}
					if (!flag || enemyCooldowns[hitEnemies.IndexOf(eid)] <= 0f)
					{
						if (!flag)
						{
							hitEnemies.Add(eid);
							enemyCooldowns.Add(0.5f);
						}
						else
						{
							enemyCooldowns[hitEnemies.IndexOf(eid)] = 0.5f;
						}
						if (enemy)
						{
							eid.hitter = "enemy";
						}
						eid.DeliverDamage(array[i].transform.gameObject, (zero - base.transform.position).normalized * 1000f, array[i].point, damage / 10f, tryForExplode: true);
					}
				}
				else if (array[i].transform.gameObject.layer == 8 || array[i].transform.gameObject.layer == 24)
				{
					Breakable component2 = array[i].transform.GetComponent<Breakable>();
					if ((bool)component2 && !component2.playerOnly && !component2.precisionOnly)
					{
						component2.Break();
					}
					if (array[i].transform.gameObject.TryGetComponent<Bleeder>(out var component3))
					{
						component3.GetHit(array[i].point, GoreType.Small);
					}
				}
			}
		}
		if (playerCooldown > 0f)
		{
			playerCooldown = Mathf.MoveTowards(playerCooldown, 0f, Time.deltaTime);
		}
		if (enemyCooldowns.Count > 0)
		{
			for (int j = 0; j < enemyCooldowns.Count; j++)
			{
				enemyCooldowns[j] = Mathf.MoveTowards(enemyCooldowns[j], 0f, Time.deltaTime);
			}
		}
	}
}



public class ControllerBandaidFor2S : MonoBehaviour
{
	public bool a;

	public bool b;

	public bool x;

	public bool y;

	private void Update()
	{
		if (Gamepad.current != null && !(MonoSingleton<OptionsManager>.Instance == null) && !MonoSingleton<OptionsManager>.Instance.paused)
		{
			if (a && Gamepad.current.aButton.wasPressedThisFrame)
			{
				Activate();
			}
			else if (b && Gamepad.current.bButton.wasPressedThisFrame)
			{
				Activate();
			}
			else if (y && Gamepad.current.yButton.wasPressedThisFrame)
			{
				Activate();
			}
			else if (x && Gamepad.current.xButton.wasPressedThisFrame)
			{
				Activate();
			}
		}
	}

	private void Activate()
	{
		Button componentInParent = GetComponentInParent<Button>();
		if ((bool)componentInParent && componentInParent.interactable && componentInParent.gameObject.activeInHierarchy)
		{
			componentInParent.onClick.Invoke();
		}
	}
}



[DisallowMultipleComponent]
public sealed class ControllerColliderHitMessage : MessageDispatcher<ControllerColliderHit>.Callback<UnityEventControllerColliderHit>
{
	private void OnControllerColliderHit(ControllerColliderHit collision)
	{
		Handler.Invoke(collision);
	}
}



[DisallowMultipleComponent]
internal class ControllerPointer : MonoBehaviour
{
	private static RaycastResult? bestResult;

	private PointerEventData eventData;

	private static int ignoreFrame;

	[SerializeField]
	private UnityEvent onPressed;

	[SerializeField]
	private UnityEvent onReleased;

	[SerializeField]
	private UnityEvent onEnter;

	[SerializeField]
	private UnityEvent onExit;

	[SerializeField]
	private float dragThreshold;

	private bool entered;

	private bool pointerDown;

	private bool scrollState;

	public static GraphicRaycaster raycaster;

	private List<RaycastResult> results;

	private Vector2? dragPoint;

	private bool dragging;

	public UnityEvent OnPressed => onPressed;

	public UnityEvent OnReleased => onReleased;

	public UnityEvent OnEnter => onEnter;

	public UnityEvent OnExit => onExit;

	private void Awake()
	{
		if (onPressed == null)
		{
			onPressed = new UnityEvent();
		}
		if (onReleased == null)
		{
			onReleased = new UnityEvent();
		}
		if (onEnter == null)
		{
			onEnter = new UnityEvent();
		}
		if (onExit == null)
		{
			onExit = new UnityEvent();
		}
		results = new List<RaycastResult>();
	}

	private void UpdateSlider()
	{
		if (!TryGetComponent<Slider>(out var component))
		{
			return;
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 screenPoint = new Vector2(Screen.width, Screen.height) / 2f;
			Rect rect = component2.rect;
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(component2, screenPoint, raycaster.eventCamera, out var localPoint))
			{
				if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && rect.Contains(localPoint))
				{
					scrollState = true;
				}
				else if (!scrollState)
				{
					return;
				}
				float num = Mathf.InverseLerp(rect.x, rect.x + rect.width, localPoint.x);
				component.value = component.minValue + num * (component.maxValue - component.minValue);
			}
		}
		else
		{
			scrollState = false;
		}
	}

	private void UpdateScrollbars()
	{
		if (!TryGetComponent<ScrollRect>(out var component))
		{
			return;
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			if (component.horizontal)
			{
				UpdateScrollbar(component.horizontalScrollbar);
			}
			if (component.vertical)
			{
				UpdateScrollbar(component.verticalScrollbar);
			}
		}
		else
		{
			scrollState = false;
		}
		RectTransform content = component.content;
		Vector2 screenPoint = new Vector2(Screen.width, Screen.height) / 2f;
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(content, screenPoint, raycaster.eventCamera, out var localPoint) && content.rect.Contains(localPoint))
		{
			if (component.horizontal)
			{
				component.horizontalScrollbar.value += Mouse.current.scroll.x.ReadValue() / 2f / content.rect.height;
			}
			if (component.vertical)
			{
				component.verticalScrollbar.value += Mouse.current.scroll.y.ReadValue() / 2f / content.rect.height;
			}
		}
	}

	private void UpdateScrollbar(Scrollbar scroll)
	{
		RectTransform component = scroll.GetComponent<RectTransform>();
		Vector2 screenPoint = new Vector2(Screen.width, Screen.height) / 2f;
		Rect rect = component.rect;
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(component, screenPoint, raycaster.eventCamera, out var localPoint))
		{
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && rect.Contains(localPoint))
			{
				scrollState = true;
			}
			else if (!scrollState)
			{
				return;
			}
			switch (scroll.direction)
			{
			case Scrollbar.Direction.BottomToTop:
				scroll.value = Mathf.InverseLerp(rect.y, rect.y + rect.height, localPoint.y);
				break;
			case Scrollbar.Direction.LeftToRight:
				scroll.value = Mathf.InverseLerp(rect.x, rect.x + rect.width, localPoint.x);
				break;
			case Scrollbar.Direction.TopToBottom:
				scroll.value = Mathf.InverseLerp(rect.y + rect.height, rect.y, localPoint.y);
				break;
			case Scrollbar.Direction.RightToLeft:
				scroll.value = Mathf.InverseLerp(rect.x + rect.width, rect.x, localPoint.x);
				break;
			}
		}
	}

	private void Update()
	{
		if (!EventSystem.current || !raycaster || !raycaster.eventCamera || ((bool)MonoSingleton<OptionsManager>.Instance && MonoSingleton<OptionsManager>.Instance.paused))
		{
			return;
		}
		eventData = new PointerEventData(EventSystem.current)
		{
			button = PointerEventData.InputButton.Left,
			position = new Vector2((float)(raycaster ? raycaster.eventCamera.pixelWidth : Screen.width) / 2f, (float)(raycaster ? raycaster.eventCamera.pixelHeight : Screen.height) / 2f)
		};
		if ((bool)raycaster && ignoreFrame != Time.frameCount)
		{
			ignoreFrame = Time.frameCount;
			bestResult = null;
			results.Clear();
			raycaster.Raycast(eventData, results);
			foreach (RaycastResult result in results)
			{
				if (!result.gameObject.TryGetComponent<Text>(out var _) && (!bestResult.HasValue || bestResult.Value.depth <= result.depth))
				{
					bestResult = result;
				}
			}
		}
		UpdateEvents();
		UpdateSlider();
		UpdateScrollbars();
	}

	private void UpdateEvents()
	{
		if (!bestResult.HasValue)
		{
			return;
		}
		bool flag = entered;
		entered = bestResult.Value.gameObject == base.gameObject;
		if (entered && !flag)
		{
			ExecuteEvents.Execute(base.gameObject, eventData, ExecuteEvents.pointerEnterHandler);
			onEnter?.Invoke();
		}
		if (entered && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)
		{
			pointerDown = true;
			ExecuteEvents.Execute(base.gameObject, eventData, ExecuteEvents.pointerDownHandler);
			ExecuteEvents.Execute(base.gameObject, eventData, ExecuteEvents.pointerClickHandler);
			onPressed?.Invoke();
			dragPoint = eventData.position;
		}
		if (pointerDown && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasCanceledThisFrame)
		{
			pointerDown = false;
			ExecuteEvents.Execute(base.gameObject, eventData, ExecuteEvents.pointerUpHandler);
			onReleased?.Invoke();
		}
		if (flag && !entered)
		{
			ExecuteEvents.Execute(base.gameObject, eventData, ExecuteEvents.pointerExitHandler);
			onExit?.Invoke();
		}
		if (dragPoint.HasValue)
		{
			Vector2 delta = eventData.position - dragPoint.Value;
			PointerEventData pointerEventData = new PointerEventData(EventSystem.current)
			{
				button = PointerEventData.InputButton.Left,
				position = eventData.position,
				pressPosition = dragPoint.Value,
				delta = delta
			};
			if (pointerDown && entered && delta.sqrMagnitude >= dragThreshold * dragThreshold)
			{
				ExecuteEvents.Execute(base.gameObject, pointerEventData, ExecuteEvents.beginDragHandler);
				dragging = true;
			}
			if (dragging)
			{
				ExecuteEvents.Execute(base.gameObject, pointerEventData, ExecuteEvents.dragHandler);
			}
			if (!pointerDown | !entered)
			{
				dragging = false;
				dragPoint = null;
				ExecuteEvents.Execute(base.gameObject, pointerEventData, ExecuteEvents.endDragHandler);
			}
		}
	}
}



public class ControlsOptions : MonoBehaviour
{
	private InputManager inman;

	[HideInInspector]
	public OptionsManager opm;

	public List<ActionDisplayConfig> actionConfig;

	private Dictionary<Guid, ActionDisplayConfig> idConfigDict;

	public Transform actionParent;

	public GameObject actionTemplate;

	public GameObject sectionTemplate;

	public Toggle scrollWheel;

	public TMP_Dropdown variationWheel;

	public Toggle reverseWheel;

	private GameObject currentKey;

	public Color normalColor;

	public Color pressedColor;

	private bool canUnpause;

	public Selectable selectableAboveRebinds;

	private List<GameObject> rebindUIObjects = new List<GameObject>();

	public GameObject modalBackground;

	public void ShowModal()
	{
		modalBackground.SetActive(value: true);
	}

	public void HideModal()
	{
		modalBackground.SetActive(value: false);
	}

	private void Awake()
	{
		inman = MonoSingleton<InputManager>.Instance;
		opm = MonoSingleton<OptionsManager>.Instance;
		idConfigDict = actionConfig.ToDictionary((ActionDisplayConfig config) => config.actionRef.action.id);
	}

	private void Start()
	{
		scrollWheel.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("scrollEnabled");
		bool @bool = MonoSingleton<PrefsManager>.Instance.GetBool("scrollVariations");
		bool bool2 = MonoSingleton<PrefsManager>.Instance.GetBool("scrollWeapons");
		if (@bool && bool2)
		{
			variationWheel.value = 2;
		}
		else if (@bool)
		{
			variationWheel.value = 1;
		}
		else
		{
			variationWheel.value = 0;
		}
		reverseWheel.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("scrollReversed");
	}

	private void OnEnable()
	{
		Rebuild(MonoSingleton<InputManager>.Instance.InputSource.Actions.KeyboardMouseScheme);
		InputManager instance = MonoSingleton<InputManager>.Instance;
		instance.actionModified = (Action<InputAction>)Delegate.Combine(instance.actionModified, new Action<InputAction>(OnActionChanged));
	}

	private void OnDisable()
	{
		if (currentKey != null)
		{
			if (opm == null)
			{
				opm = MonoSingleton<OptionsManager>.Instance;
			}
			currentKey.GetComponent<Image>().color = normalColor;
			currentKey = null;
			if ((bool)opm)
			{
				opm.dontUnpause = false;
			}
		}
		if ((bool)MonoSingleton<InputManager>.Instance)
		{
			InputManager instance = MonoSingleton<InputManager>.Instance;
			instance.actionModified = (Action<InputAction>)Delegate.Remove(instance.actionModified, new Action<InputAction>(OnActionChanged));
		}
	}

	public void OnActionChanged(InputAction action)
	{
		Rebuild(MonoSingleton<InputManager>.Instance.InputSource.Actions.KeyboardMouseScheme);
	}

	public void ResetToDefault()
	{
		inman.ResetToDefault();
	}

	private void Rebuild(InputControlScheme controlScheme)
	{
		MonoSingleton<InputManager>.Instance.InputSource.ValidateBindings(MonoSingleton<InputManager>.Instance.InputSource.Actions.KeyboardMouseScheme);
		foreach (GameObject rebindUIObject in rebindUIObjects)
		{
			UnityEngine.Object.Destroy(rebindUIObject);
		}
		rebindUIObjects.Clear();
		InputActionMap[] obj = new InputActionMap[4]
		{
			inman.InputSource.Actions.Movement,
			inman.InputSource.Actions.Weapon,
			inman.InputSource.Actions.Fist,
			inman.InputSource.Actions.HUD
		};
		Selectable selectable = selectableAboveRebinds;
		InputActionMap[] array = obj;
		foreach (InputActionMap inputActionMap in array)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(sectionTemplate, actionParent);
			gameObject.GetComponent<TextMeshProUGUI>().text = "-- " + inputActionMap.name.ToUpper() + " --";
			gameObject.SetActive(value: true);
			rebindUIObjects.Add(gameObject);
			foreach (InputAction item in inputActionMap)
			{
				if ((item.expectedControlType != "Button" && item.expectedControlType != "Vector2") || item == inman.InputSource.Look.Action || item == inman.InputSource.WheelLook.Action)
				{
					continue;
				}
				bool flag = true;
				if (idConfigDict.TryGetValue(item.id, out var value))
				{
					if (value.hidden)
					{
						continue;
					}
					if (!string.IsNullOrEmpty(value.requiredWeapon) && GameProgressSaver.CheckGear(value.requiredWeapon) == 0)
					{
						flag = false;
					}
				}
				GameObject gameObject2 = UnityEngine.Object.Instantiate(actionTemplate, actionParent);
				ControlsOptionsKey component = gameObject2.GetComponent<ControlsOptionsKey>();
				Navigation navigation = selectable.navigation;
				navigation.mode = Navigation.Mode.Explicit;
				navigation.selectOnDown = component.selectable;
				selectable.navigation = navigation;
				Navigation navigation2 = component.selectable.navigation;
				navigation2.mode = Navigation.Mode.Explicit;
				navigation2.selectOnUp = selectable;
				component.selectable.navigation = navigation2;
				component.actionText.text = (flag ? item.name.ToUpper() : "???");
				component.RebuildBindings(item, controlScheme);
				rebindUIObjects.Add(gameObject2);
				gameObject2.SetActive(value: true);
				selectable = component.selectable;
			}
		}
	}

	private void LateUpdate()
	{
		if (canUnpause)
		{
			if (opm == null)
			{
				opm = MonoSingleton<OptionsManager>.Instance;
			}
			canUnpause = false;
			opm.dontUnpause = false;
		}
	}

	public void ScrollOn(bool stuff)
	{
		if (inman == null)
		{
			inman = MonoSingleton<InputManager>.Instance;
		}
		if (stuff)
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollEnabled", content: true);
			inman.ScrOn = true;
		}
		else
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollEnabled", content: false);
			inman.ScrOn = false;
		}
	}

	public void ScrollVariations(int stuff)
	{
		if (inman == null)
		{
			inman = MonoSingleton<InputManager>.Instance;
		}
		switch (stuff)
		{
		case 0:
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollWeapons", content: true);
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollVariations", content: false);
			inman.ScrWep = true;
			inman.ScrVar = false;
			break;
		case 1:
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollWeapons", content: false);
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollVariations", content: true);
			inman.ScrWep = false;
			inman.ScrVar = true;
			break;
		default:
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollWeapons", content: true);
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollVariations", content: true);
			inman.ScrWep = true;
			inman.ScrVar = true;
			break;
		}
	}

	public void ScrollReverse(bool stuff)
	{
		if (inman == null)
		{
			inman = MonoSingleton<InputManager>.Instance;
		}
		if (stuff)
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollReversed", content: true);
			inman.ScrRev = true;
		}
		else
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("scrollReversed", content: false);
			inman.ScrRev = false;
		}
	}
}



public class ControlsOptionsKey : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
{
	public TextMeshProUGUI actionText;

	public Button restoreDefaultsButton;

	public GameObject bindingButtonTemplate;

	public Transform bindingButtonParent;

	public Selectable selectable;

	private List<Button> bindingButtons = new List<Button>();

	private bool selected;

	private readonly Color faintTextColor = new Color(1f, 1f, 1f, 0.15f);

	public void OnSelect(BaseEventData eventData)
	{
		selected = true;
	}

	public void OnDeselect(BaseEventData eventData)
	{
		selected = false;
	}

	private void SubmitPressed(InputAction.CallbackContext ctx)
	{
		if (selected && bindingButtons.Count > 0)
		{
			bindingButtons[0].Select();
		}
	}

	private void OnEnable()
	{
		MonoSingleton<InputManager>.Instance.InputSource.Actions.UI.Submit.performed += SubmitPressed;
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<InputManager>.Instance)
		{
			MonoSingleton<InputManager>.Instance.InputSource.Actions.UI.Submit.performed -= SubmitPressed;
		}
	}

	public void RebuildBindings(InputAction action, InputControlScheme controlScheme)
	{
		foreach (Button bindingButton in bindingButtons)
		{
			Object.Destroy(bindingButton.gameObject);
		}
		bindingButtons.Clear();
		int num = 0;
		int[] bindingsWithGroup = action.GetBindingsWithGroup(controlScheme.bindingGroup);
		foreach (int num2 in bindingsWithGroup)
		{
			InputBinding binding = action.bindings[num2];
			num++;
			string bindingDisplayStringWithoutOverride = action.GetBindingDisplayStringWithoutOverride(binding, InputBinding.DisplayStringOptions.DontIncludeInteractions);
			(Button, TextMeshProUGUI, Image, TooltipOnHover) tuple = BuildBindingButton(bindingDisplayStringWithoutOverride);
			Button item = tuple.Item1;
			TextMeshProUGUI txt = tuple.Item2;
			Image img = tuple.Item3;
			TooltipOnHover item2 = tuple.Item4;
			string text = txt.text + "<br>";
			bool flag = false;
			if (binding.isComposite)
			{
				InputActionSetupExtensions.BindingSyntax bindingSyntax = action.ChangeBinding(binding).NextBinding();
				HashSet<string> hashSet = new HashSet<string>();
				while (bindingSyntax.valid && bindingSyntax.binding.isPartOfComposite)
				{
					InputBinding[] conflicts = MonoSingleton<InputManager>.Instance.InputSource.GetConflicts(bindingSyntax.binding);
					if (conflicts.Length != 0 && !hashSet.Contains(bindingSyntax.binding.path))
					{
						flag = true;
						text = text + "<br>" + GenerateTooltip(action, bindingSyntax.binding, conflicts);
						hashSet.Add(bindingSyntax.binding.path);
					}
					bindingSyntax = bindingSyntax.NextBinding();
				}
			}
			else
			{
				InputBinding[] conflicts2 = MonoSingleton<InputManager>.Instance.InputSource.GetConflicts(binding);
				if (conflicts2.Length != 0)
				{
					flag = true;
					text = text + "<br>" + GenerateTooltip(action, binding, conflicts2);
				}
			}
			item2.text = text;
			item2.enabled = true;
			if (flag)
			{
				txt.color = Color.red;
			}
			int index = num2;
			item.onClick.AddListener(delegate
			{
				_ = img.color;
				img.color = Color.red;
				if (binding.isComposite)
				{
					MonoSingleton<InputManager>.Instance.RebindComposite(action, index, delegate(string part)
					{
						txt.text = "PRESS " + part.ToUpper();
					}, delegate
					{
						RebuildBindings(action, controlScheme);
					}, delegate
					{
						action.ChangeBinding(index).Erase();
						MonoSingleton<InputManager>.Instance.actionModified?.Invoke(action);
					}, controlScheme);
				}
				else
				{
					MonoSingleton<InputManager>.Instance.Rebind(action, index, delegate
					{
						RebuildBindings(action, controlScheme);
					}, delegate
					{
						action.ChangeBinding(index).Erase();
						MonoSingleton<InputManager>.Instance.actionModified?.Invoke(action);
					}, controlScheme);
				}
			});
		}
		if (num < 4)
		{
			var (button, txt, img) = BuildNewBindButton();
			button.onClick.AddListener(delegate
			{
				img.color = Color.red;
				txt.color = Color.white;
				txt.text = "...";
				if (action.expectedControlType == "Button")
				{
					MonoSingleton<InputManager>.Instance.Rebind(action, null, delegate
					{
						RebuildBindings(action, controlScheme);
					}, delegate
					{
						RebuildBindings(action, controlScheme);
					}, controlScheme);
				}
				else if (action.expectedControlType == "Vector2")
				{
					MonoSingleton<InputManager>.Instance.RebindComposite(action, null, delegate(string part)
					{
						txt.text = "PRESS " + part.ToUpper();
					}, delegate
					{
						RebuildBindings(action, controlScheme);
					}, delegate
					{
						RebuildBindings(action, controlScheme);
					}, controlScheme);
				}
			});
		}
		bool flag2 = action.IsActionEqual(MonoSingleton<InputManager>.Instance.defaultActions.FindAction(action.id), controlScheme.bindingGroup);
		restoreDefaultsButton.gameObject.SetActive(!flag2);
		restoreDefaultsButton.onClick.RemoveAllListeners();
		restoreDefaultsButton.onClick.AddListener(delegate
		{
			MonoSingleton<InputManager>.Instance.ResetToDefault(action, controlScheme);
			RebuildBindings(action, controlScheme);
		});
		Navigation navigation = selectable.navigation;
		navigation.mode = Navigation.Mode.Explicit;
		navigation.selectOnRight = bindingButtons[0];
		selectable.navigation = navigation;
	}

	private (Button, TextMeshProUGUI, Image) BuildNewBindButton()
	{
		(Button, TextMeshProUGUI, Image, TooltipOnHover) tuple = BuildBindingButton("+");
		Button item = tuple.Item1;
		TextMeshProUGUI item2 = tuple.Item2;
		Image item3 = tuple.Item3;
		item2.color = faintTextColor;
		item2.fontSizeMax = 27f;
		return (item, item2, item3);
	}

	private string GenerateTooltip(InputAction action, InputBinding binding, InputBinding[] conflicts)
	{
		string text = action.GetBindingDisplayStringWithoutOverride(binding, InputBinding.DisplayStringOptions.DontIncludeInteractions).ToUpper();
		string text2 = "<color=red>" + text + " IS BOUND MULTIPLE TIMES:";
		HashSet<string> hashSet = new HashSet<string>();
		for (int i = 0; i < conflicts.Length; i++)
		{
			InputBinding inputBinding = conflicts[i];
			if (!hashSet.Contains(inputBinding.action))
			{
				text2 += "<br>";
				text2 = text2 + "- " + inputBinding.action.ToUpper();
				hashSet.Add(inputBinding.action);
			}
		}
		return text2 + "</color>";
	}

	private (Button, TextMeshProUGUI, Image, TooltipOnHover) BuildBindingButton(string text)
	{
		GameObject obj = Object.Instantiate(bindingButtonTemplate, bindingButtonParent);
		TextMeshProUGUI componentInChildren = obj.GetComponentInChildren<TextMeshProUGUI>();
		Button component = obj.GetComponent<Button>();
		Image component2 = obj.GetComponent<Image>();
		TooltipOnHover component3 = obj.GetComponent<TooltipOnHover>();
		componentInChildren.text = text;
		bindingButtons.Add(component);
		obj.SetActive(value: true);
		return (component, componentInChildren, component2, component3);
	}
}



[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class ConvertPaletteToLUT : MonoSingleton<ConvertPaletteToLUT>
{
	public RenderTexture processedLUT;

	public RenderTexture lastLUT;

	public Texture2D lastPalette;

	private IEnumerator coroutine;

	public void ApplyLastPalette()
	{
		MonoBehaviour.print("reached");
		Shader.EnableKeyword("PALETTIZE");
		Shader.SetGlobalInt("_ColorPrecision", 2048);
		if (coroutine != null)
		{
			Shader.SetGlobalTexture("_LUT", processedLUT);
		}
	}

	public void ConvertPalette(Texture2D inputPalette, Material conversionMaterial)
	{
		if (!processedLUT)
		{
			processedLUT = new RenderTexture(4096, 4096, 0, RenderTextureFormat.ARGB32, 0);
		}
		Shader.SetGlobalTexture("_LUT", processedLUT);
		bool flag = true;
		if ((bool)lastPalette)
		{
			flag = lastPalette.name != inputPalette.name;
		}
		if (flag)
		{
			if (coroutine != null)
			{
				StopCoroutine(coroutine);
			}
			lastPalette = inputPalette;
			conversionMaterial.SetTexture("_Palette", inputPalette);
			lastLUT = new RenderTexture(processedLUT);
			processedLUT.antiAliasing = 1;
			processedLUT.filterMode = FilterMode.Point;
			lastLUT.antiAliasing = 1;
			lastLUT.filterMode = FilterMode.Point;
			coroutine = paletteToLUT(conversionMaterial);
			StartCoroutine(coroutine);
		}
	}

	private IEnumerator paletteToLUT(Material conversionMaterial)
	{
		int progress = 0;
		while (progress < 33)
		{
			conversionMaterial.SetInt("progress", progress);
			conversionMaterial.SetTexture("_LastLUT", lastLUT);
			Graphics.Blit(null, processedLUT, conversionMaterial);
			RenderTexture renderTexture = lastLUT;
			lastLUT = processedLUT;
			processedLUT = renderTexture;
			progress++;
			yield return null;
		}
		lastLUT.Release();
		Object.Destroy(lastLUT);
		Shader.SetGlobalTexture("_LUT", processedLUT);
		coroutine = null;
	}
}



public class CopyAndEnableGameObject : MonoBehaviour
{
	public GameObject target;

	public bool onEnable;

	private void Start()
	{
		if (onEnable)
		{
			Activate();
		}
	}

	public void Activate()
	{
		GameObject gameObject = Object.Instantiate(target, target.transform.position, target.transform.rotation);
		if ((bool)target.transform.parent)
		{
			gameObject.transform.SetParent(target.transform.parent, worldPositionStays: true);
		}
		gameObject.SetActive(value: true);
	}
}



public class CopyColor : MonoBehaviour
{
	private Image img;

	public Image target;

	private void Start()
	{
		img = GetComponent<Image>();
	}

	private void Update()
	{
		if ((bool)img && (bool)target)
		{
			img.color = target.color;
		}
	}
}



public class CopyImage : MonoBehaviour
{
	private Image img;

	public Image imgToCopy;

	public CopyType copyType;

	public bool copyColor;

	private void Update()
	{
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		if (imgToCopy == null && copyType != 0 && MonoSingleton<WeaponHUD>.Instance != null)
		{
			if (copyType == CopyType.WeaponIcon)
			{
				imgToCopy = MonoSingleton<WeaponHUD>.Instance.GetComponent<Image>();
			}
			else if (copyType == CopyType.WeaponShadow)
			{
				imgToCopy = MonoSingleton<WeaponHUD>.Instance.transform.GetChild(0).GetComponent<Image>();
			}
		}
		if (imgToCopy != null)
		{
			img.sprite = imgToCopy.sprite;
			if (copyColor)
			{
				img.color = imgToCopy.color;
			}
		}
	}
}



public class CopyLineRenderer : MonoBehaviour
{
	private LineRenderer toCopy;

	private LineRenderer lr;

	private float origWidth;

	private void Start()
	{
		lr = GetComponent<LineRenderer>();
		toCopy = base.transform.parent.GetComponentInParent<LineRenderer>();
		origWidth = lr.widthMultiplier;
	}

	private void Update()
	{
		for (int i = 0; i < toCopy.positionCount; i++)
		{
			lr.SetPosition(i, toCopy.GetPosition(i));
		}
		lr.widthMultiplier = toCopy.widthMultiplier * origWidth;
	}
}



[DefaultExecutionOrder(int.MinValue)]
public sealed class CopyPositionAndRotation : MonoBehaviour
{
	[SerializeField]
	[FormerlySerializedAs("target")]
	private Transform m_Target;

	[SerializeField]
	[FormerlySerializedAs("copyRotation")]
	private bool m_CopyRotation = true;

	[SerializeField]
	[FormerlySerializedAs("copyPosition")]
	private bool m_CopyPosition = true;

	public Transform target
	{
		get
		{
			return m_Target;
		}
		set
		{
			m_Target = value;
		}
	}

	public bool copyRotation
	{
		get
		{
			return m_CopyRotation;
		}
		set
		{
			m_CopyRotation = value;
		}
	}

	public bool copyPosition
	{
		get
		{
			return m_CopyPosition;
		}
		set
		{
			m_CopyPosition = value;
		}
	}

	private void LateUpdate()
	{
		if (m_CopyRotation)
		{
			base.transform.rotation = m_Target.rotation;
		}
		if (m_CopyPosition)
		{
			base.transform.position = m_Target.position;
		}
	}
}



public class CopySliderValue : MonoBehaviour
{
	public Slider target;

	private Slider currentSlider;

	private void Start()
	{
		currentSlider = GetComponent<Slider>();
		currentSlider.value = target.value;
	}
}



public class CopyText : MonoBehaviour
{
	private TMP_Text txt;

	public TMP_Text target;

	private void Start()
	{
		txt = GetComponent<TMP_Text>();
	}

	private void Update()
	{
		txt.text = target.text;
	}
}



public class CopyToggleValue : MonoBehaviour
{
	public Toggle target;

	private Toggle currentToggle;

	private void Start()
	{
		currentToggle = GetComponent<Toggle>();
		currentToggle.isOn = target.isOn;
	}
}


public enum CopyType
{
	None,
	WeaponIcon,
	WeaponShadow
}



public class Cork : MonoBehaviour
{
	public float wiggleTime = 2f;

	public float wiggleStrength = 1f;

	public GameObject vortex;

	public Pond tinter;

	public bool insideSuckZone;

	private Vector3 basePos;

	private float wiggleTimer;

	private Rigidbody rb;

	private Coroutine crt;

	private FloatOnWater floater;

	private bool disallowWiggle;

	private void Start()
	{
		basePos = base.transform.position;
		rb = GetComponent<Rigidbody>();
		floater = GetComponent<FloatOnWater>();
	}

	private void Update()
	{
		if (!insideSuckZone)
		{
			StopWiggle();
		}
	}

	public void StartWiggle()
	{
		if (!disallowWiggle && crt == null)
		{
			crt = StartCoroutine(Wiggle());
		}
	}

	public void StopWiggle()
	{
		if (!disallowWiggle)
		{
			base.transform.position = basePos;
			if (crt != null)
			{
				StopCoroutine(crt);
			}
			crt = null;
		}
	}

	private IEnumerator Wiggle()
	{
		wiggleTimer = 0f;
		while (wiggleTimer < wiggleTime)
		{
			base.transform.position = basePos + Random.onUnitSphere * wiggleStrength;
			wiggleTimer += Time.deltaTime;
			yield return null;
		}
		rb.isKinematic = false;
		rb.AddForce(Vector3.up);
		floater.enabled = true;
		disallowWiggle = true;
		yield return new WaitForSeconds(1f);
		vortex.SetActive(value: true);
		tinter.isDraining = true;
		Object.Destroy(this);
	}
}



public class CorrectCameraView : MonoBehaviour
{
	private Camera mainCam;

	private Camera hudCam;

	private Vector3 lastpos;

	private Quaternion lastrot;

	public Transform targetObject;

	public bool canModifyTarget = true;

	private void OnEnable()
	{
		mainCam = MonoSingleton<CameraController>.Instance.cam;
		hudCam = MonoSingleton<PostProcessV2_Handler>.Instance.hudCam;
	}

	private void OnDisable()
	{
	}

	private void LateUpdate()
	{
		if (canModifyTarget)
		{
			mainCam = MonoSingleton<CameraController>.Instance.cam;
			hudCam = MonoSingleton<PostProcessV2_Handler>.Instance.hudCam;
			Vector3 position = hudCam.WorldToScreenPoint(base.transform.position);
			position = mainCam.ScreenToWorldPoint(position);
			Quaternion rotation = Quaternion.LookRotation(base.transform.position + base.transform.forward * 4f - position);
			targetObject.SetPositionAndRotation(position, rotation);
		}
	}

	private void OnPostRenderCallback(Camera cam)
	{
		if (canModifyTarget && !(cam != mainCam))
		{
			targetObject.SetPositionAndRotation(lastpos, lastrot);
		}
	}
}



public class Countdown : MonoBehaviour
{
	public float countdownLength;

	private float time;

	public TextMeshProUGUI countdownText;

	public float decimalFontSize;

	public BossHealthBar bossbar;

	public bool invertBossBarAmount;

	public bool disableBossBarOnDisable;

	public bool paused;

	public bool resetOnEnable;

	public UltrakillEvent onZero;

	private bool done;

	private void Start()
	{
		if (time == 0f && !done)
		{
			time = countdownLength;
		}
	}

	private void OnEnable()
	{
		ResetTime();
	}

	private void OnDisable()
	{
		if ((bool)bossbar && disableBossBarOnDisable)
		{
			bossbar.secondaryBarValue = 0f;
			bossbar.secondaryBar = false;
		}
	}

	private void Update()
	{
		if (!paused)
		{
			time = Mathf.MoveTowards(time, 0f, Time.deltaTime);
		}
		if (!done && time <= 0f)
		{
			onZero?.Invoke();
			done = true;
		}
		if ((bool)countdownText)
		{
			if (decimalFontSize == 0f)
			{
				countdownText.text = time.ToString("F2");
			}
			else
			{
				int num = Mathf.FloorToInt(time % 1f * 100f);
				countdownText.text = Mathf.FloorToInt(time).ToString() + "<size=" + decimalFontSize + ((num < 10) ? ">.0" : ">.") + num.ToString();
			}
		}
		if ((bool)bossbar)
		{
			bossbar.secondaryBar = true;
			bossbar.secondaryBarValue = (invertBossBarAmount ? ((countdownLength - time) / countdownLength) : (time / countdownLength));
		}
	}

	public void PauseState(bool pause)
	{
		paused = pause;
	}

	public void ChangeTime(float newTime)
	{
		time = newTime;
	}

	public void ResetTime()
	{
		time = countdownLength;
		done = false;
	}
}



public class CrateCoin : MonoBehaviour
{
	[SerializeField]
	private GameObject getEffect;

	private bool caught;

	private float speed = 25f;

	private Vector3 startDirection;

	private void Start()
	{
		startDirection = Random.insideUnitSphere;
		speed = Random.Range(20, 35);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			caught = true;
		}
	}

	private void Update()
	{
		if (caught)
		{
			speed += Time.deltaTime * 25f;
			base.transform.position = Vector3.MoveTowards(base.transform.position, MonoSingleton<PlayerTracker>.Instance.GetPlayer().position, Time.deltaTime * speed);
			if (Vector3.Distance(base.transform.position, MonoSingleton<PlayerTracker>.Instance.GetPlayer().position) < 1f)
			{
				caught = false;
				MonoSingleton<CrateCounter>.Instance?.AddCoin();
				if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
				{
					Object.Instantiate(getEffect, base.transform.position, Quaternion.identity);
				}
				else
				{
					MonoSingleton<PlatformerMovement>.Instance.CoinGet();
				}
				Object.Destroy(base.gameObject);
			}
		}
		else
		{
			if (speed > 0f)
			{
				speed = Mathf.MoveTowards(speed, 0f, Time.deltaTime * 50f);
			}
			base.transform.position += startDirection * speed * Time.deltaTime;
		}
	}
}



public class CrateCounter : MonoSingleton<CrateCounter>
{
	public int crateAmount;

	private int currentCrates;

	private int unsavedCrates;

	[SerializeField]
	private TMP_Text display;

	private int currentCoins;

	private int savedCoins;

	private bool success;

	public UltrakillEvent onAllCratesGet;

	private void Start()
	{
		UpdateDisplay();
	}

	public void AddCrate()
	{
		currentCrates++;
		unsavedCrates++;
		UpdateDisplay();
	}

	public void AddCoin()
	{
		currentCoins++;
	}

	public void SaveStuff()
	{
		unsavedCrates = 0;
		savedCoins += currentCoins;
		currentCoins = 0;
	}

	public void CoinsToPoints()
	{
		if (savedCoins > 0)
		{
			Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
			GameProgressSaver.AddMoney(savedCoins * 100);
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=grey>TRANSACTION COMPLETE:</color> " + savedCoins + " COINS <color=orange>=></color> " + StatsManager.DivideMoney(savedCoins * 100) + "<color=orange>P</color>");
			savedCoins = 0;
		}
	}

	public void ResetUnsavedStuff()
	{
		currentCrates -= unsavedCrates;
		unsavedCrates = 0;
		currentCoins = 0;
		UpdateDisplay();
	}

	private void UpdateDisplay()
	{
		if ((bool)display)
		{
			display.text = currentCrates.ToString() + " / " + crateAmount;
		}
		if (crateAmount != 0)
		{
			if (!success && currentCrates >= crateAmount)
			{
				success = true;
				onAllCratesGet?.Invoke();
			}
			else if (success && currentCrates < crateAmount)
			{
				success = false;
				onAllCratesGet?.Revert();
			}
		}
	}
}



public class Crossfade : MonoBehaviour
{
	public bool multipleTargets;

	public AudioSource from;

	public AudioSource to;

	public AudioSource[] froms;

	public AudioSource[] tos;

	[HideInInspector]
	public float[] fromMaxVolumes;

	[HideInInspector]
	public float[] toOriginalVolumes;

	[HideInInspector]
	public float[] toMaxVolumes;

	[HideInInspector]
	public float[] toMinVolumes;

	[HideInInspector]
	public bool inProgress;

	public float time;

	private float fadeAmount;

	public bool match;

	public bool dontActivateOnStart;

	public bool oneTime;

	private bool activated;

	private bool firstTime = true;

	private void Awake()
	{
		if (!multipleTargets)
		{
			if ((bool)from)
			{
				froms = new AudioSource[1];
				froms[0] = from;
			}
			else
			{
				froms = new AudioSource[0];
			}
			if ((bool)to)
			{
				tos = new AudioSource[1];
				tos[0] = to;
			}
			else
			{
				tos = new AudioSource[0];
			}
		}
		if (fromMaxVolumes == null || fromMaxVolumes.Length == 0)
		{
			fromMaxVolumes = new float[froms.Length];
		}
		if (toOriginalVolumes == null || toOriginalVolumes.Length == 0)
		{
			toOriginalVolumes = new float[tos.Length];
		}
		if (toMaxVolumes == null || toMaxVolumes.Length == 0)
		{
			toMaxVolumes = new float[tos.Length];
		}
		if (toMinVolumes == null || toMinVolumes.Length == 0)
		{
			toMinVolumes = new float[tos.Length];
		}
		if (tos.Length != 0)
		{
			for (int i = 0; i < tos.Length; i++)
			{
				toOriginalVolumes[i] = tos[i].volume;
			}
		}
	}

	private void Start()
	{
		if (!dontActivateOnStart && !inProgress)
		{
			StartFade();
		}
	}

	private void OnEnable()
	{
		if (!dontActivateOnStart && !inProgress)
		{
			StartFade();
		}
	}

	private void Update()
	{
		if (!inProgress)
		{
			return;
		}
		fadeAmount = Mathf.MoveTowards(fadeAmount, 1f, Time.deltaTime / time);
		if (froms.Length != 0)
		{
			for (int i = 0; i < froms.Length; i++)
			{
				if (!(froms[i] == null))
				{
					froms[i].volume = Mathf.Lerp(fromMaxVolumes[i], 0f, fadeAmount);
				}
			}
		}
		if (tos.Length != 0)
		{
			for (int j = 0; j < tos.Length; j++)
			{
				if (!(tos[j] == null))
				{
					tos[j].volume = Mathf.Lerp(toMinVolumes[j], toMaxVolumes[j], fadeAmount);
				}
			}
		}
		if (fadeAmount == 1f)
		{
			StopFade();
		}
	}

	public void StartFade()
	{
		if (!activated)
		{
			activated = true;
		}
		else if (oneTime)
		{
			return;
		}
		if (froms.Length != 0)
		{
			for (int i = 0; i < froms.Length; i++)
			{
				if (froms[i] == null)
				{
					continue;
				}
				if (MonoSingleton<CrossfadeTracker>.Instance.actives.Count > 0)
				{
					for (int num = MonoSingleton<CrossfadeTracker>.Instance.actives.Count - 1; num >= 0; num--)
					{
						if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num] == null))
						{
							if (MonoSingleton<CrossfadeTracker>.Instance.actives[num].froms != null && MonoSingleton<CrossfadeTracker>.Instance.actives[num].froms.Length != 0)
							{
								for (int num2 = MonoSingleton<CrossfadeTracker>.Instance.actives[num].froms.Length - 1; num2 >= 0; num2--)
								{
									if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num].froms[num2] == null) && MonoSingleton<CrossfadeTracker>.Instance.actives[num].froms[num2] == froms[i])
									{
										MonoSingleton<CrossfadeTracker>.Instance.actives[num].StopFade();
									}
								}
							}
							if (MonoSingleton<CrossfadeTracker>.Instance.actives[num].tos != null && MonoSingleton<CrossfadeTracker>.Instance.actives[num].tos.Length != 0)
							{
								for (int num3 = MonoSingleton<CrossfadeTracker>.Instance.actives[num].tos.Length - 1; num3 >= 0; num3--)
								{
									if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num].tos[num3] == null) && MonoSingleton<CrossfadeTracker>.Instance.actives[num].tos[num3] == froms[i])
									{
										MonoSingleton<CrossfadeTracker>.Instance.actives[num].StopFade();
									}
								}
							}
						}
					}
				}
				if (fromMaxVolumes != null && fromMaxVolumes.Length != 0)
				{
					fromMaxVolumes[i] = froms[i].volume;
				}
			}
		}
		if (tos.Length != 0)
		{
			for (int j = 0; j < tos.Length; j++)
			{
				if (tos[j] == null)
				{
					continue;
				}
				if (MonoSingleton<CrossfadeTracker>.Instance.actives.Count > 0)
				{
					bool flag = false;
					for (int num4 = MonoSingleton<CrossfadeTracker>.Instance.actives.Count - 1; num4 >= 0; num4--)
					{
						if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num4] == null))
						{
							if (MonoSingleton<CrossfadeTracker>.Instance.actives[num4].froms != null && MonoSingleton<CrossfadeTracker>.Instance.actives[num4].froms.Length != 0)
							{
								for (int num5 = MonoSingleton<CrossfadeTracker>.Instance.actives[num4].froms.Length - 1; num5 >= 0; num5--)
								{
									if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num4].froms[num5] == null) && MonoSingleton<CrossfadeTracker>.Instance.actives[num4].froms[num5] == tos[j])
									{
										flag = true;
									}
								}
							}
							if (MonoSingleton<CrossfadeTracker>.Instance.actives[num4].tos != null && MonoSingleton<CrossfadeTracker>.Instance.actives[num4].tos.Length != 0)
							{
								for (int num6 = MonoSingleton<CrossfadeTracker>.Instance.actives[num4].tos.Length - 1; num6 >= 0; num6--)
								{
									if (!(MonoSingleton<CrossfadeTracker>.Instance.actives[num4].tos[num6] == null) && MonoSingleton<CrossfadeTracker>.Instance.actives[num4].tos[num6] == tos[j])
									{
										flag = true;
									}
								}
							}
							if (flag)
							{
								MonoSingleton<CrossfadeTracker>.Instance.actives[num4].StopFade();
								toMinVolumes[j] = tos[j].volume;
							}
						}
					}
					if (!flag && firstTime)
					{
						tos[j].volume = 0f;
					}
				}
				else if (firstTime)
				{
					tos[j].volume = 0f;
				}
				if (toMinVolumes != null && toMinVolumes.Length != 0)
				{
					toMinVolumes[j] = tos[j].volume;
				}
				if (toMaxVolumes != null && toMaxVolumes.Length != 0)
				{
					toMaxVolumes[j] = toOriginalVolumes[j];
				}
				if (!tos[j].isPlaying)
				{
					tos[j].Play();
				}
				if (match && froms.Length != 0)
				{
					tos[j].time = froms[0].time % tos[j].clip.length;
				}
			}
		}
		MonoSingleton<CrossfadeTracker>.Instance.actives.Add(this);
		fadeAmount = 0f;
		inProgress = true;
		firstTime = false;
	}

	public void StopFade()
	{
		if (inProgress)
		{
			inProgress = false;
			if (MonoSingleton<CrossfadeTracker>.Instance.actives.Contains(this))
			{
				MonoSingleton<CrossfadeTracker>.Instance.actives.Remove(this);
			}
		}
	}
}



public class CrossfadeTracker : MonoSingleton<CrossfadeTracker>
{
	public List<Crossfade> actives = new List<Crossfade>();
}



public class Crosshair : MonoBehaviour
{
	private int crossHairType;

	private Image mainch;

	public Image[] altchs;

	public Image[] chuds;

	public Sprite[] circles;

	public Material invertMaterial;

	private void Start()
	{
		mainch = GetComponent<Image>();
		MonoSingleton<StatsManager>.Instance.crosshair = base.gameObject;
		CheckCrossHair();
	}

	public void CheckCrossHair()
	{
		if (mainch == null)
		{
			mainch = GetComponent<Image>();
		}
		Image[] array;
		if (HideUI.Active)
		{
			mainch.enabled = false;
			array = altchs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			array = chuds;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			return;
		}
		crossHairType = MonoSingleton<PrefsManager>.Instance.GetInt("crossHair");
		switch (crossHairType)
		{
		case 0:
		{
			mainch.enabled = false;
			array = altchs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			break;
		}
		case 1:
		{
			mainch.enabled = true;
			array = altchs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			break;
		}
		case 2:
		{
			mainch.enabled = true;
			array = altchs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
			break;
		}
		}
		Color color = Color.white;
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("crossHairColor");
		switch (@int)
		{
		case 0:
		case 1:
			color = Color.white;
			break;
		case 2:
			color = Color.gray;
			break;
		case 3:
			color = Color.black;
			break;
		case 4:
			color = Color.red;
			break;
		case 5:
			color = Color.green;
			break;
		case 6:
			color = Color.blue;
			break;
		case 7:
			color = Color.cyan;
			break;
		case 8:
			color = Color.yellow;
			break;
		case 9:
			color = Color.magenta;
			break;
		}
		if (@int == 0)
		{
			mainch.material = invertMaterial;
		}
		else
		{
			mainch.material = null;
		}
		mainch.color = color;
		array = altchs;
		foreach (Image image in array)
		{
			image.color = color;
			if (@int == 0)
			{
				image.material = invertMaterial;
			}
			else
			{
				image.material = null;
			}
		}
		int int2 = MonoSingleton<PrefsManager>.Instance.GetInt("crossHairHud");
		if (int2 == 0)
		{
			array = chuds;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			return;
		}
		array = chuds;
		foreach (Image obj in array)
		{
			obj.enabled = true;
			obj.sprite = circles[int2 - 1];
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CrowdReactions : MonoSingleton<CrowdReactions>
{
	private AudioSource aud;

	public AudioClip cheer;

	public AudioClip cheerLong;

	public AudioClip aww;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	public void React(AudioClip clip)
	{
		if (aud.clip != cheerLong || !aud.isPlaying)
		{
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.clip = clip;
			aud.Play();
		}
	}
}



public class CullingOverride : MonoBehaviour
{
}



public class CustomCampaign : CustomGameContent
{
	public int levelCount;

	public CampaignLevel[] levels;

	public bool valid;

	public CampaignJson json;

	public CustomCampaign(string path)
	{
		if (path.EndsWith("campaign.json"))
		{
			path = path.Substring(0, path.Length - "campaign.json".Length);
		}
		lastModified = File.GetLastWriteTime(path);
		base.path = path;
		if (!File.Exists(Path.Combine(path, "campaign.json")))
		{
			Debug.Log(path);
			Debug.LogError("Campaign is missing campaign.json");
			name = "<color=red>Loading Failed!</color>";
			levels = Array.Empty<CampaignLevel>();
			valid = false;
			return;
		}
		string text = File.ReadAllText(Path.Combine(path, "campaign.json"));
		Debug.Log(text);
		CampaignJson campaignJson = (json = JsonConvert.DeserializeObject<CampaignJson>(text));
		name = campaignJson.name;
		uniqueId = campaignJson.uuid;
		levelCount = campaignJson.levels.Length;
		levels = campaignJson.levels;
		author = campaignJson.author;
		valid = true;
		campaignJson.path = path;
		if (File.Exists(Path.Combine(path, "thumbnail.png")))
		{
			byte[] data = File.ReadAllBytes(Path.Combine(path, "thumbnail.png"));
			thumbnail = new Texture2D(640, 480)
			{
				filterMode = FilterMode.Point
			};
			thumbnail.LoadImage(data);
		}
	}
}



public class CustomContentButton : MonoBehaviour
{
	public Button button;

	public Image icon;

	public Image border;

	public TMP_Text text;

	public TMP_Text costText;

	public List<GameObject> objectsToActivateIfAvailable;
}



public class CustomContentCategory : MonoBehaviour
{
	public TMP_Text title;
}



public class CustomContentGrid : MonoBehaviour
{
	public GameObject grid;
}



public class CustomContentGui : MonoBehaviour
{
	[SerializeField]
	private GameObject typeSelectionMenu;

	[Space]
	[SerializeField]
	private GameObject grid;

	[SerializeField]
	private GameObject gridLoadingBlocker;

	[SerializeField]
	private CustomLevelPanel itemTemplate;

	[SerializeField]
	private CustomContentCategory categoryTemplate;

	[SerializeField]
	private CustomContentGrid gridTemplate;

	[SerializeField]
	private GameObject pagination;

	[Space]
	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private ForceLayoutRebuilds forceLayoutRebuilds;

	[SerializeField]
	private GameObject workshopError;

	[SerializeField]
	private GameObject fetchingPanel;

	[SerializeField]
	private GameObject loadingFailed;

	[SerializeField]
	private InputField workshopSearch;

	[SerializeField]
	private Dropdown difficultyDropdown;

	[SerializeField]
	private GameObject workshopButtons;

	[SerializeField]
	private Button[] workshopTabButtons;

	[SerializeField]
	private GameObject localButtons;

	[SerializeField]
	private Dropdown localSortModeDropdown;

	[Space]
	[SerializeField]
	public CampaignViewScreen campaignView;

	private Action afterLegacyAgonyInterrupt;

	private UnscaledTimeSince timeSinceStart;

	private FileSystemWatcher watcher;

	private bool localListUpdatePending;

	private int currentPage = 1;

	private static LocalSortMode currentLocalSortMode = LocalSortMode.Name;

	private static WorkshopTab currentWorkshopTab = WorkshopTab.Trending;

	private static bool lastTabWorkshop;

	public static CustomCampaign lastCustomCampaign;

	public static bool wasAgonyOpen { get; private set; }

	public void ShowLocalMaps()
	{
		lastTabWorkshop = false;
		base.gameObject.SetActive(value: true);
		typeSelectionMenu.SetActive(value: false);
		RefreshCustomMaps();
	}

	public void ShowWorkshopMaps()
	{
		lastTabWorkshop = true;
		base.gameObject.SetActive(value: true);
		typeSelectionMenu.SetActive(value: false);
		currentPage = 1;
		RefreshWorkshopItems(currentPage);
	}

	public void ReturnToTypeSelection()
	{
		base.gameObject.SetActive(value: false);
		typeSelectionMenu.SetActive(value: true);
	}

	private void ResetItems()
	{
		for (int i = 2; i < grid.transform.childCount; i++)
		{
			if (!(pagination == grid.transform.GetChild(i).gameObject))
			{
				UnityEngine.Object.Destroy(grid.transform.GetChild(i).gameObject);
			}
		}
		itemTemplate.gameObject.SetActive(value: false);
		categoryTemplate.gameObject.SetActive(value: false);
		gridTemplate.gameObject.SetActive(value: false);
	}

	public void DismissBlockers()
	{
		loadingFailed.SetActive(value: false);
	}

	public void ShowInExplorer()
	{
		Application.OpenURL("file://" + GameProgressSaver.customMapsPath);
	}

	public void SetLocalSortMode(int option)
	{
		currentLocalSortMode = (LocalSortMode)option;
		MonoSingleton<PrefsManager>.Instance.SetInt("agonyLocalSortMode", option);
		RefreshCustomMaps();
	}

	public void SetDifficulty(int dif)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("difficulty", dif);
	}

	public void SetWorkshopTab(int tab)
	{
		Button[] array = workshopTabButtons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].interactable = true;
		}
		MonoSingleton<PrefsManager>.Instance.SetInt("agonyWorkshopTab", tab);
		currentWorkshopTab = (WorkshopTab)tab;
		workshopTabButtons[(int)currentWorkshopTab].interactable = false;
		List<WorkshopTab> list = new List<WorkshopTab>
		{
			WorkshopTab.Favorite,
			WorkshopTab.Subscribed,
			WorkshopTab.YourUploads
		};
		workshopSearch.interactable = !list.Contains(currentWorkshopTab);
		if (!workshopSearch.interactable)
		{
			workshopSearch.text = string.Empty;
		}
		RefreshWorkshopItems();
	}

	public async void RefreshWorkshopItems(int page = 1, bool lockScroll = false)
	{
	}

	public void LoadMore()
	{
		currentPage++;
		RefreshWorkshopItems(currentPage, lockScroll: true);
	}

	public async void RefreshCustomMaps()
	{
	}

	private void Update()
	{
		if (localListUpdatePending)
		{
			localListUpdatePending = false;
			Debug.Log("Refreshing local maps");
			RefreshCustomMaps();
		}
	}
}



public class CustomGameContent
{
	public string name;

	public string uniqueId;

	public string path;

	public Texture2D thumbnail;

	public DateTime lastModified;

	public string author;

	public string description;

	public string shortPath
	{
		get
		{
			if (!(this is CustomCampaign))
			{
				return Path.GetFileName(path);
			}
			return Path.GetFileName(path) + "/";
		}
	}
}


public class CustomGameDetails
{
	public string uniqueIdentifier;

	public int levelNumber;

	public ulong? workshopId;

	public CampaignJson campaign;

	public string campaignId => campaign?.uuid;
}



public class CustomGroundProperties : MonoBehaviour
{
	public float friction = 1f;

	public float speedMultiplier = 1f;

	public bool push;

	public Vector3 pushForce;

	public bool pushDirectionRelative;

	public bool canJump = true;

	public bool silentJumpFail;

	public float jumpForceMultiplier = 1f;

	public bool canSlide = true;

	public bool silentSlideFail;

	public bool canDash = true;

	public bool silentDashFail;

	public bool launchable = true;

	public bool forceCrouch;

	public bool overrideFootsteps;

	public AudioClip newFootstepSound;

	public bool dontRotateCamera;
}



public class CustomLevelButton : MonoBehaviour
{
	public Text mapName;

	public Text mapDetails;

	public RawImage thumbnail;

	public Button bodyButton;

	public Image downloadArrowIcon;

	public GameObject customCampaignBadge;

	public GameObject legacyBadge;

	public GameObject lockedBlocker;

	public Text campaignText;
}



public class CustomLevelPanel : MonoBehaviour
{
	[SerializeField]
	private PersistentColors nameColors;

	[Space]
	[SerializeField]
	private TMP_Text title;

	[SerializeField]
	private RawImage thumbnail;

	[Space]
	[SerializeField]
	private GameObject workshopInfoContainer;

	[SerializeField]
	private Button likeButton;

	[SerializeField]
	private TMP_Text likeCount;

	[SerializeField]
	private Image likeIcon;

	[SerializeField]
	private Button subscribeButton;

	[SerializeField]
	private Sprite subscribeSprite;

	[SerializeField]
	private Sprite subscribedSprite;

	[SerializeField]
	private Image subscribeIcon;

	[SerializeField]
	private Button dislikeButton;

	[SerializeField]
	private TMP_Text dislikeCount;

	[SerializeField]
	private Image dislikeIcon;

	[Space]
	[SerializeField]
	private GameObject downloadArrowIcon;

	[Space]
	[SerializeField]
	public HudOpenEffect detailsOpenEffect;

	[SerializeField]
	private TMP_Text description;

	[SerializeField]
	private CustomLevelStats stats;

	[Space]
	[SerializeField]
	private Image descriptionButton;

	[SerializeField]
	private Image statsButton;

	[SerializeField]
	private TMP_Text descriptionButtonLabel;

	[SerializeField]
	private TMP_Text statsButtonLabel;

	[Space]
	[SerializeField]
	private Button selfButton;

	[NonSerialized]
	public Vector2? originalDetailsSize;

	private string uniqueId;

	public void SetDetailsTab(int tabIndex)
	{
	}
}



public class CustomLevelStats : MonoBehaviour
{
	[SerializeField]
	private RankIcon mainRankIcon;

	[SerializeField]
	private TMP_Text secretsText;

	[SerializeField]
	private TMP_Text statsText;

	private const string AccentColor = "orange";

	public void LoadStats(string uuid)
	{
		if (uuid == null || string.IsNullOrEmpty(uuid))
		{
			statsText.text = "Unsupported";
			secretsText.text = string.Empty;
			mainRankIcon.gameObject.SetActive(value: false);
			return;
		}
		statsText.text = "No stats yet";
		Debug.Log("Loading stats for " + uuid);
		RankData customRankData = GameProgressSaver.GetCustomRankData(uuid);
		if (customRankData == null)
		{
			mainRankIcon.SetEmpty();
			secretsText.text = string.Empty;
			return;
		}
		int[] ranks = customRankData.ranks;
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		int rank = ranks[@int];
		mainRankIcon.SetRank(rank);
		int secretsAmount = customRankData.secretsAmount;
		int num = customRankData.secretsFound.Count((bool x) => x);
		secretsText.text = $"Secrets\n{num}/{secretsAmount}";
		RankScoreData[] stats = customRankData.stats;
		if (stats != null && stats.Length >= @int && stats[@int] != null)
		{
			StringBuilder stringBuilder = new StringBuilder();
			RankScoreData rankScoreData = stats[@int];
			stringBuilder.AppendLine("Time: <color=orange>" + TimeHelper.ConvertSecondsToString(rankScoreData.time) + "</color>");
			stringBuilder.AppendLine(string.Format("Kills: <color={0}>{1}</color>", "orange", rankScoreData.kills));
			stringBuilder.AppendLine(string.Format("Style: <color={0}>{1}</color>", "orange", rankScoreData.style));
			statsText.text = stringBuilder.ToString();
		}
	}
}



public class CustomMusicButton : CustomContentButton, IDragHandler, IEventSystemHandler, IPointerExitHandler
{
	[SerializeField]
	private RectTransform canvasTransform;

	[SerializeField]
	private ControllerPointer pointer;

	[SerializeField]
	private UnityEvent<GameObject, Vector3> onDrag;

	[SerializeField]
	private UnityEvent<GameObject, Vector3> onDrop;

	private Vector3? dragPoint;

	public void OnPointerDown(PointerEventData eventData)
	{
		dragPoint = GetScreenPositionInCanvasSpace(eventData.position);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		dragPoint = null;
		onDrop?.Invoke(base.gameObject, GetScreenPositionInCanvasSpace(eventData.position));
	}

	private void Update()
	{
	}

	private Vector2 GetScreenPositionInCanvasSpace(Vector2 screenPos)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(canvasTransform, screenPos, MonoSingleton<CameraController>.Instance.cam, out var localPoint);
		return localPoint;
	}

	public void OnDrag(PointerEventData eventData)
	{
	}
}



public class CustomMusicFileBrowser : DirectoryTreeBrowser<FileInfo>
{
	[SerializeField]
	private CyberGrindSettingsNavigator navigator;

	[SerializeField]
	private CustomMusicPlaylistEditor playlistEditorLogic;

	[SerializeField]
	private GameObject playlistEditor;

	[SerializeField]
	private GameObject loadingPrefab;

	[SerializeField]
	private Sprite defaultIcon;

	private AudioClip selectedClip;

	public static Dictionary<string, AudioType> extensionTypeDict = new Dictionary<string, AudioType>
	{
		{
			".wav",
			AudioType.WAV
		},
		{
			".mp3",
			AudioType.MPEG
		},
		{
			".ogg",
			AudioType.OGGVORBIS
		}
	};

	private AudioClip currentSong;

	protected override int maxPageLength => 4;

	protected override IDirectoryTree<FileInfo> baseDirectory => new FileDirectoryTree(Path.Combine(Directory.GetParent(Application.dataPath).FullName, "CyberGrind", "Music"));

	protected override Action BuildLeaf(FileInfo file, int indexInPage)
	{
		if (extensionTypeDict.ContainsKey(file.Extension.ToLower()))
		{
			GameObject go = UnityEngine.Object.Instantiate(itemButtonTemplate, itemParent, worldPositionStays: false);
			CustomContentButton component = go.GetComponent<CustomContentButton>();
			component.button.onClick.AddListener(delegate
			{
				int count = playlistEditorLogic.playlist.Count;
				int page = playlistEditorLogic.PageOf(count);
				playlistEditorLogic.playlist.Add(new Playlist.SongIdentifier(file.FullName, Playlist.SongIdentifier.IdentifierType.File));
				playlistEditorLogic.SetPage(page);
				playlistEditorLogic.Select(count);
				navigator.GoToNoMenu(playlistEditor);
			});
			component.text.text = file.Name;
			component.icon.sprite = defaultIcon;
			component.costText.text = "";
			go.SetActive(value: true);
			return delegate
			{
				UnityEngine.Object.Destroy(go);
			};
		}
		return null;
	}
}



public class CustomMusicPlaceholder : MonoBehaviour
{
	private float offset;

	private TimeSince sinceEnabled;

	private void Awake()
	{
		Random.Range(0, 1);
	}

	private void OnEnable()
	{
		sinceEnabled = offset;
	}

	private void Update()
	{
		base.transform.localRotation = Quaternion.Euler(0f, 0f, (float)sinceEnabled * -360f);
	}
}



public class CustomMusicPlayer : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup panelGroup;

	[SerializeField]
	private Text panelText;

	[SerializeField]
	private Image panelIcon;

	[SerializeField]
	private CustomMusicPlaylistEditor playlistEditor;

	[SerializeField]
	private Sprite defaultIcon;

	public AudioSource source;

	public float panelApproachTime;

	public float panelStayTime;

	private System.Random random = new System.Random();

	private bool stopped;

	public Dictionary<string, AudioClip> fileClipCache = new Dictionary<string, AudioClip>();

	public void OnEnable()
	{
		StartPlaylist();
	}

	public void StartPlaylist()
	{
		if (playlistEditor.playlist.Count < 1)
		{
			Debug.LogError("No songs in playlist, somehow. Not starting playlist routine...");
		}
		else
		{
			StartCoroutine(PlaylistRoutine());
		}
	}

	public void StopPlaylist()
	{
		stopped = true;
	}

	private IEnumerator ShowPanelRoutine(Playlist.SongMetadata song)
	{
		panelText.text = song.displayName.ToUpper();
		panelIcon.sprite = ((song.icon != null) ? song.icon : defaultIcon);
		float time = 0f;
		while (time < panelApproachTime)
		{
			time += Time.deltaTime;
			panelGroup.alpha = time / panelApproachTime;
			yield return null;
		}
		panelGroup.alpha = 1f;
		yield return new WaitForSecondsRealtime(panelStayTime);
		time = panelApproachTime;
		while (time > 0f)
		{
			time -= Time.deltaTime;
			panelGroup.alpha = time / panelApproachTime;
			yield return null;
		}
		panelGroup.alpha = 0f;
	}

	private IEnumerator PlaylistRoutine()
	{
		WaitUntil songFinished = new WaitUntil(() => Application.isFocused && !source.isPlaying);
		Playlist.SongIdentifier lastSong = null;
		bool first = true;
		Playlist playlist = playlistEditor.playlist;
		IEnumerable<Playlist.SongIdentifier> currentOrder = (playlist.shuffled ? new DeckShuffled<Playlist.SongIdentifier>(playlist.ids).AsEnumerable() : playlist.ids.AsEnumerable());
		if (playlist.loopMode == Playlist.LoopMode.LoopOne)
		{
			currentOrder = currentOrder.Skip(playlist.selected).Take(1);
		}
		while (!stopped)
		{
			if (currentOrder is DeckShuffled<Playlist.SongIdentifier> deckShuffled)
			{
				deckShuffled.Reshuffle();
			}
			foreach (Playlist.SongIdentifier id in currentOrder)
			{
				Playlist.SongMetadata songMetadata = playlistEditor.GetSongMetadata(id);
				if (id != lastSong)
				{
					StartCoroutine(ShowPanelRoutine(songMetadata));
				}
				lastSong = id;
				if (id.type == Playlist.SongIdentifier.IdentifierType.File)
				{
					FileInfo fileInfo = new FileInfo(id.path);
					AudioType audioType = CustomMusicFileBrowser.extensionTypeDict[fileInfo.Extension.ToLower()];
					using UnityWebRequest request = UnityWebRequestMultimedia.GetAudioClip(new Uri(id.path).AbsoluteUri, audioType);
					DownloadHandlerAudioClip handler = request.downloadHandler as DownloadHandlerAudioClip;
					handler.streamAudio = true;
					request.SendWebRequest();
					yield return request;
					source.clip = handler.audioClip;
					source.Play();
					yield return songFinished;
					UnityEngine.Object.Destroy(handler.audioClip);
				}
				if (id.type == Playlist.SongIdentifier.IdentifierType.Addressable)
				{
					AsyncOperationHandle<SoundtrackSong> handle = Addressables.LoadAssetAsync<SoundtrackSong>(id.path);
					yield return handle;
					SoundtrackSong song = handle.Result;
					if (first)
					{
						source.clip = song.introClip;
						source.Play();
						yield return songFinished;
					}
					int clipsPlayed = 0;
					foreach (AudioClip clip in song.clips)
					{
						source.clip = clip;
						source.Play();
						yield return songFinished;
						clipsPlayed++;
						if (playlist.loopMode != Playlist.LoopMode.LoopOne && song.maxClipsIfNotRepeating > 0 && clipsPlayed >= song.maxClipsIfNotRepeating)
						{
							break;
						}
					}
					Addressables.Release(handle);
				}
				first = false;
			}
		}
	}
}



public class CustomMusicPlaylistEditor : DirectoryTreeBrowser<Playlist.SongIdentifier>
{
	[SerializeField]
	private CustomMusicSoundtrackBrowser browser;

	[SerializeField]
	private Sprite defaultIcon;

	[SerializeField]
	private Sprite loopSprite;

	[SerializeField]
	private Sprite loopOnceSprite;

	[Header("UI Elements")]
	[SerializeField]
	private Image loopModeImage;

	[SerializeField]
	private Image shuffleImage;

	[SerializeField]
	private RectTransform selectedControls;

	[SerializeField]
	private List<Transform> anchors;

	public Playlist playlist = new Playlist();

	private Coroutine moveControlsRoutine;

	private Dictionary<Transform, Coroutine> changeAnchorRoutines = new Dictionary<Transform, Coroutine>();

	private List<Transform> buttons = new List<Transform>();

	private Dictionary<Playlist.SongIdentifier, Playlist.SongMetadata> metadataDict = new Dictionary<Playlist.SongIdentifier, Playlist.SongMetadata>();

	protected override int maxPageLength => anchors.Count;

	protected override IDirectoryTree<Playlist.SongIdentifier> baseDirectory => new FakeDirectoryTree<Playlist.SongIdentifier>("Songs", playlist.ids);

	private Playlist.SongIdentifier selectedSongId => playlist.ids[playlist.selected];

	private CustomContentButton currentButton => buttons.ElementAtOrDefault(playlist.selected % maxPageLength)?.GetComponent<CustomContentButton>();

	public Playlist.SongMetadata GetSongMetadata(Playlist.SongIdentifier id)
	{
		if (metadataDict.TryGetValue(id, out var value))
		{
			return value;
		}
		Playlist.SongMetadata songMetadata = null;
		songMetadata = id.type switch
		{
			Playlist.SongIdentifier.IdentifierType.Addressable => GetSongMetadataFromAddressable(id), 
			Playlist.SongIdentifier.IdentifierType.File => GetSongMetadataFromFilepath(id), 
			_ => throw new ArgumentException($"Could not fetch matadata: SongIdentifier '{id.path}' has invalid type '{id.type}'."), 
		};
		metadataDict.Add(id, songMetadata);
		return songMetadata;
	}

	private Playlist.SongMetadata GetSongMetadataFromAddressable(Playlist.SongIdentifier id)
	{
		AsyncOperationHandle<SoundtrackSong> asyncOperationHandle = new AssetReferenceSoundtrackSong(id.path).LoadAssetAsync();
		asyncOperationHandle.WaitForCompletion();
		return new Playlist.SongMetadata(asyncOperationHandle.Result.songName, asyncOperationHandle.Result.icon, asyncOperationHandle.Result.maxClipsIfNotRepeating);
	}

	private Playlist.SongMetadata GetSongMetadataFromFilepath(Playlist.SongIdentifier id)
	{
		return new Playlist.SongMetadata(new FileInfo(id.path).Name, defaultIcon);
	}

	public void SavePlaylist()
	{
		File.WriteAllText(Playlist.currentPath, JsonConvert.SerializeObject(playlist));
	}

	public void LoadPlaylist()
	{
		Debug.Log("Loading Playlist");
		Playlist playlist = null;
		using (StreamReader streamReader = new StreamReader(File.Open(Playlist.currentPath, FileMode.OpenOrCreate)))
		{
			playlist = JsonConvert.DeserializeObject<Playlist>(streamReader.ReadToEnd());
		}
		if (playlist == null)
		{
			Debug.Log("No saved playlist found at " + Playlist.currentPath + ". Creating default...");
			foreach (AssetReferenceSoundtrackSong item in browser.rootFolder)
			{
				this.playlist.Add(new Playlist.SongIdentifier(item.AssetGUID, Playlist.SongIdentifier.IdentifierType.Addressable));
			}
		}
		else
		{
			this.playlist = playlist;
			currentDirectory = baseDirectory;
			Rebuild();
		}
		Rebuild();
	}

	public void Remove()
	{
		playlist.Remove(playlist.selected);
		if (playlist.selected >= playlist.ids.Count)
		{
			Select(playlist.Count - 1);
		}
		Rebuild(setToPageZero: false);
	}

	public void MoveUp()
	{
		Move(-1);
	}

	public void MoveDown()
	{
		Move(1);
	}

	public void Move(int amount)
	{
		int num = playlist.selected % maxPageLength;
		int index = num + amount;
		bool flag = PageOf(playlist.selected) == PageOf(playlist.selected + amount);
		if (playlist.selected + amount >= 0 && playlist.selected + amount < playlist.ids.Count)
		{
			playlist.Swap(playlist.selected, playlist.selected + amount);
			if (flag)
			{
				ChangeAnchorOf(buttons[num], anchors[index]);
				ChangeAnchorOf(selectedControls, anchors[index]);
				ChangeAnchorOf(buttons[index], anchors[num]);
				CustomContentButton customContentButton = currentButton;
				buttons.RemoveAt(num);
				buttons.Insert(index, customContentButton.transform);
				Select(playlist.selected + amount, rebuild: false);
			}
			else
			{
				selectedControls.gameObject.SetActive(value: false);
				Select(playlist.selected + amount);
			}
		}
	}

	public void ChangeAnchorOf(Transform obj, Transform anchor, float time = 0.15f)
	{
		if (changeAnchorRoutines.ContainsKey(obj))
		{
			if (changeAnchorRoutines[obj] != null)
			{
				StopCoroutine(changeAnchorRoutines[obj]);
			}
			changeAnchorRoutines.Remove(obj);
		}
		changeAnchorRoutines.Add(obj, StartCoroutine(ChangeAnchorOverTime()));
		IEnumerator ChangeAnchorOverTime()
		{
			float t = 0f;
			_ = obj.position;
			while (t < time && time > 0f)
			{
				obj.position = Vector3.MoveTowards(obj.position, anchor.position, Time.deltaTime * 2f);
				if (Vector3.Distance(obj.position, anchor.position) <= Mathf.Epsilon)
				{
					break;
				}
				yield return null;
			}
			obj.position = anchor.position;
		}
	}

	public void ToggleLoopMode()
	{
		SetLoopMode((playlist.loopMode == Playlist.LoopMode.Loop) ? Playlist.LoopMode.LoopOne : Playlist.LoopMode.Loop);
	}

	private void SetLoopMode(Playlist.LoopMode mode)
	{
		playlist.loopMode = mode;
		loopModeImage.sprite = ((playlist.loopMode == Playlist.LoopMode.Loop) ? loopSprite : loopOnceSprite);
	}

	public void ToggleShuffle()
	{
		SetShuffle(!playlist.shuffled);
	}

	private void SetShuffle(bool shuffle)
	{
		playlist.shuffled = shuffle;
		shuffleImage.color = (shuffle ? Color.white : Color.gray);
	}

	public void Select(int newIndex, bool rebuild = true)
	{
		if (newIndex < 0 || newIndex >= playlist.Count)
		{
			Debug.LogWarning("Attempted to set current index outside bounds of playlist");
			return;
		}
		bool num = PageOf(newIndex) == currentPage;
		if ((bool)currentButton)
		{
			currentButton.border.color = Color.white;
		}
		int selected = playlist.selected;
		playlist.selected = newIndex;
		if (PageOf(selected) < PageOf(newIndex))
		{
			ChangeAnchorOf(selectedControls, anchors.First(), 0f);
		}
		else if (PageOf(selected) > PageOf(newIndex))
		{
			ChangeAnchorOf(selectedControls, anchors.Last(), 0f);
		}
		if ((bool)currentButton)
		{
			currentButton.border.color = Color.red;
		}
		Transform transform = anchors[playlist.selected % maxPageLength];
		if (num)
		{
			selectedControls.gameObject.SetActive(value: true);
			ChangeAnchorOf(selectedControls, transform);
		}
		else
		{
			selectedControls.gameObject.SetActive(value: false);
			selectedControls.transform.position = transform.position;
		}
		if (rebuild)
		{
			Rebuild(setToPageZero: false);
		}
	}

	public override void Rebuild(bool setToPageZero = true)
	{
		foreach (KeyValuePair<Transform, Coroutine> changeAnchorRoutine in changeAnchorRoutines)
		{
			if (changeAnchorRoutine.Value != null)
			{
				StopCoroutine(changeAnchorRoutine.Value);
			}
		}
		changeAnchorRoutines.Clear();
		buttons.Clear();
		base.Rebuild(setToPageZero);
		if (buttons.Count < maxPageLength)
		{
			ChangeAnchorOf(plusButton.transform, anchors[buttons.Count], 0f);
		}
		LayoutRebuilder.ForceRebuildLayoutImmediate(itemParent as RectTransform);
	}

	protected override Action BuildLeaf(Playlist.SongIdentifier id, int currentIndex)
	{
		Playlist.SongMetadata songMetadata = GetSongMetadata(id);
		GameObject go = UnityEngine.Object.Instantiate(itemButtonTemplate, itemButtonTemplate.transform.parent);
		CustomContentButton contentButton = go.GetComponent<CustomContentButton>();
		contentButton.text.text = songMetadata.displayName.ToUpper();
		contentButton.icon.sprite = ((songMetadata.icon != null) ? songMetadata.icon : defaultIcon);
		go.SetActive(value: true);
		ChangeAnchorOf(go.transform, anchors[currentIndex], 0f);
		buttons.Add(go.transform);
		if (PageOf(playlist.selected) == currentPage && contentButton == currentButton)
		{
			contentButton.border.color = Color.red;
			selectedControls.gameObject.SetActive(value: true);
			ChangeAnchorOf(selectedControls, anchors[currentIndex]);
			return delegate
			{
				selectedControls.gameObject.SetActive(value: false);
				UnityEngine.Object.Destroy(go);
			};
		}
		contentButton.button.onClick.AddListener(delegate
		{
			Select(buttons.IndexOf(contentButton.transform) + currentPage * maxPageLength);
		});
		return delegate
		{
			UnityEngine.Object.Destroy(go);
		};
	}

	private void Start()
	{
		try
		{
			LoadPlaylist();
		}
		catch (JsonReaderException ex)
		{
			Debug.LogError("Error loading Playlist.json: '" + ex.Message + "'. Recreating file.");
			File.Delete(Playlist.currentPath);
			LoadPlaylist();
		}
		Select(playlist.selected);
		SetLoopMode(playlist.loopMode);
		SetShuffle(playlist.shuffled);
		playlist.OnChanged += SavePlaylist;
	}

	private void OnDestroy()
	{
		playlist.OnChanged -= SavePlaylist;
	}
}



public class CustomMusicSoundtrackBrowser : DirectoryTreeBrowser<AssetReferenceSoundtrackSong>
{
	[Header("References")]
	[SerializeField]
	private CustomMusicPlaylistEditor playlistEditorLogic;

	[SerializeField]
	private GameObject playlistEditorPanel;

	[SerializeField]
	private CyberGrindSettingsNavigator navigator;

	[SerializeField]
	private TMP_Text songName;

	[SerializeField]
	private Image songIcon;

	[Header("Assets")]
	[SerializeField]
	private GameObject loadingPrefab;

	[SerializeField]
	private Sprite lockedLevelSprite;

	[SerializeField]
	private Sprite defaultIcon;

	[SerializeField]
	private GameObject buySound;

	public List<AssetReferenceSoundtrackSong> rootFolder = new List<AssetReferenceSoundtrackSong>();

	public List<SoundtrackFolder> levelFolders = new List<SoundtrackFolder>();

	public List<AssetReferenceSoundtrackSong> secretLevelFolder = new List<AssetReferenceSoundtrackSong>();

	public List<AssetReferenceSoundtrackSong> primeFolder = new List<AssetReferenceSoundtrackSong>();

	public List<AssetReferenceSoundtrackSong> miscFolder = new List<AssetReferenceSoundtrackSong>();

	private FakeDirectoryTree<AssetReferenceSoundtrackSong> _baseDirectory;

	private Dictionary<AssetReferenceSoundtrackSong, SoundtrackSong> referenceCache = new Dictionary<AssetReferenceSoundtrackSong, SoundtrackSong>();

	private SoundtrackSong songBeingBought;

	protected override int maxPageLength => 4;

	protected override IDirectoryTree<AssetReferenceSoundtrackSong> baseDirectory
	{
		get
		{
			if (_baseDirectory == null)
			{
				levelFolders.Add(new SoundtrackFolder("SECRET LEVELS", secretLevelFolder));
				for (int i = 1; i <= 3; i++)
				{
					if (GameProgressSaver.GetPrime(0, i) > 0)
					{
						levelFolders.Add(new SoundtrackFolder("PRIME SANCTUMS", primeFolder));
						break;
					}
				}
				levelFolders.Add(new SoundtrackFolder("MISCELLANEOUS TRACKS", miscFolder));
				levelFolders.Insert(0, new SoundtrackFolder("THE CYBER GRIND", rootFolder));
				IEnumerable<FakeDirectoryTree<AssetReferenceSoundtrackSong>> source = levelFolders.Select((SoundtrackFolder f) => new FakeDirectoryTree<AssetReferenceSoundtrackSong>(f.name, f.songs));
				_baseDirectory = DirectoryTreeBrowser<AssetReferenceSoundtrackSong>.Folder("OST", null, source.Cast<IDirectoryTree<AssetReferenceSoundtrackSong>>().ToList());
			}
			return _baseDirectory;
		}
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
		Rebuild();
	}

	private void SelectSong(string id, SoundtrackSong song)
	{
		if (song.clips.Count > 0)
		{
			int count = playlistEditorLogic.playlist.Count;
			int page = playlistEditorLogic.PageOf(count);
			playlistEditorLogic.playlist.Add(new Playlist.SongIdentifier(id, Playlist.SongIdentifier.IdentifierType.Addressable));
			playlistEditorLogic.SetPage(page);
			playlistEditorLogic.Select(count);
			navigator.GoToNoMenu(playlistEditorPanel);
		}
		else
		{
			Debug.LogWarning("Attempted to add song with no clips to playlist.");
		}
	}

	private void OnDestroy()
	{
	}

	public IEnumerator LoadSongButton(AssetReferenceSoundtrackSong reference, GameObject btn)
	{
		GameObject placeholder = UnityEngine.Object.Instantiate(loadingPrefab, itemParent, worldPositionStays: false);
		placeholder.SetActive(value: true);
		SoundtrackSong song;
		if (referenceCache.ContainsKey(reference))
		{
			yield return new WaitUntil(() => referenceCache[reference] != null || btn == null);
			if (btn == null)
			{
				UnityEngine.Object.Destroy(placeholder);
				yield break;
			}
			song = referenceCache[reference];
		}
		else
		{
			AsyncOperationHandle<SoundtrackSong> handle = reference.LoadAssetAsync();
			referenceCache.Add(reference, null);
			yield return new WaitUntil(() => handle.IsDone || btn == null);
			if (btn == null)
			{
				UnityEngine.Object.Destroy(placeholder);
				yield return handle;
			}
			song = handle.Result;
			referenceCache[reference] = song;
			Addressables.Release(handle);
			if (btn == null)
			{
				yield break;
			}
		}
		UnityEngine.Object.Destroy(placeholder);
		CustomContentButton componentInChildren = btn.GetComponentInChildren<CustomContentButton>();
		componentInChildren.button.onClick.RemoveAllListeners();
		if (song.conditions.AllMet())
		{
			componentInChildren.icon.sprite = ((song.icon != null) ? song.icon : defaultIcon);
			componentInChildren.text.text = song.songName.ToUpper() + " <color=grey>" + song.extraLevelBit + "</color>";
			componentInChildren.costText.text = "<i>UNLOCKED</i>";
			componentInChildren.button.onClick.AddListener(delegate
			{
				SelectSong(reference.AssetGUID, song);
			});
			SetActiveAll(componentInChildren.objectsToActivateIfAvailable, active: true);
			btn.SetActive(value: true);
		}
		else
		{
			SetActiveAll(componentInChildren.objectsToActivateIfAvailable, active: false);
			componentInChildren.text.text = "????????? " + song.extraLevelBit;
			componentInChildren.costText.text = song.conditions.DescribeAll();
			componentInChildren.icon.sprite = lockedLevelSprite;
			componentInChildren.border.color = Color.grey;
			componentInChildren.text.color = Color.grey;
			componentInChildren.costText.color = Color.grey;
			btn.SetActive(value: true);
		}
	}

	protected override Action BuildLeaf(AssetReferenceSoundtrackSong reference, int indexInPage)
	{
		GameObject btn = UnityEngine.Object.Instantiate(itemButtonTemplate, itemParent, worldPositionStays: false);
		StartCoroutine(LoadSongButton(reference, btn));
		return delegate
		{
			UnityEngine.Object.Destroy(btn);
		};
	}

	private void SetActiveAll(List<GameObject> objects, bool active)
	{
		foreach (GameObject @object in objects)
		{
			@object.SetActive(active);
		}
	}
}



public class CustomPaletteSelector : MonoBehaviour
{
	[SerializeField]
	private GraphicsOptions go;

	[Space]
	[SerializeField]
	private GameObject menu;

	[SerializeField]
	private Transform container;

	[Space]
	[SerializeField]
	private Image templatePreviewImage;

	[SerializeField]
	private Text templateFileName;

	[SerializeField]
	private Button buttonTemplate;

	[Space]
	[SerializeField]
	private Image previewImage;

	private static string PalettePath => Path.Combine(Directory.GetParent(Application.dataPath).FullName, "Palettes");

	private static void Init()
	{
		if (!Directory.Exists(PalettePath))
		{
			Directory.CreateDirectory(PalettePath);
		}
	}

	private void ResetMenu()
	{
		for (int i = 1; i < container.childCount; i++)
		{
			Object.Destroy(container.GetChild(i).gameObject);
		}
	}

	private void RefreshCurrentPreview()
	{
		Texture currentTexture = MonoSingleton<PostProcessV2_Handler>.Instance.CurrentTexture;
		if (!(currentTexture == null))
		{
			Sprite sprite = Sprite.Create((Texture2D)currentTexture, new Rect(0f, 0f, currentTexture.width, currentTexture.height), new Vector2(0.5f, 0.5f), 100f);
			sprite.texture.filterMode = FilterMode.Point;
			previewImage.sprite = sprite;
		}
	}

	public void ShowMenu()
	{
		BuildMenu();
		RefreshCurrentPreview();
		menu.SetActive(value: true);
	}

	private void BuildMenu()
	{
		ResetMenu();
		buttonTemplate.gameObject.SetActive(value: false);
		foreach (string palette in (from a in Directory.GetFiles(PalettePath, "*", SearchOption.TopDirectoryOnly)
			where CustomTextures.AllowedExtensions.Contains(Path.GetExtension(a))
			select a).Select(Path.GetFileName))
		{
			Texture2D txt = LoadPalette(palette);
			Sprite sprite = Sprite.Create(txt, new Rect(0f, 0f, txt.width, txt.height), new Vector2(0.5f, 0.5f), 100f);
			sprite.texture.filterMode = FilterMode.Point;
			templatePreviewImage.sprite = sprite;
			templateFileName.text = Path.GetFileNameWithoutExtension(palette);
			Button button = Object.Instantiate(buttonTemplate, container, worldPositionStays: false);
			button.gameObject.SetActive(value: true);
			button.onClick.AddListener(delegate
			{
				SetGamePalette(txt, palette);
			});
		}
	}

	private void SetGamePalette(Texture2D txt, string name)
	{
		MonoSingleton<PrefsManager>.Instance.SetStringLocal("colorPaletteTexture", name);
		go.ApplyPalette(txt);
		RefreshCurrentPreview();
	}

	private static Texture2D LoadPalette(string name)
	{
		if (!File.Exists(Path.Combine(PalettePath, name)))
		{
			return null;
		}
		byte[] data = File.ReadAllBytes(Path.Combine(PalettePath, name));
		Texture2D obj = new Texture2D(0, 0, TextureFormat.RGBA32, mipChain: false)
		{
			filterMode = FilterMode.Point
		};
		obj.LoadImage(data);
		obj.name = name;
		return obj;
	}

	public static Texture2D LoadSavedPalette()
	{
		Init();
		string stringLocal = MonoSingleton<PrefsManager>.Instance.GetStringLocal("colorPaletteTexture");
		if (!string.IsNullOrEmpty(stringLocal))
		{
			return LoadPalette(stringLocal);
		}
		return null;
	}
}



public class CustomPatterns : MonoBehaviour
{
	private Dictionary<string, ArenaPattern> patternCache = new Dictionary<string, ArenaPattern>();

	private Dictionary<string, ArenaPattern> enabledPatterns = new Dictionary<string, ArenaPattern>();

	private Dictionary<string, ArenaPattern[]> enabledPatternPacks = new Dictionary<string, ArenaPattern[]>();

	private Dictionary<string, GameObject> patternActiveIndicators = new Dictionary<string, GameObject>();

	private Dictionary<string, GameObject> patternPackActiveIndicators = new Dictionary<string, GameObject>();

	private int currentPage = 1;

	private int maxPages = 1;

	private int maxItemsPerPage = 15;

	[SerializeField]
	private AnimationCurve colorCurve;

	[SerializeField]
	private Texture2D parsingErrorTexture;

	[SerializeField]
	private GameObject buttonTemplate;

	[SerializeField]
	private GameObject packButtonTemplate;

	[SerializeField]
	private Transform grid;

	[SerializeField]
	private TMP_Text stateButtonText;

	[SerializeField]
	private TMP_Text pageText;

	public GameObject enableWhenCustom;

	private string PatternsPath => Path.Combine(Directory.GetParent(Application.dataPath).FullName, "CyberGrind", "Patterns");

	private ArenaPattern[] AllEnabledPatterns
	{
		get
		{
			List<ArenaPattern> list = new List<ArenaPattern>();
			list.AddRange(enabledPatterns.Values.ToArray());
			foreach (ArenaPattern[] value in enabledPatternPacks.Values)
			{
				list.AddRange(value);
			}
			return list.ToArray();
		}
	}

	private void Awake()
	{
		Directory.CreateDirectory(Path.GetDirectoryName(PatternsPath));
		Directory.CreateDirectory(PatternsPath);
		LoadEnabledPatterns();
		BuildButtons();
	}

	public void Toggle()
	{
		UnityEngine.Debug.Log("Toggling custom patterns");
		bool customPatternMode = MonoSingleton<EndlessGrid>.Instance.customPatternMode;
		MonoSingleton<EndlessGrid>.Instance.customPatternMode = !customPatternMode;
		stateButtonText.text = (customPatternMode ? "DISABLED" : "ENABLED");
		enableWhenCustom?.SetActive(!customPatternMode);
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("cyberGrind.customPool", MonoSingleton<EndlessGrid>.Instance.customPatternMode);
	}

	public void SaveEnabledPatterns()
	{
		ActivePatterns obj = new ActivePatterns
		{
			enabledPatterns = enabledPatterns.Keys.ToArray(),
			enabledPatternPacks = enabledPatternPacks.Keys.ToArray()
		};
		MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.enabledPatterns", JsonUtility.ToJson(obj));
	}

	public void LoadEnabledPatterns()
	{
		string stringLocal = MonoSingleton<PrefsManager>.Instance.GetStringLocal("cyberGrind.enabledPatterns");
		if (!string.IsNullOrEmpty(stringLocal))
		{
			ActivePatterns activePatterns = JsonUtility.FromJson<ActivePatterns>(stringLocal);
			enabledPatterns = new Dictionary<string, ArenaPattern>();
			enabledPatternPacks = new Dictionary<string, ArenaPattern[]>();
			if (activePatterns.enabledPatterns != null)
			{
				string[] array = activePatterns.enabledPatterns;
				foreach (string text in array)
				{
					string text2 = text;
					if (Path.GetFileName(text) != text)
					{
						text2 = Path.GetFileName(text);
					}
					ArenaPattern arenaPattern = LoadPattern(text2);
					if ((bool)arenaPattern)
					{
						enabledPatterns.Add(text2, arenaPattern);
					}
				}
			}
			if (activePatterns.enabledPatternPacks != null)
			{
				string[] array = activePatterns.enabledPatternPacks;
				foreach (string text3 in array)
				{
					if (Directory.Exists(Path.Combine(PatternsPath, text3)))
					{
						string[] array2 = (from f in Directory.GetFiles(Path.Combine(PatternsPath, text3))
							select Path.GetFileName(f)).ToArray();
						List<ArenaPattern> list = new List<ArenaPattern>();
						string[] array3 = array2;
						foreach (string path in array3)
						{
							ArenaPattern item = LoadPattern(Path.Combine(text3, path));
							list.Add(item);
						}
						enabledPatternPacks.Add(text3, list.ToArray());
					}
				}
			}
			MonoSingleton<EndlessGrid>.Instance.customPatterns = AllEnabledPatterns;
		}
		MonoSingleton<EndlessGrid>.Instance.customPatterns = AllEnabledPatterns;
		MonoSingleton<EndlessGrid>.Instance.customPatternMode = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("cyberGrind.customPool");
		bool flag = !MonoSingleton<EndlessGrid>.Instance.customPatternMode;
		stateButtonText.text = (flag ? "DISABLED" : "ENABLED");
		enableWhenCustom.SetActive(!flag);
	}

	public void BuildButtons()
	{
		GridTile[] collection = (from f in Directory.GetDirectories(PatternsPath, "*", SearchOption.TopDirectoryOnly)
			select new GridTile
			{
				path = Path.GetFileName(f),
				folder = true
			}).ToArray();
		GridTile[] collection2 = (from f in Directory.GetFiles(PatternsPath, "*.cgp", SearchOption.TopDirectoryOnly)
			select new GridTile
			{
				path = Path.GetFileName(f),
				folder = false
			}).ToArray();
		List<GridTile> list = new List<GridTile>();
		list.AddRange(collection);
		list.AddRange(collection2);
		for (int i = 2; i < grid.childCount; i++)
		{
			Object.Destroy(grid.GetChild(i).gameObject);
		}
		maxPages = Mathf.CeilToInt((float)list.Count / (float)maxItemsPerPage);
		for (int j = (currentPage - 1) * maxItemsPerPage; j < list.Count && j < currentPage * maxItemsPerPage; j++)
		{
			GridTile tile = list[j];
			if (tile.folder)
			{
				string[] array = (from f in Directory.GetFiles(Path.Combine(PatternsPath, tile.path), "*.cgp")
					select Path.GetFileName(f)).ToArray();
				Texture2D target = new Texture2D(48, 48);
				for (int k = 0; k < 48; k++)
				{
					for (int l = 0; l < 48; l++)
					{
						target.SetPixel(k, l, Color.black);
					}
				}
				for (int m = 0; m < array.Length && m < 7; m++)
				{
					ArenaPattern pattern = LoadPattern(Path.Combine(tile.path, array[m]));
					Vector2Int offset = new Vector2Int(m % 3, (m > 2) ? 1 : 0);
					GeneratePatternPreview(pattern, offset, ref target);
				}
				target.Apply();
				GameObject gameObject = Object.Instantiate(packButtonTemplate, grid, worldPositionStays: false);
				Sprite sprite = Sprite.Create(target, new Rect(0f, 0f, 48f, 48f), new Vector2(0.5f, 0.5f), 100f);
				sprite.texture.filterMode = FilterMode.Point;
				gameObject.GetComponentInChildren<TMP_Text>(includeInactive: true).text = tile.path;
				gameObject.GetComponent<Image>().sprite = sprite;
				gameObject.GetComponent<ControllerPointer>().OnPressed.AddListener(delegate
				{
					TogglePattern(tile.path, isPack: true);
				});
				patternPackActiveIndicators[tile.path] = gameObject.transform.GetChild(0).gameObject;
				patternPackActiveIndicators[tile.path].SetActive(enabledPatternPacks.ContainsKey(tile.path));
				gameObject.SetActive(value: true);
				continue;
			}
			string path = list[j].path;
			ArenaPattern arenaPattern = LoadPattern(path);
			GameObject gameObject2 = Object.Instantiate(buttonTemplate, grid, worldPositionStays: false);
			if (arenaPattern == null)
			{
				Sprite sprite2 = Sprite.Create(parsingErrorTexture, new Rect(0f, 0f, 16f, 16f), new Vector2(0.5f, 0.5f), 100f);
				sprite2.texture.filterMode = FilterMode.Point;
				gameObject2.GetComponent<Image>().sprite = sprite2;
				gameObject2.transform.GetChild(0).gameObject.SetActive(value: false);
				gameObject2.SetActive(value: true);
				continue;
			}
			Texture2D target2 = new Texture2D(16, 16);
			bool num = GeneratePatternPreview(arenaPattern, Vector2Int.zero, ref target2);
			target2.Apply();
			if (!num)
			{
				Sprite sprite3 = Sprite.Create(parsingErrorTexture, new Rect(0f, 0f, 16f, 16f), new Vector2(0.5f, 0.5f), 100f);
				sprite3.texture.filterMode = FilterMode.Point;
				gameObject2.GetComponent<Image>().sprite = sprite3;
				gameObject2.transform.GetChild(0).gameObject.SetActive(value: false);
				gameObject2.SetActive(value: true);
				continue;
			}
			Sprite sprite4 = Sprite.Create(target2, new Rect(0f, 0f, 16f, 16f), new Vector2(0.5f, 0.5f), 100f);
			sprite4.texture.filterMode = FilterMode.Point;
			gameObject2.GetComponent<Image>().sprite = sprite4;
			gameObject2.SetActive(value: true);
			string key = Path.GetFileName(path);
			gameObject2.GetComponent<ControllerPointer>().OnPressed.AddListener(delegate
			{
				TogglePattern(key, isPack: false);
			});
			patternActiveIndicators[key] = gameObject2.transform.GetChild(0).gameObject;
			patternActiveIndicators[key].SetActive(enabledPatterns.ContainsKey(key));
		}
		pageText.text = $"{currentPage}/{maxPages}";
		buttonTemplate.SetActive(value: false);
	}

	private bool GeneratePatternPreview(ArenaPattern pattern, Vector2Int offset, ref Texture2D target)
	{
		string[] array = pattern.heights.Split('\n');
		if (array.Length != 16)
		{
			UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array.Length + " rows instead of " + 16);
			UnityEngine.Debug.Log(pattern.heights);
			return false;
		}
		for (int i = 0; i < array.Length; i++)
		{
			int[] array2 = new int[16];
			if (array[i].Length != 16)
			{
				if (array[i].Length < 16)
				{
					UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array[i].Length + " elements in row " + i + " instead of " + 16);
					return false;
				}
				int num = 0;
				bool flag = false;
				string text = "";
				for (int j = 0; j < array[i].Length; j++)
				{
					if (int.TryParse(array[i][j].ToString(), out var result) || array[i][j] == '-')
					{
						if (!flag)
						{
							array2[num] = result;
							num++;
							continue;
						}
						text += array[i][j];
					}
					if (array[i][j] == '(')
					{
						if (flag)
						{
							UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\", Error while parsing extended numbers!");
							return false;
						}
						flag = true;
					}
					if (array[i][j] == ')')
					{
						if (!flag)
						{
							UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\", Error while parsing extended numbers!");
							return false;
						}
						array2[num] = int.Parse(text);
						flag = false;
						text = "";
						num++;
					}
				}
				if (num != 16)
				{
					UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array[i].Length + " elements in row " + num + " instead of " + 16);
					return false;
				}
			}
			else
			{
				for (int k = 0; k < array[i].Length; k++)
				{
					array2[k] = int.Parse(array[i][k].ToString());
				}
			}
			for (int l = 0; l < array2.Length; l++)
			{
				float num2 = colorCurve.Evaluate(array2[l]);
				target.SetPixel(offset.x * 16 + l, offset.y * 16 + i, new Color(num2, num2, num2));
			}
		}
		return true;
	}

	private void TogglePattern(string key, bool isPack)
	{
		if (isPack)
		{
			if (enabledPatternPacks.ContainsKey(key))
			{
				enabledPatternPacks.Remove(key);
				patternPackActiveIndicators[key].SetActive(value: false);
			}
			else if (Directory.Exists(Path.Combine(PatternsPath, key)))
			{
				string[] array = (from f in Directory.GetFiles(Path.Combine(PatternsPath, key))
					select Path.GetFileName(f)).ToArray();
				List<ArenaPattern> list = new List<ArenaPattern>();
				string[] array2 = array;
				foreach (string path in array2)
				{
					ArenaPattern item = LoadPattern(Path.Combine(key, path));
					list.Add(item);
				}
				enabledPatternPacks.Add(key, list.ToArray());
				enabledPatternPacks[key] = list.ToArray();
				patternPackActiveIndicators[key].SetActive(value: true);
			}
			if (!MonoSingleton<EndlessGrid>.Instance.customPatternMode)
			{
				Toggle();
			}
		}
		else
		{
			if (enabledPatterns.ContainsKey(key))
			{
				enabledPatterns.Remove(key);
				patternActiveIndicators[key].SetActive(value: false);
			}
			else
			{
				enabledPatterns[key] = LoadPattern(key);
				patternActiveIndicators[key].SetActive(value: true);
			}
			if (!MonoSingleton<EndlessGrid>.Instance.customPatternMode)
			{
				Toggle();
			}
		}
		MonoSingleton<EndlessGrid>.Instance.customPatterns = AllEnabledPatterns;
		SaveEnabledPatterns();
	}

	private ArenaPattern LoadPattern(string relativePath)
	{
		if (patternCache.ContainsKey(relativePath))
		{
			return patternCache[relativePath];
		}
		if (!File.Exists(Path.Combine(PatternsPath, relativePath)))
		{
			return null;
		}
		string[] array = File.ReadAllLines(Path.Combine(PatternsPath, relativePath));
		if (array.Length != 33)
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 16; i++)
		{
			stringBuilder.Append(array[i]);
			if (i != 15)
			{
				stringBuilder.Append('\n');
			}
		}
		StringBuilder stringBuilder2 = new StringBuilder();
		for (int j = 17; j < 33; j++)
		{
			stringBuilder2.Append(array[j]);
			if (j != 32)
			{
				stringBuilder2.Append('\n');
			}
		}
		ArenaPattern arenaPattern = ScriptableObject.CreateInstance<ArenaPattern>();
		arenaPattern.heights = stringBuilder.ToString();
		arenaPattern.prefabs = stringBuilder2.ToString();
		arenaPattern.name = relativePath;
		patternCache[relativePath] = arenaPattern;
		return arenaPattern;
	}

	public void NextPage()
	{
		if (currentPage != maxPages)
		{
			currentPage++;
			BuildButtons();
		}
	}

	public void PreviousPage()
	{
		if (currentPage != 1)
		{
			currentPage--;
			BuildButtons();
		}
	}

	public void OpenEditor()
	{
		try
		{
			Process process = new Process();
			process.StartInfo.FileName = Path.Combine(Application.streamingAssetsPath, "cgef", "cgef.exe");
			process.Start();
		}
		catch
		{
			Application.OpenURL("https://cyber.pitr.dev/");
		}
	}
}



public class CustomTextures : DirectoryTreeBrowser<FileInfo>
{
	private enum EditMode
	{
		None,
		Grid,
		Skybox,
		Emission
	}

	[SerializeField]
	private Material[] gridMaterials;

	[SerializeField]
	private OutdoorLightMaster olm;

	[SerializeField]
	private Material skyMaterial;

	[SerializeField]
	private Texture defaultGlow;

	[SerializeField]
	private Texture[] defaultGridTextures;

	[SerializeField]
	private Texture defaultEmission;

	[SerializeField]
	private Texture[] defaultSkyboxes;

	[SerializeField]
	private GameObject gridWrapper;

	[SerializeField]
	private Image gridBtnFrame;

	[SerializeField]
	private Image skyboxBtnFrame;

	[SerializeField]
	private Image emissionBtnFrame;

	private Dictionary<string, Texture2D> imageCache = new Dictionary<string, Texture2D>();

	private EditMode currentEditMode;

	private bool editBase = true;

	private bool editTop = true;

	private bool editTopRow = true;

	[SerializeField]
	private Image baseBtnFrame;

	[SerializeField]
	private Image topBtnFrame;

	[SerializeField]
	private Image topRowBtnFrame;

	[SerializeField]
	private Slider glowSlider;

	private static readonly int EmissiveTex = Shader.PropertyToID("_EmissiveTex");

	public static readonly string[] AllowedExtensions = new string[3] { ".png", ".jpg", ".jpeg" };

	private string TexturesPath => Path.Combine(Directory.GetParent(Application.dataPath).FullName, "CyberGrind", "Textures");

	protected override int maxPageLength => 14;

	protected override IDirectoryTree<FileInfo> baseDirectory => new FileDirectoryTree(TexturesPath);

	public bool TryToLoad(string key)
	{
		if (!File.Exists(Path.Combine(TexturesPath, key)))
		{
			Debug.LogError("Tried to load an invalid texture! " + key);
			return false;
		}
		LoadTexture(key);
		return true;
	}

	public void SetEditMode(int m)
	{
		GoToBase();
		EditMode editMode = (currentEditMode = (EditMode)m);
		switch (editMode)
		{
		case EditMode.Grid:
			gridBtnFrame.color = Color.red;
			skyboxBtnFrame.color = Color.white;
			emissionBtnFrame.color = Color.white;
			break;
		case EditMode.Skybox:
			gridBtnFrame.color = Color.white;
			skyboxBtnFrame.color = Color.red;
			emissionBtnFrame.color = Color.white;
			break;
		case EditMode.Emission:
			gridBtnFrame.color = Color.white;
			skyboxBtnFrame.color = Color.white;
			emissionBtnFrame.color = Color.red;
			break;
		}
		gridWrapper.SetActive(editMode != EditMode.None);
	}

	public void SetGridEditMode(int num)
	{
		switch (num)
		{
		case 0:
			if (editBase)
			{
				editBase = false;
			}
			else
			{
				editBase = true;
			}
			break;
		case 1:
			if (editTop)
			{
				editTop = false;
			}
			else
			{
				editTop = true;
			}
			break;
		case 2:
			if (editTopRow)
			{
				editTopRow = false;
			}
			else
			{
				editTopRow = true;
			}
			break;
		}
		if (editBase)
		{
			baseBtnFrame.color = Color.red;
		}
		else
		{
			baseBtnFrame.color = Color.white;
		}
		if (editTop)
		{
			topBtnFrame.color = Color.red;
		}
		else
		{
			topBtnFrame.color = Color.white;
		}
		if (editTopRow)
		{
			topRowBtnFrame.color = Color.red;
		}
		else
		{
			topRowBtnFrame.color = Color.white;
		}
	}

	public void SetTexture(string key)
	{
		switch (currentEditMode)
		{
		case EditMode.Grid:
			if (editBase)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGrid_" + 0, key);
				gridMaterials[0].mainTexture = imageCache[key];
			}
			if (editTop)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGrid_" + 1, key);
				gridMaterials[1].mainTexture = imageCache[key];
			}
			if (editTopRow)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGrid_" + 2, key);
				gridMaterials[2].mainTexture = imageCache[key];
			}
			break;
		case EditMode.Emission:
			if (editBase)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGlow_" + 0, key);
				gridMaterials[0].SetTexture(EmissiveTex, imageCache[key]);
			}
			if (editTop)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGlow_" + 1, key);
				gridMaterials[1].SetTexture(EmissiveTex, imageCache[key]);
			}
			if (editTopRow)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customGlow_" + 2, key);
				gridMaterials[2].SetTexture(EmissiveTex, imageCache[key]);
			}
			break;
		case EditMode.Skybox:
			MonoSingleton<PrefsManager>.Instance.SetStringLocal("cyberGrind.customSkybox", key);
			skyMaterial.mainTexture = imageCache[key];
			olm?.UpdateSkyboxMaterial();
			break;
		}
	}

	public void SetGlowIntensity()
	{
		MonoSingleton<EndlessGrid>.Instance.glowMultiplier = glowSlider.value;
		MonoSingleton<EndlessGrid>.Instance.UpdateGlow();
		MonoSingleton<PrefsManager>.Instance.SetFloatLocal("cyberGrind.glowIntensity", glowSlider.value);
	}

	private void Start()
	{
		string[] array = new int[3] { 0, 1, 2 }.Select((int i) => MonoSingleton<PrefsManager>.Instance.GetStringLocal("cyberGrind.customGrid_" + i)).ToArray();
		string[] array2 = new int[3] { 0, 1, 2 }.Select((int i) => MonoSingleton<PrefsManager>.Instance.GetStringLocal("cyberGrind.customGlow_" + i)).ToArray();
		for (int j = 0; j < array.Length; j++)
		{
			if (!string.IsNullOrEmpty(array[j]) && TryToLoad(array[j]))
			{
				gridMaterials[j].mainTexture = imageCache[array[j]];
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGrid_" + j);
			}
		}
		for (int k = 0; k < array2.Length; k++)
		{
			if (!string.IsNullOrEmpty(array2[k]) && TryToLoad(array2[k]))
			{
				gridMaterials[k].SetTexture(EmissiveTex, imageCache[array2[k]]);
				continue;
			}
			MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGlow_" + k);
			gridMaterials[k].SetTexture("_EmissiveTex", defaultGlow);
		}
		string stringLocal = MonoSingleton<PrefsManager>.Instance.GetStringLocal("cyberGrind.customSkybox");
		if (!string.IsNullOrEmpty(stringLocal) && TryToLoad(stringLocal))
		{
			skyMaterial.mainTexture = imageCache[stringLocal];
			olm?.UpdateSkyboxMaterial();
		}
		float floatLocal = MonoSingleton<PrefsManager>.Instance.GetFloatLocal("cyberGrind.glowIntensity", -1f);
		if (floatLocal != -1f)
		{
			glowSlider.SetValueWithoutNotify(floatLocal);
			MonoSingleton<EndlessGrid>.Instance.glowMultiplier = glowSlider.value;
			MonoSingleton<EndlessGrid>.Instance.UpdateGlow();
		}
	}

	protected override Action BuildLeaf(FileInfo file, int indexInPage)
	{
		Texture2D texture2D = LoadTexture(file.FullName);
		GameObject btn = UnityEngine.Object.Instantiate(itemButtonTemplate, itemParent, worldPositionStays: false);
		Sprite sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f);
		sprite.texture.filterMode = FilterMode.Point;
		btn.GetComponent<Button>().onClick.RemoveAllListeners();
		btn.GetComponent<Button>().onClick.AddListener(delegate
		{
			SetTexture(file.FullName);
		});
		btn.GetComponent<Image>().sprite = sprite;
		btn.SetActive(value: true);
		return delegate
		{
			UnityEngine.Object.Destroy(btn);
		};
	}

	private Texture2D LoadTexture(string name)
	{
		if (imageCache.ContainsKey(name))
		{
			return imageCache[name];
		}
		byte[] data = File.ReadAllBytes(Path.Combine(TexturesPath, name));
		Texture2D texture2D = new Texture2D(0, 0, TextureFormat.RGBA32, mipChain: false);
		texture2D.filterMode = FilterMode.Point;
		texture2D.LoadImage(data);
		imageCache[name] = texture2D;
		return texture2D;
	}

	public void RemoveCustomPrefs()
	{
		for (int i = 0; i < 3; i++)
		{
			MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGlow_" + i);
			MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGrid_" + i);
		}
		MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customSkybox");
		MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.glowIntensity");
	}

	public void ResetTexture()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("cyberGrind.theme");
		switch (currentEditMode)
		{
		case EditMode.Grid:
			if (editBase)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGrid_" + 0);
				gridMaterials[0].mainTexture = defaultGridTextures[@int];
			}
			if (editTop)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGrid_" + 1);
				gridMaterials[1].mainTexture = defaultGridTextures[@int];
			}
			if (editTopRow)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGrid_" + 2);
				gridMaterials[2].mainTexture = defaultGridTextures[@int];
			}
			break;
		case EditMode.Emission:
			if (editBase)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGlow_" + 0);
				gridMaterials[0].SetTexture(EmissiveTex, defaultEmission);
			}
			if (editTop)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGlow_" + 1);
				gridMaterials[1].SetTexture(EmissiveTex, defaultEmission);
			}
			if (editTopRow)
			{
				MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customGlow_" + 2);
				gridMaterials[2].SetTexture(EmissiveTex, defaultEmission);
			}
			break;
		case EditMode.Skybox:
			skyMaterial.mainTexture = defaultSkyboxes[@int];
			olm?.UpdateSkyboxMaterial();
			MonoSingleton<PrefsManager>.Instance.DeleteKey("cyberGrind.customSkybox");
			break;
		}
	}
}



public class CutsceneSkip : MonoBehaviour
{
	public float addToTimer;

	private float timeLeft;

	public UltrakillEvent onSkip;

	private bool waitingForInput;

	private bool printLengthOfCutscene = true;

	private float startTime;

	private void Start()
	{
		if (CheckLevelRank.CheckLevelStatus() || Debug.isDebugBuild)
		{
			waitingForInput = true;
			timeLeft = addToTimer;
			MonoSingleton<CutsceneSkipText>.Instance.Show();
			startTime = MonoSingleton<StatsManager>.Instance.seconds;
		}
	}

	private void OnEnable()
	{
		if (waitingForInput)
		{
			MonoSingleton<CutsceneSkipText>.Instance.Show();
		}
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<CutsceneSkipText>.Instance && waitingForInput)
		{
			MonoSingleton<CutsceneSkipText>.Instance.Hide();
			if (printLengthOfCutscene)
			{
				Debug.Log("Length of cutscene: " + (MonoSingleton<StatsManager>.Instance.seconds - startTime));
			}
		}
	}

	private void Update()
	{
		if (waitingForInput && MonoSingleton<StatsManager>.Instance.timer)
		{
			timeLeft = Mathf.MoveTowards(timeLeft, 0f, Time.deltaTime);
		}
		if (waitingForInput && MonoSingleton<NewMovement>.Instance.dead)
		{
			waitingForInput = false;
			MonoSingleton<CutsceneSkipText>.Instance.Hide();
		}
	}

	private void LateUpdate()
	{
		if (waitingForInput && MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame)
		{
			waitingForInput = false;
			printLengthOfCutscene = false;
			if (MonoSingleton<OptionsManager>.Instance.paused)
			{
				MonoSingleton<OptionsManager>.Instance.UnPause();
			}
			onSkip.Invoke();
			MonoSingleton<CutsceneSkipText>.Instance.Hide();
			if (timeLeft > 0f)
			{
				MonoSingleton<StatsManager>.Instance.seconds += timeLeft;
				MonoSingleton<WeaponCharges>.Instance.Charge(timeLeft);
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class CutsceneSkipText : MonoSingleton<CutsceneSkipText>
{
	private TMP_Text txt;

	private void Start()
	{
		txt = GetComponent<TMP_Text>();
		Hide();
	}

	public void Show()
	{
		txt.enabled = true;
	}

	public void Hide()
	{
		txt.enabled = false;
	}
}



public class CyberGrindNavHelper : MonoBehaviour
{
	private enum BridgeDirection
	{
		Left,
		Right,
		Top,
		Bottom
	}

	private struct BridgeBlock
	{
		public bool TopBridge;

		public bool BottomBridge;

		public bool LeftBridge;

		public bool RightBridge;
	}

	private BridgeBlock[][] bridges;

	public void ResetLinks()
	{
	}

	public void GenerateLinks(EndlessCube[][] cbs)
	{
	}

	private void CheckNeighbors(EndlessCube[][] cbs, int x, int y)
	{
		bool num = x - 1 >= 0;
		bool flag = x - 2 >= 0;
		bool flag2 = x + 1 < 16;
		bool flag3 = x + 2 < 16;
		bool flag4 = y - 1 >= 0;
		bool flag5 = y - 2 >= 0;
		bool flag6 = y + 1 < 16;
		bool flag7 = y + 2 < 16;
		if (num)
		{
			CheckNeighbors(cbs[x][y], cbs[x - 1][y]);
		}
		if (flag)
		{
			CheckIfBridge(cbs[x][y], cbs[x - 1][y], cbs[x - 2][y], BridgeDirection.Left);
		}
		if (flag2)
		{
			CheckNeighbors(cbs[x][y], cbs[x + 1][y]);
		}
		if (flag3)
		{
			CheckIfBridge(cbs[x][y], cbs[x + 1][y], cbs[x + 2][y], BridgeDirection.Right);
		}
		if (flag4)
		{
			CheckNeighbors(cbs[x][y], cbs[x][y - 1]);
		}
		if (flag5)
		{
			CheckIfBridge(cbs[x][y], cbs[x][y - 1], cbs[x][y - 2], BridgeDirection.Top);
		}
		if (flag6)
		{
			CheckNeighbors(cbs[x][y], cbs[x][y + 1]);
		}
		if (flag7)
		{
			CheckIfBridge(cbs[x][y], cbs[x][y + 1], cbs[x][y + 2], BridgeDirection.Bottom);
		}
	}

	private void CheckIfBridge(EndlessCube dom, EndlessCube mid, EndlessCube sub, BridgeDirection dir)
	{
		if (sub.transform.position.y == dom.transform.position.y && !(dom.transform.position.y - mid.transform.position.y <= 10f) && (dir != BridgeDirection.Bottom || !bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].BottomBridge) && (dir != BridgeDirection.Top || !bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].TopBridge) && (dir != 0 || !bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].LeftBridge) && (dir != BridgeDirection.Right || !bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].RightBridge))
		{
			GameObject obj = new GameObject("NavLink");
			obj.transform.parent = base.transform;
			obj.transform.position = dom.transform.position + Vector3.up * 25f;
			NavMeshLink navMeshLink = obj.AddComponent<NavMeshLink>();
			Vector3 position = sub.transform.position;
			Vector3 position2 = dom.transform.position;
			position.y = 0f;
			position2.y = 0f;
			Vector3 normalized = (position - position2).normalized;
			normalized *= 1.75f;
			navMeshLink.startPoint = normalized;
			navMeshLink.endPoint = sub.transform.position - dom.transform.position - normalized;
			navMeshLink.bidirectional = true;
			navMeshLink.width = 3f;
			navMeshLink.UpdateLink();
			switch (dir)
			{
			case BridgeDirection.Bottom:
				bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].BottomBridge = true;
				bridges[sub.positionOnGrid.x][sub.positionOnGrid.y].TopBridge = true;
				break;
			case BridgeDirection.Top:
				bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].TopBridge = true;
				bridges[sub.positionOnGrid.x][sub.positionOnGrid.y].BottomBridge = true;
				break;
			case BridgeDirection.Left:
				bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].LeftBridge = true;
				bridges[sub.positionOnGrid.x][sub.positionOnGrid.y].RightBridge = true;
				break;
			case BridgeDirection.Right:
				bridges[dom.positionOnGrid.x][dom.positionOnGrid.y].RightBridge = true;
				bridges[sub.positionOnGrid.x][sub.positionOnGrid.y].LeftBridge = true;
				break;
			}
		}
	}

	private void CheckNeighbors(EndlessCube dom, EndlessCube sub)
	{
		if (!sub.blockedByPrefab && !dom.blockedByPrefab)
		{
			CheckNeighbors(dom.transform, sub.transform);
		}
	}

	private void CheckNeighbors(Transform dom, Transform sub)
	{
		if (!(sub.position.y >= dom.position.y) && !(dom.position.y - sub.position.y > 10f))
		{
			GameObject obj = new GameObject("NavLink");
			obj.transform.SetParent(base.transform);
			obj.transform.position = dom.position + Vector3.up * 25f;
			NavMeshLink navMeshLink = obj.AddComponent<NavMeshLink>();
			Vector3 position = sub.position;
			Vector3 position2 = dom.position;
			position.y = 0f;
			position2.y = 0f;
			Vector3 normalized = (position - position2).normalized;
			normalized *= 1.75f;
			navMeshLink.startPoint = normalized;
			navMeshLink.endPoint = sub.position - dom.position;
			navMeshLink.bidirectional = true;
			navMeshLink.width = 5f;
			navMeshLink.UpdateLink();
		}
	}
}



public class CyberGrindSettingsNavigator : MonoBehaviour
{
	public GameObject menu;

	public GameObject tipPanel;

	public GameObject[] allPanels;

	public void GoTo(GameObject panel)
	{
		GameObject[] array = allPanels;
		foreach (GameObject obj in array)
		{
			obj.SetActive(obj == panel);
		}
		tipPanel.SetActive(value: false);
		menu.SetActive(value: true);
		panel.SetActive(value: true);
	}

	public void GoToNoMenu(GameObject panel)
	{
		GoTo(panel);
		menu.SetActive(value: false);
	}
}



public class CyberPooledPrefab : MonoBehaviour
{
	public CyberPooledType Type;

	public EndlessPrefabAnimator Animator;

	public int Index;
}


public enum CyberPooledType
{
	None,
	JumpPad
}



[Serializable]
public class CyberRankData
{
	public int wave;

	public float[] preciseWavesByDifficulty;

	public int[] kills;

	public int[] style;

	public float[] time;

	public CyberRankData()
	{
		preciseWavesByDifficulty = new float[6];
		kills = new int[6];
		style = new int[6];
		time = new float[6];
	}
}



public class DeathMarker : MonoBehaviour
{
	public bool activated;

	private void OnEnable()
	{
		if (!activated)
		{
			activated = true;
			GetComponentInParent<ActivateNextWave>().AddDeadEnemy();
		}
	}
}



public class DeathZone : MonoBehaviour
{
	private NewMovement pm;

	public GameObject sawSound;

	public string deathType;

	public bool dontExplode;

	public bool splatter;

	public bool enemiesCanDodge;

	public bool aliveOnly;

	public bool deleteLimbs;

	public AffectedSubjects affected;

	private bool playerAffected;

	private bool enemyAffected;

	public bool checkForPlayerOutsideTrigger;

	[Space(10f)]
	public bool notInstakill;

	public Vector3 respawnTarget;

	public bool dontChangeRespawnTarget;

	public int damage = 50;

	public int styleAmount = 80;

	private Transform player;

	public EnemyType[] unaffectedEnemyTypes;

	private void Start()
	{
		if (unaffectedEnemyTypes == null)
		{
			unaffectedEnemyTypes = Array.Empty<EnemyType>();
		}
		player = MonoSingleton<NewMovement>.Instance.transform;
		switch (affected)
		{
		case AffectedSubjects.All:
			enemyAffected = true;
			playerAffected = true;
			break;
		case AffectedSubjects.EnemiesOnly:
			enemyAffected = true;
			playerAffected = false;
			break;
		case AffectedSubjects.PlayerOnly:
			enemyAffected = false;
			playerAffected = true;
			break;
		}
		Invoke("SlowUpdate", 1f);
	}

	private void SlowUpdate()
	{
		if (base.gameObject.activeInHierarchy && checkForPlayerOutsideTrigger && player.transform.position.y < base.transform.position.y)
		{
			GotHit(player.GetComponent<Collider>());
		}
		Invoke("SlowUpdate", 1f);
	}

	private void OnTriggerEnter(Collider other)
	{
		GotHit(other);
	}

	private void OnCollisionEnter(Collision collision)
	{
		GotHit(collision.collider);
	}

	private void GotHit(Collider other)
	{
		if (other.gameObject.layer == 20 && (bool)other.transform.parent && other.transform.parent != MonoSingleton<NewMovement>.Instance.transform && other.transform.parent.TryGetComponent<Collider>(out var component))
		{
			other = component;
		}
		if (other.gameObject.CompareTag("Player") && playerAffected)
		{
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
			{
				if (dontExplode || deathType.ToLower() == "fall")
				{
					MonoSingleton<PlatformerMovement>.Instance.Fall();
				}
				else
				{
					MonoSingleton<PlatformerMovement>.Instance.Explode(ignoreInvincible: true);
				}
				return;
			}
			if (!notInstakill)
			{
				if (pm == null)
				{
					pm = other.GetComponent<NewMovement>();
				}
				pm.GetHurt(999999, invincible: false, 1f, explosion: false, instablack: true);
				if (sawSound != null)
				{
					UnityEngine.Object.Instantiate(sawSound, other.transform.position, Quaternion.identity);
				}
				base.enabled = false;
				return;
			}
			if (pm == null)
			{
				pm = other.GetComponent<NewMovement>();
			}
			if (pm.hp > 0)
			{
				if (damage == 0 || pm.hp == 1)
				{
					pm.FakeHurt();
				}
				else if (pm.hp > damage)
				{
					pm.GetHurt(damage, invincible: true);
				}
				else if (pm.hp > 1)
				{
					pm.GetHurt(pm.hp - 1, invincible: true);
				}
				if (sawSound != null)
				{
					UnityEngine.Object.Instantiate(sawSound, other.transform.position, Quaternion.identity);
				}
				other.gameObject.GetComponent<Rigidbody>().velocity = Vector3.zero;
				StatsManager instance = MonoSingleton<StatsManager>.Instance;
				_ = Vector3.zero;
				if (respawnTarget != Vector3.zero)
				{
					other.transform.position = respawnTarget + Vector3.up * 1.25f;
				}
				else if (instance.currentCheckPoint != null)
				{
					other.transform.position = instance.currentCheckPoint.transform.position + Vector3.up * 1.25f;
				}
				else
				{
					other.transform.position = instance.spawnPos;
				}
			}
		}
		else if ((other.gameObject.CompareTag("Enemy") || other.gameObject.layer == 10) && enemyAffected)
		{
			EnemyIdentifier enemyIdentifier = other.gameObject.GetComponentInParent<EnemyIdentifier>();
			if (enemyIdentifier == null)
			{
				EnemyIdentifierIdentifier component2 = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
				if (component2 != null)
				{
					if (component2.eid != null)
					{
						enemyIdentifier = component2.eid;
					}
					else
					{
						UnityEngine.Object.Destroy(component2.gameObject);
					}
				}
			}
			if (!(enemyIdentifier != null))
			{
				return;
			}
			if (unaffectedEnemyTypes.Length != 0)
			{
				for (int i = 0; i < unaffectedEnemyTypes.Length; i++)
				{
					if (unaffectedEnemyTypes[i] == enemyIdentifier.enemyType)
					{
						return;
					}
				}
			}
			if ((!dontExplode && !aliveOnly && !enemyIdentifier.exploded) || !enemyIdentifier.dead)
			{
				if (sawSound != null)
				{
					UnityEngine.Object.Instantiate(sawSound, other.transform.position, Quaternion.identity);
				}
				enemyIdentifier.hitter = "deathzone";
				StyleHUD instance2 = MonoSingleton<StyleHUD>.Instance;
				if ((bool)instance2 && !enemyIdentifier.puppet)
				{
					if (!enemyIdentifier.dead)
					{
						instance2.AddPoints(styleAmount, deathType, null, enemyIdentifier);
					}
					else
					{
						instance2.AddPoints(styleAmount / 4, (deathType == "") ? "" : ("<color=grey>" + deathType + "</color>"), null, enemyIdentifier);
					}
				}
				if (enemiesCanDodge)
				{
					EnemyIdentifier.FallOnEnemy(enemyIdentifier);
				}
				if (splatter)
				{
					enemyIdentifier.Splatter(styleBonus: false);
				}
				else if (!dontExplode)
				{
					enemyIdentifier.Explode();
					if (enemyIdentifier.enemyType == EnemyType.Gutterman && enemyIdentifier.TryGetComponent<Gutterman>(out var component3))
					{
						component3.Explode();
					}
				}
				else
				{
					enemyIdentifier.InstaKill();
				}
			}
			if (deleteLimbs && enemyIdentifier.dead && !enemyIdentifier.DestroyLimb(other.transform))
			{
				other.gameObject.SetActive(value: false);
				other.transform.position = new Vector3(-100f, -100f, -100f);
				other.transform.localScale = Vector3.zero;
			}
		}
		else if (other.gameObject.CompareTag("Coin"))
		{
			other.GetComponent<Coin>()?.GetDeleted();
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class DebugUI : MonoSingleton<DebugUI>
{
	public static bool previewRumble;

	[SerializeField]
	private GameObject rumbleContainer;

	[SerializeField]
	private RectTransform rumbleIconTransform;

	[SerializeField]
	private Image rumbleImage;

	[SerializeField]
	private Slider rumbleIntensityBar;

	private void Update()
	{
		if (!previewRumble)
		{
			rumbleContainer.gameObject.SetActive(value: false);
			return;
		}
		float currentIntensity = MonoSingleton<RumbleManager>.Instance.currentIntensity;
		rumbleContainer.gameObject.SetActive(value: true);
		float x = Mathf.Sin(Time.time * 100f) * (currentIntensity * 6f);
		rumbleIconTransform.anchoredPosition = new Vector2(x, rumbleIconTransform.anchoredPosition.y);
		rumbleImage.color = new Color(1f, 1f, 1f, (currentIntensity == 0f) ? 0.3f : 1f);
		rumbleIntensityBar.gameObject.SetActive(currentIntensity > 0f);
		rumbleIntensityBar.value = currentIntensity;
	}
}


public enum DecimalType
{
	NoLimit,
	Three,
	Two,
	One,
	NoDecimals
}



internal class DeckShuffled<T> : IEnumerable<T>, IEnumerable
{
	private List<T> current;

	public DeckShuffled(IEnumerable<T> target)
	{
		current = Randomize(target).ToList();
	}

	public void Reshuffle()
	{
		if (current.Count > 1)
		{
			IEnumerable<T> source = current.Take(Mathf.FloorToInt(current.Count / 2));
			IEnumerable<T> source2 = current.Skip(Mathf.FloorToInt(current.Count / 2));
			current = Randomize(source).Concat(Randomize(source2)).ToList();
		}
	}

	private static IEnumerable<T> Randomize(IEnumerable<T> source)
	{
		T[] arr = source.ToArray();
		for (int i = arr.Length - 1; i > 0; i--)
		{
			int swapIndex = Random.Range(0, i + 1);
			yield return arr[swapIndex];
			arr[swapIndex] = arr[i];
		}
		yield return arr[0];
	}

	public IEnumerator<T> GetEnumerator()
	{
		return current.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return current.GetEnumerator();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class DefaultReferenceManager : MonoSingleton<DefaultReferenceManager>
{
	public GameObject wetParticle;

	public GameObject sandDrip;

	public GameObject blessingGlow;

	public GameObject sandificationEffect;

	public GameObject enrageEffect;

	public GameObject ineffectiveSound;

	public GameObject continuousSplash;

	public GameObject projectile;

	public GameObject parryableFlash;

	public GameObject unparryableFlash;

	public GameObject explosion;

	public GameObject superExplosion;

	public Material puppetMaterial;

	public GameObject puppetSpawn;

	public Material blankMaterial;

	public GameObject madnessEffect;

	public LineRenderer electricLine;

	public GameObject zapImpactParticle;
}


[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class DefaultSandboxCheckpoint : MonoSingleton<DefaultSandboxCheckpoint>
{
	public CheckPoint checkpoint;
}



public class DelayedActivationManager : MonoSingleton<DelayedActivationManager>
{
	private List<GameObject> toActivate = new List<GameObject>();

	private List<float> activateCountdowns = new List<float>();

	private void Update()
	{
		if (activateCountdowns.Count == 0)
		{
			return;
		}
		for (int num = activateCountdowns.Count - 1; num >= 0; num--)
		{
			if (toActivate[num] == null)
			{
				toActivate.RemoveAt(num);
				activateCountdowns.RemoveAt(num);
			}
			else
			{
				activateCountdowns[num] = Mathf.MoveTowards(activateCountdowns[num], 0f, Time.deltaTime);
				if (activateCountdowns[num] == 0f)
				{
					toActivate[num].SetActive(value: true);
					toActivate.RemoveAt(num);
					activateCountdowns.RemoveAt(num);
				}
			}
		}
	}

	public void Add(GameObject target, float time)
	{
		toActivate.Add(target);
		activateCountdowns.Add(time);
	}

	public void Remove(GameObject target)
	{
		if (toActivate.Count == 0)
		{
			return;
		}
		for (int i = 0; i < toActivate.Count; i++)
		{
			if (toActivate[i] == target)
			{
				toActivate.RemoveAt(i);
				activateCountdowns.RemoveAt(i);
				break;
			}
		}
	}
}



public class DeletePlayerPref : MonoBehaviour
{
	public string playerPref;

	private void Start()
	{
		string text = playerPref;
		if (text == "cg_custom_pool")
		{
			playerPref = "cyberGrind.customPool";
		}
		MonoSingleton<PrefsManager>.Instance.DeleteKey(playerPref);
	}
}



public class DestroyAudio : MonoBehaviour
{
	public float time;

	private void Start()
	{
		Invoke("Delet", time);
	}

	private void Delet()
	{
		Object.Destroy(GetComponent<AudioSource>());
		Object.Destroy(this);
	}
}



[DisallowMultipleComponent]
public sealed class DestroyMessage : MessageDispatcher
{
	private void OnDestroy()
	{
		base.Handler.Invoke();
	}
}



public class DestroyObjects : MonoBehaviour
{
	[SerializeField]
	private bool destroyOnEnable;

	[SerializeField]
	private bool dontDestroyOnTrigger;

	[SerializeField]
	private GameObject[] targets;

	private void OnEnable()
	{
		if (destroyOnEnable)
		{
			Destroy();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player") && !dontDestroyOnTrigger)
		{
			Destroy();
		}
	}

	public void Destroy()
	{
		GameObject[] array = targets;
		foreach (GameObject gameObject in array)
		{
			if (gameObject != null)
			{
				Object.Destroy(gameObject);
			}
		}
	}
}



public class DestroyOnCheckpointRestart : MonoBehaviour
{
	public bool dontDestroy;
}



public class DestroyOnDisable : MonoBehaviour
{
	[HideInInspector]
	public bool beenActivated;

	private void Start()
	{
		if (!beenActivated)
		{
			beenActivated = true;
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.activeSelf)
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class DetachFromParent : MonoBehaviour
{
	public bool detachOnStart;

	private void Start()
	{
		if (detachOnStart)
		{
			Detach();
		}
	}

	public void Detach()
	{
		base.transform.SetParent(null, worldPositionStays: true);
	}
}



public class DietProp : MonoBehaviour
{
	public DietProp parent;
}



public class DifficultyDependantObject : MonoBehaviour
{
	public bool autoDeactivate = true;

	[Header("Active in difficulties:")]
	public bool veryEasy = true;

	public bool easy = true;

	public bool normal = true;

	public bool hard = true;

	public bool veryHard = true;

	public bool UKMD = true;

	[Header("Optional events: ")]
	public UnityEvent onRightDifficulty;

	public UnityEvent onWrongDifficulty;

	private void Awake()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		bool flag = false;
		switch (@int)
		{
		case 0:
			if (veryEasy)
			{
				flag = true;
			}
			break;
		case 1:
			if (easy)
			{
				flag = true;
			}
			break;
		case 2:
			if (normal)
			{
				flag = true;
			}
			break;
		case 3:
			if (hard)
			{
				flag = true;
			}
			break;
		case 4:
			if (veryHard)
			{
				flag = true;
			}
			break;
		case 5:
			if (UKMD)
			{
				flag = true;
			}
			break;
		}
		if (flag)
		{
			onRightDifficulty?.Invoke();
			return;
		}
		onWrongDifficulty?.Invoke();
		if (autoDeactivate)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}



public class DifficultySelectButton : MonoBehaviour
{
	public int difficulty;

	private int stage;

	private int level;

	private void Start()
	{
		level = GameProgressSaver.GetProgress(difficulty);
		if (level > 5)
		{
			level -= 5;
			stage = 1;
			while (level > 10)
			{
				level -= 10;
				stage += 3;
			}
			while (level > 4)
			{
				level -= 4;
				stage++;
			}
		}
		base.transform.Find("Progress").GetComponent<TMP_Text>().text = stage + "-" + level;
	}

	public void SetDifficulty()
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("difficulty", difficulty);
		Debug.Log("Set Difficulty to: " + difficulty);
	}
}



public class DifficultyTitle : MonoBehaviour
{
	public bool lines;

	private TMP_Text txt2;

	private void Start()
	{
		Check();
	}

	private void OnEnable()
	{
		Check();
	}

	private void Check()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		string text = "";
		if (lines)
		{
			text += "-- ";
		}
		switch (@int)
		{
		case 0:
			text += "HARMLESS";
			break;
		case 1:
			text += "LENIENT";
			break;
		case 2:
			text += "STANDARD";
			break;
		case 3:
			text += "VIOLENT";
			break;
		case 4:
			text += "BRUTAL";
			break;
		case 5:
			text += "ULTRAKILL MUST DIE";
			break;
		}
		if (lines)
		{
			text += " --";
		}
		if (!txt2)
		{
			txt2 = GetComponent<TMP_Text>();
		}
		if ((bool)txt2)
		{
			txt2.text = text;
		}
	}
}



public abstract class DirectoryTreeBrowser<T> : MonoBehaviour
{
	[SerializeField]
	protected GameObject itemButtonTemplate;

	[SerializeField]
	protected GameObject folderButtonTemplate;

	[SerializeField]
	protected Transform itemParent;

	[SerializeField]
	protected GameObject backButton;

	[SerializeField]
	protected GameObject plusButton;

	[SerializeField]
	private TMP_Text pageText;

	private List<Action> cleanupActions = new List<Action>();

	protected IDirectoryTree<T> currentDirectory;

	protected int maxPages;

	protected int currentPage;

	protected abstract int maxPageLength { get; }

	protected abstract IDirectoryTree<T> baseDirectory { get; }

	public static FakeDirectoryTree<T> Folder(string name, List<T> files = null, List<IDirectoryTree<T>> children = null, IDirectoryTree<T> parent = null)
	{
		FakeDirectoryTree<T> fakeDirectoryTree = new FakeDirectoryTree<T>(name, files, children);
		if (children != null)
		{
			foreach (IDirectoryTree<T> child in children)
			{
				child.parent = fakeDirectoryTree;
			}
		}
		return fakeDirectoryTree;
	}

	private void Awake()
	{
		currentDirectory = baseDirectory;
		Rebuild();
	}

	public int PageOf(int index)
	{
		return Mathf.CeilToInt(index / maxPageLength);
	}

	public void SetPage(int target)
	{
		currentPage = Mathf.Clamp(target, 0, maxPages - 1);
		Rebuild(setToPageZero: false);
	}

	public void NextPage()
	{
		SetPage(currentPage + 1);
	}

	public void PreviousPage()
	{
		SetPage(currentPage - 1);
	}

	public void StepUp()
	{
		currentDirectory = currentDirectory.parent ?? currentDirectory;
		Rebuild();
	}

	public void StepDown(IDirectoryTree<T> dir)
	{
		currentDirectory = dir;
		Rebuild();
	}

	public void GoToBase()
	{
		if (currentDirectory != baseDirectory)
		{
			currentDirectory = baseDirectory;
			Rebuild();
		}
	}

	public virtual void Rebuild(bool setToPageZero = true)
	{
		if (setToPageZero)
		{
			currentPage = 0;
		}
		currentDirectory.Refresh();
		int num = maxPageLength;
		if ((bool)backButton)
		{
			backButton.SetActive(currentDirectory.parent != null);
		}
		foreach (Action cleanupAction in cleanupActions)
		{
			cleanupAction?.Invoke();
		}
		cleanupActions.Clear();
		List<IDirectoryTree<T>> list = currentDirectory.children.Skip(currentPage * num).Take(num).ToList();
		int num2 = 0;
		foreach (IDirectoryTree<T> item in list)
		{
			Action action = BuildDirectory(item, num2++);
			if (action != null)
			{
				cleanupActions.Add(action);
			}
		}
		List<T> list2 = currentDirectory.files.Skip(currentPage * num - currentDirectory.children.Count()).Take(num - list.Count).ToList();
		num2 = 0;
		foreach (T item2 in list2)
		{
			Action action2 = BuildLeaf(item2, num2++);
			if (action2 != null)
			{
				cleanupActions.Add(action2);
			}
		}
		int num3 = currentDirectory.children.Count() + currentDirectory.files.Count();
		if ((bool)plusButton)
		{
			num3++;
			plusButton.transform.SetAsLastSibling();
			if (list.Count + list2.Count < maxPageLength)
			{
				plusButton.SetActive(value: true);
			}
			else
			{
				plusButton.SetActive(value: false);
			}
		}
		maxPages = Mathf.CeilToInt((float)num3 / (float)num);
		pageText.text = $"{currentPage + 1}/{maxPages}";
	}

	protected abstract Action BuildLeaf(T item, int indexInPage);

	protected virtual Action BuildDirectory(IDirectoryTree<T> folder, int indexInPage)
	{
		GameObject btn = UnityEngine.Object.Instantiate(folderButtonTemplate, itemParent, worldPositionStays: false);
		btn.GetComponent<Button>().onClick.RemoveAllListeners();
		btn.GetComponent<Button>().onClick.AddListener(delegate
		{
			StepDown(folder);
		});
		btn.GetComponentInChildren<TMP_Text>().text = folder.name.ToUpper();
		btn.SetActive(value: true);
		return delegate
		{
			UnityEngine.Object.Destroy(btn);
		};
	}
}



public class DisableAtDistance : MonoBehaviour
{
	public float distance;

	public GameObject toDisable;

	private void Update()
	{
		if ((bool)MonoSingleton<CameraController>.Instance)
		{
			if (toDisable.activeSelf && Vector3.Distance(base.transform.position, MonoSingleton<CameraController>.Instance.transform.position) > distance)
			{
				toDisable.SetActive(value: false);
			}
			else if (!toDisable.activeSelf && Vector3.Distance(base.transform.position, MonoSingleton<CameraController>.Instance.transform.position) < distance)
			{
				toDisable.SetActive(value: true);
			}
		}
	}
}



public class DisableChildScrollingTexturesOnPref : MonoBehaviour
{
	public bool localPref;

	public string prefName;

	public bool disableIfTrue = true;

	private void OnEnable()
	{
		bool flag = (localPref ? MonoSingleton<PrefsManager>.Instance.GetBoolLocal(prefName) : MonoSingleton<PrefsManager>.Instance.GetBool(prefName));
		if (disableIfTrue ? flag : (!flag))
		{
			ScrollingTexture[] componentsInChildren = GetComponentsInChildren<ScrollingTexture>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
		}
	}
}



public class DisabledEnemiesChecker : MonoBehaviour
{
	private bool activated;

	public float delay;

	public UnityEvent onDisabledEnemies;

	private void Update()
	{
		if (!activated && (bool)MonoSingleton<StatsManager>.Instance && MonoSingleton<StatsManager>.Instance.levelStarted && DisableEnemySpawns.DisableArenaTriggers)
		{
			activated = true;
			Invoke("Activate", delay);
		}
	}

	private void Activate()
	{
		onDisabledEnemies?.Invoke();
	}
}



public class DisableLightsOnFullBright : MonoBehaviour
{
	private Light[] lights;

	private bool fullBrightActive;

	private void OnEnable()
	{
		fullBrightActive = FullBright.Enabled;
		if (fullBrightActive)
		{
			SetLightsEnabled(isEnabled: false);
		}
	}

	private void Update()
	{
		if (fullBrightActive && !FullBright.Enabled)
		{
			fullBrightActive = false;
			SetLightsEnabled(isEnabled: true);
		}
		else if (!fullBrightActive && FullBright.Enabled)
		{
			fullBrightActive = true;
			SetLightsEnabled(isEnabled: false);
		}
	}

	private void SetLightsEnabled(bool isEnabled)
	{
		if (lights == null)
		{
			lights = GetComponentsInChildren<Light>();
		}
		Light[] array = lights;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = isEnabled;
		}
	}
}



[DisallowMultipleComponent]
public sealed class DisableMessage : MessageDispatcher
{
	private void OnDisable()
	{
		base.Handler.Invoke();
	}
}



public class DisablePowerUp : MonoBehaviour
{
	private void Start()
	{
		if (MonoSingleton<PowerUpMeter>.Instance.juice > 0f && !InfinitePowerUps.Enabled)
		{
			MonoSingleton<PowerUpMeter>.Instance.EndPowerUp();
		}
	}
}



public class DiscChange : MonoBehaviour
{
	public string targetLevelName;

	private bool ready;

	private bool done;

	[SerializeField]
	private GameObject discSound;

	private void Update()
	{
		if (ready && !done)
		{
			done = true;
			PlayerPrefs.SetInt("DisCha", 1);
			discSound.transform.parent = null;
			Object.DontDestroyOnLoad(discSound);
			if (discSound.TryGetComponent<FadeOut>(out var component))
			{
				component.BeginFade();
			}
			SceneHelper.LoadScene(targetLevelName, noBlocker: true);
		}
	}

	public void ReadyToChangeLevel()
	{
		ready = true;
	}
}



public class DiscordController : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("Discord");

	public static DiscordController Instance;

	[SerializeField]
	private long discordClientId;

	[Space]
	[SerializeField]
	private SerializedActivityAssets customLevelActivityAssets;

	[SerializeField]
	private SerializedActivityAssets missingActivityAssets;

	[SerializeField]
	private ActivityRankIcon[] rankIcons;

	private global::Discord.Discord discord;

	private ActivityManager activityManager;

	private int lastPoints;

	private bool disabled;

	private Activity cachedActivity;

	private void Awake()
	{
		if ((bool)Instance)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Instance = this;
		base.transform.SetParent(null);
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		bool @bool = MonoSingleton<PrefsManager>.Instance.GetBool("discordIntegration");
		if (@bool)
		{
			Enable();
		}
		disabled = !@bool;
	}

	private void Update()
	{
		if (discord == null || disabled)
		{
			return;
		}
		try
		{
			discord.RunCallbacks();
		}
		catch (Exception)
		{
			Log.Warning("Discord lost");
			disabled = true;
			discord.Dispose();
		}
	}

	private void OnApplicationQuit()
	{
		if (discord != null && !disabled)
		{
			discord.Dispose();
		}
	}

	public static void UpdateRank(int rank)
	{
		if ((bool)Instance && !Instance.disabled)
		{
			if (Instance.rankIcons.Length <= rank)
			{
				Log.Error("Discord Controller is missing rank names/icons!");
				return;
			}
			Instance.cachedActivity.Assets.SmallText = Instance.rankIcons[rank].Text;
			Instance.cachedActivity.Assets.SmallImage = Instance.rankIcons[rank].Image;
			Instance.SendActivity();
		}
	}

	public static void UpdateStyle(int points)
	{
		if ((bool)Instance && !Instance.disabled && Instance.lastPoints != points)
		{
			Instance.lastPoints = points;
			Instance.cachedActivity.Details = "STYLE: " + points;
			Instance.SendActivity();
		}
	}

	public static void UpdateWave(int wave)
	{
		if ((bool)Instance && !Instance.disabled && Instance.lastPoints != wave)
		{
			Instance.lastPoints = wave;
			Instance.cachedActivity.Details = "WAVE: " + wave;
			Instance.SendActivity();
		}
	}

	public static void Disable()
	{
		if ((bool)Instance && Instance.discord != null && !Instance.disabled)
		{
			Instance.disabled = true;
			Instance.activityManager.ClearActivity(delegate
			{
			});
		}
	}

	public static void Enable()
	{
		if (!Instance || Instance.discord != null)
		{
			return;
		}
		try
		{
			Instance.discord = new global::Discord.Discord(Instance.discordClientId, 1uL);
			Instance.activityManager = Instance.discord.GetActivityManager();
			Log.Info("Discord initialized!");
			Instance.disabled = false;
			Instance.ResetActivityCache();
		}
		catch (Exception)
		{
			Log.Info("Couldn't initialize Discord");
			Instance.disabled = true;
		}
	}

	private void ResetActivityCache()
	{
		cachedActivity = new Activity
		{
			State = "LOADING",
			Assets = 
			{
				LargeImage = "generic",
				LargeText = "LOADING"
			},
			Instance = true
		};
	}

	public void FetchSceneActivity(string scene)
	{
		if (!Instance || Instance.disabled || Instance.discord == null)
		{
			return;
		}
		ResetActivityCache();
		if (SceneHelper.IsPlayingCustom)
		{
			cachedActivity.State = "Playing Custom Level";
			cachedActivity.Assets = customLevelActivityAssets.Deserialize();
		}
		else
		{
			StockMapInfo instance = StockMapInfo.Instance;
			if ((bool)instance)
			{
				cachedActivity.Assets = instance.assets.Deserialize();
				if (string.IsNullOrEmpty(cachedActivity.Assets.LargeImage))
				{
					cachedActivity.Assets.LargeImage = missingActivityAssets.Deserialize().LargeImage;
				}
				if (string.IsNullOrEmpty(cachedActivity.Assets.LargeText))
				{
					cachedActivity.Assets.LargeText = missingActivityAssets.Deserialize().LargeText;
				}
			}
			else
			{
				cachedActivity.Assets = missingActivityAssets.Deserialize();
			}
			if (scene == "Main Menu")
			{
				cachedActivity.State = "Main Menu";
			}
			else
			{
				cachedActivity.State = "DIFFICULTY: " + MonoSingleton<PresenceController>.Instance.diffNames[MonoSingleton<PrefsManager>.Instance.GetInt("difficulty")];
			}
		}
		DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
		long start = (long)(DateTime.UtcNow - dateTime).TotalSeconds;
		cachedActivity.Timestamps = new ActivityTimestamps
		{
			Start = start
		};
		SendActivity();
	}

	private void SendActivity()
	{
		if (discord != null && activityManager != null && !disabled)
		{
			activityManager.UpdateActivity(cachedActivity, delegate
			{
			});
		}
	}
}



public class DistantSprite : MonoBehaviour
{
	private SpriteRenderer sr;

	private Color clr;

	private float distance;

	private float originalAlpha;

	public float mininumDistance;

	public float maximumDistance;

	private void Start()
	{
		sr = GetComponent<SpriteRenderer>();
		originalAlpha = sr.color.a;
	}

	private void Update()
	{
		clr = sr.color;
		distance = Vector3.Distance(base.transform.position, MonoSingleton<CameraController>.Instance.transform.position);
		if (distance > mininumDistance)
		{
			if (distance > maximumDistance)
			{
				clr.a = originalAlpha;
			}
			else
			{
				clr.a = Mathf.Lerp(0f, originalAlpha, (distance - mininumDistance) / (maximumDistance - mininumDistance));
			}
		}
		else
		{
			clr.a = 0f;
		}
		sr.color = clr;
	}
}



public class DistantThunder : MonoBehaviour
{
	private Renderer rend;

	private Light[] lights;

	private float[] lightIntensities;

	private AudioSource aud;

	public float delay;

	public float delayRandomizer;

	public float firstTimeDelay = -1f;

	public float fadeSpeed = 1f;

	private MaterialPropertyBlock block;

	private Color clr;

	private float fade;

	private float originalPitch;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		aud = GetComponent<AudioSource>();
		lights = GetComponentsInChildren<Light>();
		if (lights.Length != 0)
		{
			lightIntensities = new float[lights.Length];
			for (int i = 0; i < lightIntensities.Length; i++)
			{
				lightIntensities[i] = lights[i].intensity;
				lights[i].intensity = 0f;
			}
		}
		if ((bool)aud)
		{
			originalPitch = aud.pitch;
		}
		block = new MaterialPropertyBlock();
		UpdateColor();
		Invoke("Thunder", (firstTimeDelay >= 0f) ? firstTimeDelay : (delay + Random.Range(0f - delayRandomizer, delayRandomizer)));
	}

	private void Update()
	{
		if (fade > 0f)
		{
			fade = Mathf.MoveTowards(fade, 0f, fadeSpeed * Time.deltaTime);
			UpdateColor();
		}
	}

	private void Thunder()
	{
		fade = 1f;
		UpdateColor();
		if ((bool)aud)
		{
			aud.pitch = originalPitch + Random.Range(-0.1f, 0.1f);
			aud.Play();
		}
		Invoke("Thunder", delay + Random.Range(0f - delayRandomizer, delayRandomizer));
	}

	private void UpdateColor()
	{
		if ((bool)rend)
		{
			clr = Color.white * fade;
			rend.GetPropertyBlock(block, 0);
			block.SetColor(UKShaderProperties.Color, clr);
			rend.SetPropertyBlock(block, 0);
		}
		if (lights != null && lights.Length != 0)
		{
			for (int i = 0; i < lightIntensities.Length; i++)
			{
				lights[i].intensity = lightIntensities[i] * fade;
			}
		}
	}

	public void ForceThunder()
	{
		CancelInvoke("Thunder");
		Thunder();
	}
}



public class DontDestroy : MonoBehaviour
{
	private void Awake()
	{
		Object.DontDestroyOnLoad(base.gameObject);
	}
}



public class Door : MonoBehaviour
{
	public DoorType doorType;

	private BigDoor[] bdoors;

	private SubDoor[] subdoors;

	public bool open;

	public bool gotValues;

	public bool gotPos;

	public Vector3 closedPos;

	public Vector3 openPos;

	[HideInInspector]
	public Vector3 openPosRelative;

	public bool startOpen;

	[HideInInspector]
	public Vector3 targetPos;

	public float speed;

	[HideInInspector]
	public bool inPos = true;

	public bool reverseDirection;

	public int requests;

	private AudioSource aud;

	public AudioClip openSound;

	public AudioClip closeSound;

	private AudioSource aud2;

	private MaterialPropertyBlock block;

	public bool locked;

	public GameObject noPass;

	private NavMeshObstacle nmo;

	public GameObject[] activatedRooms;

	public GameObject[] deactivatedRooms;

	public Light openLight;

	public UnityEvent onFullyOpened;

	public UnityEvent onFullyClosed;

	private Door[] allDoors;

	public bool screenShake;

	public bool dontCloseWhenAnotherDoorOpens;

	public bool dontCloseOtherDoorsWhenOpening;

	private CameraController cc;

	private DoorLock thisLock;

	private List<DoorLock> locks = new List<DoorLock>();

	private int openLocks;

	[HideInInspector]
	public DoorController[] docons;

	[HideInInspector]
	public List<bool> origDoconStates = new List<bool>();

	private bool doconless;

	private Collider doconlessClosingCol;

	private MeshRenderer[] lightsMeshRenderers;

	public Color defaultLightsColor;

	public Color currentLightsColor;

	public bool turnEmissiveOffWhenLocked;

	private OcclusionPortal occpor;

	public bool ignoreHookCheck;

	public bool openOnUnlock;

	private void Awake()
	{
		block = new MaterialPropertyBlock();
		lightsMeshRenderers = GetComponentsInChildren<MeshRenderer>();
		nmo = GetComponent<NavMeshObstacle>();
		occpor = GetComponent<OcclusionPortal>();
		if (!occpor)
		{
			occpor = GetComponentInChildren<OcclusionPortal>();
		}
		if (requests == 1)
		{
			requests = 0;
			startOpen = true;
		}
		if (nmo != null && (startOpen || open))
		{
			nmo.enabled = false;
		}
		if (doorType == DoorType.Normal)
		{
			aud = GetComponent<AudioSource>();
			if (!gotPos)
			{
				GetPos();
			}
			else if (openPosRelative == Vector3.zero)
			{
				openPosRelative = base.transform.localPosition + openPos;
			}
		}
		else if (doorType == DoorType.BigDoorController)
		{
			bdoors = GetComponentsInChildren<BigDoor>(includeInactive: true);
			if (startOpen && !open)
			{
				BigDoor[] array = bdoors;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].open = true;
				}
			}
		}
		else if (doorType == DoorType.SubDoorController)
		{
			subdoors = GetComponentsInChildren<SubDoor>(includeInactive: true);
			if (startOpen)
			{
				SubDoor[] array2 = subdoors;
				foreach (SubDoor subDoor in array2)
				{
					subDoor.SetValues();
					if (subDoor.transform.localPosition == subDoor.origPos)
					{
						subDoor.transform.localPosition = subDoor.origPos + subDoor.openPos;
						subDoor.Open();
					}
				}
			}
		}
		if (noPass != null)
		{
			aud2 = base.transform.GetChild(0).GetComponent<AudioSource>();
			if (!aud2)
			{
				aud2 = GetComponentInChildren<AudioSource>();
			}
		}
		if (openLight != null && !startOpen)
		{
			openLight.enabled = false;
		}
		DoorLock[] componentsInChildren = GetComponentsInChildren<DoorLock>();
		if (componentsInChildren.Length != 0)
		{
			DoorLock[] array3 = componentsInChildren;
			foreach (DoorLock doorLock in array3)
			{
				if (doorLock.gameObject == base.gameObject)
				{
					thisLock = doorLock;
					continue;
				}
				locks.Add(doorLock);
				doorLock.parentDoor = this;
			}
		}
		if (doorType == DoorType.BigDoorController || doorType == DoorType.SubDoorController)
		{
			docons = GetComponentsInChildren<DoorController>();
		}
		else if (base.transform.parent != null)
		{
			docons = base.transform.parent.GetComponentsInChildren<DoorController>();
		}
		if (docons == null)
		{
			docons = new DoorController[0];
		}
		if (((componentsInChildren.Length != 0 && thisLock == null) || componentsInChildren.Length > 1) && docons.Length != 0)
		{
			for (int j = 0; j < docons.Length; j++)
			{
				if (docons[j].gameObject.activeInHierarchy)
				{
					origDoconStates.Add(item: true);
				}
				else
				{
					origDoconStates.Add(item: false);
				}
				docons[j].gameObject.SetActive(value: false);
			}
		}
		else if ((docons == null || docons.Length == 0) && base.gameObject.layer != 8 && base.gameObject.layer != 24)
		{
			doconlessClosingCol = GetComponent<Collider>();
			if ((bool)doconlessClosingCol && !doconlessClosingCol.isTrigger)
			{
				doconless = true;
				if (!startOpen && !open && (doorType != DoorType.BigDoorController || bdoors.Length != 0) && (doorType != DoorType.SubDoorController || subdoors.Length != 0))
				{
					doconlessClosingCol.enabled = true;
				}
				else
				{
					doconlessClosingCol.enabled = false;
				}
			}
		}
		MeshRenderer[] array4 = lightsMeshRenderers;
		foreach (MeshRenderer meshRenderer in array4)
		{
			if ((bool)meshRenderer && (bool)meshRenderer.sharedMaterial && meshRenderer.sharedMaterial.HasProperty(UKShaderProperties.EmissiveColor))
			{
				meshRenderer.GetPropertyBlock(block);
				defaultLightsColor = meshRenderer.sharedMaterial.GetColor(UKShaderProperties.EmissiveColor);
				if (noPass != null && noPass.activeInHierarchy)
				{
					block.SetColor(UKShaderProperties.EmissiveColor, turnEmissiveOffWhenLocked ? new Color(0f, 0f, 0f, 0f) : Color.red);
				}
				else if (locked)
				{
					locked = false;
					Lock();
				}
				meshRenderer.SetPropertyBlock(block);
			}
		}
		currentLightsColor = defaultLightsColor;
		gotValues = true;
		if (startOpen || open)
		{
			open = true;
			if ((bool)occpor)
			{
				occpor.open = true;
			}
		}
		else if ((bool)occpor)
		{
			occpor.open = false;
		}
	}

	private void GetPos()
	{
		gotPos = true;
		closedPos = base.transform.localPosition;
		openPosRelative = base.transform.localPosition + openPos;
		if (startOpen && doorType == DoorType.Normal)
		{
			base.transform.localPosition = openPosRelative;
		}
	}

	public void AltarControlled()
	{
		doconlessClosingCol = GetComponent<Collider>();
		DoorController[] array = docons;
		foreach (DoorController doorController in array)
		{
			if (!doorController.dontDeactivateOnAltarControl)
			{
				doorController.gameObject.SetActive(value: false);
			}
		}
		if ((bool)doconlessClosingCol && !doconlessClosingCol.isTrigger)
		{
			doconless = true;
			if (!startOpen)
			{
				doconlessClosingCol.enabled = true;
			}
		}
	}

	private void Update()
	{
		if (doorType != 0 || inPos)
		{
			return;
		}
		base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Time.deltaTime * speed);
		if (screenShake)
		{
			if (cc == null)
			{
				cc = MonoSingleton<CameraController>.Instance;
			}
			cc.CameraShake(0.05f);
		}
		if (!(Vector3.Distance(base.transform.localPosition, targetPos) < Mathf.Min(0.1f, Vector3.Distance(closedPos, openPos) / 100f)))
		{
			return;
		}
		base.transform.localPosition = targetPos;
		inPos = true;
		if (base.transform.localPosition == openPosRelative)
		{
			onFullyOpened?.Invoke();
		}
		else
		{
			onFullyClosed?.Invoke();
			if ((bool)openLight)
			{
				openLight.enabled = false;
			}
		}
		if (closeSound != null && (bool)aud)
		{
			aud.clip = closeSound;
			aud.loop = false;
			aud.Play();
		}
		if (nmo != null)
		{
			if (base.transform.localPosition == closedPos)
			{
				nmo.enabled = true;
			}
			else
			{
				nmo.enabled = false;
			}
		}
		if ((bool)occpor && base.transform.localPosition == closedPos)
		{
			occpor.open = false;
		}
	}

	public void SimpleOpenOverride()
	{
		Open(enemy: false, skull: true);
	}

	public void Open(bool enemy = false, bool skull = false)
	{
		if (!gotPos)
		{
			GetPos();
		}
		if (!skull || docons.Length == 0)
		{
			requests++;
		}
		else if (skull && docons.Length != 0)
		{
			bool flag = false;
			DoorController[] array = docons;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].gameObject.activeInHierarchy)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				requests++;
			}
		}
		if (!(requests == 1 || skull) || (!(base.transform.localPosition != openPosRelative) && doorType == DoorType.Normal))
		{
			return;
		}
		if (!gotValues)
		{
			startOpen = true;
			return;
		}
		open = true;
		if ((bool)occpor)
		{
			occpor.open = true;
		}
		if (!enemy && !dontCloseOtherDoorsWhenOpening && docons.Length != 0)
		{
			allDoors = Object.FindObjectsOfType<Door>();
			Door[] array2 = allDoors;
			foreach (Door door in array2)
			{
				if (door != null && door != this && door.open && !door.startOpen && !door.dontCloseWhenAnotherDoorOpens)
				{
					DoorController doorController = null;
					if (door.doorType != 0)
					{
						doorController = door.GetComponentInChildren<DoorController>();
					}
					else if (door.transform.parent != null)
					{
						doorController = door.transform.parent.GetComponentInChildren<DoorController>();
					}
					if (doorController != null && doorController.type == 0 && !doorController.enemyIn)
					{
						door.Close();
					}
				}
			}
		}
		if (doorType == DoorType.Normal)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			if ((bool)aud)
			{
				aud.clip = openSound;
				if (closeSound != null)
				{
					aud.loop = true;
				}
				aud.Play();
			}
			targetPos = openPosRelative;
			inPos = false;
		}
		else
		{
			if (doorType == DoorType.BigDoorController)
			{
				BigDoor[] array3 = bdoors;
				foreach (BigDoor bigDoor in array3)
				{
					if (reverseDirection)
					{
						bigDoor.reverseDirection = true;
					}
					else
					{
						bigDoor.reverseDirection = false;
					}
					bigDoor.Open();
				}
			}
			else if (doorType == DoorType.SubDoorController)
			{
				SubDoor[] array4 = subdoors;
				foreach (SubDoor subDoor in array4)
				{
					if (!subDoor.dr)
					{
						subDoor.dr = this;
					}
					subDoor.Open();
				}
			}
			if ((bool)nmo)
			{
				nmo.enabled = false;
			}
		}
		if (activatedRooms.Length != 0)
		{
			GameObject[] array5 = activatedRooms;
			foreach (GameObject gameObject in array5)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: true);
				}
			}
		}
		if (openLight != null)
		{
			openLight.enabled = true;
		}
		if (thisLock != null)
		{
			thisLock.Open();
		}
		if (doconless && (bool)doconlessClosingCol)
		{
			doconlessClosingCol.enabled = false;
		}
	}

	public void Optimize()
	{
		if (deactivatedRooms.Length != 0)
		{
			GameObject[] array = deactivatedRooms;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
	}

	public void Close(bool force = false)
	{
		if (!gotPos)
		{
			GetPos();
		}
		if (requests > 1 && !force)
		{
			requests--;
		}
		else
		{
			if (!(base.transform.localPosition != closedPos) && doorType == DoorType.Normal)
			{
				return;
			}
			open = false;
			if (requests > 0 && !force)
			{
				requests--;
			}
			else if (force)
			{
				requests = 0;
			}
			if (startOpen)
			{
				startOpen = false;
			}
			if (doorType == DoorType.Normal)
			{
				if (aud == null)
				{
					aud = GetComponent<AudioSource>();
				}
				if (aud != null)
				{
					aud.clip = openSound;
					if (closeSound != null)
					{
						aud.loop = true;
					}
					aud.Play();
				}
				if (doorType == DoorType.Normal)
				{
					targetPos = closedPos;
				}
				inPos = false;
			}
			else if (doorType == DoorType.BigDoorController && bdoors != null)
			{
				BigDoor[] array = bdoors;
				foreach (BigDoor bigDoor in array)
				{
					bigDoor.Close();
					if (openLight != null)
					{
						bigDoor.openLight = openLight;
					}
				}
				if ((bool)nmo)
				{
					nmo.enabled = true;
				}
			}
			else if (doorType == DoorType.SubDoorController && subdoors != null)
			{
				SubDoor[] array2 = subdoors;
				foreach (SubDoor subDoor in array2)
				{
					if (!subDoor.dr)
					{
						subDoor.dr = this;
					}
					subDoor.Close();
				}
				if ((bool)nmo)
				{
					nmo.enabled = true;
				}
			}
			if (thisLock != null)
			{
				thisLock.Close();
			}
			if (doconless && (bool)doconlessClosingCol)
			{
				doconlessClosingCol.enabled = true;
			}
		}
	}

	public void Lock()
	{
		if (locked)
		{
			return;
		}
		locked = true;
		if ((bool)noPass)
		{
			noPass.SetActive(value: true);
		}
		if (doorType == DoorType.Normal)
		{
			if (base.transform.localPosition != closedPos)
			{
				Close(force: true);
			}
		}
		else if (doorType == DoorType.BigDoorController)
		{
			BigDoor[] array = bdoors;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].open)
				{
					Close(force: true);
					break;
				}
			}
		}
		else if (doorType == DoorType.SubDoorController)
		{
			SubDoor[] array2 = subdoors;
			for (int i = 0; i < array2.Length; i++)
			{
				if (array2[i].isOpen)
				{
					Close(force: true);
					break;
				}
			}
		}
		if ((bool)aud2)
		{
			aud2.pitch = 0.2f;
			aud2.Play();
		}
		ChangeColor(turnEmissiveOffWhenLocked ? new Color(0f, 0f, 0f, 0f) : Color.red);
	}

	public void Unlock()
	{
		if (locked && (bool)aud2)
		{
			aud2.pitch = 0.5f;
			aud2.Play();
		}
		locked = false;
		if ((bool)noPass)
		{
			noPass.SetActive(value: false);
		}
		ChangeColor(defaultLightsColor);
		if (openOnUnlock && !open)
		{
			Open();
		}
	}

	public void ChangeColor(Color targetColor)
	{
		currentLightsColor = targetColor;
		if (lightsMeshRenderers == null || lightsMeshRenderers.Length == 0)
		{
			return;
		}
		MeshRenderer[] array = lightsMeshRenderers;
		foreach (MeshRenderer meshRenderer in array)
		{
			if ((bool)meshRenderer && meshRenderer.sharedMaterial.HasProperty(UKShaderProperties.EmissiveColor))
			{
				meshRenderer.GetPropertyBlock(block);
				block.SetColor(UKShaderProperties.EmissiveColor, targetColor);
				meshRenderer.SetPropertyBlock(block);
			}
		}
	}

	public void LockOpen()
	{
		openLocks++;
		if (openLocks != locks.Count)
		{
			return;
		}
		if (docons.Length != 0)
		{
			for (int i = 0; i < docons.Length; i++)
			{
				if (origDoconStates[i])
				{
					docons[i].gameObject.SetActive(value: true);
				}
			}
		}
		Open(enemy: false, skull: true);
	}

	public void LockClose()
	{
		openLocks--;
		if (openLocks == locks.Count - 1)
		{
			Close(force: true);
		}
	}

	public void BigDoorClosed()
	{
		onFullyClosed?.Invoke();
		if ((bool)occpor)
		{
			occpor.open = false;
		}
		if ((bool)openLight)
		{
			openLight.enabled = false;
		}
	}

	public void ForceStartOpen(bool force = true)
	{
		startOpen = force;
	}
}



public class DoorBlocker : MonoBehaviour
{
	private AudioSource aud;

	private Door blockedDoor;

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag("Door"))
		{
			Door componentInParent = collision.gameObject.GetComponentInParent<Door>();
			if (componentInParent != null)
			{
				blockedDoor = componentInParent;
			}
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			if (aud != null)
			{
				aud.Play();
			}
			if (componentInParent != null)
			{
				componentInParent.Close();
			}
		}
	}

	private void OnDestroy()
	{
		if (blockedDoor != null && blockedDoor.gameObject.activeInHierarchy && base.gameObject.scene.isLoaded)
		{
			blockedDoor.Open(enemy: false, skull: true);
		}
	}
}



public class DoorController : MonoBehaviour
{
	public int type;

	private Door dc;

	private bool open;

	private bool playerIn;

	public bool enemyIn;

	public bool reverseDirection;

	public bool dontDeactivateOnAltarControl;

	public List<EnemyIdentifier> doorUsers = new List<EnemyIdentifier>();

	private List<EnemyIdentifier> doorUsersToDelete = new List<EnemyIdentifier>();

	private void Start()
	{
		dc = base.transform.parent.GetComponentInChildren<Door>();
	}

	private void OnDrawGizmos()
	{
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			Bounds bounds = component.bounds;
			Gizmos.color = new Color(0.2f, 0.2f, 1f, 1f);
			Gizmos.DrawWireCube(bounds.center, bounds.size);
			Gizmos.color = new Color(0.2f, 0.2f, 1f, 0.15f);
			Gizmos.DrawCube(bounds.center, bounds.size);
		}
	}

	private void OnDisable()
	{
		if (playerIn && open && !dc.locked && type == 0)
		{
			Close();
		}
	}

	private void Update()
	{
		if ((playerIn || enemyIn) && !open && !dc.locked)
		{
			open = true;
			if (reverseDirection)
			{
				dc.reverseDirection = true;
			}
			else
			{
				dc.reverseDirection = false;
			}
			if (playerIn)
			{
				dc.Optimize();
			}
			if (type == 0)
			{
				if (!playerIn)
				{
					dc.Open(enemy: true);
				}
				else
				{
					dc.Open();
				}
			}
			else if (type == 1)
			{
				if (!playerIn)
				{
					dc.Open(enemy: true);
				}
				else
				{
					dc.Open();
				}
				Object.Destroy(this);
			}
			else if (type == 2)
			{
				dc.Close();
				Object.Destroy(this);
			}
		}
		else if (open && !dc.locked && !playerIn && !enemyIn)
		{
			Close();
		}
		if (enemyIn && doorUsers.Count > 0)
		{
			foreach (EnemyIdentifier doorUser in doorUsers)
			{
				if (doorUser == null || !doorUser.gameObject.activeInHierarchy || doorUser.dead)
				{
					doorUsersToDelete.Add(doorUser);
				}
			}
			if (doorUsersToDelete.Count > 0)
			{
				foreach (EnemyIdentifier item in doorUsersToDelete)
				{
					doorUsers.Remove(item);
				}
				doorUsersToDelete.Clear();
				if (doorUsers.Count <= 0)
				{
					enemyIn = false;
					if (!playerIn)
					{
						Close();
					}
				}
			}
		}
		if (!playerIn && !enemyIn && dc.transform.localPosition == dc.closedPos)
		{
			open = false;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			playerIn = true;
		}
		else if (other.gameObject.CompareTag("Enemy") && !open)
		{
			EnemyIdentifier component = other.gameObject.GetComponent<EnemyIdentifier>();
			if (component != null && !component.dead && component.enemyClass == EnemyClass.Machine && component.enemyType != EnemyType.Drone && !doorUsers.Contains(component))
			{
				enemyIn = true;
				doorUsers.Add(component);
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			playerIn = false;
		}
		else
		{
			if (!other.gameObject.CompareTag("Enemy"))
			{
				return;
			}
			EnemyIdentifier component = other.gameObject.GetComponent<EnemyIdentifier>();
			if (component != null && component.enemyClass == EnemyClass.Machine && component.enemyType != EnemyType.Drone)
			{
				if (doorUsers.Contains(component))
				{
					doorUsers.Remove(component);
				}
				if (doorUsers.Count <= 0)
				{
					enemyIn = false;
				}
			}
		}
	}

	public void Close()
	{
		open = false;
		dc.Close();
	}

	public void ForcePlayerOut()
	{
		playerIn = false;
	}
}



public class DoorlessChecker : MonoBehaviour
{
	private Door dr;

	private bool failed;

	private void Start()
	{
		MonoSingleton<ChallengeDoneByDefault>.Instance.Prepare();
	}

	private void Update()
	{
		if (!failed)
		{
			if (dr == null)
			{
				dr = GetComponent<Door>();
			}
			if (dr != null && dr.open)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeFailed = true;
				failed = true;
			}
		}
	}
}



public class DoorLightsHider : MonoBehaviour
{
	public GameObject[] sideA;

	public GameObject[] sideB;

	private Door parentDoor;

	private bool currentSideIsA;

	private bool overridePreviousSide = true;

	private void Start()
	{
		parentDoor = GetComponentInParent<Door>();
		SlowUpdate();
	}

	private void SlowUpdate()
	{
		GameObject[] array;
		if ((bool)parentDoor && parentDoor.open)
		{
			array = sideA;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			array = sideB;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			overridePreviousSide = true;
			Invoke("SlowUpdate", 0.025f);
			return;
		}
		if (Vector3.Distance(base.transform.position, MonoSingleton<PlayerTracker>.Instance.GetTarget().position) > 200f)
		{
			array = sideA;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			array = sideB;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			overridePreviousSide = true;
			Invoke("SlowUpdate", 0.5f);
			return;
		}
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		array = sideA;
		foreach (GameObject gameObject in array)
		{
			zero += gameObject.transform.position;
		}
		array = sideB;
		foreach (GameObject gameObject2 in array)
		{
			zero2 += gameObject2.transform.position;
		}
		zero /= (float)sideA.Length;
		zero2 /= (float)sideB.Length;
		if (Vector3.Distance(zero, MonoSingleton<PlayerTracker>.Instance.GetTarget().position) <= Vector3.Distance(zero2, MonoSingleton<PlayerTracker>.Instance.GetTarget().position))
		{
			SetSide(targetSideIsA: true);
		}
		else
		{
			SetSide(targetSideIsA: false);
		}
		Invoke("SlowUpdate", 0.1f);
	}

	public void SetSide(bool targetSideIsA)
	{
		if (overridePreviousSide || currentSideIsA != targetSideIsA)
		{
			GameObject[] array = sideA;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(targetSideIsA);
			}
			array = sideB;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(!targetSideIsA);
			}
			overridePreviousSide = false;
			currentSideIsA = targetSideIsA;
		}
	}
}



public class DoorLock : MonoBehaviour
{
	[HideInInspector]
	public Door parentDoor;

	public void Open()
	{
		if (parentDoor != null)
		{
			parentDoor.LockOpen();
		}
	}

	public void Close()
	{
		if (parentDoor != null)
		{
			parentDoor.LockClose();
		}
	}
}



public class DoorOpener : MonoBehaviour
{
	public Door door;

	public bool oneTime;

	private bool colliderless;

	private void Awake()
	{
		colliderless = GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null;
	}

	private void OnEnable()
	{
		if (colliderless)
		{
			Open();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			Open();
		}
	}

	private void Open()
	{
		door.Open(enemy: false, skull: true);
		if (oneTime)
		{
			base.enabled = false;
		}
	}
}


public enum DoorType
{
	Normal,
	BigDoorController,
	SubDoorController
}



public class DoorUnlocker : MonoBehaviour
{
	public Door door;

	public bool open;

	private void OnEnable()
	{
		door.Unlock();
		if (open)
		{
			door.Open(enemy: false, skull: true);
		}
	}
}



public class DoubleRender : MonoBehaviour
{
	public List<int> subMeshesToIgnore = new List<int>();

	public Material radiantMat;

	public Renderer thisRend;

	private CommandBuffer cb;

	private CameraController cc;

	private Camera currentCam;

	public int shouldOutline;

	private bool isActive;

	private void Awake()
	{
		cc = MonoSingleton<CameraController>.Instance;
		currentCam = cc.cam;
		radiantMat = new Material(MonoSingleton<PostProcessV2_Handler>.Instance.radiantBuff);
		thisRend = GetComponent<Renderer>();
		cb = new CommandBuffer
		{
			name = "BuffRender"
		};
		Mesh mesh = null;
		if (thisRend is SkinnedMeshRenderer)
		{
			mesh = (thisRend as SkinnedMeshRenderer).sharedMesh;
		}
		else if (thisRend is MeshRenderer)
		{
			mesh = thisRend.GetComponent<MeshFilter>().sharedMesh;
		}
		if (mesh != null)
		{
			for (int i = 0; i < mesh.subMeshCount; i++)
			{
				if (!subMeshesToIgnore.Contains(i))
				{
					cb.DrawRenderer(thisRend, radiantMat, i);
				}
			}
		}
		radiantMat.SetFloat("_ForceOutline", 1f);
		currentCam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
		isActive = true;
	}

	private void LateUpdate()
	{
		if (!thisRend.enabled && isActive)
		{
			currentCam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
			isActive = false;
		}
		if (thisRend.enabled && !isActive)
		{
			currentCam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
			isActive = true;
		}
		radiantMat.SetFloat("_Outline", shouldOutline);
		if (currentCam != cc.cam)
		{
			currentCam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
			currentCam = cc.cam;
			currentCam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
		}
	}

	public void OnDisable()
	{
		if (currentCam != null)
		{
			currentCam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
		}
		isActive = false;
	}

	public void RemoveEffect()
	{
		currentCam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, cb);
		Object.Destroy(this);
		isActive = false;
	}

	public void SetOutline(int showOultine)
	{
		shouldOutline = showOultine;
	}
}



public class DownscaleChangeSprite : MonoBehaviour
{
	public Sprite normal;

	public Sprite downscaled;

	private Image img;

	private void Start()
	{
		CheckScale();
	}

	private void OnEnable()
	{
		CheckScale();
	}

	public void CheckScale()
	{
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("pixelization") == 1)
		{
			img.sprite = downscaled;
		}
		else
		{
			img.sprite = normal;
		}
	}
}



public class DragBehind : MonoBehaviour
{
	private Vector3 previousPosition;

	private Quaternion currentRotation;

	private Quaternion nextRotation;

	private Quaternion previousRotation;

	public bool active;

	public bool notAnimated;

	public float dragAmount;

	private Quaternion defaultRotation;

	private void Awake()
	{
		previousPosition = base.transform.position;
		previousRotation = base.transform.rotation;
		defaultRotation = base.transform.localRotation;
	}

	private void LateUpdate()
	{
		if (active)
		{
			currentRotation = base.transform.rotation;
			Quaternion rotation = Quaternion.LookRotation(previousPosition - base.transform.position, base.transform.right);
			base.transform.rotation = rotation;
			base.transform.up = base.transform.forward;
			nextRotation = Quaternion.Lerp(currentRotation, base.transform.rotation, Vector3.Distance(base.transform.position, previousPosition) / 5f);
			if (notAnimated)
			{
				base.transform.rotation = Quaternion.Lerp(Quaternion.RotateTowards(previousRotation, nextRotation, Time.deltaTime * 1000f), base.transform.parent.rotation * defaultRotation, dragAmount);
			}
			else
			{
				base.transform.rotation = Quaternion.Lerp(Quaternion.RotateTowards(previousRotation, nextRotation, Time.deltaTime * 1000f), currentRotation, dragAmount);
			}
		}
		previousPosition = Vector3.MoveTowards(previousPosition, base.transform.position, Time.deltaTime * (Vector3.Distance(previousPosition, base.transform.position) * 10f));
		previousRotation = base.transform.rotation;
	}
}



public class Drone : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	public bool dontStartAware;

	public bool stationary;

	public float health;

	public bool crashing;

	private Vector3 crashTarget;

	private Rigidbody rb;

	private bool canInterruptCrash;

	private Transform modelTransform;

	public bool targetSpotted;

	public bool toLastKnownPos;

	private Vector3 lastKnownPos;

	private Vector3 nextRandomPos;

	public float checkCooldown;

	public float blockCooldown;

	public float preferredDistanceToTarget = 15f;

	private BloodsplatterManager bsm;

	public AssetReference explosion;

	public AssetReference gib;

	private StyleCalculator scalc;

	private EnemyIdentifier eid;

	private EnemyType type;

	private AudioSource aud;

	public AudioClip hurtSound;

	public AudioClip deathSound;

	public AudioClip windUpSound;

	public AudioClip spotSound;

	public AudioClip loseSound;

	private float dodgeCooldown;

	private float attackCooldown;

	public AssetReference projectile;

	private Material origMaterial;

	public Material shootMaterial;

	private EnemySimplifier[] ensims;

	public ParticleSystem chargeParticle;

	private bool killedByPlayer;

	private bool parried;

	private bool exploded;

	private bool parryable;

	private Vector3 viewTarget;

	[HideInInspector]
	public bool musicRequested;

	private GoreZone gz;

	private int difficulty;

	private Animator anim;

	public bool enraged;

	public GameObject enrageEffect;

	private int usedAttacks;

	[HideInInspector]
	public List<VirtueInsignia> childVi = new List<VirtueInsignia>();

	private EnemyCooldowns vc;

	private KeepInBounds kib;

	private bool checkingForCrash;

	private bool canHurtOtherDrones;

	[HideInInspector]
	public bool lockRotation;

	[HideInInspector]
	public bool lockPosition;

	private bool hooked;

	private bool homeRunnable;

	public bool cantInstaExplode;

	private GameObject currentEnrageEffect;

	[HideInInspector]
	public bool fleshDrone;

	private int parryFramesLeft;

	public GameObject ghost;

	private EnemyTarget target => eid.target;

	private int relevantSightBlockMask => LayerMaskDefaults.Get((!target.isPlayer) ? LMD.Environment : LMD.EnvironmentAndBigEnemies);

	public bool isEnraged { get; private set; }

	public string alterKey => "drone";

	public string alterCategoryName => "drone";

	public AlterOption<bool>[] options
	{
		get
		{
			if (type != EnemyType.Drone)
			{
				return new AlterOption<bool>[1]
				{
					new AlterOption<bool>
					{
						key = "enraged",
						name = "Enraged",
						value = isEnraged,
						callback = delegate(bool value)
						{
							if (value)
							{
								Enrage();
							}
							else
							{
								UnEnrage();
							}
						}
					}
				};
			}
			return null;
		}
	}

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		rb = GetComponent<Rigidbody>();
		kib = GetComponent<KeepInBounds>();
		type = eid.enemyType;
		if (type == EnemyType.Virtue)
		{
			vc = MonoSingleton<EnemyCooldowns>.Instance;
		}
	}

	private void Start()
	{
		bsm = MonoSingleton<BloodsplatterManager>.Instance;
		if (!chargeParticle)
		{
			chargeParticle = GetComponentInChildren<ParticleSystem>();
		}
		if (type == EnemyType.Virtue)
		{
			anim = GetComponent<Animator>();
		}
		dodgeCooldown = UnityEngine.Random.Range(0.5f, 3f);
		if (type == EnemyType.Drone)
		{
			attackCooldown = UnityEngine.Random.Range(1f, 3f);
		}
		else
		{
			attackCooldown = 1.5f;
		}
		if (!dontStartAware)
		{
			targetSpotted = true;
		}
		if (type == EnemyType.Drone)
		{
			modelTransform = base.transform.Find("drone");
			if ((bool)modelTransform)
			{
				ensims = modelTransform.GetComponentsInChildren<EnemySimplifier>();
				origMaterial = ensims[0].GetComponent<Renderer>().material;
			}
			rb.solverIterations *= 3;
			rb.solverVelocityIterations *= 3;
		}
		SlowUpdate();
		if (!musicRequested && !eid.dead)
		{
			musicRequested = true;
			MonoSingleton<MusicManager>.Instance.PlayBattleMusic();
		}
		gz = GoreZone.ResolveGoreZone(base.transform);
		if (enraged)
		{
			Enrage();
		}
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
	}

	private void UpdateBuff()
	{
		if ((bool)anim)
		{
			anim.speed = eid.totalSpeedModifier;
		}
	}

	private void OnDisable()
	{
		if (type == EnemyType.Virtue && (bool)vc)
		{
			vc.RemoveVirtue(this);
		}
		if (musicRequested)
		{
			musicRequested = false;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if ((bool)instance)
			{
				instance.PlayCleanMusic();
			}
		}
		if ((bool)MonoSingleton<EnemyTracker>.Instance && type == EnemyType.Drone && MonoSingleton<EnemyTracker>.Instance.drones.Contains(this))
		{
			MonoSingleton<EnemyTracker>.Instance.drones.Remove(this);
		}
	}

	private void OnEnable()
	{
		if (type == EnemyType.Virtue && (bool)vc)
		{
			vc.AddVirtue(this);
		}
		if (!musicRequested && !eid.dead)
		{
			musicRequested = true;
			MonoSingleton<MusicManager>.Instance.PlayBattleMusic();
		}
		if (type == EnemyType.Drone && !MonoSingleton<EnemyTracker>.Instance.drones.Contains(this))
		{
			MonoSingleton<EnemyTracker>.Instance.drones.Add(this);
		}
	}

	private void UpdateRigidbodySettings()
	{
		if (target == null && !crashing)
		{
			rb.drag = 3f;
			rb.angularDrag = 3f;
		}
		else
		{
			rb.drag = 0f;
			rb.angularDrag = 0f;
		}
	}

	private void Update()
	{
		if (!crashing)
		{
			UpdateRigidbodySettings();
			if (target == null)
			{
				return;
			}
			if (targetSpotted)
			{
				viewTarget = target.position;
				float num = difficulty / 2;
				if (num == 0f)
				{
					num = 0.25f;
				}
				num *= eid.totalSpeedModifier;
				if (dodgeCooldown > 0f)
				{
					dodgeCooldown = Mathf.MoveTowards(dodgeCooldown, 0f, Time.deltaTime * num);
				}
				else if (!stationary && !lockPosition)
				{
					dodgeCooldown = UnityEngine.Random.Range(1f, 3f);
					RandomDodge();
				}
			}
			if ((type == EnemyType.Virtue && (!target.isPlayer || !MonoSingleton<NewMovement>.Instance.levelOver) && (Vector3.Distance(base.transform.position, target.position) < 150f || stationary)) || targetSpotted)
			{
				float num2 = difficulty / 2;
				if (type == EnemyType.Virtue && difficulty >= 4)
				{
					num2 = 1.2f;
				}
				else if (difficulty == 1)
				{
					num2 = 0.75f;
				}
				else if (difficulty == 0)
				{
					num2 = 0.5f;
				}
				num2 *= eid.totalSpeedModifier;
				if (attackCooldown > 0f)
				{
					attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * num2);
				}
				else if (projectile != null && (!vc || vc.virtueCooldown == 0f))
				{
					if ((bool)vc)
					{
						vc.virtueCooldown = 1f / eid.totalSpeedModifier;
					}
					parryable = true;
					PlaySound(windUpSound);
					if (chargeParticle != null)
					{
						chargeParticle.Play();
					}
					if (shootMaterial != null && ensims != null && ensims.Length != 0)
					{
						EnemySimplifier[] array = ensims;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].ChangeMaterialNew(EnemySimplifier.MaterialState.normal, shootMaterial);
						}
					}
					if (type == EnemyType.Drone)
					{
						attackCooldown = UnityEngine.Random.Range(2f, 4f);
						Invoke("Shoot", 0.75f / eid.totalSpeedModifier);
					}
					else
					{
						attackCooldown = UnityEngine.Random.Range(4f, 6f);
						if (anim != null)
						{
							anim.SetTrigger("Attack");
						}
					}
					if (parryFramesLeft > 0)
					{
						eid.hitter = "punch";
						eid.DeliverDamage(base.gameObject, MonoSingleton<CameraController>.Instance.transform.forward * 25000f, base.transform.position, 1f, tryForExplode: false);
						parryFramesLeft = 0;
					}
				}
			}
		}
		if ((bool)eid && eid.hooked && !hooked)
		{
			Hooked();
		}
		else if ((bool)eid && !eid.hooked && hooked)
		{
			Unhooked();
		}
	}

	private void SlowUpdate()
	{
		if (!crashing && target != null)
		{
			if (targetSpotted)
			{
				if (Physics.Raycast(base.transform.position, target.position - base.transform.position, Vector3.Distance(base.transform.position, target.position) - 1f, relevantSightBlockMask))
				{
					targetSpotted = false;
					PlaySound(loseSound);
					lastKnownPos = target.position;
					blockCooldown = 0f;
					checkCooldown = 0f;
					toLastKnownPos = true;
				}
			}
			else if (!Physics.Raycast(base.transform.position, target.position - base.transform.position, Vector3.Distance(base.transform.position, target.position) - 1f, relevantSightBlockMask))
			{
				PlaySound(spotSound);
				targetSpotted = true;
			}
			if (difficulty >= 4 && MonoSingleton<EnemyTracker>.Instance.drones.Count > 1)
			{
				Vector3 zero = Vector3.zero;
				foreach (Drone drone in MonoSingleton<EnemyTracker>.Instance.drones)
				{
					if (!(drone == this) && Vector3.Distance(drone.transform.position, base.transform.position) < 10f)
					{
						zero += base.transform.position - drone.transform.position;
					}
				}
				if (zero.magnitude > 0f)
				{
					Dodge(zero);
				}
			}
		}
		Invoke("SlowUpdate", 0.25f);
	}

	private void FixedUpdate()
	{
		if (parryFramesLeft > 0)
		{
			parryFramesLeft--;
		}
		if (rb.velocity.magnitude < 1f && rb.collisionDetectionMode != 0)
		{
			rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
		}
		if (crashing)
		{
			if (type == EnemyType.Virtue)
			{
				if (parried)
				{
					rb.useGravity = false;
					rb.velocity = base.transform.forward * 120f * eid.totalSpeedModifier;
				}
			}
			else if (!parried)
			{
				float num = 50f;
				if (difficulty == 1)
				{
					num = 40f;
				}
				else if (difficulty == 0)
				{
					num = 25f;
				}
				num *= eid.totalSpeedModifier;
				rb.AddForce(base.transform.forward * num, ForceMode.Acceleration);
				modelTransform?.Rotate(0f, 0f, 10f, Space.Self);
			}
			else
			{
				rb.velocity = base.transform.forward * 50f;
				modelTransform?.Rotate(0f, 0f, 50f, Space.Self);
			}
		}
		else if (targetSpotted && target != null)
		{
			if (type == EnemyType.Drone)
			{
				rb.velocity *= 0.95f;
				if (!stationary && !lockPosition)
				{
					float num2 = 50f;
					if (difficulty >= 4)
					{
						num2 = 250f;
					}
					if (Vector3.Distance(base.transform.position, target.position) > preferredDistanceToTarget)
					{
						rb.AddForce(base.transform.forward * num2 * eid.totalSpeedModifier, ForceMode.Acceleration);
					}
					else if (Vector3.Distance(base.transform.position, target.position) < 5f)
					{
						if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
						{
							rb.AddForce(base.transform.forward * -0.1f * eid.totalSpeedModifier, ForceMode.Impulse);
						}
						else
						{
							rb.AddForce(base.transform.forward * (0f - num2) * eid.totalSpeedModifier, ForceMode.Impulse);
						}
					}
				}
			}
			else
			{
				rb.velocity *= 0.975f;
				if (!stationary && Vector3.Distance(base.transform.position, target.position) > 15f)
				{
					rb.AddForce(base.transform.forward * 10f * eid.totalSpeedModifier, ForceMode.Acceleration);
				}
			}
		}
		else if (toLastKnownPos && !stationary && !lockPosition && target != null)
		{
			if (blockCooldown == 0f)
			{
				viewTarget = lastKnownPos;
			}
			else
			{
				blockCooldown = Mathf.MoveTowards(blockCooldown, 0f, 0.01f);
			}
			rb.AddForce(base.transform.forward * 10f * eid.totalSpeedModifier, ForceMode.Acceleration);
			if (checkCooldown == 0f && Vector3.Distance(base.transform.position, lastKnownPos) > 5f)
			{
				checkCooldown = 0.1f;
				if (Physics.BoxCast(base.transform.position - (viewTarget - base.transform.position).normalized, Vector3.one, viewTarget - base.transform.position, base.transform.rotation, 4f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
				{
					blockCooldown = UnityEngine.Random.Range(1.5f, 3f);
					Vector3 vector = new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
					viewTarget = base.transform.position + vector * 100f;
				}
			}
			else if (Vector3.Distance(base.transform.position, lastKnownPos) <= 3f)
			{
				Physics.Raycast(base.transform.position, UnityEngine.Random.onUnitSphere, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies));
				lastKnownPos = hitInfo.point;
			}
			if (checkCooldown != 0f)
			{
				checkCooldown = Mathf.MoveTowards(checkCooldown, 0f, 0.01f);
			}
		}
		if (!crashing)
		{
			if (!lockRotation && target != null)
			{
				Quaternion b = Quaternion.LookRotation(viewTarget - base.transform.position);
				base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, 0.075f + 0.00025f * Quaternion.Angle(base.transform.rotation, b) * eid.totalSpeedModifier);
			}
			rb.velocity = Vector3.ClampMagnitude(rb.velocity, 50f * eid.totalSpeedModifier);
			if ((bool)kib)
			{
				kib.ValidateMove();
			}
		}
	}

	public void RandomDodge()
	{
		if ((difficulty != 1 || !(UnityEngine.Random.Range(0f, 1f) > 0.75f)) && difficulty != 0)
		{
			Dodge(base.transform.up * UnityEngine.Random.Range(-5f, 5f) + base.transform.right * UnityEngine.Random.Range(-5f, 5f));
		}
	}

	public void Dodge(Vector3 direction)
	{
		float num = 50f;
		if (type == EnemyType.Virtue)
		{
			num = 150f;
		}
		num *= eid.totalSpeedModifier;
		rb.AddForce(direction.normalized * num, ForceMode.Impulse);
	}

	public void GetHurt(Vector3 force, float multiplier, GameObject sourceWeapon = null, bool fromExplosion = false)
	{
		bool flag = false;
		if (!crashing)
		{
			if ((eid.hitter == "shotgunzone" || eid.hitter == "hammerzone") && !parryable && health - multiplier > 0f)
			{
				return;
			}
			if (((eid.hitter == "shotgunzone" || eid.hitter == "hammerzone") && parryable) || eid.hitter == "punch")
			{
				if (parryable)
				{
					if (!InvincibleEnemies.Enabled && !eid.blessed)
					{
						multiplier = ((parryFramesLeft > 0) ? 3 : 4);
					}
					MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: false, eid);
					parryable = false;
				}
				else
				{
					parryFramesLeft = MonoSingleton<FistControl>.Instance.currentPunch.activeFrames;
				}
			}
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= 1f * multiplier;
			}
			else
			{
				multiplier = 0f;
			}
			health = (float)Math.Round(health, 4);
			if ((double)health <= 0.001)
			{
				health = 0f;
			}
			if (eid == null)
			{
				eid = GetComponent<EnemyIdentifier>();
			}
			if (health <= 0f)
			{
				flag = true;
			}
			if (homeRunnable && !fleshDrone && !eid.puppet && flag && (eid.hitter == "punch" || eid.hitter == "heavypunch" || eid.hitter == "hammer"))
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.homerun", sourceWeapon, eid);
				MonoSingleton<StyleCalculator>.Instance.AddToMultiKill();
			}
			else if (eid.hitter != "enemy" && !eid.puppet && multiplier != 0f)
			{
				if (scalc == null)
				{
					scalc = MonoSingleton<StyleCalculator>.Instance;
				}
				if ((bool)scalc)
				{
					scalc.HitCalculator(eid.hitter, "drone", "", flag, eid, sourceWeapon);
				}
			}
			if (health <= 0f && !crashing)
			{
				parryable = false;
				Death(fromExplosion);
				if (eid.hitter != "punch" && eid.hitter != "heavypunch" && eid.hitter != "hammer")
				{
					if (target != null)
					{
						crashTarget = target.position;
					}
				}
				else
				{
					canHurtOtherDrones = true;
					base.transform.position += force.normalized;
					crashTarget = base.transform.position + force;
					rb.velocity = force.normalized * 40f;
				}
				base.transform.LookAt(crashTarget);
				if (aud == null)
				{
					aud = GetComponent<AudioSource>();
				}
				if (type == EnemyType.Drone)
				{
					aud.clip = deathSound;
					aud.volume = 0.75f;
					aud.pitch = UnityEngine.Random.Range(0.85f, 1.35f);
					aud.priority = 11;
					aud.Play();
				}
				else
				{
					PlaySound(deathSound);
				}
				Invoke("CanInterruptCrash", 0.5f);
				Invoke("Explode", 5f);
			}
			else if (eid.hitter != "fire")
			{
				PlaySound(hurtSound);
				GameObject gameObject = null;
				Bloodsplatter bloodsplatter = null;
				if (multiplier != 0f)
				{
					gameObject = bsm.GetGore(GoreType.Body, eid, fromExplosion);
					gameObject.transform.position = base.transform.position;
					gameObject.SetActive(value: true);
					gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
					if (eid.hitter == "drill")
					{
						gameObject.transform.localScale *= 2f;
					}
					bloodsplatter = gameObject.GetComponent<Bloodsplatter>();
				}
				if (health > 0f)
				{
					if ((bool)bloodsplatter)
					{
						bloodsplatter.GetReady();
					}
					if (!eid.blessed)
					{
						rb.velocity /= 10f;
						rb.AddForce(force.normalized * (force.magnitude / 100f), ForceMode.Impulse);
						rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
						if (rb.velocity.magnitude > 50f)
						{
							rb.velocity = Vector3.ClampMagnitude(rb.velocity, 50f);
						}
					}
				}
				if (multiplier >= 1f)
				{
					if ((bool)bloodsplatter)
					{
						bloodsplatter.hpAmount = 30;
					}
					if (gib != null)
					{
						for (int i = 0; (float)i <= multiplier; i++)
						{
							UnityEngine.Object.Instantiate(gib.ToAsset(), base.transform.position, UnityEngine.Random.rotation).transform.SetParent(gz.gibZone, worldPositionStays: true);
						}
					}
				}
				if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && (bool)gameObject && gameObject.TryGetComponent<ParticleSystem>(out var component))
				{
					component.Play();
				}
			}
			else
			{
				PlaySound(hurtSound);
			}
		}
		else if ((eid.hitter == "punch" || eid.hitter == "hammer") && !parried)
		{
			parried = true;
			rb.velocity = Vector3.zero;
			base.transform.rotation = MonoSingleton<CameraController>.Instance.transform.rotation;
			Punch currentPunch = MonoSingleton<FistControl>.Instance.currentPunch;
			if (eid.hitter == "punch")
			{
				currentPunch.GetComponent<Animator>().Play("Hook", -1, 0.065f);
				currentPunch.Parry(hook: false, eid);
			}
			if (type == EnemyType.Virtue && TryGetComponent<Collider>(out var component2))
			{
				component2.isTrigger = true;
			}
		}
		else if (multiplier >= 1f || canInterruptCrash)
		{
			Explode();
		}
	}

	public void PlaySound(AudioClip clippe)
	{
		if ((bool)clippe)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = clippe;
			if (type == EnemyType.Drone)
			{
				aud.volume = 0.5f;
				aud.pitch = UnityEngine.Random.Range(0.85f, 1.35f);
			}
			aud.priority = 12;
			aud.Play();
		}
	}

	public void Explode()
	{
		if (exploded || !base.gameObject.activeInHierarchy || (cantInstaExplode && !canInterruptCrash))
		{
			return;
		}
		exploded = true;
		GameObject obj = UnityEngine.Object.Instantiate(this.explosion.ToAsset(), base.transform.position, Quaternion.identity);
		obj.transform.SetParent(gz.transform, worldPositionStays: true);
		Explosion[] componentsInChildren = obj.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			if (eid.totalDamageModifier != 1f)
			{
				explosion.damage = Mathf.RoundToInt((float)explosion.damage * eid.totalDamageModifier);
				explosion.maxSize *= eid.totalDamageModifier;
				explosion.speed *= eid.totalDamageModifier;
			}
			if (difficulty >= 4 && type == EnemyType.Drone && !parried && !canHurtOtherDrones)
			{
				explosion.toIgnore.Add(EnemyType.Drone);
			}
			if (killedByPlayer)
			{
				explosion.friendlyFire = true;
			}
		}
		DoubleRender componentInChildren = GetComponentInChildren<DoubleRender>();
		if ((bool)componentInChildren)
		{
			componentInChildren.RemoveEffect();
		}
		if (!crashing)
		{
			Death(fromExplosion: true);
		}
		else if (eid.drillers.Count > 0)
		{
			for (int num = eid.drillers.Count - 1; num >= 0; num--)
			{
				UnityEngine.Object.Destroy(eid.drillers[num].gameObject);
			}
		}
		if (GhostDroneMode.Enabled && ghost != null)
		{
			UnityEngine.Object.Instantiate(ghost, base.transform.position, base.transform.rotation);
		}
		UnityEngine.Object.Destroy(base.gameObject);
		if (musicRequested)
		{
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if ((bool)instance)
			{
				instance.PlayCleanMusic();
			}
		}
	}

	private void Death(bool fromExplosion = false)
	{
		if (crashing)
		{
			return;
		}
		crashing = true;
		UpdateRigidbodySettings();
		if (rb.isKinematic)
		{
			rb.isKinematic = false;
		}
		if (type == EnemyType.Virtue)
		{
			rb.velocity = Vector3.zero;
			rb.AddForce(Vector3.up * 10f, ForceMode.VelocityChange);
			rb.useGravity = true;
			if (childVi.Count > 0)
			{
				for (int i = 0; i < childVi.Count; i++)
				{
					if (childVi[i] != null && (bool)childVi[i].gameObject)
					{
						UnityEngine.Object.Destroy(childVi[i].gameObject);
					}
				}
			}
		}
		if (eid.hitter != "enemy")
		{
			killedByPlayer = true;
		}
		if (!eid.dontCountAsKills)
		{
			if (gz != null && gz.checkpoint != null)
			{
				gz.AddDeath();
				gz.checkpoint.sm.kills++;
			}
			else
			{
				MonoSingleton<StatsManager>.Instance.kills++;
			}
		}
		if (eid.hitter != "fire")
		{
			GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion);
			if ((bool)gore)
			{
				gore.transform.position = base.transform.position;
				if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && gore.TryGetComponent<ParticleSystem>(out var component))
				{
					component.Play();
				}
				gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				if (eid.hitter == "drill")
				{
					gore.transform.localScale *= 2f;
				}
				if (gore.TryGetComponent<Bloodsplatter>(out var component2))
				{
					component2.GetReady();
				}
			}
		}
		if (!eid.dontCountAsKills)
		{
			ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
			if (componentInParent != null)
			{
				componentInParent.AddDeadEnemy();
			}
		}
	}

	public void Shoot()
	{
		parryable = false;
		if (crashing || !projectile.RuntimeKeyIsValid())
		{
			return;
		}
		EnemySimplifier[] array = ensims;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ChangeMaterialNew(EnemySimplifier.MaterialState.normal, origMaterial);
		}
		if (base.gameObject.activeInHierarchy)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(projectile.ToAsset(), base.transform.position + base.transform.forward, base.transform.rotation);
			gameObject.transform.rotation = Quaternion.Euler(gameObject.transform.rotation.eulerAngles.x, gameObject.transform.rotation.eulerAngles.y, UnityEngine.Random.Range(0, 360));
			gameObject.transform.localScale *= 0.5f;
			SetProjectileSettings(gameObject.GetComponent<Projectile>());
			GameObject gameObject2 = UnityEngine.Object.Instantiate(projectile.ToAsset(), gameObject.transform.position + gameObject.transform.up, gameObject.transform.rotation);
			if (difficulty > 2)
			{
				gameObject2.transform.rotation = Quaternion.Euler(gameObject.transform.rotation.eulerAngles.x + 10f, gameObject.transform.rotation.eulerAngles.y, gameObject.transform.rotation.eulerAngles.z);
			}
			gameObject2.transform.localScale *= 0.5f;
			SetProjectileSettings(gameObject2.GetComponent<Projectile>());
			gameObject2 = UnityEngine.Object.Instantiate(projectile.ToAsset(), gameObject.transform.position - gameObject.transform.up, gameObject.transform.rotation);
			if (difficulty > 2)
			{
				gameObject2.transform.rotation = Quaternion.Euler(gameObject.transform.rotation.eulerAngles.x - 10f, gameObject.transform.rotation.eulerAngles.y, gameObject.transform.rotation.eulerAngles.z);
			}
			gameObject2.transform.localScale *= 0.5f;
			SetProjectileSettings(gameObject2.GetComponent<Projectile>());
		}
	}

	private void SetProjectileSettings(Projectile proj)
	{
		float speed = 35f;
		if (difficulty >= 3)
		{
			speed = 45f;
		}
		else if (difficulty == 1)
		{
			speed = 25f;
		}
		else if (difficulty == 0)
		{
			speed = 15f;
		}
		proj.damage *= eid.totalDamageModifier;
		proj.target = target;
		proj.safeEnemyType = EnemyType.Drone;
		proj.speed = speed;
	}

	public void SpawnInsignia()
	{
		if (target != null && !crashing)
		{
			parryable = false;
			GameObject gameObject = UnityEngine.Object.Instantiate(projectile.ToAsset(), target.position, Quaternion.identity);
			VirtueInsignia component = gameObject.GetComponent<VirtueInsignia>();
			component.target = target;
			component.parentDrone = this;
			component.hadParent = true;
			chargeParticle.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmittingAndClear);
			if (enraged)
			{
				component.predictive = true;
			}
			if (difficulty == 1)
			{
				component.windUpSpeedMultiplier = 0.875f;
			}
			else if (difficulty == 0)
			{
				component.windUpSpeedMultiplier = 0.75f;
			}
			if (difficulty >= 4)
			{
				component.explosionLength = ((difficulty == 5) ? 5f : 3.5f);
			}
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
			{
				gameObject.transform.localScale *= 0.75f;
				component.windUpSpeedMultiplier *= 0.875f;
			}
			component.windUpSpeedMultiplier *= eid.totalSpeedModifier;
			component.damage = Mathf.RoundToInt((float)component.damage * eid.totalDamageModifier);
			usedAttacks++;
			if (((difficulty > 2 && usedAttacks > 2) || (difficulty == 2 && usedAttacks > 4 && !eid.blessed)) && !enraged && vc.currentVirtues.Count < 3)
			{
				Invoke("Enrage", 3f / eid.totalSpeedModifier);
			}
		}
	}

	private void OnCollisionStay(Collision collision)
	{
		if (crashing && (collision.gameObject.layer == 0 || collision.gameObject.layer == 8 || collision.gameObject.layer == 24 || collision.gameObject.CompareTag("Player") || collision.gameObject.layer == 10 || collision.gameObject.layer == 11 || collision.gameObject.layer == 12 || collision.gameObject.layer == 26))
		{
			Explode();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!crashing)
		{
			return;
		}
		if ((type == EnemyType.Drone && (other.gameObject.layer == 10 || other.gameObject.layer == 11 || other.gameObject.layer == 12)) || (!other.isTrigger && (other.gameObject.layer == 0 || other.gameObject.layer == 8 || other.gameObject.layer == 24 || other.gameObject.layer == 26 || other.gameObject.CompareTag("Player"))))
		{
			Explode();
		}
		else
		{
			if (type == EnemyType.Drone || (other.gameObject.layer != 10 && other.gameObject.layer != 11 && other.gameObject.layer != 12) || checkingForCrash)
			{
				return;
			}
			checkingForCrash = true;
			EnemyIdentifierIdentifier component = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
			EnemyIdentifier enemyIdentifier = ((!component || !component.eid) ? other.gameObject.GetComponent<EnemyIdentifier>() : component.eid);
			if ((bool)enemyIdentifier)
			{
				bool flag = true;
				if (!enemyIdentifier.dead)
				{
					flag = false;
				}
				enemyIdentifier.hitter = "cannonball";
				enemyIdentifier.DeliverDamage(other.gameObject, (other.transform.position - base.transform.position).normalized * 100f, base.transform.position, 5f * enemyIdentifier.totalDamageModifier, tryForExplode: true);
				if (!enemyIdentifier || enemyIdentifier.dead)
				{
					if (!flag)
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.cannonballed", null, enemyIdentifier);
					}
					if ((bool)enemyIdentifier)
					{
						enemyIdentifier.Explode();
					}
					checkingForCrash = false;
				}
				else
				{
					Explode();
				}
			}
			else
			{
				checkingForCrash = false;
			}
		}
	}

	private void CanInterruptCrash()
	{
		canInterruptCrash = true;
	}

	public void Hooked()
	{
		hooked = true;
		lockPosition = true;
		homeRunnable = true;
		CancelInvoke("DelayedUnhooked");
	}

	public void Unhooked()
	{
		hooked = false;
		Invoke("DelayedUnhooked", 0.25f);
	}

	private void DelayedUnhooked()
	{
		if (!crashing)
		{
			Invoke("NoMoreHomeRun", 0.5f);
		}
		lockPosition = false;
	}

	private void NoMoreHomeRun()
	{
		if (!crashing)
		{
			homeRunnable = false;
		}
	}

	public void Enrage()
	{
		if (!isEnraged && type != EnemyType.Drone)
		{
			isEnraged = true;
			currentEnrageEffect = UnityEngine.Object.Instantiate(enrageEffect, base.transform.position, base.transform.rotation);
			currentEnrageEffect.transform.SetParent(base.transform, worldPositionStays: true);
			enraged = true;
			EnemySimplifier[] componentsInChildren = GetComponentsInChildren<EnemySimplifier>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enraged = true;
			}
		}
	}

	public void UnEnrage()
	{
		if (isEnraged)
		{
			isEnraged = false;
			EnemySimplifier[] componentsInChildren = GetComponentsInChildren<EnemySimplifier>();
			if (componentsInChildren == null || componentsInChildren.Length == 0)
			{
				componentsInChildren = GetComponentsInChildren<EnemySimplifier>();
			}
			UnityEngine.Object.Destroy(currentEnrageEffect);
			EnemySimplifier[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = false;
			}
		}
	}
}



public class DroneFlesh : MonoBehaviour
{
	public GameObject beam;

	public GameObject warningBeam;

	public GameObject chargeEffect;

	private GameObject currentWarningBeam;

	private GameObject currentChargeEffect;

	private AudioSource ceAud;

	private Light ceLight;

	private float cooldown = 3f;

	private bool inAction;

	private Drone drn;

	private EnemyIdentifier eid;

	private bool tracking;

	public Transform shootPoint;

	public float predictionAmount;

	public Vector3 rotationOffset;

	private int difficulty;

	private float difficultySpeedModifier = 1f;

	private void Awake()
	{
		eid = GetComponentInParent<EnemyIdentifier>();
		drn = GetComponent<Drone>();
	}

	private void Start()
	{
		cooldown = Random.Range(2f, 3f);
		if ((bool)drn)
		{
			drn.fleshDrone = true;
		}
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (difficulty == 1)
		{
			difficultySpeedModifier = 0.8f;
		}
		else if (difficulty == 0)
		{
			difficultySpeedModifier = 0.6f;
		}
	}

	private void Update()
	{
		if ((bool)eid && eid.enemyType == EnemyType.Virtue)
		{
			return;
		}
		if ((bool)drn && drn.crashing)
		{
			drn.Explode();
		}
		else
		{
			if (eid.target == null)
			{
				return;
			}
			if (tracking)
			{
				base.transform.LookAt(eid.target.position);
				if (rotationOffset != Vector3.zero)
				{
					base.transform.localRotation = Quaternion.Euler(base.transform.localRotation.eulerAngles + rotationOffset);
				}
			}
			if (((bool)drn && !drn.targetSpotted) || inAction)
			{
				return;
			}
			if (cooldown > 0f)
			{
				cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
				if (cooldown <= 1f && (bool)chargeEffect)
				{
					if (!currentChargeEffect)
					{
						currentChargeEffect = Object.Instantiate(chargeEffect, shootPoint ? shootPoint.position : (base.transform.position + base.transform.forward * 1.5f), shootPoint ? shootPoint.rotation : base.transform.rotation);
						currentChargeEffect.transform.SetParent(base.transform);
						currentChargeEffect.transform.localScale = Vector3.zero;
						ceAud = currentChargeEffect.GetComponent<AudioSource>();
						ceLight = currentChargeEffect.GetComponent<Light>();
					}
					currentChargeEffect.transform.localScale = Vector3.one * (1f - cooldown) * 2.5f;
					if ((bool)ceAud)
					{
						ceAud.pitch = (1f - cooldown) * 2f;
					}
					if ((bool)ceLight)
					{
						ceLight.intensity = (1f - cooldown) * 30f;
					}
				}
			}
			else
			{
				inAction = true;
				cooldown = Random.Range(1f, 3f);
				if (difficulty > 2)
				{
					cooldown *= 0.75f;
				}
				if (difficulty == 1)
				{
					cooldown *= 1.5f;
				}
				else if (difficulty == 0)
				{
					cooldown *= 2f;
				}
				PrepareBeam();
			}
		}
	}

	private void PrepareBeam()
	{
		if ((bool)drn)
		{
			drn.lockPosition = true;
			drn.lockRotation = true;
		}
		base.transform.LookAt(eid.target.PredictTargetPosition(0.5f / eid.totalSpeedModifier * predictionAmount));
		if (rotationOffset != Vector3.zero)
		{
			base.transform.localRotation = Quaternion.Euler(base.transform.localRotation.eulerAngles + rotationOffset);
		}
		currentWarningBeam = Object.Instantiate(warningBeam, shootPoint ? shootPoint : base.transform);
		if (!shootPoint)
		{
			currentWarningBeam.transform.position += base.transform.forward * 1.5f;
		}
		float num = 0.5f;
		if (difficulty == 1)
		{
			num = 1f;
		}
		if (difficulty == 0)
		{
			num = 1.5f;
		}
		Invoke("ShootBeam", num / eid.totalSpeedModifier);
	}

	private void StopTracking()
	{
		tracking = false;
	}

	private void ShootBeam()
	{
		if ((bool)currentWarningBeam)
		{
			Object.Destroy(currentWarningBeam);
		}
		if ((bool)currentChargeEffect)
		{
			Object.Destroy(currentChargeEffect);
		}
		GameObject gameObject = Object.Instantiate(beam, shootPoint ? shootPoint.position : base.transform.position, shootPoint ? shootPoint.rotation : base.transform.rotation);
		Grenade component2;
		if (eid.totalDamageModifier != 1f && gameObject.TryGetComponent<RevolverBeam>(out var component))
		{
			component.damage *= eid.totalDamageModifier;
		}
		else if (gameObject.TryGetComponent<Grenade>(out component2))
		{
			if (eid.totalDamageModifier != 1f)
			{
				component2.totalDamageMultiplier = eid.totalDamageModifier;
			}
			component2.originEnemy = eid;
			component2.rocketSpeed *= difficultySpeedModifier;
		}
		if ((bool)drn)
		{
			drn.lockPosition = false;
			drn.lockRotation = false;
		}
		inAction = false;
	}

	public void Explode()
	{
		drn?.Explode();
	}
}



public class DropdownCombinationRestoreDefaultButton : MonoBehaviour
{
	[Serializable]
	public struct CombinationOption
	{
		public List<BooleanPrefOption> subOptions;
	}

	[Serializable]
	public struct BooleanPrefOption
	{
		public string prefKey;

		public bool isLocal;

		public bool expectedValue;
	}

	[SerializeField]
	private GameObject buttonContainer;

	public int defaultCombination;

	public List<CombinationOption> combinations;

	[SerializeField]
	private TMP_Dropdown dropdown;

	private bool isValueDirty;

	private void Awake()
	{
		dropdown.onValueChanged.AddListener(delegate
		{
			isValueDirty = true;
		});
	}

	private void Start()
	{
		UpdateSelf();
	}

	public void RestoreDefault()
	{
		dropdown.value = defaultCombination;
	}

	private void UpdateSelf()
	{
		CombinationOption combinationOption = combinations[defaultCombination];
		bool flag = true;
		foreach (BooleanPrefOption subOption in combinationOption.subOptions)
		{
			if ((subOption.isLocal ? MonoSingleton<PrefsManager>.Instance.GetBoolLocal(subOption.prefKey) : MonoSingleton<PrefsManager>.Instance.GetBool(subOption.prefKey)) != subOption.expectedValue)
			{
				flag = false;
				break;
			}
		}
		buttonContainer.SetActive(!flag);
	}

	private void LateUpdate()
	{
		if (isValueDirty)
		{
			isValueDirty = false;
			UpdateSelf();
		}
	}
}



public class DryZone : MonoBehaviour
{
	private HashSet<Collider> cols = new HashSet<Collider>();

	private DryZoneController dzc;

	private void Awake()
	{
		dzc = MonoSingleton<DryZoneController>.Instance;
		dzc.dryZones.Add(this);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.attachedRigidbody != null)
		{
			cols.Add(other);
			dzc.AddCollider(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (cols.Remove(other))
		{
			dzc.RemoveCollider(other);
		}
	}

	private void OnDisable()
	{
		if (!base.gameObject.scene.isLoaded)
		{
			return;
		}
		foreach (Collider col in cols)
		{
			dzc.RemoveCollider(col);
		}
		dzc.dryZones.Remove(this);
	}

	private void OnEnable()
	{
		dzc = MonoSingleton<DryZoneController>.Instance;
		foreach (Collider col in cols)
		{
			dzc.AddCollider(col);
		}
		dzc.dryZones.Add(this);
	}
}



public class DryZoneController : MonoSingleton<DryZoneController>
{
	public List<Water> waters = new List<Water>();

	public Dictionary<Collider, int> colliderCalls = new Dictionary<Collider, int>();

	public HashSet<DryZone> dryZones = new HashSet<DryZone>();

	public void AddCollider(Collider other)
	{
		if (!colliderCalls.TryGetValue(other, out var _))
		{
			colliderCalls.Add(other, 1);
			if (waters.Count <= 0)
			{
				return;
			}
			{
				foreach (Water item in waters)
				{
					item.EnterDryZone(other);
				}
				return;
			}
		}
		colliderCalls[other]++;
	}

	public void RemoveCollider(Collider other)
	{
		if (!colliderCalls.TryGetValue(other, out var value))
		{
			return;
		}
		if (value > 1)
		{
			colliderCalls[other]--;
			return;
		}
		colliderCalls.Remove(other);
		if (waters.Count <= 0)
		{
			return;
		}
		foreach (Water item in waters)
		{
			item.ExitDryZone(other);
		}
	}
}



public class DualWield : MonoBehaviour
{
	private GunControl gc;

	private PowerUpMeter meter;

	public float juiceAmount;

	private bool juiceGiven;

	private GameObject copyTarget;

	private GameObject currentWeapon;

	public float delay;

	private Vector3 defaultPosition;

	private void Start()
	{
		gc = MonoSingleton<GunControl>.Instance;
		meter = MonoSingleton<PowerUpMeter>.Instance;
		defaultPosition = base.transform.localPosition;
		if (juiceAmount == 0f)
		{
			juiceAmount = 30f;
		}
		if (meter.juice < juiceAmount)
		{
			meter.latestMaxJuice = juiceAmount;
			meter.juice = juiceAmount;
		}
		meter.powerUpColor = new Color(1f, 0.6f, 0f);
		juiceGiven = true;
		MonoSingleton<FistControl>.Instance.forceNoHold++;
		gc.dualWieldCount++;
		if ((bool)gc.currentWeapon)
		{
			WeaponPos componentInChildren = gc.currentWeapon.GetComponentInChildren<WeaponPos>();
			if ((bool)componentInChildren)
			{
				componentInChildren.CheckPosition();
			}
			UpdateWeapon();
		}
	}

	private void Update()
	{
		if (juiceGiven && meter.juice <= 0f)
		{
			EndPowerUp();
			return;
		}
		if (!copyTarget || copyTarget != gc.currentWeapon)
		{
			UpdateWeapon();
		}
		if ((bool)currentWeapon && (bool)gc)
		{
			if (!gc.currentWeapon.activeInHierarchy && currentWeapon.activeSelf)
			{
				currentWeapon.SetActive(value: false);
			}
			else if (gc.currentWeapon.activeInHierarchy && !currentWeapon.activeSelf)
			{
				currentWeapon.SetActive(value: true);
			}
		}
	}

	private void UpdateWeapon()
	{
		if ((bool)currentWeapon)
		{
			Object.Destroy(currentWeapon);
		}
		if ((bool)gc.currentWeapon && gc.currentWeapon.TryGetComponent<WeaponIdentifier>(out var component))
		{
			copyTarget = gc.currentWeapon;
			currentWeapon = Object.Instantiate(gc.currentWeapon, base.transform);
			if (currentWeapon.TryGetComponent<WeaponIdentifier>(out component))
			{
				component.delay = delay;
				component.duplicate = true;
				base.transform.localPosition = defaultPosition + component.duplicateOffset;
			}
		}
		else
		{
			copyTarget = null;
		}
	}

	public void EndPowerUp()
	{
		if ((bool)gc.currentWeapon)
		{
			WeaponPos componentInChildren = gc.currentWeapon.GetComponentInChildren<WeaponPos>();
			if ((bool)componentInChildren)
			{
				componentInChildren.CheckPosition();
			}
		}
		if (MonoSingleton<FistControl>.Instance.forceNoHold > 0)
		{
			MonoSingleton<FistControl>.Instance.forceNoHold--;
		}
		gc.dualWieldCount--;
		Object.Destroy(base.gameObject);
	}
}



public class DualWieldPickup : MonoBehaviour, IAlter, IAlterOptions<float>, IAlterOptions<bool>
{
	public bool infiniteUses;

	public float juiceAmount = 30f;

	public GameObject pickUpEffect;

	public string alterKey => "dual-wield-pickup";

	public string alterCategoryName => "Dual Wield Pickup";

	AlterOption<float>[] IAlterOptions<float>.options => new AlterOption<float>[1]
	{
		new AlterOption<float>
		{
			name = "Juice",
			key = "juice",
			value = juiceAmount,
			callback = delegate(float value)
			{
				juiceAmount = value;
			},
			constraints = new SliderConstraints
			{
				min = 0f,
				max = 100f,
				step = 1f
			}
		}
	};

	AlterOption<bool>[] IAlterOptions<bool>.options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			name = "Infinite Uses",
			key = "infinite-uses",
			value = infiniteUses,
			callback = delegate(bool value)
			{
				infiniteUses = value;
			}
		}
	};

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			PickedUp();
		}
	}

	private void PickedUp()
	{
		if (!MonoSingleton<GunControl>.Instance)
		{
			return;
		}
		Object.Instantiate(pickUpEffect, base.transform.position, Quaternion.identity);
		MonoSingleton<CameraController>.Instance.CameraShake(0.35f);
		if (!infiniteUses)
		{
			base.gameObject.SetActive(value: false);
		}
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			MonoSingleton<PlatformerMovement>.Instance.AddExtraHit(3);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.transform.SetParent(MonoSingleton<GunControl>.Instance.transform, worldPositionStays: true);
		gameObject.transform.localRotation = Quaternion.identity;
		DualWield[] componentsInChildren = MonoSingleton<GunControl>.Instance.GetComponentsInChildren<DualWield>();
		if (componentsInChildren != null && componentsInChildren.Length % 2 == 0)
		{
			gameObject.transform.localScale = new Vector3(-1f, 1f, 1f);
		}
		else
		{
			gameObject.transform.localScale = Vector3.one;
		}
		if (componentsInChildren == null || componentsInChildren.Length == 0)
		{
			gameObject.transform.localPosition = Vector3.zero;
		}
		else if (componentsInChildren.Length % 2 == 0)
		{
			gameObject.transform.localPosition = new Vector3((float)(componentsInChildren.Length / 2) * -1.5f, 0f, 0f);
		}
		else
		{
			gameObject.transform.localPosition = new Vector3((float)((componentsInChildren.Length + 1) / 2) * 1.5f, 0f, 0f);
		}
		DualWield dualWield = gameObject.AddComponent<DualWield>();
		dualWield.delay = 0.05f;
		dualWield.juiceAmount = juiceAmount;
		if (componentsInChildren != null && componentsInChildren.Length != 0)
		{
			dualWield.delay += (float)componentsInChildren.Length / 20f;
		}
	}
}



public static class EasingFunction
{
	public enum Ease
	{
		EaseInQuad,
		EaseOutQuad,
		EaseInOutQuad,
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInQuart,
		EaseOutQuart,
		EaseInOutQuart,
		EaseInQuint,
		EaseOutQuint,
		EaseInOutQuint,
		EaseInSine,
		EaseOutSine,
		EaseInOutSine,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		EaseInCirc,
		EaseOutCirc,
		EaseInOutCirc,
		Linear,
		Spring,
		EaseInBounce,
		EaseOutBounce,
		EaseInOutBounce,
		EaseInBack,
		EaseOutBack,
		EaseInOutBack,
		EaseInElastic,
		EaseOutElastic,
		EaseInOutElastic
	}

	public delegate float Function(float s, float e, float v);

	private const float NATURAL_LOG_OF_2 = 0.6931472f;

	public static float Linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	public static float Spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	public static float EaseInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	public static float EaseOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	public static float EaseInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value + start;
		}
		value -= 1f;
		return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
	}

	public static float EaseInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	public static float EaseOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	public static float EaseInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	public static float EaseInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	public static float EaseOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	public static float EaseInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
	}

	public static float EaseInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	public static float EaseOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	public static float EaseInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value * value * value + 2f) + start;
	}

	public static float EaseInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
	}

	public static float EaseOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
	}

	public static float EaseInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
	}

	public static float EaseInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	public static float EaseOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	public static float EaseInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	public static float EaseInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	public static float EaseOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	public static float EaseInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	public static float EaseInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - EaseOutBounce(0f, end, num - value) + start;
	}

	public static float EaseOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	public static float EaseInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num * 0.5f)
		{
			return EaseInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return EaseOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	public static float EaseInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	public static float EaseOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value -= 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	public static float EaseInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	public static float EaseInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f;
		}
		else
		{
			num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
		}
		return 0f - num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) + start;
	}

	public static float EaseOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f;
		}
		else
		{
			num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	public static float EaseInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f;
		}
		else
		{
			num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num3 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static float LinearD(float start, float end, float value)
	{
		return end - start;
	}

	public static float EaseInQuadD(float start, float end, float value)
	{
		return 2f * (end - start) * value;
	}

	public static float EaseOutQuadD(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value - end * (value - 2f);
	}

	public static float EaseInOutQuadD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * value;
		}
		value -= 1f;
		return end * (1f - value);
	}

	public static float EaseInCubicD(float start, float end, float value)
	{
		return 3f * (end - start) * value * value;
	}

	public static float EaseOutCubicD(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return 3f * end * value * value;
	}

	public static float EaseInOutCubicD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return 1.5f * end * value * value;
		}
		value -= 2f;
		return 1.5f * end * value * value;
	}

	public static float EaseInQuartD(float start, float end, float value)
	{
		return 4f * (end - start) * value * value * value;
	}

	public static float EaseOutQuartD(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return -4f * end * value * value * value;
	}

	public static float EaseInOutQuartD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return 2f * end * value * value * value;
		}
		value -= 2f;
		return -2f * end * value * value * value;
	}

	public static float EaseInQuintD(float start, float end, float value)
	{
		return 5f * (end - start) * value * value * value * value;
	}

	public static float EaseOutQuintD(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return 5f * end * value * value * value * value;
	}

	public static float EaseInOutQuintD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return 2.5f * end * value * value * value * value;
		}
		value -= 2f;
		return 2.5f * end * value * value * value * value;
	}

	public static float EaseInSineD(float start, float end, float value)
	{
		return (end - start) * 0.5f * (float)Math.PI * Mathf.Sin((float)Math.PI / 2f * value);
	}

	public static float EaseOutSineD(float start, float end, float value)
	{
		end -= start;
		return (float)Math.PI / 2f * end * Mathf.Cos(value * ((float)Math.PI / 2f));
	}

	public static float EaseInOutSineD(float start, float end, float value)
	{
		end -= start;
		return end * 0.5f * (float)Math.PI * Mathf.Sin((float)Math.PI * value);
	}

	public static float EaseInExpoD(float start, float end, float value)
	{
		return 6.931472f * (end - start) * Mathf.Pow(2f, 10f * (value - 1f));
	}

	public static float EaseOutExpoD(float start, float end, float value)
	{
		end -= start;
		return 3.465736f * end * Mathf.Pow(2f, 1f - 10f * value);
	}

	public static float EaseInOutExpoD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return 3.465736f * end * Mathf.Pow(2f, 10f * (value - 1f));
		}
		value -= 1f;
		return 3.465736f * end / Mathf.Pow(2f, 10f * value);
	}

	public static float EaseInCircD(float start, float end, float value)
	{
		return (end - start) * value / Mathf.Sqrt(1f - value * value);
	}

	public static float EaseOutCircD(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * value / Mathf.Sqrt(1f - value * value);
	}

	public static float EaseInOutCircD(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * value / (2f * Mathf.Sqrt(1f - value * value));
		}
		value -= 2f;
		return (0f - end) * value / (2f * Mathf.Sqrt(1f - value * value));
	}

	public static float EaseInBounceD(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return EaseOutBounceD(0f, end, num - value);
	}

	public static float EaseOutBounceD(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return 2f * end * 7.5625f * value;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return 2f * end * 7.5625f * value;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return 2f * end * 7.5625f * value;
		}
		value -= 21f / 22f;
		return 2f * end * 7.5625f * value;
	}

	public static float EaseInOutBounceD(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num * 0.5f)
		{
			return EaseInBounceD(0f, end, value * 2f) * 0.5f;
		}
		return EaseOutBounceD(0f, end, value * 2f - num) * 0.5f;
	}

	public static float EaseInBackD(float start, float end, float value)
	{
		float num = 1.70158f;
		return 3f * (num + 1f) * (end - start) * value * value - 2f * num * (end - start) * value;
	}

	public static float EaseOutBackD(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value -= 1f;
		return end * ((num + 1f) * value * value + 2f * value * ((num + 1f) * value + num));
	}

	public static float EaseInOutBackD(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return 0.5f * end * (num + 1f) * value * value + end * value * ((num + 1f) * value - num);
		}
		value -= 2f;
		num *= 1.525f;
		return 0.5f * end * ((num + 1f) * value * value + 2f * value * ((num + 1f) * value + num));
	}

	public static float EaseInElasticD(float start, float end, float value)
	{
		return EaseOutElasticD(start, end, 1f - value);
	}

	public static float EaseOutElasticD(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f;
		}
		else
		{
			num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * (float)Math.PI * num * Mathf.Pow(2f, 1f - 10f * value) * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / num2 - 3.465736f * num3 * Mathf.Pow(2f, 1f - 10f * value) * Mathf.Sin((float)Math.PI * 2f * (num * value - num4) / num2);
	}

	public static float EaseInOutElasticD(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f;
		}
		else
		{
			num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			value -= 1f;
			return -3.465736f * num3 * Mathf.Pow(2f, 10f * value) * Mathf.Sin((float)Math.PI * 2f * (num * value - 2f) / num2) - num3 * (float)Math.PI * num * Mathf.Pow(2f, 10f * value) * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / num2;
		}
		value -= 1f;
		return num3 * (float)Math.PI * num * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / (num2 * Mathf.Pow(2f, 10f * value)) - 3.465736f * num3 * Mathf.Sin((float)Math.PI * 2f * (num * value - num4) / num2) / Mathf.Pow(2f, 10f * value);
	}

	public static float SpringD(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		end -= start;
		return end * (6f * (1f - value) / 5f + 1f) * (-2.2f * Mathf.Pow(1f - value, 1.2f) * Mathf.Sin((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + Mathf.Pow(1f - value, 2.2f) * ((float)Math.PI * (2.5f * value * value * value + 0.2f) + 23.561945f * value * value * value) * Mathf.Cos((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + 1f) - 6f * end * (Mathf.Pow(1f - value, 2.2f) * Mathf.Sin((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + value / 5f);
	}

	public static Function GetEasingFunction(Ease easingFunction)
	{
		return easingFunction switch
		{
			Ease.EaseInQuad => EaseInQuad, 
			Ease.EaseOutQuad => EaseOutQuad, 
			Ease.EaseInOutQuad => EaseInOutQuad, 
			Ease.EaseInCubic => EaseInCubic, 
			Ease.EaseOutCubic => EaseOutCubic, 
			Ease.EaseInOutCubic => EaseInOutCubic, 
			Ease.EaseInQuart => EaseInQuart, 
			Ease.EaseOutQuart => EaseOutQuart, 
			Ease.EaseInOutQuart => EaseInOutQuart, 
			Ease.EaseInQuint => EaseInQuint, 
			Ease.EaseOutQuint => EaseOutQuint, 
			Ease.EaseInOutQuint => EaseInOutQuint, 
			Ease.EaseInSine => EaseInSine, 
			Ease.EaseOutSine => EaseOutSine, 
			Ease.EaseInOutSine => EaseInOutSine, 
			Ease.EaseInExpo => EaseInExpo, 
			Ease.EaseOutExpo => EaseOutExpo, 
			Ease.EaseInOutExpo => EaseInOutExpo, 
			Ease.EaseInCirc => EaseInCirc, 
			Ease.EaseOutCirc => EaseOutCirc, 
			Ease.EaseInOutCirc => EaseInOutCirc, 
			Ease.Linear => Linear, 
			Ease.Spring => Spring, 
			Ease.EaseInBounce => EaseInBounce, 
			Ease.EaseOutBounce => EaseOutBounce, 
			Ease.EaseInOutBounce => EaseInOutBounce, 
			Ease.EaseInBack => EaseInBack, 
			Ease.EaseOutBack => EaseOutBack, 
			Ease.EaseInOutBack => EaseInOutBack, 
			Ease.EaseInElastic => EaseInElastic, 
			Ease.EaseOutElastic => EaseOutElastic, 
			Ease.EaseInOutElastic => EaseInOutElastic, 
			_ => null, 
		};
	}

	public static Function GetEasingFunctionDerivative(Ease easingFunction)
	{
		return easingFunction switch
		{
			Ease.EaseInQuad => EaseInQuadD, 
			Ease.EaseOutQuad => EaseOutQuadD, 
			Ease.EaseInOutQuad => EaseInOutQuadD, 
			Ease.EaseInCubic => EaseInCubicD, 
			Ease.EaseOutCubic => EaseOutCubicD, 
			Ease.EaseInOutCubic => EaseInOutCubicD, 
			Ease.EaseInQuart => EaseInQuartD, 
			Ease.EaseOutQuart => EaseOutQuartD, 
			Ease.EaseInOutQuart => EaseInOutQuartD, 
			Ease.EaseInQuint => EaseInQuintD, 
			Ease.EaseOutQuint => EaseOutQuintD, 
			Ease.EaseInOutQuint => EaseInOutQuintD, 
			Ease.EaseInSine => EaseInSineD, 
			Ease.EaseOutSine => EaseOutSineD, 
			Ease.EaseInOutSine => EaseInOutSineD, 
			Ease.EaseInExpo => EaseInExpoD, 
			Ease.EaseOutExpo => EaseOutExpoD, 
			Ease.EaseInOutExpo => EaseInOutExpoD, 
			Ease.EaseInCirc => EaseInCircD, 
			Ease.EaseOutCirc => EaseOutCircD, 
			Ease.EaseInOutCirc => EaseInOutCircD, 
			Ease.Linear => LinearD, 
			Ease.Spring => SpringD, 
			Ease.EaseInBounce => EaseInBounceD, 
			Ease.EaseOutBounce => EaseOutBounceD, 
			Ease.EaseInOutBounce => EaseInOutBounceD, 
			Ease.EaseInBack => EaseInBackD, 
			Ease.EaseOutBack => EaseOutBackD, 
			Ease.EaseInOutBack => EaseInOutBackD, 
			Ease.EaseInElastic => EaseInElasticD, 
			Ease.EaseOutElastic => EaseOutElasticD, 
			Ease.EaseInOutElastic => EaseInOutElasticD, 
			_ => null, 
		};
	}
}



public class ElectricityLine : MonoBehaviour
{
	private LineRenderer lr;

	public Material[] lightningMats;

	public float minWidth;

	public float maxWidth;

	public Gradient colors;

	private float cooldown;

	public float fadeSpeed;

	private float fadeLerp = 1f;

	private void Update()
	{
		fadeLerp = Mathf.MoveTowards(fadeLerp, 0f, Time.deltaTime * fadeSpeed);
		if (fadeLerp <= 0f)
		{
			base.gameObject.SetActive(value: false);
		}
		if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
			return;
		}
		cooldown = 0.05f;
		if (!lr)
		{
			lr = GetComponent<LineRenderer>();
		}
		lr.material = lightningMats[Random.Range(0, lightningMats.Length)];
		lr.widthMultiplier = Random.Range(minWidth, maxWidth);
		lr.startColor = colors.Evaluate(Random.Range(0f, 1f));
		lr.endColor = colors.Evaluate(Random.Range(0f, 1f));
		lr.startColor = new Color(lr.startColor.r, lr.startColor.g, lr.startColor.b, lr.startColor.a * fadeLerp);
		lr.endColor = new Color(lr.endColor.r, lr.endColor.g, lr.endColor.b, lr.endColor.a * fadeLerp);
	}
}



[CreateAssetMenu]
public class EmbeddedSceneInfo : ScriptableObject
{
	[Tooltip("Special scenes cannot be normally loaded by the console.")]
	public string[] specialScenes;

	public string[] ranklessScenes;

	public IntermissionRelation[] intermissions;
}



[DisallowMultipleComponent]
public sealed class EnableMessage : MessageDispatcher
{
	private void OnEnable()
	{
		base.Handler.Invoke();
	}
}



public class EndlessCube : MonoBehaviour
{
	[SerializeField]
	private MeshRenderer meshRenderer;

	[SerializeField]
	private MeshFilter meshFilter;

	public Vector2Int positionOnGrid;

	public bool blockedByPrefab;

	private Vector3 targetPos;

	private Transform tf;

	private bool active;

	private float speed;

	private EndlessGrid eg;

	public MeshRenderer MeshRenderer => meshRenderer;

	public MeshFilter MeshFilter => meshFilter;

	private void Awake()
	{
		tf = base.transform;
		eg = GetComponentInParent<EndlessGrid>();
	}

	private void Update()
	{
		if (active)
		{
			tf.position = Vector3.MoveTowards(tf.position, targetPos, (Vector3.Distance(tf.position, targetPos) * 1.75f + speed) * Time.deltaTime);
			if (tf.position == targetPos)
			{
				eg.OneDone();
				active = false;
			}
		}
	}

	public void SetTarget(float target)
	{
		targetPos = new Vector3(tf.position.x, target, tf.position.z);
		speed = Random.Range(9, 11);
		Invoke("StartMoving", Random.Range(0f, 0.5f));
	}

	private void StartMoving()
	{
		active = true;
	}
}



[CreateAssetMenu(menuName = "ULTRAKILL/Endless Enemy Data")]
public class EndlessEnemy : ScriptableObject
{
	public EnemyType enemyType;

	public GameObject prefab;

	public int spawnCost;

	public int spawnWave;

	public int costIncreasePerSpawn;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class EndlessGrid : MonoSingleton<EndlessGrid>
{
	public bool customPatternMode;

	public ArenaPattern[] customPatterns;

	public const int ArenaSize = 16;

	[SerializeField]
	private ArenaPattern[] patterns;

	private int[] usedPatterns;

	[SerializeField]
	private List<CyberPooledPrefab> jumpPadPool;

	private int jumpPadSelector;

	[SerializeField]
	private CyberGrindNavHelper nvmhlpr;

	[SerializeField]
	private PrefabDatabase prefabs;

	[SerializeField]
	private GameObject gridCube;

	[SerializeField]
	private LayerMask prefabSpawnLayerCheck;

	[SerializeField]
	private float offset = 5f;

	[HideInInspector]
	public EndlessCube[][] cubes;

	private int incompleteBlocks;

	private ArenaPattern currentPattern;

	public NavMeshSurface nms;

	private ActivateNextWave anw;

	public int enemyAmount = 999;

	public int tempEnemyAmount;

	private int points;

	private int maxPoints = 10;

	public int currentWave;

	private int currentPatternNum = -1;

	private List<Vector2> meleePositions = new List<Vector2>();

	private int usedMeleePositions;

	private List<Vector2> projectilePositions = new List<Vector2>();

	private int usedProjectilePositions;

	private List<GameObject> spawnedEnemies = new List<GameObject>();

	private List<GameObject> spawnedPrefabs = new List<GameObject>();

	private List<EnemyTypeTracker> spawnedEnemyTypes = new List<EnemyTypeTracker>();

	private int incompletePrefabs;

	private GoreZone gz;

	private int specialAntiBuffer;

	private int massAntiBuffer;

	private float uncommonAntiBuffer;

	public Text waveNumberText;

	public Text enemiesLeftText;

	public bool crowdReactions;

	private CrowdReactions crorea;

	private int hideousMasses;

	private NewMovement nmov;

	private WeaponCharges wc;

	private Material[] mats;

	private Color targetColor;

	private bool testMode;

	private bool lastEnemyMode;

	public Transform enemyToTrack;

	private float currentGlow = 0.2f;

	public float glowMultiplier = 1f;

	private GameObject combinedGridStaticObject;

	private MeshRenderer combinedGridStaticMeshRenderer;

	private MeshFilter combinedGridStaticMeshFilter;

	private Mesh combinedGridStaticMesh;

	private static readonly int WorldOffset = Shader.PropertyToID("_WorldOffset");

	private static readonly int GradientSpeed = Shader.PropertyToID("_GradientSpeed");

	private static readonly int GradientFalloff = Shader.PropertyToID("_GradientFalloff");

	private static readonly int GradientScale = Shader.PropertyToID("_GradientScale");

	private static readonly int PcGamerMode = Shader.PropertyToID("_PCGamerMode");

	public int startWave;

	private ArenaPattern[] CurrentPatternPool
	{
		get
		{
			if (!customPatternMode)
			{
				return patterns;
			}
			return customPatterns;
		}
	}

	public void TrySetupStaticGridMesh()
	{
		if (incompleteBlocks == 0 && incompletePrefabs == 0)
		{
			SetupStaticGridMesh();
		}
	}

	public void SetupStaticGridMesh()
	{
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		if (combinedGridStaticObject == null)
		{
			combinedGridStaticObject = new GameObject("Combined Static Mesh");
			combinedGridStaticObject.transform.parent = base.transform;
			combinedGridStaticObject.layer = LayerMask.NameToLayer("Outdoors");
			combinedGridStaticMeshRenderer = combinedGridStaticObject.AddComponent<MeshRenderer>();
			combinedGridStaticMeshFilter = combinedGridStaticObject.AddComponent<MeshFilter>();
		}
		combinedGridStaticObject.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);
		combinedGridStaticObject.transform.localScale = Vector3.one;
		if (combinedGridStaticMesh == null)
		{
			combinedGridStaticMesh = new Mesh();
		}
		combinedGridStaticMesh.Clear();
		List<Mesh> list = new List<Mesh>();
		List<Material> list2 = new List<Material>();
		bool flag = false;
		for (int i = 0; i < cubes[0][0].MeshRenderer.sharedMaterials.Length; i++)
		{
			Material item = cubes[0][0].MeshRenderer.sharedMaterials[i];
			if (!list2.Contains(item))
			{
				list2.Add(item);
			}
		}
		for (int j = 0; j < list2.Count; j++)
		{
			Mesh mesh = new Mesh();
			List<CombineInstance> list3 = new List<CombineInstance>();
			for (int k = 0; k < 16; k++)
			{
				for (int l = 0; l < 16; l++)
				{
					EndlessCube endlessCube = cubes[k][l];
					if (!(endlessCube == null))
					{
						list3.Add(new CombineInstance
						{
							transform = endlessCube.MeshRenderer.localToWorldMatrix,
							mesh = endlessCube.MeshFilter.sharedMesh,
							subMeshIndex = j
						});
						endlessCube.MeshRenderer.enabled = false;
					}
				}
			}
			if (j == 1)
			{
				foreach (GameObject spawnedPrefab in spawnedPrefabs)
				{
					if (!spawnedPrefab.TryGetComponent<EndlessStairs>(out var component))
					{
						continue;
					}
					if (component.ActivateFirst)
					{
						if (!flag)
						{
							Material[] sharedMaterials = component.PrimaryMeshRenderer.sharedMaterials;
							foreach (Material item2 in sharedMaterials)
							{
								if (!list2.Contains(item2))
								{
									list2.Add(item2);
								}
							}
							flag = true;
						}
						list3.Add(new CombineInstance
						{
							transform = component.PrimaryMeshRenderer.localToWorldMatrix,
							mesh = component.PrimaryMeshFilter.sharedMesh
						});
						component.PrimaryMeshRenderer.enabled = false;
					}
					if (!component.ActivateSecond)
					{
						continue;
					}
					if (!flag)
					{
						Material[] sharedMaterials = component.SecondaryMeshRenderer.sharedMaterials;
						foreach (Material item3 in sharedMaterials)
						{
							if (!list2.Contains(item3))
							{
								list2.Add(item3);
							}
						}
						flag = true;
					}
					list3.Add(new CombineInstance
					{
						transform = component.SecondaryMeshRenderer.localToWorldMatrix,
						mesh = component.SecondaryMeshFilter.sharedMesh
					});
					component.SecondaryMeshRenderer.enabled = false;
				}
			}
			mesh.CombineMeshes(list3.ToArray(), mergeSubMeshes: true, useMatrices: true);
			list.Add(mesh);
		}
		CombineInstance[] array = new CombineInstance[list.Count];
		for (int n = 0; n < list.Count; n++)
		{
			array[n] = new CombineInstance
			{
				mesh = list[n]
			};
		}
		combinedGridStaticMesh.CombineMeshes(array, mergeSubMeshes: false, useMatrices: false);
		combinedGridStaticMesh.Optimize();
		combinedGridStaticMesh.RecalculateBounds();
		combinedGridStaticMesh.RecalculateNormals();
		combinedGridStaticMesh.UploadMeshData(markNoLongerReadable: false);
		combinedGridStaticMeshRenderer.sharedMaterials = list2.ToArray();
		combinedGridStaticMeshRenderer.enabled = true;
		combinedGridStaticMeshFilter.sharedMesh = combinedGridStaticMesh;
		for (int num = 0; num < list.Count; num++)
		{
			UnityEngine.Object.Destroy(list[num]);
		}
		list.Clear();
		stopwatch.Stop();
		UnityEngine.Debug.Log($"Combined arena mesh in {stopwatch.ElapsedMilliseconds} ms");
	}

	private void Start()
	{
		nms = GetComponent<NavMeshSurface>();
		anw = GetComponent<ActivateNextWave>();
		gz = GoreZone.ResolveGoreZone(base.transform);
		cubes = new EndlessCube[16][];
		for (int i = 0; i < 16; i++)
		{
			cubes[i] = new EndlessCube[16];
			for (int j = 0; j < 16; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(gridCube, base.transform, worldPositionStays: true);
				gameObject.SetActive(value: true);
				gameObject.transform.localPosition = new Vector3((float)i * offset, 0f, (float)j * offset);
				cubes[i][j] = gameObject.GetComponent<EndlessCube>();
				cubes[i][j].positionOnGrid = new Vector2Int(i, j);
			}
		}
		for (int k = 0; k < CurrentPatternPool.Length; k++)
		{
			ArenaPattern arenaPattern = CurrentPatternPool[k];
			int num = UnityEngine.Random.Range(k, CurrentPatternPool.Length);
			CurrentPatternPool[k] = CurrentPatternPool[num];
			CurrentPatternPool[num] = arenaPattern;
		}
		crorea = MonoSingleton<CrowdReactions>.Instance;
		if (crorea != null)
		{
			crowdReactions = true;
		}
		ShuffleDecks();
		PresenceController.UpdateCyberGrindWave(0);
		mats = GetComponentInChildren<MeshRenderer>().sharedMaterials;
		Material[] array = mats;
		foreach (Material obj in array)
		{
			obj.SetColor(UKShaderProperties.EmissiveColor, Color.blue);
			obj.SetFloat(UKShaderProperties.EmissiveIntensity, 0.2f * glowMultiplier);
			obj.SetFloat("_PCGamerMode", 0f);
			obj.SetFloat("_GradientScale", 2f);
			obj.SetFloat("_GradientFalloff", 5f);
			obj.SetFloat("_GradientSpeed", 10f);
			obj.SetVector("_WorldOffset", new Vector4(0f, 0f, 62.5f, 0f));
			targetColor = Color.blue;
		}
		TrySetupStaticGridMesh();
	}

	private void LastEnemyMode()
	{
		lastEnemyMode = true;
		EnemyIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifier>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!componentsInChildren[i].dead)
			{
				enemyToTrack = componentsInChildren[i].transform;
				break;
			}
		}
		Material[] array = mats;
		foreach (Material obj in array)
		{
			if (currentWave < 20)
			{
				currentGlow = 0.5f;
			}
			else
			{
				currentGlow = 1f;
			}
			obj.SetFloat(UKShaderProperties.EmissiveIntensity, currentGlow * glowMultiplier);
			obj.SetFloat(GradientScale, 0.5f);
			obj.SetFloat(GradientSpeed, 25f);
		}
	}

	private void NormalMode()
	{
		lastEnemyMode = false;
		Material[] array = mats;
		foreach (Material obj in array)
		{
			if (currentWave < 20)
			{
				currentGlow = 0.2f;
			}
			else
			{
				currentGlow = 0.5f;
			}
			obj.SetFloat(UKShaderProperties.EmissiveIntensity, currentGlow * glowMultiplier);
			obj.SetFloat(GradientScale, 2f);
			obj.SetFloat(GradientFalloff, 5f);
			obj.SetFloat(GradientSpeed, 10f);
			obj.SetVector(WorldOffset, new Vector4(0f, 0f, 62.5f, 0f));
		}
	}

	public void UpdateGlow()
	{
		Material[] array = mats;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetFloat(UKShaderProperties.EmissiveIntensity, currentGlow * glowMultiplier);
		}
	}

	private void Update()
	{
		Material[] array;
		if (lastEnemyMode)
		{
			if (anw.deadEnemies != enemyAmount - 1)
			{
				NormalMode();
			}
			else if ((bool)enemyToTrack)
			{
				array = mats;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetVector(WorldOffset, new Vector4(enemyToTrack.position.x, enemyToTrack.position.y, enemyToTrack.position.z, 0f));
				}
			}
		}
		else if (!lastEnemyMode && anw.deadEnemies == enemyAmount - 1)
		{
			LastEnemyMode();
		}
		if (anw.deadEnemies >= enemyAmount && !testMode)
		{
			anw.deadEnemies = 0;
			enemyAmount = 999;
			tempEnemyAmount = 0;
			Invoke("NextWave", 1f);
			if (crowdReactions)
			{
				if (crorea == null)
				{
					crorea = MonoSingleton<CrowdReactions>.Instance;
				}
				if (crorea.enabled)
				{
					crorea.React(crorea.cheerLong);
				}
				else
				{
					crowdReactions = false;
				}
			}
		}
		array = mats;
		foreach (Material material in array)
		{
			if (material.GetColor(UKShaderProperties.EmissiveColor) != targetColor)
			{
				material.SetColor(UKShaderProperties.EmissiveColor, Color.Lerp(material.GetColor(UKShaderProperties.EmissiveColor), targetColor, Time.deltaTime));
			}
		}
		if (anw.deadEnemies > tempEnemyAmount)
		{
			anw.deadEnemies = tempEnemyAmount;
		}
		waveNumberText.text = string.Concat(currentWave);
		enemiesLeftText.text = string.Concat(tempEnemyAmount - anw.deadEnemies);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.CompareTag("Player"))
		{
			return;
		}
		GetComponent<Collider>().enabled = false;
		if (startWave > 0)
		{
			currentWave = startWave - 1;
			for (int i = 1; i <= currentWave; i++)
			{
				maxPoints += 3 + i / 3;
			}
		}
		waveNumberText.transform.parent.parent.gameObject.SetActive(value: true);
		ShuffleDecks();
		NextWave();
	}

	private void NextWave()
	{
		currentPatternNum++;
		currentWave++;
		maxPoints += 3 + currentWave / 3;
		points = maxPoints;
		if (!nmov)
		{
			nmov = MonoSingleton<NewMovement>.Instance;
		}
		if (nmov.hp > 0)
		{
			nmov.ResetHardDamage();
			nmov.exploded = false;
			nmov.GetHealth(999, silent: true);
			nmov.FullStamina();
		}
		if (!wc)
		{
			wc = MonoSingleton<WeaponCharges>.Instance;
		}
		wc.MaxCharges();
		if ((bool)gz)
		{
			gz.ResetGibs();
		}
		if ((bool)MonoSingleton<ObjectTracker>.Instance && MonoSingleton<ObjectTracker>.Instance.landmineList.Count > 0)
		{
			for (int num = MonoSingleton<ObjectTracker>.Instance.landmineList.Count - 1; num >= 0; num--)
			{
				if (!(MonoSingleton<ObjectTracker>.Instance.landmineList[num] == null))
				{
					UnityEngine.Object.Destroy(MonoSingleton<ObjectTracker>.Instance.landmineList[num].gameObject);
				}
			}
		}
		Projectile[] array = UnityEngine.Object.FindObjectsOfType<Projectile>();
		if (array.Length != 0)
		{
			Projectile[] array2 = array;
			foreach (Projectile projectile in array2)
			{
				if (projectile != null && !projectile.friendly && !projectile.playerBullet)
				{
					UnityEngine.Object.Destroy(projectile.gameObject);
				}
			}
		}
		switch (currentWave)
		{
		case 10:
			targetColor = Color.green;
			break;
		case 15:
			targetColor = Color.yellow;
			break;
		case 20:
		{
			targetColor = Color.red;
			currentGlow = 0.35f;
			Material[] array3 = mats;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].SetFloat(UKShaderProperties.EmissiveIntensity, currentGlow * glowMultiplier);
			}
			break;
		}
		case 25:
		{
			currentGlow = 0.5f;
			Material[] array3 = mats;
			foreach (Material obj in array3)
			{
				obj.SetFloat(PcGamerMode, 1f);
				obj.SetFloat(UKShaderProperties.EmissiveIntensity, currentGlow * glowMultiplier);
			}
			break;
		}
		}
		if (currentPatternNum >= CurrentPatternPool.Length)
		{
			currentPatternNum = 0;
			ShuffleDecks();
		}
		foreach (GameObject spawnedPrefab in spawnedPrefabs)
		{
			spawnedPrefab.GetComponent<EndlessPrefabAnimator>().reverse = true;
		}
		spawnedPrefabs.Clear();
		incompletePrefabs = 0;
		PresenceController.UpdateCyberGrindWave(currentWave);
		if (CurrentPatternPool.Length == 0)
		{
			Invoke("DisplayNoPatternWarning", 2f);
		}
		if (CurrentPatternPool.Length > currentPatternNum)
		{
			LoadPattern(CurrentPatternPool[currentPatternNum]);
		}
	}

	private void DisplayNoPatternWarning()
	{
		MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("NO PATTERNS SELECTED.");
	}

	private void LoadPattern(ArenaPattern pattern)
	{
		if (customPatternMode)
		{
			string text = pattern.name.Split('\\')[^1];
			text = text.Substring(0, text.Length - 4);
			text = text.Replace("CG_", "");
			text = text.Replace("Cg_", "");
			text = text.Replace("cg_", "");
			text = text.Replace('_', ' ');
			text = SplitCamelCase(text);
			text = text.Replace("  ", " ");
			text = text.ToUpper();
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage(text, "", "", 0, silent: true);
		}
		string[] array = pattern.heights.Split('\n');
		if (array.Length != 16)
		{
			UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array.Length + " rows instead of " + 16);
			return;
		}
		for (int i = 0; i < array.Length; i++)
		{
			int[] array2 = new int[16];
			if (array[i].Length != 16)
			{
				if (array[i].Length < 16)
				{
					UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array[i].Length + " elements in row " + i + " instead of " + 16);
					return;
				}
				int num = 0;
				bool flag = false;
				string text2 = "";
				for (int j = 0; j < array[i].Length; j++)
				{
					if (int.TryParse(array[i][j].ToString(), out var result) || array[i][j] == '-')
					{
						if (!flag)
						{
							if (array2.Length <= num)
							{
								throw new Exception("Unable to parse pattern: " + pattern.name + " at row " + i + " and column " + j);
							}
							array2[num] = result;
							num++;
							continue;
						}
						text2 += array[i][j];
					}
					if (array[i][j] == '(')
					{
						if (flag)
						{
							UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\", Error while parsing extended numbers!");
							return;
						}
						flag = true;
					}
					if (array[i][j] == ')')
					{
						if (!flag)
						{
							UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\", Error while parsing extended numbers!");
							return;
						}
						if (array2.Length <= num)
						{
							throw new Exception("Unable to parse pattern: " + pattern.name + " at row " + i + " and column " + j);
						}
						array2[num] = int.Parse(text2);
						flag = false;
						text2 = "";
						num++;
					}
				}
				if (num != 16)
				{
					UnityEngine.Debug.LogError("[Heights] Pattern \"" + pattern.name + "\" has " + array[i].Length + " elements in row " + num + " instead of " + 16);
					return;
				}
			}
			else
			{
				for (int k = 0; k < array[i].Length; k++)
				{
					array2[k] = int.Parse(array[i][k].ToString());
				}
			}
			for (int l = 0; l < array2.Length; l++)
			{
				cubes[i][l].SetTarget((float)array2[l] * offset / 2f);
				cubes[i][l].blockedByPrefab = false;
				incompleteBlocks++;
			}
		}
		currentPattern = pattern;
		MakeGridDynamic();
	}

	public void MakeGridDynamic()
	{
		for (int i = 0; i < 16; i++)
		{
			for (int j = 0; j < 16; j++)
			{
				EndlessCube endlessCube = cubes[i][j];
				if (!(endlessCube == null))
				{
					endlessCube.MeshRenderer.enabled = true;
				}
			}
		}
		foreach (GameObject spawnedPrefab in spawnedPrefabs)
		{
			if (spawnedPrefab.TryGetComponent<EndlessStairs>(out var component))
			{
				if (component.ActivateFirst)
				{
					component.PrimaryMeshRenderer.enabled = true;
				}
				if (component.ActivateSecond)
				{
					component.SecondaryMeshRenderer.enabled = true;
				}
			}
		}
		combinedGridStaticMeshRenderer.enabled = false;
	}

	private GameObject SpawnOnGrid(GameObject obj, Vector2 position, bool prefab = false, bool enemy = false, CyberPooledType poolType = CyberPooledType.None, bool radiant = false)
	{
		if (Physics.Raycast(base.transform.position + new Vector3(position.x * offset, 200f, position.y * offset), Vector3.down, out var hitInfo, float.PositiveInfinity, prefabSpawnLayerCheck))
		{
			float y = obj.transform.position.y;
			GameObject gameObject = null;
			bool flag = false;
			if (poolType != 0 && poolType == CyberPooledType.JumpPad && jumpPadSelector < jumpPadPool.Count)
			{
				CyberPooledPrefab cyberPooledPrefab = jumpPadPool[jumpPadSelector];
				gameObject = cyberPooledPrefab.gameObject;
				gameObject.transform.position = hitInfo.point + Vector3.up * y;
				cyberPooledPrefab.Animator.Start();
				cyberPooledPrefab.Animator.reverse = false;
				jumpPadSelector++;
				flag = true;
				gameObject.SetActive(value: true);
			}
			if (!flag)
			{
				gameObject = UnityEngine.Object.Instantiate(obj, hitInfo.point + Vector3.up * y, obj.transform.rotation, base.transform);
			}
			if (prefab)
			{
				if (!flag && poolType == CyberPooledType.JumpPad)
				{
					CyberPooledPrefab cyberPooledPrefab2 = gameObject.AddComponent<CyberPooledPrefab>();
					jumpPadPool.Add(cyberPooledPrefab2);
					jumpPadSelector++;
					cyberPooledPrefab2.Index = jumpPadPool.Count - 1;
					cyberPooledPrefab2.Type = CyberPooledType.JumpPad;
					cyberPooledPrefab2.Animator = gameObject.GetComponent<EndlessPrefabAnimator>();
				}
				spawnedPrefabs.Add(gameObject);
				incompletePrefabs++;
			}
			if (enemy)
			{
				if (radiant && (bool)gameObject)
				{
					EnemyIdentifier componentInChildren = gameObject.GetComponentInChildren<EnemyIdentifier>(includeInactive: true);
					if ((bool)componentInChildren)
					{
						componentInChildren.HealthBuff();
						componentInChildren.SpeedBuff();
					}
				}
				spawnedEnemies.Add(gameObject);
			}
			return gameObject;
		}
		return null;
	}

	public GameObject[] GetSpawnedEnemies()
	{
		return spawnedEnemies.ToArray();
	}

	public void OneDone()
	{
		jumpPadSelector = 0;
		incompleteBlocks--;
		if (incompleteBlocks == 0)
		{
			projectilePositions.Clear();
			meleePositions.Clear();
			foreach (GameObject spawnedEnemy in spawnedEnemies)
			{
				if (spawnedEnemy != null)
				{
					spawnedEnemy.transform.SetParent(gz.gibZone, worldPositionStays: true);
					EnemyIdentifier component = spawnedEnemy.GetComponent<EnemyIdentifier>();
					if (component != null && !component.dead)
					{
						UnityEngine.Object.Destroy(spawnedEnemy);
					}
				}
			}
			if ((bool)gz)
			{
				gz.ResetGibs();
			}
			spawnedEnemies.Clear();
			string[] array = currentPattern.prefabs.Split('\n');
			if (array.Length != 16)
			{
				UnityEngine.Debug.LogError("[Prefabs] Pattern \"" + currentPattern.name + "\" has " + array.Length + " rows instead of " + 16);
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].Length != 16)
				{
					UnityEngine.Debug.LogError("[Prefabs] Pattern \"" + currentPattern.name + "\" has " + array[i].Length + " elements in row " + i + " instead of " + 16);
					return;
				}
				for (int j = 0; j < array[i].Length; j++)
				{
					if (array[i][j] == '0')
					{
						continue;
					}
					switch (array[i][j])
					{
					case 'n':
						meleePositions.Add(new Vector2(i, j));
						break;
					case 'p':
						projectilePositions.Add(new Vector2(i, j));
						break;
					case 'J':
						cubes[i][j].blockedByPrefab = true;
						SpawnOnGrid(prefabs.jumpPad, new Vector2(i, j), prefab: true, enemy: false, CyberPooledType.JumpPad);
						break;
					case 's':
					{
						cubes[i][j].blockedByPrefab = true;
						if (SpawnOnGrid(prefabs.stairs, new Vector2(i, j), prefab: true).TryGetComponent<EndlessStairs>(out var component2))
						{
							if (component2.PrimaryMeshRenderer != null && component2.ActivateFirst)
							{
								component2.PrimaryMeshRenderer.enabled = true;
							}
							if (component2.SecondaryMeshRenderer != null && component2.ActivateSecond)
							{
								component2.SecondaryMeshRenderer.enabled = true;
							}
						}
						break;
					}
					case 'H':
						if (massAntiBuffer == 0 && currentWave >= (hideousMasses + 1) * 10 && points > 70)
						{
							hideousMasses++;
							SpawnOnGrid(prefabs.hideousMass, new Vector2(i, j), prefab: false, enemy: true);
							points -= 45;
						}
						break;
					}
				}
			}
			if (hideousMasses > 0)
			{
				massAntiBuffer += hideousMasses * 2;
			}
			else if (massAntiBuffer > 0)
			{
				massAntiBuffer--;
			}
			if (spawnedPrefabs.Count == 0)
			{
				GetEnemies();
			}
		}
		TrySetupStaticGridMesh();
	}

	public void OnePrefabDone()
	{
		incompletePrefabs--;
		if (incompletePrefabs == 0)
		{
			GetEnemies();
		}
		TrySetupStaticGridMesh();
	}

	private void GetEnemies()
	{
		nms.BuildNavMesh();
		nvmhlpr.GenerateLinks(cubes);
		for (int i = 0; i < meleePositions.Count; i++)
		{
			Vector2 value = meleePositions[i];
			int index = UnityEngine.Random.Range(i, meleePositions.Count);
			meleePositions[i] = meleePositions[index];
			meleePositions[index] = value;
		}
		for (int j = 0; j < projectilePositions.Count; j++)
		{
			Vector2 value2 = projectilePositions[j];
			int index2 = UnityEngine.Random.Range(j, projectilePositions.Count);
			projectilePositions[j] = projectilePositions[index2];
			projectilePositions[index2] = value2;
		}
		tempEnemyAmount = 0;
		usedMeleePositions = 0;
		usedProjectilePositions = 0;
		spawnedEnemyTypes.Clear();
		tempEnemyAmount += hideousMasses;
		hideousMasses = 0;
		if (currentWave > 11)
		{
			int num = currentWave;
			int num2 = 0;
			while (num >= 10)
			{
				num -= 10;
				num2++;
			}
			if (tempEnemyAmount > 0)
			{
				num2 -= tempEnemyAmount;
			}
			if (uncommonAntiBuffer < 1f && num2 > 0)
			{
				int num3 = UnityEngine.Random.Range(0, currentWave / 10 + 1);
				if (uncommonAntiBuffer <= -0.5f && num3 < 1)
				{
					num3 = 1;
				}
				if (num3 > 0 && meleePositions.Count > 0)
				{
					int num4 = UnityEngine.Random.Range(0, prefabs.uncommonEnemies.Length);
					int num5 = UnityEngine.Random.Range(0, prefabs.uncommonEnemies.Length);
					int num6 = 0;
					while (num4 >= 0 && currentWave < prefabs.uncommonEnemies[num4].spawnWave)
					{
						num4--;
					}
					while (num5 >= 0 && (currentWave < prefabs.uncommonEnemies[num5].spawnWave || num5 == num4))
					{
						if (num5 == 0)
						{
							num6 = -1;
							break;
						}
						num5--;
					}
					if (num4 >= 0)
					{
						if (currentWave > 16)
						{
							if (currentWave < 25)
							{
								num3++;
							}
							else if (num6 != -1)
							{
								num6 = num3;
							}
						}
						bool flag = false;
						bool flag2 = false;
						flag = SpawnUncommons(num4, num3);
						if (num6 > 0)
						{
							flag2 = SpawnUncommons(num5, num6);
						}
						if (flag || flag2)
						{
							if (uncommonAntiBuffer < 0f)
							{
								uncommonAntiBuffer = 0f;
							}
							if (flag)
							{
								uncommonAntiBuffer += ((prefabs.uncommonEnemies[num4].enemyType == EnemyType.Stalker || prefabs.uncommonEnemies[num4].enemyType == EnemyType.Idol) ? 1f : 0.5f);
							}
							if (flag2)
							{
								uncommonAntiBuffer += ((prefabs.uncommonEnemies[num5].enemyType == EnemyType.Stalker || prefabs.uncommonEnemies[num5].enemyType == EnemyType.Idol) ? 1f : 0.5f);
							}
							num2 -= ((!(flag && flag2)) ? 1 : 2);
						}
					}
				}
			}
			else
			{
				uncommonAntiBuffer -= 1f;
			}
			if (currentWave > 15)
			{
				bool flag3 = false;
				if (specialAntiBuffer <= 0 && num2 > 0)
				{
					int num7 = UnityEngine.Random.Range(0, num2 + 1);
					if (specialAntiBuffer <= -2 && num7 < 1)
					{
						num7 = 1;
					}
					if (num7 > 0 && meleePositions.Count > 0)
					{
						for (int k = 0; k < num7; k++)
						{
							int num8 = UnityEngine.Random.Range(0, prefabs.specialEnemies.Length);
							int indexOfEnemyType = GetIndexOfEnemyType(prefabs.specialEnemies[num8].enemyType);
							float num9 = 0f;
							while (num8 >= 0 && usedMeleePositions < meleePositions.Count - 1)
							{
								if (currentWave >= prefabs.specialEnemies[num8].spawnWave && (float)points >= (float)prefabs.specialEnemies[num8].spawnCost + num9)
								{
									bool flag4 = SpawnRadiant(prefabs.specialEnemies[num8], indexOfEnemyType);
									SpawnOnGrid(prefabs.specialEnemies[num8].prefab, meleePositions[usedMeleePositions], prefab: false, enemy: true, CyberPooledType.None, flag4);
									points -= Mathf.RoundToInt((float)(prefabs.specialEnemies[num8].spawnCost * ((!flag4) ? 1 : 3)) + num9);
									num9 += (float)(prefabs.specialEnemies[num8].costIncreasePerSpawn * ((!flag4) ? 1 : 3));
									spawnedEnemyTypes[indexOfEnemyType].amount++;
									usedMeleePositions++;
									tempEnemyAmount++;
									if (specialAntiBuffer < 0)
									{
										specialAntiBuffer = 0;
									}
									specialAntiBuffer++;
									flag3 = true;
									break;
								}
								num8--;
								if (num8 >= 0)
								{
									indexOfEnemyType = GetIndexOfEnemyType(prefabs.specialEnemies[num8].enemyType);
								}
							}
						}
					}
				}
				if (!flag3)
				{
					specialAntiBuffer--;
				}
			}
		}
		GetNextEnemy();
	}

	private int CapUncommonsAmount(int target, int amount)
	{
		switch (prefabs.uncommonEnemies[target].enemyType)
		{
		case EnemyType.Stalker:
			if (amount > currentWave / 8 || amount > 3)
			{
				return Mathf.Min(currentWave / 8, 3);
			}
			break;
		case EnemyType.Idol:
			if (amount > currentWave / 8 || amount > 5)
			{
				return Mathf.Min(currentWave / 8, 5);
			}
			break;
		case EnemyType.Turret:
			if (amount > currentWave / 5 || amount > 6)
			{
				return Mathf.Min(currentWave / 5, 6);
			}
			break;
		case EnemyType.Gutterman:
			if (amount > currentWave / 15 || amount > 5)
			{
				return Mathf.Min(currentWave / 15, 5);
			}
			break;
		case EnemyType.Guttertank:
			if (amount > currentWave / 20 || amount > 3)
			{
				return Mathf.Min(currentWave / 20, 3);
			}
			break;
		case EnemyType.Virtue:
			if (amount > currentWave / 5 || amount > 8)
			{
				return Mathf.Min(currentWave / 5, 8);
			}
			break;
		}
		return amount;
	}

	private int GetIndexOfEnemyType(EnemyType target)
	{
		if (spawnedEnemyTypes.Count > 0)
		{
			for (int i = 0; i < spawnedEnemyTypes.Count; i++)
			{
				if (spawnedEnemyTypes[i].type == target)
				{
					return i;
				}
			}
		}
		spawnedEnemyTypes.Add(new EnemyTypeTracker(target));
		return spawnedEnemyTypes.Count - 1;
	}

	private bool SpawnRadiant(EndlessEnemy target, int indexOf)
	{
		float num = target.spawnWave * 2 + 25;
		float num2 = target.spawnCost;
		if (target.spawnCost < 10)
		{
			num2 += 1f;
		}
		if (target.spawnCost > 10)
		{
			num2 = num2 / 2f + 5f;
		}
		return (float)currentWave >= num + (float)spawnedEnemyTypes[indexOf].amount * num2;
	}

	private bool SpawnUncommons(int target, int amount)
	{
		amount = CapUncommonsAmount(target, amount);
		bool result = false;
		for (int i = 0; i < amount; i++)
		{
			EndlessEnemy endlessEnemy = prefabs.uncommonEnemies[target];
			bool flag = endlessEnemy.enemyType != EnemyType.Stalker && endlessEnemy.enemyType != EnemyType.Guttertank && UnityEngine.Random.Range(0f, 1f) > 0.5f;
			if (flag && usedProjectilePositions >= projectilePositions.Count - 1)
			{
				flag = false;
			}
			if (usedMeleePositions >= meleePositions.Count - 1)
			{
				break;
			}
			int indexOfEnemyType = GetIndexOfEnemyType(endlessEnemy.enemyType);
			int num = endlessEnemy.costIncreasePerSpawn * spawnedEnemyTypes[indexOfEnemyType].amount;
			_ = endlessEnemy.spawnCost;
			if (currentWave < endlessEnemy.spawnWave || points / 2 < endlessEnemy.spawnCost + num)
			{
				break;
			}
			bool flag2 = SpawnRadiant(endlessEnemy, indexOfEnemyType);
			SpawnOnGrid(endlessEnemy.prefab, flag ? projectilePositions[usedProjectilePositions] : meleePositions[usedMeleePositions], prefab: false, enemy: true, CyberPooledType.None, flag2);
			points -= endlessEnemy.spawnCost * ((!flag2) ? 1 : 3) + num;
			spawnedEnemyTypes[indexOfEnemyType].amount++;
			if (flag)
			{
				usedProjectilePositions++;
			}
			else
			{
				usedMeleePositions++;
			}
			tempEnemyAmount++;
			result = true;
			if (flag2)
			{
				amount -= 2;
			}
		}
		return result;
	}

	private void GetNextEnemy()
	{
		if (!base.gameObject.scene.isLoaded)
		{
			return;
		}
		if ((points > 0 && usedMeleePositions < meleePositions.Count) || (points > 1 && usedProjectilePositions < projectilePositions.Count))
		{
			if ((UnityEngine.Random.Range(0f, 1f) < 0.5f || usedProjectilePositions >= projectilePositions.Count) && usedMeleePositions < meleePositions.Count)
			{
				int num = UnityEngine.Random.Range(0, prefabs.meleeEnemies.Length);
				bool flag = false;
				for (int num2 = num; num2 >= 0; num2--)
				{
					EndlessEnemy endlessEnemy = prefabs.meleeEnemies[num2];
					int indexOfEnemyType = GetIndexOfEnemyType(endlessEnemy.enemyType);
					int num3 = endlessEnemy.costIncreasePerSpawn * spawnedEnemyTypes[indexOfEnemyType].amount;
					int num4 = endlessEnemy.spawnCost + num3;
					if (((float)points >= (float)num4 * 1.5f || (num2 == 0 && points >= num4)) && currentWave >= endlessEnemy.spawnWave)
					{
						bool flag2 = SpawnRadiant(endlessEnemy, indexOfEnemyType);
						flag = true;
						SpawnOnGrid(endlessEnemy.prefab, meleePositions[usedMeleePositions], prefab: false, enemy: true, CyberPooledType.None, flag2);
						points -= endlessEnemy.spawnCost * ((!flag2) ? 1 : 3) + num3;
						spawnedEnemyTypes[indexOfEnemyType].amount++;
						usedMeleePositions++;
						tempEnemyAmount++;
						break;
					}
				}
				if (!flag)
				{
					usedMeleePositions = meleePositions.Count;
				}
			}
			else if (usedProjectilePositions < projectilePositions.Count)
			{
				int num5 = UnityEngine.Random.Range(0, prefabs.projectileEnemies.Length);
				bool flag3 = false;
				for (int num6 = num5; num6 >= 0; num6--)
				{
					EndlessEnemy endlessEnemy2 = prefabs.projectileEnemies[num6];
					int indexOfEnemyType2 = GetIndexOfEnemyType(endlessEnemy2.enemyType);
					int num7 = endlessEnemy2.costIncreasePerSpawn * spawnedEnemyTypes[indexOfEnemyType2].amount;
					int num8 = endlessEnemy2.spawnCost + num7;
					if (((float)points >= (float)num8 * 1.5f || (num6 == 0 && points >= num8)) && currentWave >= endlessEnemy2.spawnWave)
					{
						bool flag4 = SpawnRadiant(endlessEnemy2, indexOfEnemyType2);
						flag3 = true;
						SpawnOnGrid(endlessEnemy2.prefab, projectilePositions[usedProjectilePositions], prefab: false, enemy: true, CyberPooledType.None, flag4);
						points -= endlessEnemy2.spawnCost * ((!flag4) ? 1 : 3) + num7;
						spawnedEnemyTypes[indexOfEnemyType2].amount++;
						usedProjectilePositions++;
						tempEnemyAmount++;
						break;
					}
				}
				if (!flag3)
				{
					usedProjectilePositions = projectilePositions.Count;
				}
			}
			Invoke("GetNextEnemy", 0.1f);
		}
		else
		{
			enemyAmount = tempEnemyAmount;
		}
	}

	private void ShuffleDecks()
	{
		int num = Mathf.FloorToInt(CurrentPatternPool.Length / 2);
		for (int i = 0; i < num; i++)
		{
			ArenaPattern arenaPattern = CurrentPatternPool[i];
			int num2 = UnityEngine.Random.Range(i, num);
			CurrentPatternPool[i] = CurrentPatternPool[num2];
			CurrentPatternPool[num2] = arenaPattern;
		}
		for (int j = num; j < CurrentPatternPool.Length; j++)
		{
			ArenaPattern arenaPattern2 = CurrentPatternPool[j];
			int num3 = UnityEngine.Random.Range(j, CurrentPatternPool.Length);
			CurrentPatternPool[j] = CurrentPatternPool[num3];
			CurrentPatternPool[num3] = arenaPattern2;
		}
	}

	private string SplitCamelCase(string str)
	{
		return Regex.Replace(Regex.Replace(str, "(\\P{Ll})(\\P{Ll}\\p{Ll})", "$1 $2"), "(\\p{Ll})(\\P{Ll})", "$1 $2");
	}
}



public class EndlessHighScore : MonoBehaviour
{
	private TMP_Text text;

	private void OnEnable()
	{
		if (!text)
		{
			text = GetComponent<TMP_Text>();
		}
		if ((bool)text)
		{
			int num = (int)Mathf.Floor(GameProgressSaver.GetBestCyber().preciseWavesByDifficulty[MonoSingleton<PrefsManager>.Instance.GetInt("difficulty", 2)]);
			if (num <= 0)
			{
				text.text = "";
			}
			else
			{
				text.text = string.Concat(num);
			}
		}
	}
}



public class EndlessPrefabAnimator : MonoBehaviour
{
	private Vector3 origPos;

	private bool moving;

	public bool reverse;

	public bool reverseOnly;

	private EndlessGrid eg;

	private CyberPooledPrefab pooledId;

	public void Start()
	{
		if (!pooledId)
		{
			pooledId = GetComponent<CyberPooledPrefab>();
		}
		origPos = base.transform.position;
		if (!reverseOnly)
		{
			base.transform.position = origPos - Vector3.up * 20f;
			moving = true;
		}
	}

	private void Update()
	{
		if (moving)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, origPos, Time.deltaTime * 2f + 5f * Vector3.Distance(base.transform.position, origPos) * Time.deltaTime);
			if (base.transform.position == origPos)
			{
				moving = false;
				eg = GetComponentInParent<EndlessGrid>();
				eg.OnePrefabDone();
			}
		}
		else
		{
			if (!reverse)
			{
				return;
			}
			base.transform.position = Vector3.MoveTowards(base.transform.position, origPos - Vector3.up * 20f, Time.deltaTime * 2f + 5f * Vector3.Distance(base.transform.position, origPos) * Time.deltaTime);
			if (base.transform.position == origPos - Vector3.up * 20f)
			{
				if ((bool)pooledId)
				{
					base.gameObject.SetActive(value: false);
				}
				else
				{
					Object.Destroy(base.gameObject);
				}
			}
		}
	}
}



public class EndlessScrollingPiece : MonoBehaviour
{
	private Rigidbody rb;

	public Vector3 velocity;

	public float maxDistance;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		if (Vector3.Distance(base.transform.position, base.transform.parent.position) > maxDistance)
		{
			base.transform.position += velocity.normalized * -2f * maxDistance;
		}
		rb.MovePosition(base.transform.position + velocity * Time.fixedDeltaTime);
	}
}



public class EndlessStairs : MonoBehaviour
{
	[SerializeField]
	private MeshRenderer primaryMeshRenderer;

	[SerializeField]
	private MeshRenderer secondaryMeshRenderer;

	[SerializeField]
	private MeshFilter primaryMeshFilter;

	[SerializeField]
	private MeshFilter secondaryMeshFilter;

	private Transform primaryStairs;

	private Transform secondaryStairs;

	private LayerMask lmask;

	private bool activateFirst;

	private bool activateSecond;

	private bool moving;

	public MeshRenderer PrimaryMeshRenderer => primaryMeshRenderer;

	public MeshRenderer SecondaryMeshRenderer => secondaryMeshRenderer;

	public MeshFilter PrimaryMeshFilter => primaryMeshFilter;

	public MeshFilter SecondaryMeshFilter => secondaryMeshFilter;

	public bool ActivateFirst => activateFirst;

	public bool ActivateSecond => activateSecond;

	private void Start()
	{
		lmask = 16777216;
		primaryStairs = base.transform.GetChild(0);
		secondaryStairs = base.transform.GetChild(1);
		if (RayCastCheck(base.transform.forward))
		{
			if (!RayCastCheck(base.transform.forward * -1f))
			{
				activateFirst = true;
				primaryStairs.forward = base.transform.forward;
			}
		}
		else if (RayCastCheck(base.transform.forward * -1f))
		{
			activateFirst = true;
			primaryStairs.forward = base.transform.forward * -1f;
		}
		if (RayCastCheck(base.transform.right))
		{
			if (!RayCastCheck(base.transform.right * -1f))
			{
				activateSecond = true;
				secondaryStairs.forward = base.transform.right;
			}
		}
		else if (RayCastCheck(base.transform.right * -1f))
		{
			activateSecond = true;
			secondaryStairs.forward = base.transform.right * -1f;
		}
		if (activateFirst && RayCastCheck(primaryStairs.forward, 4f))
		{
			primaryStairs.localScale = new Vector3(1f, 2f, 1f);
		}
		if (activateSecond && RayCastCheck(secondaryStairs.forward, 4f))
		{
			secondaryStairs.localScale = new Vector3(1f, 2f, 1f);
		}
		if (primaryStairs.localScale.y == 2f && activateSecond && secondaryStairs.localScale.y == 1f)
		{
			activateFirst = false;
		}
		else if (secondaryStairs.localScale.y == 2f && activateFirst && primaryStairs.localScale.y == 1f)
		{
			activateSecond = false;
		}
		Invoke("ActivationTime", 0.1f);
	}

	private bool RayCastCheck(Vector3 direction, float height = 1f)
	{
		if (Physics.Raycast(base.transform.position + Vector3.up * height, direction, 3f, lmask) && !Physics.Raycast(base.transform.position + Vector3.up * 6f, direction, 3f, lmask))
		{
			return true;
		}
		return false;
	}

	private void ActivationTime()
	{
		moving = true;
		if (activateFirst)
		{
			primaryStairs.position = base.transform.position - Vector3.up * 5f;
			primaryStairs.gameObject.SetActive(value: true);
		}
		if (activateSecond)
		{
			secondaryStairs.position = base.transform.position - Vector3.up * 5f;
			secondaryStairs.gameObject.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (moving)
		{
			if (activateFirst)
			{
				primaryStairs.position = Vector3.MoveTowards(primaryStairs.position, base.transform.position, Time.deltaTime * 2f + 5f * Vector3.Distance(primaryStairs.position, base.transform.position) * Time.deltaTime);
			}
			if (activateSecond)
			{
				secondaryStairs.position = Vector3.MoveTowards(secondaryStairs.position, base.transform.position, Time.deltaTime * 2f + 5f * Vector3.Distance(secondaryStairs.position, base.transform.position) * Time.deltaTime);
			}
			if ((!activateFirst || primaryStairs.position == base.transform.position) && (!activateSecond || secondaryStairs.position == base.transform.position))
			{
				moving = false;
				GetComponentInParent<EndlessGrid>().OnePrefabDone();
			}
		}
	}
}



public class Enemy : MonoBehaviour
{
	private Rigidbody[] rbs;

	public bool limp;

	private Rigidbody rb;

	private Animator anim;

	private float currentSpeed;

	public float coolDown;

	public bool damaging;

	private TrailRenderer tr;

	private bool track;

	private AudioSource aud;

	private GroundCheck gc;

	public bool grounded;

	private float defaultSpeed;

	public Vector3 agentVelocity;

	private void Start()
	{
		rbs = GetComponentsInChildren<Rigidbody>();
		rb = GetComponent<Rigidbody>();
		anim = GetComponent<Animator>();
		gc = GetComponentInChildren<GroundCheck>();
	}
}


public enum EnemyClass
{
	Husk,
	Machine,
	Demon,
	Divine,
	Other
}



public class EnemyCooldowns : MonoSingleton<EnemyCooldowns>
{
	public float virtueCooldown;

	public float ferrymanCooldown;

	public List<Drone> currentVirtues = new List<Drone>();

	public List<Ferryman> ferrymen = new List<Ferryman>();

	private void Start()
	{
		SlowUpdate();
	}

	private void Update()
	{
		if (virtueCooldown > 0f)
		{
			virtueCooldown = Mathf.MoveTowards(virtueCooldown, 0f, Time.deltaTime);
		}
		if (ferrymanCooldown > 0f)
		{
			ferrymanCooldown = Mathf.MoveTowards(ferrymanCooldown, 0f, Time.deltaTime);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 10f);
		for (int num = currentVirtues.Count - 1; num >= 0; num--)
		{
			if (currentVirtues[num] == null || !currentVirtues[num].gameObject.activeInHierarchy)
			{
				currentVirtues.RemoveAt(num);
			}
		}
		for (int num2 = ferrymen.Count - 1; num2 >= 0; num2--)
		{
			if (ferrymen[num2] == null || !ferrymen[num2].gameObject.activeInHierarchy)
			{
				ferrymen.RemoveAt(num2);
			}
		}
	}

	public void AddVirtue(Drone drn)
	{
		if (currentVirtues.Count <= 0 || !currentVirtues.Contains(drn))
		{
			currentVirtues.Add(drn);
		}
	}

	public void RemoveVirtue(Drone drn)
	{
		if (currentVirtues.Count > 0 && currentVirtues.Contains(drn))
		{
			currentVirtues.Remove(drn);
		}
	}

	public void AddFerryman(Ferryman fm)
	{
		if (ferrymen.Count <= 0 || !ferrymen.Contains(fm))
		{
			ferrymen.Add(fm);
		}
	}

	public void RemoveFerryman(Ferryman fm)
	{
		if (ferrymen.Count > 0 && ferrymen.Contains(fm))
		{
			ferrymen.Remove(fm);
		}
	}
}



[DefaultExecutionOrder(-500)]
public class EnemyIdentifier : MonoBehaviour, IAlter, IAlterOptions<bool>, IEnemyHealthDetails
{
	private static readonly plog.Logger Log = new plog.Logger("EnemyIdentifier");

	[HideInInspector]
	public Zombie zombie;

	[HideInInspector]
	public SpiderBody spider;

	[HideInInspector]
	public Machine machine;

	[HideInInspector]
	public Statue statue;

	[HideInInspector]
	public Wicked wicked;

	[HideInInspector]
	public Drone drone;

	[HideInInspector]
	public Idol idol;

	public EnemyClass enemyClass;

	public EnemyType enemyType;

	public bool spawnIn;

	public GameObject spawnEffect;

	public float health;

	[HideInInspector]
	public string hitter;

	[HideInInspector]
	public List<HitterAttribute> hitterAttributes = new List<HitterAttribute>();

	[HideInInspector]
	public List<string> hitterWeapons = new List<string>();

	public string[] weaknesses;

	public float[] weaknessMultipliers;

	public float totalDamageTakenMultiplier = 1f;

	public GameObject weakPoint;

	public Transform overrideCenter;

	[HideInInspector]
	public bool exploded;

	public bool dead;

	[HideInInspector]
	public DoorController usingDoor;

	public bool ignoredByEnemies;

	private EnemyIdentifierIdentifier[] limbs;

	[HideInInspector]
	public int nailsAmount;

	[HideInInspector]
	public List<Nail> nails = new List<Nail>();

	public bool useBrakes;

	public bool bigEnemy;

	public bool unbounceable;

	public bool poise;

	public bool immuneToFriendlyFire;

	[HideInInspector]
	public bool beingZapped;

	[HideInInspector]
	public TimeSince lastZapped;

	[HideInInspector]
	public bool pulledByMagnet;

	[HideInInspector]
	public List<Magnet> stuckMagnets = new List<Magnet>();

	[HideInInspector]
	public List<Harpoon> drillers = new List<Harpoon>();

	[HideInInspector]
	public bool underwater;

	[HideInInspector]
	public List<Water> touchingWaters = new List<Water>();

	[HideInInspector]
	public bool checkingSpawnStatus = true;

	public bool flying;

	public bool dontCountAsKills;

	public bool dontUnlockBestiary;

	public bool specialOob;

	public GameObject[] activateOnDeath;

	public UnityEvent onDeath;

	public UltrakillEvent onEnable;

	private BloodsplatterManager bsm;

	[HideInInspector]
	public GroundCheckEnemy gce;

	private GoreZone gz;

	private Rigidbody rb;

	private RigidbodyConstraints rbc;

	private List<GameObject> sandifiedParticles = new List<GameObject>();

	[HideInInspector]
	public List<GameObject> blessingGlows = new List<GameObject>();

	[HideInInspector]
	public EnemyIdentifier buffTargeter;

	public int difficultyOverride = -1;

	private int difficulty;

	[HideInInspector]
	public bool hooked;

	public List<Flammable> burners;

	[HideInInspector]
	public List<Flammable> flammables;

	private bool getFireDamageMultiplier;

	[HideInInspector]
	public bool beenGasolined;

	[HideInInspector]
	public bool harpooned;

	[HideInInspector]
	public Zapper zapperer;

	private GameObject afterShockSourceWeapon;

	private bool waterOnlyAftershock;

	[Header("Modifiers")]
	public bool hookIgnore;

	public bool sandified;

	public bool blessed;

	public bool puppet;

	private bool permaPuppet;

	private int blessings;

	private float puppetSpawnTimer;

	[HideInInspector]
	public Vector3 squishedScale;

	[HideInInspector]
	public Vector3 originalScale;

	private List<Renderer> puppetRenderers = new List<Renderer>();

	private bool puppetSpawnIgnoringPlayer;

	private Collider[] puppetSpawnColliders;

	public float radianceTier = 1f;

	public bool healthBuff;

	public float healthBuffModifier = 1.5f;

	[HideInInspector]
	public int healthBuffRequests;

	public bool speedBuff;

	public float speedBuffModifier = 1.5f;

	[HideInInspector]
	public int speedBuffRequests;

	public bool damageBuff;

	public float damageBuffModifier = 1.5f;

	[HideInInspector]
	public int damageBuffRequests;

	[HideInInspector]
	public float totalSpeedModifier = 1f;

	[HideInInspector]
	public float totalDamageModifier = 1f;

	[HideInInspector]
	public float totalHealthModifier = 1f;

	[HideInInspector]
	public bool isBoss;

	[Space(10f)]
	public List<Renderer> buffUnaffectedRenderers = new List<Renderer>();

	[SerializeField]
	private string overrideFullName;

	[Header("Relationships")]
	public bool ignorePlayer;

	public bool attackEnemies;

	public EnemyTarget target;

	public bool prioritizePlayerOverFallback = true;

	public bool prioritizeEnemiesUnlessAttacked;

	public Transform fallbackTarget;

	[HideInInspector]
	public bool madness;

	[HideInInspector]
	public TimeSince timeSinceSpawned;

	private TimeSince? timeSinceNoTarget;

	[HideInInspector]
	public EnemyScanner enemyScanner;

	private IEnemyRelationshipLogic[] relationshipLogic;

	private EnemyIdentifierDebugOverlay debugOverlay;

	private BossHealthBar cheatCreatedBossBar;

	[HideInInspector]
	public List<GameObject> destroyOnDeath = new List<GameObject>();

	private static readonly int HasSandBuff = Shader.PropertyToID("_HasSandBuff");

	[HideInInspector]
	public bool isGasolined
	{
		get
		{
			foreach (Flammable flammable in flammables)
			{
				if (flammable.fuel > 0f)
				{
					return true;
				}
			}
			return false;
		}
	}

	private bool IsSandboxEnemy
	{
		get
		{
			if (TryGetComponent<SandboxEnemy>(out var component))
			{
				return component.sourceObject != null;
			}
			return false;
		}
	}

	public bool IsCurrentTargetFallback
	{
		get
		{
			if (target != null && fallbackTarget != null)
			{
				return target.trackedTransform == fallbackTarget;
			}
			return false;
		}
	}

	public string FullName
	{
		get
		{
			if (!string.IsNullOrEmpty(overrideFullName))
			{
				return overrideFullName;
			}
			return EnemyTypes.GetEnemyName(enemyType);
		}
	}

	public float Health => health;

	public bool Dead => dead;

	public bool Blessed => blessed;

	public bool AttackEnemies
	{
		get
		{
			if (BlindEnemies.Blind)
			{
				return false;
			}
			if (EnemiesHateEnemies.Active)
			{
				return true;
			}
			if (madness)
			{
				return true;
			}
			IEnemyRelationshipLogic[] array = relationshipLogic;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].ShouldAttackEnemies())
				{
					return true;
				}
			}
			return attackEnemies;
		}
	}

	public bool IgnorePlayer
	{
		get
		{
			if (BlindEnemies.Blind)
			{
				return true;
			}
			if (EnemyIgnorePlayer.Active)
			{
				return true;
			}
			if (madness)
			{
				return true;
			}
			IEnemyRelationshipLogic[] array = relationshipLogic;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].ShouldIgnorePlayer())
				{
					return true;
				}
			}
			return ignorePlayer;
		}
	}

	public string alterKey => "enemy-identifier";

	public string alterCategoryName => "enemy";

	public AlterOption<bool>[] options => new AlterOption<bool>[5]
	{
		new AlterOption<bool>
		{
			name = "Boss Health Bar",
			key = "health-bar",
			callback = delegate(bool value)
			{
				BossBar(value);
			},
			value = (GetComponent<BossHealthBar>() != null)
		},
		new AlterOption<bool>
		{
			name = "Sandified",
			key = "sandified",
			callback = delegate(bool value)
			{
				if (value)
				{
					Sandify();
				}
				else
				{
					Desandify();
				}
			},
			value = sandified
		},
		new AlterOption<bool>
		{
			name = "Puppeted",
			key = "puppeted",
			callback = ((!puppet || (IsSandboxEnemy && !permaPuppet)) ? ((Action<bool>)delegate(bool value)
			{
				if (value && !puppet)
				{
					PuppetSpawn();
				}
				if (!value && puppet && IsSandboxEnemy)
				{
					TryUnPuppet();
				}
			}) : null),
			tooltip = (permaPuppet ? "This enemy cannot be un-puppeteered " : ((puppet && !IsSandboxEnemy) ? "Un-puppeteering is not supported for non-sandbox enemies" : null)),
			value = puppet
		},
		new AlterOption<bool>
		{
			name = "Ignore Player",
			key = "ignorePlayer",
			callback = delegate(bool value)
			{
				ignorePlayer = value;
			},
			value = ignorePlayer
		},
		new AlterOption<bool>
		{
			name = "Attack Enemies",
			key = "attackEnemies",
			callback = delegate(bool value)
			{
				attackEnemies = value;
			},
			value = attackEnemies
		}
	};

	private void Awake()
	{
		if (puppet)
		{
			permaPuppet = true;
		}
		health = 999f;
		InitializeReferences();
		ForceGetHealth();
		UpdateModifiers();
		if (StockMapInfo.Instance != null && StockMapInfo.Instance.forceUpdateEnemyRenderers)
		{
			SkinnedMeshRenderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].updateWhenOffscreen = true;
			}
		}
	}

	private void OnEnable()
	{
		onEnable?.Invoke();
	}

	private void OnDisable()
	{
		onEnable?.Revert();
	}

	private void InitializeReferences()
	{
		if (enemyType == EnemyType.Idol)
		{
			if (!idol)
			{
				idol = (idol ? idol : GetComponent<Idol>());
			}
			ignoredByEnemies = true;
		}
		relationshipLogic = GetComponents<IEnemyRelationshipLogic>();
		rb = GetComponent<Rigidbody>();
		gce = GetComponentInChildren<GroundCheckEnemy>(includeInactive: true);
		Flammable[] componentsInChildren = GetComponentsInChildren<Flammable>();
		foreach (Flammable flammable in componentsInChildren)
		{
			if (!flammables.Contains(flammable))
			{
				flammables.Add(flammable);
			}
			if (!flammable.fuelOnly)
			{
				getFireDamageMultiplier = true;
			}
		}
	}

	public bool DestroyLimb(Transform limb, LimbDestroyType type = LimbDestroyType.Destroy)
	{
		if (puppet)
		{
			type = LimbDestroyType.Destroy;
		}
		if (!limb.TryGetComponent<CharacterJoint>(out var component))
		{
			return false;
		}
		UnityEngine.Object.Destroy(component);
		GoreZone goreZone = GetGoreZone();
		if (type == LimbDestroyType.Detach)
		{
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && limb.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
			{
				component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
			limb.transform.parent = goreZone.transform;
		}
		if (type == LimbDestroyType.LimbGibs)
		{
			CharacterJoint[] componentsInChildren = limb.GetComponentsInChildren<CharacterJoint>();
			foreach (CharacterJoint characterJoint in componentsInChildren)
			{
				if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component3))
				{
					component3.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
				}
				UnityEngine.Object.Destroy(characterJoint);
				characterJoint.transform.parent = goreZone.transform;
			}
		}
		if (type == LimbDestroyType.Destroy)
		{
			CharacterJoint[] componentsInChildren = limb.GetComponentsInChildren<CharacterJoint>();
			foreach (CharacterJoint characterJoint2 in componentsInChildren)
			{
				if (characterJoint2.TryGetComponent<Collider>(out var component4))
				{
					UnityEngine.Object.Destroy(characterJoint2);
					if ((bool)component4.attachedRigidbody)
					{
						UnityEngine.Object.Destroy(component4.attachedRigidbody);
					}
					UnityEngine.Object.Destroy(component4);
				}
				else
				{
					UnityEngine.Object.Destroy(characterJoint2);
				}
				characterJoint2.transform.localScale = Vector3.zero;
				characterJoint2.gameObject.SetActive(value: false);
			}
		}
		if (type != LimbDestroyType.Detach)
		{
			limb.localScale = Vector3.zero;
			limb.gameObject.SetActive(value: false);
		}
		return true;
	}

	public bool IsTypeFriendly(EnemyIdentifier owner)
	{
		if (enemyType == owner.enemyType)
		{
			return true;
		}
		if (enemyClass == EnemyClass.Husk && owner.enemyClass == EnemyClass.Husk)
		{
			return true;
		}
		return false;
	}

	private GoreZone GetGoreZone()
	{
		if ((bool)gz)
		{
			return gz;
		}
		Transform parent = base.transform;
		if (enemyType == EnemyType.Cerberus)
		{
			parent = parent.parent;
		}
		gz = GoreZone.ResolveGoreZone(parent);
		return gz;
	}

	public void ForceGetHealth()
	{
		if (enemyType == EnemyType.Drone || enemyType == EnemyType.Virtue)
		{
			if (!drone)
			{
				drone = GetComponent<Drone>();
			}
			if ((bool)drone)
			{
				health = drone.health;
			}
			return;
		}
		if (enemyType == EnemyType.MaliciousFace)
		{
			if (!spider)
			{
				spider = GetComponent<SpiderBody>();
			}
			if ((bool)spider)
			{
				health = spider.health;
			}
			return;
		}
		switch (enemyClass)
		{
		case EnemyClass.Husk:
			if (!zombie)
			{
				zombie = GetComponent<Zombie>();
			}
			if ((bool)zombie)
			{
				health = zombie.health;
			}
			break;
		case EnemyClass.Demon:
			if (!statue)
			{
				statue = GetComponent<Statue>();
			}
			if ((bool)statue)
			{
				health = statue.health;
			}
			break;
		case EnemyClass.Machine:
			if (!machine)
			{
				machine = GetComponent<Machine>();
			}
			if ((bool)machine)
			{
				health = machine.health;
			}
			break;
		}
	}

	private void Start()
	{
		if (OptionsManager.forcePuppet)
		{
			puppet = true;
		}
		if (spawnIn && (bool)spawnEffect && !puppet)
		{
			Collider component = GetComponent<Collider>();
			if ((bool)component)
			{
				UnityEngine.Object.Instantiate(spawnEffect, component.bounds.center, base.transform.rotation);
			}
			else
			{
				UnityEngine.Object.Instantiate(spawnEffect, base.transform.position + Vector3.up * 1.5f, base.transform.rotation);
			}
			spawnIn = false;
			timeSinceSpawned = 0f;
		}
		if (!dontUnlockBestiary)
		{
			MonoSingleton<BestiaryData>.Instance.SetEnemy(enemyType, 1);
		}
		bsm = MonoSingleton<BloodsplatterManager>.Instance;
		if (checkingSpawnStatus)
		{
			if (!dead)
			{
				if (OptionsManager.forceBossBars)
				{
					BossBar(enable: true);
				}
				if (puppet)
				{
					PuppetSpawn();
				}
				if ((sandified || OptionsManager.forceSand) && enemyType != EnemyType.Stalker)
				{
					Sandify(ignorePrevious: true);
				}
				if (blessed)
				{
					Bless(ignorePrevious: true);
				}
				if (speedBuff || damageBuff || healthBuff || OptionsManager.forceRadiance)
				{
					if (speedBuff)
					{
						speedBuffRequests++;
					}
					if (damageBuff)
					{
						damageBuffRequests++;
					}
					if (healthBuff)
					{
						healthBuffRequests++;
					}
					UpdateBuffs();
				}
			}
			checkingSpawnStatus = false;
		}
		if (!MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies().Contains(this))
		{
			MonoSingleton<EnemyTracker>.Instance.AddEnemy(this);
		}
		if ((bool)MonoSingleton<MarkedForDeath>.Instance && MonoSingleton<MarkedForDeath>.Instance.gameObject.activeInHierarchy)
		{
			PlayerMarkedForDeath();
		}
		isBoss = GetComponentInChildren<BossIdentifier>() != null;
		if (difficultyOverride >= 0)
		{
			difficulty = difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		UpdateTarget();
		SlowUpdate();
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 1f);
		if (drillers.Count <= 0)
		{
			return;
		}
		for (int num = drillers.Count - 1; num >= 0; num--)
		{
			if (drillers[num] == null || !drillers[num].gameObject.activeInHierarchy)
			{
				drillers.RemoveAt(num);
			}
		}
	}

	private void Update()
	{
		UpdateTarget();
		UpdateEnemyScanner();
		ForceGetHealth();
		UpdateModifiers();
		UpdateDebugStuff();
		if (!puppet)
		{
			return;
		}
		if (puppetSpawnTimer < 1f)
		{
			puppetSpawnTimer = Mathf.MoveTowards(puppetSpawnTimer, 1f, Time.deltaTime * 2f * Mathf.Max(1f - puppetSpawnTimer, 0.001f));
			base.transform.localScale = Vector3.Lerp(squishedScale, originalScale, puppetSpawnTimer);
			squishedScale = new Vector3(Mathf.MoveTowards(squishedScale.x, originalScale.x * puppetSpawnTimer, Time.deltaTime * 4f), squishedScale.y, Mathf.MoveTowards(squishedScale.z, originalScale.z * puppetSpawnTimer, Time.deltaTime * 4f));
			if (puppetSpawnIgnoringPlayer && puppetSpawnTimer > 0.75f)
			{
				puppetSpawnIgnoringPlayer = false;
				Collider[] array = puppetSpawnColliders;
				for (int i = 0; i < array.Length; i++)
				{
					Physics.IgnoreCollision(array[i], MonoSingleton<NewMovement>.Instance.playerCollider, ignore: false);
				}
				if ((bool)rb)
				{
					rb.constraints = rbc;
				}
			}
			UpdateBuffs();
		}
		foreach (Renderer puppetRenderer in puppetRenderers)
		{
			if (puppetRenderer != null)
			{
				MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
				puppetRenderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat("_VertexNoiseAmplitude", Mathf.Lerp(10f, 1f, Mathf.Max(0f, puppetSpawnTimer - 0.5f) * 2f));
				materialPropertyBlock.SetColor("_FlowDirection", new Color(UnityEngine.Random.Range(0f, 1f), 0.2f, UnityEngine.Random.Range(0f, 1f)));
				puppetRenderer.SetPropertyBlock(materialPropertyBlock);
			}
		}
	}

	private void UpdateEnemyScanner()
	{
		if (!AttackEnemies)
		{
			enemyScanner?.Reset();
			return;
		}
		if (enemyScanner == null)
		{
			enemyScanner = new EnemyScanner(this);
		}
		enemyScanner.Update();
	}

	private void UpdateDebugStuff()
	{
		if (EnemyIdentifierDebug.Active)
		{
			if (debugOverlay == null)
			{
				debugOverlay = base.gameObject.AddComponent<EnemyIdentifierDebugOverlay>();
			}
			debugOverlay.ConsumeData(enemyType, enemyClass, dead, IgnorePlayer, AttackEnemies, target);
		}
		else if (debugOverlay != null)
		{
			UnityEngine.Object.Destroy(debugOverlay);
		}
		if (ForceBossBars.Active)
		{
			if (!GetComponent<BossHealthBar>())
			{
				cheatCreatedBossBar = base.gameObject.AddComponent<BossHealthBar>();
			}
		}
		else if (cheatCreatedBossBar != null)
		{
			UnityEngine.Object.Destroy(cheatCreatedBossBar);
		}
	}

	private bool HandleTargetCheats()
	{
		if (BlindEnemies.Blind)
		{
			target = null;
			return true;
		}
		if (EnemyIgnorePlayer.Active && target != null && target.isPlayer)
		{
			target = null;
		}
		return false;
	}

	private void UpdateTarget()
	{
		if (target != null && !target.isValid)
		{
			if (target.trackedTransform == fallbackTarget)
			{
				fallbackTarget = null;
			}
			target = null;
		}
		if (timeSinceNoTarget.HasValue && target != null)
		{
			timeSinceNoTarget = null;
		}
		if (!timeSinceNoTarget.HasValue && target == null)
		{
			timeSinceNoTarget = 0f;
		}
		if (HandleTargetCheats())
		{
			return;
		}
		if (!IgnorePlayer)
		{
			bool flag = fallbackTarget == null;
			flag |= prioritizePlayerOverFallback && (target == null || target.trackedTransform == fallbackTarget);
			if (!timeSinceNoTarget.HasValue || (float?)timeSinceNoTarget < 1.5f)
			{
				if (AttackEnemies && prioritizeEnemiesUnlessAttacked)
				{
					flag = false;
				}
				if (enemyType == EnemyType.Stalker)
				{
					flag = false;
				}
			}
			if (flag)
			{
				target = EnemyTarget.TrackPlayer();
			}
		}
		else if (target != null && target.isPlayer)
		{
			target = null;
		}
		if (target == null && fallbackTarget != null)
		{
			EnemyTarget enemyTarget = new EnemyTarget(fallbackTarget);
			if (enemyTarget.isValid)
			{
				target = enemyTarget;
			}
			else
			{
				fallbackTarget = null;
			}
		}
	}

	public void SetFallbackTarget(GameObject target)
	{
		fallbackTarget = target.transform;
	}

	public void SetOverrideCenter(Transform center)
	{
		overrideCenter = center;
	}

	public void ResetTarget()
	{
		target = null;
	}

	private void UpdateModifiers()
	{
		totalSpeedModifier = 1f;
		totalHealthModifier = 1f;
		totalDamageModifier = 1f;
		float num = Mathf.Max(OptionsManager.radianceTier, radianceTier);
		if (speedBuff || OptionsManager.forceRadiance)
		{
			totalSpeedModifier *= speedBuffModifier * ((num > 1f) ? (0.75f + num / 4f) : num);
		}
		if (healthBuff || OptionsManager.forceRadiance)
		{
			totalHealthModifier *= healthBuffModifier * ((num > 1f) ? (0.75f + num / 4f) : num);
		}
		if (damageBuff || OptionsManager.forceRadiance)
		{
			totalDamageModifier *= damageBuffModifier;
		}
		if (puppet)
		{
			totalHealthModifier /= 2f;
			totalSpeedModifier *= Mathf.Lerp(0.01f, Mathf.Max(0.01f, puppetSpawnTimer - 0.75f) * 3f, puppetSpawnTimer);
		}
	}

	public void StartBurning(float heat)
	{
		foreach (Flammable flammable in flammables)
		{
			flammable.Burn(heat);
		}
	}

	public void Burn()
	{
		CancelInvoke("Burn");
		if (burners.Count == 0)
		{
			return;
		}
		for (int num = burners.Count - 1; num >= 0; num--)
		{
			if (burners[num] == null)
			{
				burners.RemoveAt(num);
			}
			else if (!burners[num].burning)
			{
				burners.RemoveAt(num);
			}
			else
			{
				burners[num].Pulse();
			}
		}
		if (burners.Count == 0)
		{
			return;
		}
		Invoke("Burn", 0.5f);
		if (!dead)
		{
			TryIgniteGasoline();
		}
		float num2 = 0f;
		foreach (Flammable flammable in flammables)
		{
			num2 = Mathf.Max(num2, flammable.fuel);
		}
		hitter = "fire";
		DeliverDamage(base.gameObject, Vector3.zero, base.transform.position, (num2 > 0f) ? 0.5f : 0.2f, tryForExplode: false);
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren)
		{
			if (!buffUnaffectedRenderers.Contains(renderer) && !(renderer is ParticleSystemRenderer))
			{
				MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
				renderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat("_OiledAmount", num2 / 5f);
				renderer.SetPropertyBlock(materialPropertyBlock);
			}
		}
	}

	private void TryIgniteGasoline()
	{
		MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position);
	}

	public void DeliverDamage(GameObject target, Vector3 force, Vector3 hitPoint, float multiplier, bool tryForExplode, float critMultiplier = 0f, GameObject sourceWeapon = null, bool ignoreTotalDamageTakenMultiplier = false, bool fromExplosion = false)
	{
		if (EnemyIdentifierDebug.Active)
		{
			Log.Fine("Delivering damage to: " + base.gameObject.name + ", Damage:" + multiplier);
		}
		if (target == base.gameObject)
		{
			EnemyIdentifierIdentifier componentInChildren = GetComponentInChildren<EnemyIdentifierIdentifier>();
			if (componentInChildren != null)
			{
				target = componentInChildren.gameObject;
			}
		}
		if (sourceWeapon != null)
		{
			if (prioritizeEnemiesUnlessAttacked)
			{
				prioritizeEnemiesUnlessAttacked = false;
			}
			if (!IgnorePlayer && ((this.target != null && !this.target.isPlayer) || this.target == null))
			{
				this.target = EnemyTarget.TrackPlayer();
				HandleTargetCheats();
			}
		}
		if (!ignoreTotalDamageTakenMultiplier)
		{
			multiplier *= totalDamageTakenMultiplier;
		}
		multiplier /= totalHealthModifier;
		if (isBoss && difficulty >= 4)
		{
			multiplier = ((difficulty != 5) ? (multiplier / 1.5f) : (multiplier / 2f));
		}
		if (weaknesses.Length != 0)
		{
			for (int i = 0; i < weaknesses.Length; i++)
			{
				if (hitter == weaknesses[i] || (hitterAttributes.Contains(HitterAttribute.Electricity) && weaknesses[i] == "electricity"))
				{
					multiplier *= weaknessMultipliers[i];
				}
			}
		}
		if (getFireDamageMultiplier && burners.Count > 0 && hitter != "fire" && hitter != "explosion" && hitter != "ffexplosion")
		{
			multiplier *= 1.5f;
		}
		if (nails.Count > 10)
		{
			for (int j = 0; j < nails.Count - 10; j++)
			{
				if (nails[j] != null)
				{
					UnityEngine.Object.Destroy(nails[j].gameObject);
				}
				nails.RemoveAt(j);
			}
		}
		if (!beingZapped && hitterAttributes.Contains(HitterAttribute.Electricity) && hitter != "aftershock" && (nailsAmount > 0 || stuckMagnets.Count > 0 || touchingWaters.Count > 0))
		{
			beingZapped = true;
			foreach (Nail nail in nails)
			{
				if (nail != null)
				{
					nail.Zap();
				}
			}
			if (hitter == "zapper" && multiplier > health)
			{
				multiplier = health - 0.001f;
			}
			afterShockSourceWeapon = sourceWeapon;
			waterOnlyAftershock = nailsAmount == 0 && stuckMagnets.Count == 0;
			Invoke("AfterShock", 0.5f);
		}
		if (pulledByMagnet && hitter != "deathzone")
		{
			pulledByMagnet = false;
		}
		bool flag = false;
		switch (enemyType)
		{
		case EnemyType.MaliciousFace:
			if (spider == null)
			{
				spider = GetComponent<SpiderBody>();
			}
			if (spider == null)
			{
				return;
			}
			if ((hitter != "explosion" && hitter != "ffexplosion") || isGasolined)
			{
				spider.GetHurt(target, force, hitPoint, multiplier, sourceWeapon);
			}
			if (spider.health <= 0f)
			{
				Death();
			}
			health = spider.health;
			flag = true;
			break;
		case EnemyType.Wicked:
			if (wicked == null)
			{
				wicked = GetComponent<Wicked>();
			}
			if (wicked == null)
			{
				return;
			}
			wicked.GetHit();
			flag = true;
			break;
		case EnemyType.Drone:
		case EnemyType.Virtue:
			if (drone == null)
			{
				drone = GetComponent<Drone>();
			}
			if (drone == null)
			{
				return;
			}
			drone.GetHurt(force, multiplier, sourceWeapon, fromExplosion);
			health = drone.health;
			if (health <= 0f)
			{
				Death();
			}
			flag = true;
			break;
		case EnemyType.Idol:
			idol = (idol ? idol : GetComponent<Idol>());
			if (hitter == "punch" || hitter == "heavypunch" || hitter == "ground slam" || hitter == "hammer")
			{
				idol?.Death();
			}
			break;
		}
		if (!flag)
		{
			switch (enemyClass)
			{
			case EnemyClass.Husk:
				if (zombie == null)
				{
					zombie = GetComponent<Zombie>();
				}
				if (zombie == null)
				{
					return;
				}
				zombie.GetHurt(target, force, multiplier, critMultiplier, sourceWeapon, fromExplosion);
				if (tryForExplode && zombie.health <= 0f && !exploded)
				{
					Explode(fromExplosion);
				}
				if (zombie.health <= 0f)
				{
					Death();
				}
				health = zombie.health;
				break;
			case EnemyClass.Machine:
				if (machine == null)
				{
					machine = GetComponent<Machine>();
				}
				if (machine == null)
				{
					return;
				}
				machine.GetHurt(target, force, multiplier, critMultiplier, sourceWeapon, fromExplosion);
				if (tryForExplode && machine.health <= 0f && (machine.symbiote == null || machine.symbiote.health <= 0f) && !machine.dontDie && !exploded)
				{
					Explode(fromExplosion);
				}
				if (machine.health <= 0f && (machine.symbiote == null || machine.symbiote.health <= 0f))
				{
					Death();
				}
				health = machine.health;
				break;
			case EnemyClass.Demon:
				if (statue == null)
				{
					statue = GetComponent<Statue>();
				}
				if (statue == null)
				{
					return;
				}
				statue.GetHurt(target, force, multiplier, critMultiplier, hitPoint, sourceWeapon, fromExplosion);
				if (tryForExplode && statue.health <= 0f && !exploded)
				{
					Explode(fromExplosion);
				}
				if (statue.health <= 0f)
				{
					Death();
				}
				health = statue.health;
				break;
			}
		}
		hitterAttributes.Clear();
	}

	private void AfterShock()
	{
		float num = Mathf.Min(6f, (float)nailsAmount / 15f);
		if (stuckMagnets.Count > 0)
		{
			num += (float)stuckMagnets.Count;
			foreach (Magnet stuckMagnet in stuckMagnets)
			{
				if (stuckMagnet != null)
				{
					stuckMagnet.health -= 1f;
				}
			}
		}
		if (num < 1f && touchingWaters.Count > 0)
		{
			num = 1f;
		}
		GoreZone goreZone = GetGoreZone();
		foreach (Nail nail in nails)
		{
			if (nail == null)
			{
				continue;
			}
			GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Small, this);
			if ((bool)gore && (bool)goreZone)
			{
				gore.transform.position = nail.transform.position;
				gore.SetActive(value: true);
				Bloodsplatter component = gore.GetComponent<Bloodsplatter>();
				gore.transform.SetParent(goreZone.goreZone, worldPositionStays: true);
				if (component != null && !dead)
				{
					component.GetReady();
				}
			}
			UnityEngine.Object.Destroy(nail.gameObject);
		}
		List<GameObject> list = new List<GameObject>();
		list.Add(base.gameObject);
		Zap(overrideCenter ? overrideCenter.position : base.transform.position, num, list, afterShockSourceWeapon, this, null, waterOnlyAftershock);
		nails.Clear();
		nailsAmount = 0;
		EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		if (!dead && !puppet)
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(Mathf.Max(1, Mathf.RoundToInt(num * 15f)), "<color=#00ffffff>CONDUCTOR</color>", afterShockSourceWeapon, this);
		}
		if (componentsInChildren != null && componentsInChildren.Length != 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (!(componentsInChildren[i] == null) && componentsInChildren[i].gameObject != base.gameObject)
				{
					hitter = "aftershock";
					hitterAttributes.Add(HitterAttribute.Electricity);
					DeliverDamage(componentsInChildren[i].gameObject, Vector3.zero, base.transform.position, num, tryForExplode: true, 0f, afterShockSourceWeapon);
					break;
				}
			}
		}
		beingZapped = false;
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
	}

	public static void Zap(Vector3 position, float damage = 2f, List<GameObject> alreadyHitObjects = null, GameObject sourceWeapon = null, EnemyIdentifier sourceEid = null, Water sourceWater = null, bool waterOnly = false)
	{
		bool flag = false;
		if ((bool)sourceWater && sourceWater.playerTouchingWater)
		{
			flag = true;
		}
		else if ((bool)sourceEid && sourceEid.touchingWaters.Count > 0)
		{
			foreach (Water touchingWater in sourceEid.touchingWaters)
			{
				if (!(touchingWater == null) && touchingWater.playerTouchingWater)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			MonoSingleton<NewMovement>.Instance.GetHurt(50, invincible: true, 1f, explosion: false, instablack: false, 1f);
			LineRenderer lineRenderer = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.electricLine, Vector3.Lerp(position, MonoSingleton<NewMovement>.Instance.transform.position, 0.5f), Quaternion.identity);
			lineRenderer.SetPosition(0, position);
			lineRenderer.SetPosition(1, MonoSingleton<NewMovement>.Instance.transform.position);
			UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.zapImpactParticle, MonoSingleton<NewMovement>.Instance.transform.position, Quaternion.identity);
		}
		foreach (EnemyIdentifier currentEnemy in MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies())
		{
			if (alreadyHitObjects != null && alreadyHitObjects.Contains(currentEnemy.gameObject))
			{
				continue;
			}
			bool flag2 = false;
			if (currentEnemy.flying && ((!sourceWater && !sourceEid) || currentEnemy.touchingWaters.Count == 0))
			{
				continue;
			}
			if (currentEnemy.touchingWaters.Count > 0)
			{
				if (sourceWater != null)
				{
					flag2 = currentEnemy.touchingWaters.Contains(sourceWater);
				}
				if (!flag2 && sourceEid != null && sourceEid.touchingWaters.Count > 0)
				{
					for (int i = 0; i < currentEnemy.touchingWaters.Count; i++)
					{
						if (!(currentEnemy.touchingWaters[i] == null) && sourceEid.touchingWaters.Contains(currentEnemy.touchingWaters[i]))
						{
							flag2 = true;
							break;
						}
					}
				}
				if (currentEnemy.flying && !flag2)
				{
					continue;
				}
			}
			Vector3 vector = (currentEnemy.overrideCenter ? currentEnemy.overrideCenter.position : currentEnemy.transform.position);
			if ((flag2 && (!waterOnly || (float)currentEnemy.lastZapped > 1f)) || (!waterOnly && (Vector3.Distance(position, vector) < 30f || (position.y > vector.y && position.y - vector.y < 60f && Vector3.Distance(position, new Vector3(vector.x, position.y, vector.z)) < 30f)) && !Physics.Raycast(position, vector - position, Vector3.Distance(position, vector), LayerMaskDefaults.Get(LMD.Environment))))
			{
				currentEnemy.hitter = "zapper";
				currentEnemy.hitterAttributes.Add(HitterAttribute.Electricity);
				currentEnemy.DeliverDamage(currentEnemy.gameObject, Vector3.zero, vector, Mathf.Max(((float)currentEnemy.lastZapped < 1f) ? 0.5f : 2f, damage), tryForExplode: true, 0f, sourceWeapon);
				currentEnemy.lastZapped = 0f;
				LineRenderer lineRenderer2 = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.electricLine, Vector3.Lerp(position, vector, 0.5f), Quaternion.identity);
				lineRenderer2.SetPosition(0, position);
				lineRenderer2.SetPosition(1, vector);
				UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.zapImpactParticle, vector, Quaternion.identity);
			}
		}
		if (waterOnly)
		{
			return;
		}
		foreach (Magnet magnet in MonoSingleton<ObjectTracker>.Instance.magnetList)
		{
			if (!(magnet == null) && !alreadyHitObjects.Contains(magnet.gameObject) && (!(magnet.onEnemy != null) || !alreadyHitObjects.Contains(magnet.onEnemy.gameObject)) && Vector3.Distance(position, magnet.transform.position) < 30f && !Physics.Raycast(position, magnet.transform.position - position, Vector3.Distance(position, magnet.transform.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				magnet.StartCoroutine(magnet.Zap(alreadyHitObjects, Mathf.Max(0.5f, damage), sourceWeapon));
				LineRenderer lineRenderer3 = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.electricLine, Vector3.Lerp(position, magnet.transform.position, 0.5f), Quaternion.identity);
				lineRenderer3.SetPosition(0, position);
				lineRenderer3.SetPosition(1, magnet.transform.position);
			}
		}
		foreach (Zappable zappables in MonoSingleton<ObjectTracker>.Instance.zappablesList)
		{
			if (!(zappables == null) && !alreadyHitObjects.Contains(zappables.gameObject) && Vector3.Distance(position, zappables.transform.position) < 30f && (!Physics.Raycast(position, zappables.transform.position - position, out var hitInfo, Vector3.Distance(position, zappables.transform.position), LayerMaskDefaults.Get(LMD.Environment)) || hitInfo.transform.gameObject == zappables.gameObject))
			{
				zappables.StartCoroutine(zappables.Zap(alreadyHitObjects, Mathf.Max(0.5f, damage), sourceWeapon));
				LineRenderer lineRenderer4 = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.electricLine, Vector3.Lerp(position, zappables.transform.position, 0.5f), Quaternion.identity);
				lineRenderer4.SetPosition(0, position);
				lineRenderer4.SetPosition(1, zappables.transform.position);
			}
		}
	}

	public void Death()
	{
		Death(fromExplosion: false);
	}

	public void Death(bool fromExplosion)
	{
		if (dead)
		{
			return;
		}
		dead = true;
		GameObject[] array = activateOnDeath;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		foreach (GameObject item in destroyOnDeath)
		{
			if (item != null)
			{
				UnityEngine.Object.Destroy(item);
			}
		}
		onDeath?.Invoke();
		if (!puppet)
		{
			if (hitterWeapons.Count > 1)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.arsenal", null, this);
			}
			if (!dontUnlockBestiary)
			{
				MonoSingleton<BestiaryData>.Instance.SetEnemy(enemyType);
				if (TryGetComponent<UnlockBestiary>(out var component))
				{
					MonoSingleton<BestiaryData>.Instance.SetEnemy(component.enemy);
				}
			}
		}
		if (health > 0f)
		{
			health = 0f;
		}
		DestroyMagnets();
		if (drillers.Count > 0 && enemyType != EnemyType.MaliciousFace && enemyType != EnemyType.Gutterman && enemyType != EnemyType.Mindflayer)
		{
			foreach (Harpoon driller in drillers)
			{
				driller.DelayedDestroyIfOnCorpse();
			}
		}
		if (usingDoor != null)
		{
			usingDoor.Close();
			usingDoor = null;
		}
		Desandify(visualOnly: true);
		Unbless();
		if (puppet)
		{
			EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
			GameObject gameObject = null;
			GoreZone goreZone = GetGoreZone();
			EnemyIdentifierIdentifier[] array2 = componentsInChildren;
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in array2)
			{
				GoreType got = GoreType.Body;
				if (enemyIdentifierIdentifier.CompareTag("Head") || enemyIdentifierIdentifier.CompareTag("EndLimb"))
				{
					got = GoreType.Head;
				}
				else if (enemyIdentifierIdentifier.CompareTag("Limb"))
				{
					got = GoreType.Limb;
				}
				gameObject = bsm.GetGore(got, this, fromExplosion);
				gameObject.transform.position = enemyIdentifierIdentifier.transform.position;
				if (goreZone != null && goreZone.goreZone != null)
				{
					gameObject.transform.SetParent(goreZone.goreZone, worldPositionStays: true);
				}
				gameObject.GetComponent<Bloodsplatter>()?.GetReady();
				UnityEngine.Object.Destroy(enemyIdentifierIdentifier.gameObject);
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
		if (beingZapped)
		{
			CancelInvoke("AfterShock");
			Invoke("AfterShock", 0.1f);
		}
	}

	public void DestroyMagnets()
	{
		if (stuckMagnets.Count <= 0)
		{
			return;
		}
		for (int num = stuckMagnets.Count - 1; num >= 0; num--)
		{
			if (stuckMagnets[num] != null)
			{
				UnityEngine.Object.Destroy(stuckMagnets[num].gameObject);
			}
		}
	}

	public void InstaKill()
	{
		if (dead)
		{
			return;
		}
		Death();
		if (pulledByMagnet && !puppet)
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(240, "ultrakill.catapulted", null, this);
		}
		dead = true;
		bool flag = false;
		switch (enemyType)
		{
		case EnemyType.Drone:
		case EnemyType.Virtue:
			if (drone == null)
			{
				drone = GetComponent<Drone>();
			}
			drone.GetHurt(Vector3.zero, 999f);
			drone.Explode();
			flag = true;
			break;
		case EnemyType.MaliciousFace:
			if (spider == null)
			{
				spider = GetComponent<SpiderBody>();
			}
			spider.Die();
			flag = true;
			break;
		case EnemyType.Idol:
		{
			if (TryGetComponent<Idol>(out var component))
			{
				component.Death();
			}
			break;
		}
		}
		if (!flag)
		{
			switch (enemyClass)
			{
			case EnemyClass.Husk:
				if (zombie == null)
				{
					zombie = GetComponent<Zombie>();
				}
				if (!zombie.limp)
				{
					zombie.GoLimp();
				}
				break;
			case EnemyClass.Machine:
				if (machine == null)
				{
					machine = GetComponent<Machine>();
				}
				if (!machine.limp)
				{
					machine.GoLimp();
				}
				break;
			case EnemyClass.Demon:
				if (statue == null)
				{
					statue = GetComponent<Statue>();
				}
				if (!statue.limp)
				{
					statue.GoLimp();
				}
				break;
			}
		}
		if (usingDoor != null)
		{
			usingDoor.Close();
			usingDoor = null;
		}
	}

	public void Explode(bool fromExplosion = false)
	{
		bool flag = dead;
		if (!dead)
		{
			Death();
		}
		if (enemyType == EnemyType.MaliciousFace)
		{
			if (spider == null)
			{
				spider = GetComponent<SpiderBody>();
			}
			if (!flag)
			{
				hitter = "breaker";
				spider.Die();
			}
			else
			{
				spider.BreakCorpse();
			}
		}
		else if (enemyType == EnemyType.Drone || enemyType == EnemyType.Virtue)
		{
			if (drone == null)
			{
				drone = GetComponent<Drone>();
			}
			drone.Explode();
		}
		else if (enemyClass == EnemyClass.Husk)
		{
			if (zombie == null)
			{
				zombie = GetComponent<Zombie>();
			}
			if (exploded || !zombie || zombie.chestExploding)
			{
				return;
			}
			exploded = true;
			if (zombie.chestExploding)
			{
				zombie.ChestExplodeEnd();
			}
			if (!flag && pulledByMagnet && !puppet)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(240, "ultrakill.catapulted", null, this);
			}
			EnemyIdentifierIdentifier[] componentsInChildren = zombie.GetComponentsInChildren<EnemyIdentifierIdentifier>(includeInactive: true);
			GetGoreZone();
			bool flag2 = false;
			EnemyIdentifierIdentifier[] array = componentsInChildren;
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in array)
			{
				if (enemyIdentifierIdentifier.gameObject.CompareTag("Limb"))
				{
					DestroyLimb(enemyIdentifierIdentifier.transform, LimbDestroyType.Detach);
					if (!flag2)
					{
						zombie.GetHurt(enemyIdentifierIdentifier.gameObject, (base.transform.position - enemyIdentifierIdentifier.transform.position).normalized * 1000f, 1E+09f, 1f);
					}
				}
				else if (enemyIdentifierIdentifier.gameObject.CompareTag("Head") || enemyIdentifierIdentifier.gameObject.CompareTag("EndLimb"))
				{
					flag2 = true;
					zombie.GetHurt(enemyIdentifierIdentifier.gameObject, (base.transform.position - enemyIdentifierIdentifier.transform.position).normalized * 1000f, 1E+09f, 1f);
				}
			}
			if (!flag2)
			{
				zombie.GoLimp();
			}
			health = zombie.health;
			if (usingDoor != null)
			{
				usingDoor.Close();
				usingDoor = null;
			}
		}
		else if (enemyClass == EnemyClass.Machine && enemyType != EnemyType.Drone)
		{
			if (machine == null)
			{
				machine = GetComponent<Machine>();
			}
			if (exploded || !machine)
			{
				return;
			}
			exploded = true;
			bool flag3 = false;
			if (machine.dismemberment)
			{
				Collider[] componentsInChildren2 = machine.GetComponentsInChildren<Collider>();
				List<EnemyIdentifierIdentifier> list = new List<EnemyIdentifierIdentifier>();
				Collider[] array2 = componentsInChildren2;
				for (int i = 0; i < array2.Length; i++)
				{
					EnemyIdentifierIdentifier component = array2[i].GetComponent<EnemyIdentifierIdentifier>();
					if (component != null)
					{
						list.Add(component);
					}
				}
				GetGoreZone();
				foreach (EnemyIdentifierIdentifier item in list)
				{
					if (item.gameObject.CompareTag("Limb"))
					{
						DestroyLimb(item.transform, LimbDestroyType.Detach);
					}
					else if (item.gameObject.CompareTag("Head") || item.gameObject.CompareTag("EndLimb"))
					{
						flag3 = true;
						machine.GetHurt(item.gameObject, (base.transform.position - item.transform.position).normalized * 1000f, 999f, 1f);
					}
				}
			}
			if (!flag3)
			{
				machine.GoLimp(fromExplosion);
			}
			health = machine.health;
			if (usingDoor != null)
			{
				usingDoor.Close();
				usingDoor = null;
			}
		}
		else
		{
			if (enemyClass != EnemyClass.Demon)
			{
				return;
			}
			if (statue == null)
			{
				statue = GetComponent<Statue>();
			}
			if (!exploded)
			{
				exploded = true;
				if (!statue.limp)
				{
					statue.GoLimp();
				}
				health = statue.health;
			}
		}
	}

	public void Splatter(bool styleBonus = true)
	{
		if (InvincibleEnemies.Enabled || blessed)
		{
			return;
		}
		if (enemyType == EnemyType.MaliciousFace)
		{
			if (spider == null)
			{
				spider = GetComponent<SpiderBody>();
			}
			if (!dead)
			{
				hitter = "breaker";
				spider.Die();
			}
			else
			{
				spider.BreakCorpse();
			}
			return;
		}
		if (enemyType == EnemyType.Drone || enemyType == EnemyType.Virtue)
		{
			if (drone == null)
			{
				drone = GetComponent<Drone>();
			}
			drone.GetHurt(Vector3.zero, 999f);
			if (enemyType == EnemyType.Virtue)
			{
				drone.Explode();
			}
			Death();
			return;
		}
		switch (enemyClass)
		{
		case EnemyClass.Husk:
			if (zombie == null)
			{
				zombie = GetComponent<Zombie>();
			}
			break;
		case EnemyClass.Demon:
			if (statue == null)
			{
				statue = GetComponent<Statue>();
			}
			break;
		case EnemyClass.Machine:
			if (machine == null)
			{
				machine = GetComponent<Machine>();
			}
			break;
		}
		bool flag = dead;
		if (enemyClass == EnemyClass.Machine && (bool)machine && !machine.dismemberment)
		{
			InstaKill();
		}
		else if (enemyClass == EnemyClass.Demon && (bool)statue && (statue.massDeath || statue.specialDeath))
		{
			InstaKill();
		}
		else if (!exploded && (enemyClass != 0 || !zombie.chestExploding))
		{
			exploded = true;
			limbs = GetComponentsInChildren<EnemyIdentifierIdentifier>();
			if (!flag)
			{
				SendMessage("GoLimp", SendMessageOptions.DontRequireReceiver);
				StyleHUD instance = MonoSingleton<StyleHUD>.Instance;
				if (!puppet)
				{
					if (pulledByMagnet)
					{
						instance.AddPoints(120, "ultrakill.catapulted", null, this);
					}
					if (styleBonus)
					{
						instance.AddPoints(100, "ultrakill.splattered", null, this);
					}
				}
				base.transform.Rotate(new Vector3(90f, 0f, 0f));
			}
			GameObject gore = bsm.GetGore(GoreType.Splatter, this);
			gore.transform.position = base.transform.position + Vector3.up;
			GoreZone goreZone = GetGoreZone();
			if (goreZone != null && goreZone.goreZone != null)
			{
				gore.transform.SetParent(goreZone.goreZone, worldPositionStays: true);
			}
			gore.GetComponent<Bloodsplatter>()?.GetReady();
			EnemyIdentifierIdentifier[] array = limbs;
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in array)
			{
				if (enemyIdentifierIdentifier.gameObject.CompareTag("Body") || enemyIdentifierIdentifier.gameObject.CompareTag("Limb") || enemyIdentifierIdentifier.gameObject.CompareTag("Head") || enemyIdentifierIdentifier.gameObject.CompareTag("EndLimb"))
				{
					UnityEngine.Object.Destroy(enemyIdentifierIdentifier.GetComponent<CharacterJoint>());
					enemyIdentifierIdentifier.transform.SetParent(GetGoreZone().gibZone, worldPositionStays: true);
					Rigidbody component = enemyIdentifierIdentifier.GetComponent<Rigidbody>();
					if (component != null)
					{
						component.velocity = Vector3.zero;
						enemyIdentifierIdentifier.transform.position = new Vector3(enemyIdentifierIdentifier.transform.position.x, base.transform.position.y + 0.1f, enemyIdentifierIdentifier.transform.position.z);
						Vector3 vector = new Vector3(base.transform.position.x - enemyIdentifierIdentifier.transform.position.x, 0f, base.transform.position.z - enemyIdentifierIdentifier.transform.position.z);
						component.AddForce(vector * 15f, ForceMode.VelocityChange);
						component.constraints = RigidbodyConstraints.FreezePositionY;
					}
				}
			}
			if ((bool)machine && enemyType == EnemyType.Streetcleaner)
			{
				machine.CanisterExplosion();
			}
			Invoke("StopSplatter", 1f);
			if (usingDoor != null)
			{
				usingDoor.Close();
				usingDoor = null;
			}
		}
		Death();
	}

	public void StopSplatter()
	{
		EnemyIdentifierIdentifier[] array = limbs;
		foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in array)
		{
			if (enemyIdentifierIdentifier != null)
			{
				Rigidbody component = enemyIdentifierIdentifier.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.constraints = RigidbodyConstraints.None;
				}
			}
		}
	}

	public void Sandify(bool ignorePrevious = false)
	{
		if (dead || (!ignorePrevious && sandified))
		{
			return;
		}
		sandified = true;
		if (puppet)
		{
			InstaKill();
			return;
		}
		EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.sandDrip, enemyIdentifierIdentifier.transform.position, enemyIdentifierIdentifier.transform.rotation);
			Collider component = enemyIdentifierIdentifier.GetComponent<Collider>();
			if ((bool)component)
			{
				gameObject.transform.localScale = component.bounds.size;
			}
			gameObject.transform.SetParent(enemyIdentifierIdentifier.transform, worldPositionStays: true);
			sandifiedParticles.Add(gameObject);
		}
		Collider component2 = GetComponent<Collider>();
		if ((bool)component2)
		{
			UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.sandificationEffect, component2.bounds.center, Quaternion.identity);
		}
		else
		{
			UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.sandificationEffect, base.transform.position, Quaternion.identity);
		}
		Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren2)
		{
			if (!buffUnaffectedRenderers.Contains(renderer))
			{
				MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
				renderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat(HasSandBuff, 1f);
				renderer.SetPropertyBlock(materialPropertyBlock);
			}
		}
	}

	public void Desandify(bool visualOnly = false)
	{
		if (!visualOnly)
		{
			sandified = false;
		}
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			if (!buffUnaffectedRenderers.Contains(renderer))
			{
				renderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat(HasSandBuff, 0f);
				renderer.SetPropertyBlock(materialPropertyBlock);
			}
		}
		foreach (GameObject sandifiedParticle in sandifiedParticles)
		{
			UnityEngine.Object.Destroy(sandifiedParticle);
		}
		sandifiedParticles.Clear();
	}

	public void Bless(bool ignorePrevious = false)
	{
		if (!ignorePrevious)
		{
			blessings++;
			if (blessings > 1)
			{
				return;
			}
		}
		if (!ignorePrevious && blessed)
		{
			return;
		}
		blessed = true;
		EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.blessingGlow, enemyIdentifierIdentifier.transform.position, enemyIdentifierIdentifier.transform.rotation);
			Collider component = enemyIdentifierIdentifier.GetComponent<Collider>();
			if ((bool)component)
			{
				gameObject.transform.localScale = component.bounds.size;
			}
			gameObject.transform.SetParent(enemyIdentifierIdentifier.transform, worldPositionStays: true);
			blessingGlows.Add(gameObject);
		}
		if (burners == null || burners.Count <= 0)
		{
			return;
		}
		foreach (Flammable burner in burners)
		{
			burner.PutOut(getWet: false);
		}
		burners.Clear();
	}

	public void Unbless(bool visualOnly = false)
	{
		if (!visualOnly)
		{
			if (blessings <= 0)
			{
				return;
			}
			blessings--;
			if (blessings < 0)
			{
				blessings = 0;
			}
			if (blessings > 0)
			{
				return;
			}
			blessed = false;
		}
		foreach (GameObject blessingGlow in blessingGlows)
		{
			UnityEngine.Object.Destroy(blessingGlow);
		}
		blessingGlows.Clear();
		if (!visualOnly)
		{
			MonoSingleton<EnemyTracker>.Instance.UpdateIdolsNow();
		}
	}

	public void AddFlammable(float amount)
	{
		if (!beenGasolined)
		{
			beenGasolined = true;
			EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (!(componentsInChildren[i].gameObject == base.gameObject) && !(componentsInChildren[i].eid != this))
				{
					if (!componentsInChildren[i].TryGetComponent<Flammable>(out var component))
					{
						component = componentsInChildren[i].gameObject.AddComponent<Flammable>();
						component.fuelOnly = true;
					}
					if (!flammables.Contains(component))
					{
						flammables.Add(component);
					}
				}
			}
		}
		float num = 0f;
		foreach (Flammable flammable in flammables)
		{
			if (flammable.fuel < 5f)
			{
				flammable.fuel += Mathf.Min(amount, 5f - flammable.fuel);
			}
			num = Mathf.Max(num, flammable.fuel);
		}
		Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren2)
		{
			if (!buffUnaffectedRenderers.Contains(renderer) && !(renderer is ParticleSystemRenderer))
			{
				MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
				renderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat("_OiledAmount", num / 5f);
				renderer.SetPropertyBlock(materialPropertyBlock);
			}
		}
	}

	public void PuppetSpawn()
	{
		if (dead)
		{
			return;
		}
		dontCountAsKills = true;
		puppet = true;
		if (sandified && enemyType != EnemyType.Stalker)
		{
			InstaKill();
			return;
		}
		puppetSpawnTimer = 0f;
		SpawnEffect componentInChildren = GetComponentInChildren<SpawnEffect>();
		if ((bool)componentInChildren)
		{
			componentInChildren.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(componentInChildren.gameObject);
		}
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		Material material = new Material(MonoSingleton<DefaultReferenceManager>.Instance.puppetMaterial);
		EnemySimplifier[] componentsInChildren2 = GetComponentsInChildren<EnemySimplifier>();
		foreach (EnemySimplifier enemySimplifier in componentsInChildren2)
		{
			enemySimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, material);
			enemySimplifier.enragedMaterial = material;
			enemySimplifier.ignoreCustomColor = true;
			if ((bool)enemySimplifier.simplifiedMaterial)
			{
				Material material2 = new Material(enemySimplifier.simplifiedMaterial);
				material2.color = Color.red;
				enemySimplifier.simplifiedMaterial = material2;
				if ((bool)enemySimplifier.simplifiedMaterial2)
				{
					enemySimplifier.simplifiedMaterial2 = material2;
				}
				if ((bool)enemySimplifier.simplifiedMaterial3)
				{
					enemySimplifier.simplifiedMaterial3 = material2;
				}
			}
		}
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			if (!buffUnaffectedRenderers.Contains(renderer) && !(renderer is ParticleSystemRenderer))
			{
				Material[] array2 = new Material[renderer.sharedMaterials.Length];
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j] = material;
				}
				renderer.sharedMaterials = array2;
				puppetRenderers.Add(renderer);
			}
		}
		if (originalScale == Vector3.zero)
		{
			if ((bool)rb)
			{
				rbc = rb.constraints;
				rb.constraints = RigidbodyConstraints.FreezeAll;
			}
			originalScale = base.transform.localScale;
			squishedScale = new Vector3(originalScale.x * 5f, 0.001f, originalScale.z * 5f);
			base.transform.localScale = squishedScale;
		}
		puppetSpawnColliders = GetComponentsInChildren<Collider>();
		Collider[] array3 = puppetSpawnColliders;
		for (int i = 0; i < array3.Length; i++)
		{
			Physics.IgnoreCollision(array3[i], MonoSingleton<NewMovement>.Instance.playerCollider, ignore: true);
		}
		puppetSpawnIgnoringPlayer = true;
		UnityEngine.Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.puppetSpawn, base.transform.position + Vector3.up * 0.25f, Quaternion.identity).transform.SetParent(GetGoreZone().transform, worldPositionStays: true);
	}

	public void BuffAll()
	{
		damageBuffRequests++;
		speedBuffRequests++;
		healthBuffRequests++;
		UpdateBuffs();
	}

	public void UnbuffAll()
	{
		speedBuffRequests--;
		healthBuffRequests--;
		damageBuffRequests--;
		UpdateBuffs();
	}

	public void DamageBuff(float modifier = -999f)
	{
		if (modifier == -999f)
		{
			modifier = damageBuffModifier;
		}
		damageBuffRequests++;
		damageBuffModifier = modifier;
		UpdateBuffs();
	}

	public void DamageUnbuff()
	{
		damageBuffRequests--;
		UpdateBuffs();
	}

	public void SpeedBuff(float modifier = -999f)
	{
		if (modifier == -999f)
		{
			modifier = speedBuffModifier;
		}
		speedBuffRequests++;
		speedBuffModifier = modifier;
		UpdateBuffs();
	}

	public void SpeedUnbuff()
	{
		speedBuffRequests--;
		UpdateBuffs();
	}

	public void HealthBuff(float modifier = -999f)
	{
		if (modifier == -999f)
		{
			modifier = healthBuffModifier;
		}
		healthBuffRequests++;
		healthBuffModifier = modifier;
		UpdateBuffs();
	}

	public void HealthUnbuff()
	{
		healthBuffRequests--;
		UpdateBuffs();
	}

	public void UpdateBuffs(bool visualsOnly = false)
	{
		speedBuff = speedBuffRequests > 0;
		healthBuff = healthBuffRequests > 0;
		damageBuff = damageBuffRequests > 0;
		if (!healthBuff && !speedBuff && !damageBuff && !OptionsManager.forceRadiance)
		{
			speedBuffRequests = 0;
			healthBuffRequests = 0;
			damageBuffRequests = 0;
		}
		if (!visualsOnly)
		{
			UpdateModifiers();
			SendMessage("UpdateBuff", SendMessageOptions.DontRequireReceiver);
		}
	}

	public static bool CheckHurtException(EnemyType attacker, EnemyType receiver, EnemyTarget attackTarget = null)
	{
		if (EnemyIdentifierDebug.Active)
		{
			Log.Fine($"Checking hurt exception between <b>{attacker}</b> and <b>{receiver}</b> with attack target <b>{attackTarget}</b>");
		}
		if (attacker == receiver)
		{
			return true;
		}
		if (attackTarget != null && attackTarget.isEnemy && attackTarget.enemyIdentifier.enemyType == receiver)
		{
			return false;
		}
		if ((attacker == EnemyType.Stalker && receiver != EnemyType.Swordsmachine) || (receiver == EnemyType.Stalker && attacker != EnemyType.Swordsmachine))
		{
			return true;
		}
		if ((attacker == EnemyType.Filth || attacker == EnemyType.Stray || attacker == EnemyType.Schism || attacker == EnemyType.Soldier) && (receiver == EnemyType.Filth || receiver == EnemyType.Stray || receiver == EnemyType.Schism || receiver == EnemyType.Soldier))
		{
			return true;
		}
		switch (receiver)
		{
		case EnemyType.Sisyphus:
			return true;
		case EnemyType.Ferryman:
			return true;
		default:
			if (((attacker == EnemyType.Drone || attacker == EnemyType.Virtue) && receiver == EnemyType.FleshPrison) || ((receiver == EnemyType.Drone || receiver == EnemyType.Virtue) && attacker == EnemyType.FleshPrison))
			{
				return true;
			}
			if (((attacker == EnemyType.Drone || attacker == EnemyType.Virtue) && receiver == EnemyType.FleshPanopticon) || ((receiver == EnemyType.Drone || receiver == EnemyType.Virtue) && attacker == EnemyType.FleshPanopticon))
			{
				return true;
			}
			if ((attacker == EnemyType.Gabriel || attacker == EnemyType.GabrielSecond) && (receiver == EnemyType.Gabriel || receiver == EnemyType.GabrielSecond))
			{
				return true;
			}
			return false;
		}
	}

	public static void FallOnEnemy(EnemyIdentifier eid)
	{
		if (eid.dead)
		{
			eid.Explode();
			return;
		}
		switch (eid.enemyType)
		{
		case EnemyType.Idol:
			eid.InstaKill();
			break;
		case EnemyType.Sisyphus:
		{
			if (eid.TryGetComponent<Sisyphus>(out var component5))
			{
				eid.DeliverDamage(eid.gameObject, Vector3.zero, eid.transform.position, 22f, tryForExplode: true);
				component5.Knockdown(component5.transform.position + component5.transform.forward);
			}
			break;
		}
		case EnemyType.Mindflayer:
		{
			if (eid.TryGetComponent<Mindflayer>(out var component2))
			{
				component2.Teleport();
			}
			break;
		}
		case EnemyType.Gabriel:
		{
			if (eid.TryGetComponent<Gabriel>(out var component4))
			{
				component4.Teleport();
			}
			break;
		}
		case EnemyType.GabrielSecond:
		{
			if (eid.TryGetComponent<GabrielSecond>(out var component3))
			{
				component3.Teleport();
			}
			break;
		}
		case EnemyType.Ferryman:
		{
			if (eid.TryGetComponent<Ferryman>(out var component))
			{
				component.Roll();
			}
			break;
		}
		default:
			eid.Splatter(styleBonus: false);
			break;
		}
	}

	public void PlayerMarkedForDeath()
	{
		attackEnemies = false;
		prioritizeEnemiesUnlessAttacked = false;
		prioritizePlayerOverFallback = true;
	}

	public void BossBar(bool enable)
	{
		BossHealthBar bossHealthBar = GetComponent<BossHealthBar>();
		if (enable)
		{
			if (bossHealthBar == null)
			{
				bossHealthBar = base.gameObject.AddComponent<BossHealthBar>();
			}
			switch (enemyType)
			{
			case EnemyType.FleshPrison:
				bossHealthBar.SetSecondaryBarColor(Color.green);
				bossHealthBar.secondaryBar = true;
				break;
			case EnemyType.FleshPanopticon:
				bossHealthBar.SetSecondaryBarColor(new Color(1f, 64f / 85f, 0f));
				bossHealthBar.secondaryBar = true;
				break;
			}
		}
		else if (bossHealthBar != null)
		{
			UnityEngine.Object.Destroy(bossHealthBar);
		}
	}

	public void ChangeDamageTakenMultiplier(float newMultiplier)
	{
		totalDamageTakenMultiplier = newMultiplier;
	}

	public void SimpleDamage(float amount)
	{
		DeliverDamage(base.gameObject, Vector3.zero, base.transform.position, amount, tryForExplode: false);
	}

	public void SimpleDamageIgnoreMultiplier(float amount)
	{
		if (totalDamageTakenMultiplier != 0f)
		{
			DeliverDamage(base.gameObject, Vector3.zero, base.transform.position, amount / totalDamageTakenMultiplier, tryForExplode: false);
		}
		else
		{
			DeliverDamage(base.gameObject, Vector3.zero, base.transform.position, amount, tryForExplode: false, 0f, null, ignoreTotalDamageTakenMultiplier: true);
		}
	}

	private void TryUnPuppet()
	{
		if (!permaPuppet && TryGetComponent<SandboxEnemy>(out var component) && !(component.sourceObject.gameObject == null))
		{
			puppet = false;
			SavedEnemy savedEnemy = component.SaveEnemy();
			savedEnemy.Scale = SavedVector3.One;
			MonoSingleton<SandboxSaver>.Instance.RebuildObjectList();
			MonoSingleton<SandboxSaver>.Instance.RecreateEnemy(savedEnemy, newSizing: true);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public float GetReachDistanceMultiplier()
	{
		switch (enemyType)
		{
		case EnemyType.HideousMass:
		case EnemyType.Sisyphus:
		case EnemyType.SisyphusPrime:
		case EnemyType.Gutterman:
		case EnemyType.Guttertank:
			return 0.5f;
		default:
			return 1f;
		}
	}

	public Transform GetCenter()
	{
		if (!(overrideCenter != null))
		{
			return base.transform;
		}
		return overrideCenter;
	}
}



public class EnemyIdentifierIdentifier : MonoBehaviour
{
	[HideInInspector]
	public EnemyIdentifier eid;

	private bool deactivated;

	private Vector3 startPos;

	public int bloodAbsorberCount;

	private void Awake()
	{
		if (!eid)
		{
			eid = GetComponentInParent<EnemyIdentifier>();
		}
	}

	private void Start()
	{
		startPos = base.transform.position;
		SlowCheck();
	}

	private void DestroyLimb()
	{
		eid.DestroyLimb(base.transform);
	}

	private void DestroyLimbIfNotTouchedBloodAbsorber()
	{
		if (eid == null || !eid.dead)
		{
			return;
		}
		int num = bloodAbsorberCount;
		if (eid == GetComponentInParent<EnemyIdentifier>())
		{
			num = 0;
			EnemyIdentifierIdentifier[] componentsInChildren = eid.GetComponentsInChildren<EnemyIdentifierIdentifier>();
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
			{
				num += enemyIdentifierIdentifier.bloodAbsorberCount;
			}
		}
		if (num <= 0 && TryGetComponent<Collider>(out var component))
		{
			GibDestroyer.LimbBegone(component);
		}
		else if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
		{
			Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
		}
	}

	private void SlowCheck()
	{
		if (eid == null)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		if (base.gameObject.activeInHierarchy)
		{
			Vector3 position = base.transform.position;
			if (position.y > 0f)
			{
				position.y = startPos.y;
			}
			if (eid == null || Vector3.Distance(position, startPos) > 9999f || (Vector3.Distance(position, startPos) > 999f && eid.dead))
			{
				deactivated = true;
				MonoSingleton<FireObjectPool>.Instance.RemoveAllFiresFromObject(base.gameObject);
				base.gameObject.SetActive(value: false);
				base.transform.position = new Vector3(-100f, -100f, -100f);
				base.transform.localScale = Vector3.zero;
				if (eid != null && !eid.dead)
				{
					eid.InstaKill();
				}
			}
		}
		if (!deactivated)
		{
			Invoke("SlowCheck", 3f);
		}
	}
}



public class EnemyInfoPage : ListComponent<EnemyInfoPage>
{
	private static readonly plog.Logger Log = new plog.Logger("EnemyInfoPage");

	[SerializeField]
	private TMP_Text enemyPageTitle;

	[SerializeField]
	private TMP_Text enemyPageContent;

	[SerializeField]
	private Transform enemyPreviewWrapper;

	[Space]
	[SerializeField]
	private Transform enemyList;

	[SerializeField]
	private GameObject buttonTemplate;

	[SerializeField]
	private Image buttonTemplateBackground;

	[SerializeField]
	private Image buttonTemplateForeground;

	[SerializeField]
	private Sprite lockedSprite;

	[Space]
	[SerializeField]
	private SpawnableObjectsDatabase objects;

	private SpawnableObject currentSpawnable;

	private void Start()
	{
		UpdateInfo();
	}

	public void UpdateInfo()
	{
		if (enemyList.childCount > 1)
		{
			for (int num = enemyList.childCount - 1; num > 0; num--)
			{
				Object.Destroy(enemyList.GetChild(num).gameObject);
			}
		}
		SpawnableObject[] enemies = objects.enemies;
		foreach (SpawnableObject spawnableObject in enemies)
		{
			if (spawnableObject == null)
			{
				Log.Warning("Spawnable object in enemy list is null!");
				continue;
			}
			bool num2 = MonoSingleton<BestiaryData>.Instance.GetEnemy(spawnableObject.enemyType) >= 1;
			if (num2)
			{
				buttonTemplateBackground.color = spawnableObject.backgroundColor;
				buttonTemplateForeground.sprite = spawnableObject.gridIcon;
			}
			else
			{
				buttonTemplateBackground.color = Color.gray;
				buttonTemplateForeground.sprite = lockedSprite;
			}
			GameObject gameObject = Object.Instantiate(buttonTemplate, enemyList);
			gameObject.SetActive(value: true);
			if (num2)
			{
				gameObject.GetComponentInChildren<ShopButton>().deactivated = false;
				gameObject.GetComponentInChildren<Button>().onClick.AddListener(delegate
				{
					currentSpawnable = spawnableObject;
					DisplayInfo(spawnableObject);
				});
			}
			else
			{
				gameObject.GetComponentInChildren<ShopButton>().deactivated = true;
			}
		}
		buttonTemplate.SetActive(value: false);
	}

	private void SwapLayers(Transform target, int layer)
	{
		foreach (Transform item in target)
		{
			item.gameObject.layer = layer;
			if (item.childCount > 0)
			{
				SwapLayers(item, layer);
			}
		}
	}

	private void DisplayInfo(SpawnableObject source)
	{
		enemyPageTitle.text = source.objectName;
		string text = "<color=orange>TYPE: " + source.type + "\n\nDATA:</color>\n";
		text = ((MonoSingleton<BestiaryData>.Instance.GetEnemy(source.enemyType) <= 1) ? (text + "???") : (text + source.description));
		text = text + "\n\n<color=orange>STRATEGY:</color>\n" + source.strategy;
		enemyPageContent.text = text;
		enemyPageContent.rectTransform.localPosition = new Vector3(enemyPageContent.rectTransform.localPosition.x, 0f, enemyPageContent.rectTransform.localPosition.z);
		for (int i = 0; i < enemyPreviewWrapper.childCount; i++)
		{
			Object.Destroy(enemyPreviewWrapper.GetChild(i).gameObject);
		}
		GameObject gameObject = Object.Instantiate(source.preview, enemyPreviewWrapper);
		int layer = enemyPreviewWrapper.gameObject.layer;
		SwapLayers(gameObject.transform, layer);
		gameObject.layer = layer;
		gameObject.transform.localPosition = source.menuOffset;
		Spin spin = gameObject.AddComponent<Spin>();
		spin.spinDirection = new Vector3(0f, 1f, 0f);
		spin.speed = 10f;
	}

	public void DisplayInfo()
	{
		if (!(currentSpawnable == null))
		{
			DisplayInfo(currentSpawnable);
		}
	}

	public void UndisplayInfo()
	{
		currentSpawnable = null;
	}
}



public class EnemyNailgun : MonoBehaviour, IEnemyWeapon
{
	private EnemyTarget target;

	public GameObject nail;

	public GameObject altNail;

	public Transform shootPoint;

	public GameObject flash;

	public GameObject muzzleFlash;

	[SerializeField]
	private AudioSource chargeSound;

	private bool charging;

	private float chargeAmount;

	private int burstAmount;

	private float cooldown;

	private GameObject currentNail;

	private float currentSpread = 5f;

	private float fireRate = 0.033f;

	public Collider[] toIgnore;

	private int difficulty;

	private EnemyIdentifier eid;

	private float speedMultiplier;

	private float damageMultiplier;

	private void Awake()
	{
		eid = GetComponentInParent<EnemyIdentifier>();
	}

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
	}

	private void FixedUpdate()
	{
		if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.fixedDeltaTime * speedMultiplier);
		}
		if (burstAmount > 0 && cooldown <= 0f)
		{
			Vector3 position = shootPoint.position;
			if (Vector3.Distance(base.transform.position, eid.transform.position) > Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, eid.transform.position))
			{
				Vector3 vector = eid.transform.position + base.transform.forward * Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, eid.transform.position);
				position = new Vector3(vector.x, base.transform.position.y, vector.z);
			}
			GameObject gameObject = Object.Instantiate(currentNail, position, shootPoint.rotation);
			gameObject.transform.Rotate(Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f));
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 200f * speedMultiplier, ForceMode.VelocityChange);
			if (damageMultiplier != 1f && gameObject.TryGetComponent<Nail>(out var component))
			{
				component.damage *= damageMultiplier;
			}
			Collider component2 = gameObject.GetComponent<CapsuleCollider>();
			Collider[] array = toIgnore;
			foreach (Collider collider in array)
			{
				Physics.IgnoreCollision(component2, collider, ignore: true);
			}
			Object.Instantiate(muzzleFlash, shootPoint);
			cooldown = fireRate;
			burstAmount--;
		}
		if (charging)
		{
			chargeAmount = Mathf.MoveTowards(chargeAmount, 1f, Time.deltaTime);
			chargeSound.pitch = chargeAmount * 2f;
		}
	}

	public void UpdateTarget(EnemyTarget target)
	{
		this.target = target;
	}

	public void Fire()
	{
		burstAmount = 30;
		if (difficulty > 2)
		{
			currentSpread = 5f;
		}
		else if (difficulty == 2)
		{
			currentSpread = 3f;
		}
		else
		{
			currentSpread = 1.5f;
		}
		fireRate = 0.033f;
		currentNail = nail;
	}

	public void AltFire()
	{
		burstAmount = 100;
		if (difficulty > 2)
		{
			currentSpread = 25f;
		}
		else if (difficulty == 2)
		{
			currentSpread = 15f;
		}
		else
		{
			currentSpread = 7.5f;
		}
		fireRate = 0.01f;
		currentNail = altNail;
		chargeSound.Stop();
		charging = false;
	}

	public void PrepareFire()
	{
		burstAmount = 0;
		Object.Instantiate(flash, shootPoint.position, shootPoint.rotation).transform.localScale *= 4f;
	}

	public void PrepareAltFire()
	{
		burstAmount = 0;
		charging = true;
		chargeAmount = 0f;
		chargeSound.pitch = 0f;
		chargeSound.Play();
	}

	public void CancelAltCharge()
	{
		charging = false;
		chargeAmount = 0f;
		chargeSound.pitch = 0f;
	}

	private void UpdateBuffs(EnemyIdentifier eid)
	{
		speedMultiplier = eid.totalSpeedModifier;
		damageMultiplier = eid.totalDamageModifier;
	}
}



public class EnemyRevolver : MonoBehaviour, IEnemyWeapon
{
	private EnemyTarget target;

	public EnemyType safeEnemyType;

	public int variation;

	public GameObject bullet;

	public GameObject altBullet;

	public GameObject primaryPrepare;

	private GameObject currentpp;

	private GameObject altCharge;

	private AudioSource altChargeAud;

	private float chargeAmount;

	private bool charging;

	public Transform shootPoint;

	public GameObject muzzleFlash;

	public GameObject muzzleFlashAlt;

	private int difficulty;

	private EnemyIdentifier eid;

	private float speedMultiplier = 1f;

	private float damageMultiplier = 1f;

	private void Start()
	{
		altCharge = shootPoint.GetChild(0).gameObject;
		altChargeAud = altCharge.GetComponent<AudioSource>();
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		eid = GetComponentInParent<EnemyIdentifier>();
	}

	private void Update()
	{
		if (charging)
		{
			float num = 2f;
			if (difficulty == 1)
			{
				num = 1.5f;
			}
			if (difficulty == 0)
			{
				num = 1f;
			}
			chargeAmount = Mathf.MoveTowards(chargeAmount, 1f, Time.deltaTime * num * speedMultiplier);
			altChargeAud.pitch = chargeAmount / 1.75f;
			altCharge.transform.localScale = Vector3.one * chargeAmount * 10f;
		}
	}

	public void UpdateTarget(EnemyTarget target)
	{
		this.target = target;
	}

	public void Fire()
	{
		if (currentpp != null)
		{
			Object.Destroy(currentpp);
		}
		Vector3 position = shootPoint.position;
		if (Vector3.Distance(base.transform.position, eid.transform.position) > Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, eid.transform.position))
		{
			position = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
		}
		GameObject obj = Object.Instantiate(bullet, position, shootPoint.rotation);
		Object.Instantiate(muzzleFlash, shootPoint.position, shootPoint.rotation);
		Projectile component = obj.GetComponent<Projectile>();
		if ((bool)component)
		{
			component.safeEnemyType = safeEnemyType;
			component.target = target;
			if (difficulty == 1)
			{
				component.speed *= 0.75f;
			}
			if (difficulty == 0)
			{
				component.speed *= 0.5f;
			}
			component.damage *= damageMultiplier;
		}
	}

	public void AltFire()
	{
		CancelAltCharge();
		Vector3 position = shootPoint.position;
		if (Vector3.Distance(base.transform.position, eid.transform.position) > Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, eid.transform.position))
		{
			position = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
		}
		GameObject obj = Object.Instantiate(altBullet, position, shootPoint.rotation);
		Object.Instantiate(muzzleFlashAlt, shootPoint.position, shootPoint.rotation);
		Projectile component = obj.GetComponent<Projectile>();
		if ((bool)component)
		{
			component.target = target;
			component.safeEnemyType = safeEnemyType;
			if (difficulty == 1)
			{
				component.speed *= 0.75f;
			}
			if (difficulty == 0)
			{
				component.speed *= 0.5f;
			}
			component.damage *= damageMultiplier;
		}
	}

	public void PrepareFire()
	{
		if (currentpp != null)
		{
			Object.Destroy(currentpp);
		}
		currentpp = Object.Instantiate(primaryPrepare, shootPoint);
		currentpp.transform.Rotate(Vector3.up * 90f);
	}

	public void PrepareAltFire()
	{
		if ((bool)altCharge)
		{
			charging = true;
			altCharge.SetActive(value: true);
		}
	}

	public void CancelAltCharge()
	{
		if ((bool)altChargeAud)
		{
			charging = false;
			chargeAmount = 0f;
			altChargeAud.pitch = 0f;
			altCharge.SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		if (currentpp != null)
		{
			Object.Destroy(currentpp);
		}
	}

	private void UpdateBuffs(EnemyIdentifier eid)
	{
		speedMultiplier = eid.totalSpeedModifier;
		damageMultiplier = eid.totalDamageModifier;
	}
}



public class EnemyScanner
{
	private static readonly plog.Logger Log = new plog.Logger("EnemyScanner");

	private const bool DebugMode = false;

	private readonly EnemyIdentifier owner;

	private readonly Transform ownerRaycastOrigin;

	private readonly float tickInterval;

	private TimeSince? timeSinceLastTick;

	private Queue<EnemyIdentifier> pendingLineOfSightChecks;

	public EnemyScanner(EnemyIdentifier owner)
	{
		this.owner = owner;
		ownerRaycastOrigin = owner.GetCenter();
		tickInterval = 0.5f + Random.Range(0f, 0.3f);
	}

	public void Update()
	{
		if (owner == null || owner.dead)
		{
			Reset();
		}
		else if (!owner.AttackEnemies)
		{
			Reset();
		}
		else if (owner.target != null && !owner.IsCurrentTargetFallback && owner.target.isValid)
		{
			Reset();
		}
		else if (pendingLineOfSightChecks != null)
		{
			if (pendingLineOfSightChecks.Count <= 0)
			{
				Reset();
				return;
			}
			EnemyIdentifier enemyIdentifier = pendingLineOfSightChecks.Dequeue();
			if (!(enemyIdentifier == null) && !enemyIdentifier.dead && !enemyIdentifier.ignoredByEnemies)
			{
				Vector3 position = ownerRaycastOrigin.position;
				Vector3 position2 = enemyIdentifier.GetCenter().position;
				Ray ray = new Ray(position, position2 - position);
				float maxDistance = Vector3.Distance(position, position2);
				if (!Physics.Raycast(ray, out var _, maxDistance, LayerMaskDefaults.Get(LMD.Environment)))
				{
					SetTarget(enemyIdentifier);
					pendingLineOfSightChecks.Clear();
				}
			}
		}
		else if (!timeSinceLastTick.HasValue)
		{
			timeSinceLastTick = 0f;
		}
		else if ((float?)timeSinceLastTick > tickInterval)
		{
			Tick();
		}
	}

	public void Reset()
	{
		pendingLineOfSightChecks = null;
		timeSinceLastTick = 0f;
	}

	private void Tick()
	{
		timeSinceLastTick = 0f;
		IEnumerable<EnemyIdentifier> currentEnemies = MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies();
		if (currentEnemies != null)
		{
			currentEnemies = currentEnemies.Where(CanBeTargeted);
			currentEnemies = currentEnemies.OrderBy((EnemyIdentifier e) => Vector3.Distance(owner.GetCenter().position, e.GetCenter().position)).ToList();
			pendingLineOfSightChecks = new Queue<EnemyIdentifier>(currentEnemies);
		}
	}

	private bool CanBeTargeted(EnemyIdentifier enemy)
	{
		if (enemy == null || enemy.dead || enemy.ignoredByEnemies)
		{
			return false;
		}
		if (enemy == owner)
		{
			return false;
		}
		if (owner.IsTypeFriendly(enemy))
		{
			return false;
		}
		return true;
	}

	private void SetTarget(EnemyIdentifier enemy)
	{
		EnemyTarget enemyTarget = new EnemyTarget(enemy);
		if (enemyTarget.isValid)
		{
			owner.target = enemyTarget;
		}
	}
}



public class EnemyShotgun : MonoBehaviour, IEnemyWeapon
{
	private EnemyTarget target;

	public EnemyType safeEnemyType;

	private AudioSource gunAud;

	public AudioClip shootSound;

	public AudioClip clickSound;

	public AudioClip smackSound;

	private AudioSource heatSinkAud;

	public int variation;

	public GameObject bullet;

	public GameObject grenade;

	public float spread;

	private Animator anim;

	public bool gunReady = true;

	public Transform shootPoint;

	public GameObject muzzleFlash;

	private ParticleSystem[] parts;

	private bool charging;

	private AudioSource chargeSound;

	private float chargeAmount;

	public GameObject warningFlash;

	private int difficulty;

	private EnemyIdentifier eid;

	private float speedMultiplier = 1f;

	private float damageMultiplier = 1f;

	private void Start()
	{
		gunAud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
		parts = GetComponentsInChildren<ParticleSystem>();
		heatSinkAud = shootPoint.GetComponent<AudioSource>();
		chargeSound = base.transform.GetChild(0).GetComponent<AudioSource>();
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		eid = GetComponentInParent<EnemyIdentifier>();
		if (difficulty == 1)
		{
			spread *= 0.75f;
		}
		else if (difficulty == 0)
		{
			spread *= 0.5f;
		}
	}

	private void Update()
	{
		if (charging)
		{
			float num = 2f;
			if (difficulty == 1)
			{
				num = 1.5f;
			}
			if (difficulty == 0)
			{
				num = 1f;
			}
			chargeAmount = Mathf.MoveTowards(chargeAmount, 1f, Time.deltaTime * num * speedMultiplier);
			chargeSound.pitch = chargeAmount * 1.25f;
		}
	}

	public void UpdateTarget(EnemyTarget target)
	{
		this.target = target;
	}

	public void Fire()
	{
		if (target == null)
		{
			return;
		}
		gunReady = false;
		int num = 12;
		anim.SetTrigger("Shoot");
		Vector3 position = shootPoint.position;
		if (Vector3.Distance(base.transform.position, eid.transform.position) > Vector3.Distance(target.position, eid.transform.position))
		{
			position = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
		}
		GameObject gameObject = new GameObject();
		gameObject.AddComponent<ProjectileSpread>();
		gameObject.transform.position = base.transform.position;
		for (int i = 0; i < num; i++)
		{
			GameObject gameObject2;
			if (i == 0)
			{
				gameObject2 = Object.Instantiate(bullet, position, shootPoint.rotation, gameObject.transform);
			}
			else
			{
				Quaternion rotation = shootPoint.rotation * Quaternion.Euler(Random.Range(0f - spread, spread), Random.Range(0f - spread, spread), Random.Range(0f - spread, spread));
				gameObject2 = Object.Instantiate(bullet, position, rotation, gameObject.transform);
			}
			if (gameObject2.TryGetComponent<Projectile>(out var component))
			{
				component.target = target;
				component.safeEnemyType = safeEnemyType;
				if (difficulty == 1)
				{
					component.speed *= 0.75f;
				}
				else if (difficulty == 0)
				{
					component.speed *= 0.5f;
				}
				component.damage *= damageMultiplier;
				component.spreaded = true;
			}
		}
		gunAud.clip = shootSound;
		gunAud.volume = 0.35f;
		gunAud.panStereo = 0f;
		gunAud.pitch = Random.Range(0.95f, 1.05f);
		gunAud.Play();
		Object.Instantiate(muzzleFlash, shootPoint.position, shootPoint.rotation);
	}

	public void AltFire()
	{
		if (target == null)
		{
			CancelAltCharge();
			return;
		}
		gunReady = false;
		float num = 70f;
		if (difficulty == 1)
		{
			num = 50f;
		}
		else if (difficulty == 0)
		{
			num = 30f;
		}
		if (!(shootPoint == null))
		{
			Vector3 position = shootPoint.position;
			if (Vector3.Distance(base.transform.position, eid.transform.position) > Vector3.Distance(target.position, eid.transform.position))
			{
				position = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
			}
			GameObject obj = Object.Instantiate(grenade, position, Random.rotation);
			obj.GetComponent<Rigidbody>().AddForce(shootPoint.forward * num, ForceMode.VelocityChange);
			Grenade componentInChildren = obj.GetComponentInChildren<Grenade>();
			if (componentInChildren != null)
			{
				componentInChildren.enemy = true;
			}
			anim.SetTrigger("Secondary Fire");
			gunAud.clip = shootSound;
			gunAud.volume = 0.35f;
			gunAud.panStereo = 0f;
			gunAud.pitch = Random.Range(0.75f, 0.85f);
			gunAud.Play();
			Object.Instantiate(muzzleFlash, shootPoint.position, shootPoint.rotation);
			CancelAltCharge();
		}
	}

	public void PrepareFire()
	{
		if (heatSinkAud == null)
		{
			heatSinkAud = shootPoint.GetComponent<AudioSource>();
		}
		heatSinkAud.Play();
		Object.Instantiate(warningFlash, shootPoint.position, shootPoint.rotation).transform.localScale *= 2f;
	}

	public void PrepareAltFire()
	{
		if (chargeSound == null)
		{
			chargeSound = base.transform.GetChild(0).GetComponent<AudioSource>();
		}
		charging = true;
		chargeAmount = 0f;
		chargeSound.pitch = 0f;
	}

	public void CancelAltCharge()
	{
		if (chargeSound == null)
		{
			chargeSound = base.transform.GetChild(0).GetComponent<AudioSource>();
		}
		charging = false;
		chargeAmount = 0f;
		chargeSound.pitch = 0f;
	}

	public void ReleaseHeat()
	{
		ParticleSystem[] array = parts;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play();
		}
	}

	public void ClickSound()
	{
		gunAud.clip = clickSound;
		gunAud.volume = 0.5f;
		gunAud.pitch = Random.Range(0.95f, 1.05f);
		gunAud.Play();
	}

	public void ReadyGun()
	{
		gunReady = true;
	}

	public void Smack()
	{
		gunAud.clip = smackSound;
		gunAud.volume = 0.75f;
		gunAud.pitch = Random.Range(2f, 2.2f);
		gunAud.Play();
	}

	public void UpdateBuffs(EnemyIdentifier eid)
	{
		speedMultiplier = eid.totalSpeedModifier;
		damageMultiplier = eid.totalDamageModifier;
	}
}



[DefaultExecutionOrder(200)]
public class EnemySimplifier : MonoBehaviour
{
	public enum MaterialState
	{
		normal,
		simplified,
		enraged,
		enragedSimplified
	}

	public bool neverOutlineAndRemoveSimplifier;

	public bool enemyScriptHandlesEnrage;

	public Transform enemyRootTransform;

	public List<int> radiantSubmeshesToIgnore = new List<int>();

	private Material currentMaterial;

	public Material enragedMaterial;

	[HideInInspector]
	public Material originalMaterial;

	[HideInInspector]
	public Material originalMaterial2;

	[HideInInspector]
	public Material originalMaterial3;

	public Material simplifiedMaterial;

	public Material simplifiedMaterial2;

	public Material simplifiedMaterial3;

	public Material enragedSimplifiedMaterial;

	private Renderer meshrenderer;

	[HideInInspector]
	public bool enraged;

	private OptionsManager oman;

	private GameObject player;

	[HideInInspector]
	public LayerMask lmask;

	private bool active = true;

	private bool simplify;

	private bool playerDistCheck;

	[HideInInspector]
	public EnemyType enemyColorType;

	public bool ignoreCustomColor;

	[HideInInspector]
	public EnemyIdentifier eid;

	[HideInInspector]
	public bool isHat;

	[HideInInspector]
	public DoubleRender radianceEffect;

	public Material[] matList;

	private bool hasSimplifiedMaterial;

	private int shouldBeOutlined;

	private int lastOutlineState;

	private MaterialState currentState;

	private MaterialState lastState;

	private Dictionary<MaterialState, Material> materialDict;

	private bool hasEnragedSimplified;

	private bool lastSandified;

	private MaterialPropertyBlock propBlock;

	private static readonly int HasSandBuff = Shader.PropertyToID("_HasSandBuff");

	private static readonly int Outline = Shader.PropertyToID("_Outline");

	private static readonly int ForceOutline = Shader.PropertyToID("_ForceOutline");

	private void Awake()
	{
		oman = MonoSingleton<OptionsManager>.Instance;
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		if (enemyRootTransform == null)
		{
			enemyRootTransform = base.transform;
		}
		meshrenderer = GetComponent<Renderer>();
		currentMaterial = meshrenderer.material;
		originalMaterial = currentMaterial;
		if ((bool)enragedSimplifiedMaterial)
		{
			enragedSimplifiedMaterial = new Material(enragedSimplifiedMaterial);
		}
		if ((bool)simplifiedMaterial)
		{
			simplifiedMaterial = new Material(simplifiedMaterial);
		}
		if ((bool)simplifiedMaterial2)
		{
			simplifiedMaterial2 = new Material(simplifiedMaterial2);
		}
		if ((bool)simplifiedMaterial3)
		{
			simplifiedMaterial3 = new Material(simplifiedMaterial3);
		}
		matList = meshrenderer.materials;
		if (simplifiedMaterial2 != null && matList.Length > 1)
		{
			Material material = matList[1];
			originalMaterial2 = material;
		}
		if (simplifiedMaterial3 != null && matList.Length > 2)
		{
			Material material2 = matList[2];
			originalMaterial3 = material2;
		}
		if (!enragedMaterial)
		{
			enragedMaterial = originalMaterial;
		}
		materialDict = new Dictionary<MaterialState, Material>
		{
			{
				MaterialState.normal,
				originalMaterial
			},
			{
				MaterialState.simplified,
				simplifiedMaterial
			},
			{
				MaterialState.enraged,
				enragedMaterial
			},
			{
				MaterialState.enragedSimplified,
				enragedSimplifiedMaterial
			}
		};
		eid = GetComponentInParent<EnemyIdentifier>();
		if ((bool)eid && enemyColorType == EnemyType.Cerberus)
		{
			enemyColorType = eid.enemyType;
		}
		if ((bool)GetComponentInParent<SeasonalHats>())
		{
			isHat = true;
		}
		propBlock = new MaterialPropertyBlock();
		if (isHat && !eid)
		{
			Begone();
		}
	}

	private void Start()
	{
		lmask = (int)lmask | 0x100;
		lmask = (int)lmask | 0x1000000;
		oman = MonoSingleton<OptionsManager>.Instance;
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		TryRemoveSimplifier();
		if (enemyRootTransform == null)
		{
			enemyRootTransform = base.transform;
		}
		hasSimplifiedMaterial = simplifiedMaterial != null;
		hasEnragedSimplified = enragedSimplifiedMaterial != null;
		UpdateColors();
		SetOutline(forceUpdate: true);
		if (neverOutlineAndRemoveSimplifier)
		{
			MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
			materialPropertyBlock.SetFloat("_Outline", 0f);
			materialPropertyBlock.SetFloat("_ForceOutline", 0f);
			meshrenderer.SetPropertyBlock(materialPropertyBlock);
			active = false;
			Object.Destroy(this);
		}
	}

	private void TryRemoveSimplifier()
	{
		if (!isHat)
		{
			return;
		}
		bool flag = true;
		EnemySimplifier[] componentsInChildren = eid.GetComponentsInChildren<EnemySimplifier>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!componentsInChildren[i].isHat)
			{
				flag = false;
			}
		}
		if (flag)
		{
			Begone();
		}
	}

	private void OnEnable()
	{
		hasSimplifiedMaterial = simplifiedMaterial != null;
		UpdateColors();
	}

	private void Update()
	{
		if (active)
		{
			SetOutline(forceUpdate: false);
		}
	}

	public void SetOutline(bool forceUpdate)
	{
		playerDistCheck = Vector3.Distance(enemyRootTransform.position, player.transform.position) > oman.simplifiedDistance;
		if (!enemyScriptHandlesEnrage)
		{
			if (oman.simplifyEnemies && hasSimplifiedMaterial && playerDistCheck && !oman.outlinesOnly)
			{
				currentState = ((!enraged || !hasEnragedSimplified) ? MaterialState.simplified : MaterialState.enragedSimplified);
			}
			else
			{
				currentState = (enraged ? MaterialState.enraged : MaterialState.normal);
			}
		}
		bool flag = currentState != lastState;
		bool flag2 = false;
		if ((bool)eid && !eid.dead && eid.enemyType != EnemyType.Stalker && eid.sandified)
		{
			flag2 = true;
		}
		if (flag2 != lastSandified)
		{
			flag = true;
		}
		lastSandified = flag2;
		if (forceUpdate)
		{
			flag = true;
		}
		if (flag && !enemyScriptHandlesEnrage)
		{
			matList[0] = materialDict[currentState];
			if (simplifiedMaterial2 != null)
			{
				matList[1] = ((currentState == MaterialState.normal) ? originalMaterial2 : simplifiedMaterial2);
			}
			if (simplifiedMaterial3 != null)
			{
				matList[2] = ((currentState == MaterialState.normal) ? originalMaterial3 : simplifiedMaterial3);
			}
			meshrenderer.materials = matList;
		}
		shouldBeOutlined = ((oman.simplifyEnemies && playerDistCheck) ? 1 : 0);
		if (shouldBeOutlined != lastOutlineState || flag)
		{
			meshrenderer.GetPropertyBlock(propBlock);
			propBlock.SetFloat(HasSandBuff, flag2 ? 1 : 0);
			propBlock.SetFloat(Outline, shouldBeOutlined);
			propBlock.SetFloat(ForceOutline, 1f);
			meshrenderer.SetPropertyBlock(propBlock);
		}
		lastState = currentState;
		lastOutlineState = shouldBeOutlined;
		if ((bool)eid && (eid.damageBuff || eid.speedBuff || eid.healthBuff || OptionsManager.forceRadiance))
		{
			if (radianceEffect == null)
			{
				radianceEffect = meshrenderer.gameObject.AddComponent<DoubleRender>();
				radianceEffect.subMeshesToIgnore = radiantSubmeshesToIgnore;
			}
			radianceEffect.SetOutline((oman.simplifyEnemies && playerDistCheck) ? 1 : 0);
		}
		else if ((bool)radianceEffect)
		{
			radianceEffect.RemoveEffect();
		}
	}

	public void UpdateColors()
	{
		if (!ignoreCustomColor)
		{
			if (hasSimplifiedMaterial)
			{
				simplifiedMaterial.color = MonoSingleton<ColorBlindSettings>.Instance.GetEnemyColor(enemyColorType);
			}
			if ((bool)enragedSimplifiedMaterial)
			{
				enragedSimplifiedMaterial.color = MonoSingleton<ColorBlindSettings>.Instance.enrageColor;
			}
		}
	}

	public void Begone()
	{
		active = false;
		if ((bool)meshrenderer)
		{
			matList[0] = originalMaterial;
			if (simplifiedMaterial2 != null)
			{
				matList[1] = originalMaterial2;
			}
			if (simplifiedMaterial3 != null)
			{
				matList[2] = originalMaterial3;
			}
			meshrenderer.materials = matList;
			propBlock.SetFloat("_Outline", 0f);
			propBlock.SetFloat("_ForceOutline", 0f);
			propBlock.SetFloat(HasSandBuff, 0f);
			meshrenderer.SetPropertyBlock(propBlock);
		}
		if ((bool)radianceEffect)
		{
			radianceEffect.RemoveEffect();
		}
		Object.Destroy(this);
	}

	public void ChangeTexture(MaterialState stateToTarget, Texture newTexture)
	{
		materialDict[stateToTarget].SetTexture("_MainTex", newTexture);
	}

	public void ChangeMaterialNew(MaterialState stateToTarget, Material newMaterial)
	{
		materialDict[stateToTarget] = newMaterial;
		SetOutline(forceUpdate: true);
	}

	public void ChangeMaterial(Material oldMaterial, Material newMaterial)
	{
		bool flag = false;
		if (currentMaterial == oldMaterial)
		{
			flag = true;
		}
		newMaterial = new Material(newMaterial);
		if (oldMaterial == originalMaterial)
		{
			originalMaterial = newMaterial;
		}
		else if (oldMaterial == simplifiedMaterial)
		{
			simplifiedMaterial = newMaterial;
		}
		else if (oldMaterial == enragedMaterial)
		{
			enragedMaterial = newMaterial;
		}
		else if (oldMaterial == enragedSimplifiedMaterial)
		{
			enragedSimplifiedMaterial = newMaterial;
		}
		if (flag)
		{
			meshrenderer.material = newMaterial;
			currentMaterial = newMaterial;
		}
	}
}



public class EnemySpawnRadius : MonoBehaviour
{
	public GameObject[] spawnables;

	private List<GameObject> spawnedObjects = new List<GameObject>();

	private List<EnemyIdentifier> currentEnemies = new List<EnemyIdentifier>();

	public float minimumDistance;

	public float maximumDistance;

	public float spawnCooldown;

	private float cooldown;

	public int maximumEnemyCount;

	public bool spawnAsPuppets = true;

	private GoreZone gz;

	private void Start()
	{
		gz = GoreZone.ResolveGoreZone(base.transform);
		Invoke("SlowUpdate", 1f);
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 1f);
		if (currentEnemies == null || currentEnemies.Count == 0)
		{
			return;
		}
		for (int num = currentEnemies.Count - 1; num >= 0; num--)
		{
			if (spawnedObjects[num] == null || currentEnemies[num].dead)
			{
				spawnedObjects.RemoveAt(num);
				currentEnemies.RemoveAt(num);
			}
		}
	}

	private void Update()
	{
		cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		if (cooldown <= 0f)
		{
			if (currentEnemies.Count < maximumEnemyCount)
			{
				SpawnEnemy();
			}
			else
			{
				cooldown = 2f;
			}
		}
	}

	public void SpawnEnemy()
	{
		for (int i = 0; i < 3; i++)
		{
			Vector3 normalized = new Vector3(Random.Range(-1f, 1f), 0f, Random.Range(-1f, 1f)).normalized;
			if (!Physics.Raycast(base.transform.position + normalized * Random.Range(minimumDistance, maximumDistance), Vector3.down, out var hitInfo, 25f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				continue;
			}
			cooldown = spawnCooldown;
			GameObject gameObject = Object.Instantiate(spawnables[Random.Range(0, spawnables.Length)], hitInfo.point, Quaternion.identity);
			gameObject.transform.SetParent(gz.transform, worldPositionStays: true);
			spawnedObjects.Add(gameObject);
			EnemyIdentifier componentInChildren = gameObject.GetComponentInChildren<EnemyIdentifier>();
			if ((bool)componentInChildren)
			{
				currentEnemies.Add(componentInChildren);
				if (spawnAsPuppets)
				{
					componentInChildren.puppet = true;
				}
			}
			else
			{
				currentEnemies.Add(null);
			}
			gameObject.SetActive(value: true);
			return;
		}
		cooldown = 1f;
	}

	public void KillAllEnemies()
	{
		for (int num = currentEnemies.Count - 1; num >= 0; num--)
		{
			if (currentEnemies[num] != null)
			{
				currentEnemies[num].InstaKill();
				spawnedObjects.RemoveAt(num);
				currentEnemies.RemoveAt(num);
			}
		}
	}
}



public class EnemyTarget
{
	public bool isPlayer;

	public Transform targetTransform;

	public EnemyIdentifier enemyIdentifier;

	public Rigidbody rigidbody;

	public bool isEnemy
	{
		get
		{
			if (!isPlayer)
			{
				return enemyIdentifier != null;
			}
			return false;
		}
	}

	public Vector3 position
	{
		get
		{
			if (!(enemyIdentifier != null) || !enemyIdentifier.overrideCenter)
			{
				if (!(targetTransform != null))
				{
					return Vector3.zero;
				}
				return targetTransform.position;
			}
			return enemyIdentifier.overrideCenter.position;
		}
	}

	public Vector3 headPosition => headTransform.position;

	public Transform headTransform
	{
		get
		{
			if (!(enemyIdentifier == null) || !isPlayer || MonoSingleton<PlayerTracker>.Instance.playerType != 0)
			{
				return trackedTransform;
			}
			return MonoSingleton<CameraController>.Instance.cam.transform;
		}
	}

	public Transform trackedTransform
	{
		get
		{
			if (!(enemyIdentifier != null) || !enemyIdentifier.overrideCenter)
			{
				return targetTransform;
			}
			return enemyIdentifier.overrideCenter;
		}
	}

	public Vector3 forward => targetTransform.forward;

	public Vector3 right => targetTransform.right;

	public bool isOnGround
	{
		get
		{
			if (isPlayer)
			{
				return MonoSingleton<PlayerTracker>.Instance.GetOnGround();
			}
			return true;
		}
	}

	public bool isValid
	{
		get
		{
			if (targetTransform != null && targetTransform.gameObject.activeInHierarchy)
			{
				if (!(enemyIdentifier == null))
				{
					return !enemyIdentifier.dead;
				}
				return true;
			}
			return false;
		}
	}

	public bool IsTargetTransform(Transform other)
	{
		if (isPlayer)
		{
			return other == MonoSingleton<PlayerTracker>.Instance.GetPlayer().parent;
		}
		return other == targetTransform;
	}

	public EnemyTarget(Transform targetTransform)
	{
		isPlayer = false;
		this.targetTransform = targetTransform;
		enemyIdentifier = this.targetTransform.GetComponent<EnemyIdentifier>();
		rigidbody = this.targetTransform.GetComponent<Rigidbody>();
	}

	public EnemyTarget(EnemyIdentifier otherEnemy)
	{
		isPlayer = false;
		targetTransform = otherEnemy.transform;
		enemyIdentifier = otherEnemy;
		enemyIdentifier = targetTransform.GetComponent<EnemyIdentifier>();
		rigidbody = targetTransform.GetComponent<Rigidbody>();
	}

	public Vector3 GetVelocity()
	{
		if (isPlayer)
		{
			return MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity();
		}
		if (targetTransform == null)
		{
			return Vector3.zero;
		}
		if (targetTransform.TryGetComponent<NavMeshAgent>(out var component) && component.enabled)
		{
			return component.velocity;
		}
		if (rigidbody != null)
		{
			return rigidbody.velocity;
		}
		return Vector3.zero;
	}

	public Vector3 PredictTargetPosition(float time, bool includeGravity = false)
	{
		Vector3 vector = GetVelocity() * time;
		if (rigidbody != null)
		{
			if (includeGravity && ((isEnemy && !rigidbody.isKinematic) || (isPlayer && !MonoSingleton<NewMovement>.Instance.gc.onGround)))
			{
				vector += 0.5f * Physics.gravity * (time * time);
			}
			if (Physics.Raycast(rigidbody.position, vector, out var hitInfo, vector.magnitude, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				vector = hitInfo.point;
			}
			else
			{
				vector += rigidbody.position;
			}
		}
		else if ((bool)targetTransform)
		{
			vector += targetTransform.position;
		}
		return vector;
	}

	private EnemyTarget()
	{
		isPlayer = false;
		targetTransform = null;
	}

	public static EnemyTarget TrackPlayer()
	{
		PlayerTracker instance = MonoSingleton<PlayerTracker>.Instance;
		return new EnemyTarget
		{
			isPlayer = true,
			targetTransform = instance.GetPlayer().transform,
			rigidbody = instance.GetRigidbody()
		};
	}

	public static EnemyTarget TrackPlayerIfAllowed()
	{
		if (EnemyIgnorePlayer.Active || BlindEnemies.Blind)
		{
			return null;
		}
		return TrackPlayer();
	}

	public override string ToString()
	{
		return string.Concat(isPlayer ? "Player: " : (isEnemy ? "Enemy: " : "Custom Target: "), targetTransform.name, " (", targetTransform.position, ")");
	}
}



[ConfigureSingleton(SingletonFlags.None)]
public class EnemyTracker : MonoSingleton<EnemyTracker>
{
	public List<EnemyIdentifier> enemies = new List<EnemyIdentifier>();

	public List<int> enemyRanks = new List<int>();

	public List<Drone> drones = new List<Drone>();

	private void Update()
	{
		if (!Debug.isDebugBuild || !Input.GetKeyDown(KeyCode.F9))
		{
			return;
		}
		foreach (EnemyIdentifier currentEnemy in GetCurrentEnemies())
		{
			currentEnemy.gameObject.SetActive(value: false);
			currentEnemy.gameObject.SetActive(value: true);
		}
	}

	private void OnGUI()
	{
		if (EnemyIdentifierDebug.Active)
		{
			List<EnemyIdentifier> currentEnemies = GetCurrentEnemies();
			GUI.color = Color.white;
			GUIStyle style = new GUIStyle(GUI.skin.label)
			{
				fontStyle = FontStyle.Bold
			};
			GUILayout.Label("[Enemy Tracker]", style);
			GUILayout.Space(12f);
			GUILayout.Label("Active Enemies: " + currentEnemies.Count, style);
			for (int i = 0; i < currentEnemies.Count; i++)
			{
				GUILayout.Label("Enemy " + i + ": " + currentEnemies[i].name, style);
				GUILayout.Label("Enemy Type: " + currentEnemies[i].enemyType, style);
				GUILayout.Label("Enemy Rank: " + enemyRanks[i], style);
				GUILayout.Space(12f);
			}
		}
	}

	public List<EnemyIdentifier> GetCurrentEnemies()
	{
		List<EnemyIdentifier> list = new List<EnemyIdentifier>();
		if (enemies != null && enemies.Count > 0)
		{
			for (int num = enemies.Count - 1; num >= 0; num--)
			{
				if (enemies[num].dead || enemies[num] == null || enemies[num].gameObject == null)
				{
					enemies.RemoveAt(num);
					enemyRanks.RemoveAt(num);
				}
				else if (enemies[num].gameObject.activeInHierarchy)
				{
					list.Add(enemies[num]);
				}
			}
		}
		return list;
	}

	public void UpdateIdolsNow()
	{
		foreach (EnemyIdentifier currentEnemy in GetCurrentEnemies())
		{
			if (currentEnemy.enemyType == EnemyType.Idol && currentEnemy.idol != null)
			{
				currentEnemy.idol.PickNewTarget();
			}
		}
	}

	public List<EnemyIdentifier> GetEnemiesOfType(EnemyType type)
	{
		List<EnemyIdentifier> currentEnemies = GetCurrentEnemies();
		if (currentEnemies.Count > 0)
		{
			for (int num = currentEnemies.Count - 1; num >= 0; num--)
			{
				if (currentEnemies[num].enemyType != type)
				{
					currentEnemies.RemoveAt(num);
				}
			}
		}
		return currentEnemies;
	}

	public void AddEnemy(EnemyIdentifier eid)
	{
		if (!enemies.Contains(eid))
		{
			enemies.Add(eid);
			enemyRanks.Add(GetEnemyRank(eid));
		}
	}

	public int GetEnemyRank(EnemyIdentifier eid)
	{
		return eid.enemyType switch
		{
			EnemyType.Cerberus => 3, 
			EnemyType.Drone => 1, 
			EnemyType.Ferryman => 5, 
			EnemyType.Filth => 0, 
			EnemyType.Gabriel => 6, 
			EnemyType.GabrielSecond => 6, 
			EnemyType.Gutterman => 4, 
			EnemyType.Guttertank => 4, 
			EnemyType.HideousMass => 6, 
			EnemyType.MaliciousFace => 3, 
			EnemyType.Mandalore => 5, 
			EnemyType.Mannequin => 2, 
			EnemyType.Mindflayer => 5, 
			EnemyType.Minos => 6, 
			EnemyType.MinosPrime => 7, 
			EnemyType.Minotaur => 6, 
			EnemyType.Puppet => 0, 
			EnemyType.Schism => 1, 
			EnemyType.Sisyphus => 6, 
			EnemyType.SisyphusPrime => 7, 
			EnemyType.Soldier => 1, 
			EnemyType.Stalker => 4, 
			EnemyType.Stray => 0, 
			EnemyType.Streetcleaner => 2, 
			EnemyType.Swordsmachine => 3, 
			EnemyType.Turret => 3, 
			EnemyType.V2 => 6, 
			EnemyType.V2Second => 6, 
			EnemyType.Virtue => 3, 
			EnemyType.Wicked => 6, 
			_ => -1, 
		};
	}
}


public enum EnemyType
{
	BigJohnator = 37,
	CancerousRodent = 23,
	Centaur = 35,
	Cerberus = 0,
	Drone = 1,
	Ferryman = 26,
	Filth = 3,
	FleshPanopticon = 30,
	FleshPrison = 17,
	Gabriel = 16,
	GabrielSecond = 28,
	Gutterman = 33,
	Guttertank = 34,
	HideousMass = 2,
	Idol = 21,
	Leviathan = 27,
	MaliciousFace = 4,
	Mandalore = 25,
	Mannequin = 31,
	Mindflayer = 5,
	Minos = 11,
	MinosPrime = 18,
	Minotaur = 32,
	Puppet = 36,
	Schism = 14,
	Sisyphus = 19,
	SisyphusPrime = 29,
	Soldier = 15,
	Stalker = 12,
	Stray = 13,
	Streetcleaner = 6,
	Swordsmachine = 7,
	Turret = 20,
	V2 = 8,
	V2Second = 22,
	VeryCancerousRodent = 24,
	Virtue = 9,
	Wicked = 10
}



public static class EnemyTypes
{
	public static HashSet<Type> types = new HashSet<Type>
	{
		typeof(Zombie),
		typeof(ZombieMelee),
		typeof(Stalker),
		typeof(Statue),
		typeof(StatueBoss),
		typeof(Mass),
		typeof(Drone),
		typeof(DroneFlesh),
		typeof(Machine),
		typeof(V2),
		typeof(SpiderBody),
		typeof(Gutterman),
		typeof(Guttertank),
		typeof(Sisyphus),
		typeof(MortarLauncher)
	};

	public static string GetEnemyName(EnemyType type)
	{
		return type switch
		{
			EnemyType.Gabriel => "Gabriel, Judge of Hell", 
			EnemyType.GabrielSecond => "Gabriel, Apostate of Hate", 
			EnemyType.Mandalore => "Mysterious Druid Knight (& Owl)", 
			EnemyType.Sisyphus => "Sisyphean Insurrectionist", 
			EnemyType.Turret => "Sentry", 
			EnemyType.V2Second => "V2", 
			_ => Enum.GetName(typeof(EnemyType), type), 
		};
	}
}


public class EnemyTypeTracker
{
	public EnemyType type;

	public int amount;

	public EnemyTypeTracker(EnemyType enemyType)
	{
		type = enemyType;
	}
}



public class EnrageEffect : MonoBehaviour
{
	public GameObject endSound;

	public bool noParticle;

	[HideInInspector]
	public bool activated;

	private void Start()
	{
		if (!activated)
		{
			activated = true;
			CameraController instance = MonoSingleton<CameraController>.Instance;
			MonoSingleton<StyleHUD>.Instance.AddPoints(250, "ultrakill.enraged");
			instance.CameraShake(1f);
		}
	}

	private void OnDestroy()
	{
		if (!noParticle && base.gameObject.scene.isLoaded)
		{
			Object.Instantiate(endSound, base.transform.position, base.transform.rotation);
		}
	}
}


public enum EnviroDamageType
{
	Normal,
	Burn,
	Acid,
	WeakBurn,
	Chainsaw
}



public class Envirokills : MonoBehaviour
{
	public enviroKillType ekt;

	public int killAmount;

	private void Update()
	{
		if (ekt == enviroKillType.Glass && killAmount <= MonoSingleton<StatsManager>.Instance.maxGlassKills)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
	}
}


public enum enviroKillType
{
	Glass,
	Other
}



public class EnviroParticle : MonoBehaviour
{
	private ParticleSystem part;

	private void Start()
	{
		part = GetComponent<ParticleSystem>();
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("disableEnvironmentParticles"))
		{
			part.Stop();
			part.Clear();
		}
	}

	private void OnEnable()
	{
		CheckEnviroParticles();
	}

	public void CheckEnviroParticles()
	{
		if (part == null)
		{
			part = GetComponent<ParticleSystem>();
		}
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("disableEnvironmentParticles"))
		{
			part.Stop();
			part.Clear();
		}
		else
		{
			part.Play();
		}
	}
}



public class EventOnDestroy : MonoBehaviour
{
	public UnityEvent stuff;

	private void OnDestroy()
	{
		if ((bool)base.transform.parent && base.transform.parent.gameObject.activeInHierarchy)
		{
			stuff?.Invoke();
		}
	}
}



public class EventOnSceneName : MonoBehaviour
{
	public string sceneName;

	public bool emitRevertOnSceneMismatch;

	public UltrakillEvent onSceneName;

	private void OnEnable()
	{
		if (SceneHelper.CurrentScene == sceneName)
		{
			onSceneName.Invoke();
		}
		else if (emitRevertOnSceneMismatch)
		{
			onSceneName.Revert();
		}
	}
}



public class EventsSequence : MonoBehaviour
{
	public float delay = 1f;

	public bool loop;

	public bool startOverOnEnable;

	public UltrakillEvent[] events;

	private bool active;

	private int currentEvent;

	private void Start()
	{
		StartEvents();
	}

	private void OnEnable()
	{
		StartEvents();
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateEvent");
		active = false;
		if (startOverOnEnable)
		{
			currentEvent = 0;
		}
	}

	public void StartEvents()
	{
		if (events.Length == 0)
		{
			Debug.LogError("No events set in EventsSequence on " + base.gameObject.name, base.gameObject);
		}
		else if (!active)
		{
			active = true;
			Invoke("ActivateEvent", delay);
		}
	}

	private void ActivateEvent()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		if (currentEvent < events.Length)
		{
			events[currentEvent].Invoke();
		}
		if (currentEvent < events.Length - 1)
		{
			currentEvent++;
			Invoke("ActivateEvent", delay);
		}
		else if (loop)
		{
			currentEvent = 0;
			if (delay != 0f)
			{
				Invoke("ActivateEvent", delay);
			}
			else
			{
				Invoke("ActivateEvent", Time.deltaTime);
			}
		}
	}

	public void ChangeDelay(float newDelay)
	{
		delay = newDelay;
	}
}



public class Explosion : MonoBehaviour
{
	public static float globalSizeMulti = 1f;

	public HurtCooldownCollection HurtCooldownCollection;

	public GameObject sourceWeapon;

	public bool enemy;

	public bool harmless;

	public bool lowQuality;

	private CameraController cc;

	private Light light;

	private MeshRenderer mr;

	private Color materialColor;

	private Material originalMaterial;

	private TimeSince explosionTime;

	private bool whiteExplosion;

	private bool fading;

	public float speed;

	public float maxSize;

	private LayerMask lmask;

	public int damage;

	public float enemyDamageMultiplier;

	[HideInInspector]
	public int playerDamageOverride = -1;

	public GameObject explosionChunk;

	public bool ignite;

	public bool friendlyFire;

	public bool isFup;

	private HashSet<int> hitColliders = new HashSet<int>();

	public string hitterWeapon;

	public bool halved;

	private SphereCollider scol;

	public AffectedSubjects canHit;

	private bool hasHitPlayer;

	[HideInInspector]
	public EnemyIdentifier originEnemy;

	public bool rocketExplosion;

	public List<EnemyType> toIgnore;

	[HideInInspector]
	public EnemyIdentifier interruptedEnemy;

	[HideInInspector]
	public bool ultrabooster;

	public bool unblockable;

	public bool electric;

	private void Start()
	{
		explosionTime = 0f;
		mr = GetComponent<MeshRenderer>();
		materialColor = mr.material.GetColor("_Color");
		originalMaterial = mr.sharedMaterial;
		mr.material = new Material(MonoSingleton<DefaultReferenceManager>.Instance.blankMaterial);
		whiteExplosion = true;
		cc = MonoSingleton<CameraController>.Instance;
		float num = Vector3.Distance(base.transform.position, cc.transform.position);
		float num2 = ((damage == 0) ? 0.25f : 1f);
		if (num < 3f * maxSize)
		{
			cc.CameraShake(1.5f * num2);
		}
		else if (num < 85f)
		{
			cc.CameraShake((1.5f - (num - 20f) / 65f * 1.5f) / 6f * maxSize * num2);
		}
		scol = GetComponent<SphereCollider>();
		if ((bool)scol)
		{
			scol.enabled = true;
		}
		if (speed == 0f)
		{
			speed = 1f;
		}
		if (!lowQuality)
		{
			lowQuality = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleExplosions");
		}
		if ((bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Count > 0)
		{
			Collider[] array = Physics.OverlapSphere(base.transform.position, 1f, LayerMaskDefaults.Get(LMD.Environment));
			foreach (Collider collider in array)
			{
				if (MonoSingleton<ComponentsDatabase>.Instance.scrollers.Contains(collider.transform) && collider.transform.TryGetComponent<ScrollingTexture>(out var component))
				{
					component.attachedObjects.Add(base.transform);
				}
			}
		}
		if (!lowQuality)
		{
			light = GetComponentInChildren<Light>();
			light.enabled = true;
			if (explosionChunk != null)
			{
				for (int j = 0; j < Random.Range(24, 30); j++)
				{
					GameObject obj = Object.Instantiate(explosionChunk, base.transform.position + new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)), Random.rotation);
					Vector3 vector = new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 2f), Random.Range(-1f, 1f));
					obj.GetComponent<Rigidbody>().AddForce(vector * 250f, ForceMode.VelocityChange);
					Physics.IgnoreCollision(obj.GetComponent<Collider>(), scol);
				}
			}
		}
		lmask = (int)lmask | 0x100;
		lmask = (int)lmask | 0x1000000;
		lmask = (int)lmask | 0x4000000;
		speed *= globalSizeMulti;
		maxSize *= globalSizeMulti;
	}

	private void Update()
	{
		if (light != null)
		{
			light.range += 5f * Time.deltaTime * speed;
		}
		if (whiteExplosion && (float)explosionTime > 0.1f)
		{
			whiteExplosion = false;
			mr.material = new Material(originalMaterial);
		}
		if (fading)
		{
			materialColor.a -= 2f * Time.deltaTime;
			if (light != null)
			{
				light.intensity -= 65f * Time.deltaTime;
			}
			mr.material.SetColor("_Color", materialColor);
			if (materialColor.a <= 0f)
			{
				Object.Destroy(base.gameObject);
			}
		}
	}

	private void FixedUpdate()
	{
		base.transform.localScale += Vector3.one * 0.05f * speed;
		float num = base.transform.lossyScale.x * scol.radius;
		if (!fading && num > maxSize)
		{
			harmless = true;
			scol.enabled = false;
			fading = true;
			speed /= 4f;
		}
		if (!halved && num > maxSize / 2f)
		{
			halved = true;
			damage = Mathf.RoundToInt((float)damage / 1.5f);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer != 9 && !harmless)
		{
			Collide(other);
		}
	}

	private void Collide(Collider other)
	{
		Vector3 position = other.transform.position;
		Vector3 normalized = (position - base.transform.position).normalized;
		float num = Vector3.Distance(position, base.transform.position);
		Vector3 vector = base.transform.position - normalized * 0.01f;
		float maxDistance = Vector3.Distance(vector, position);
		int instanceID = other.GetInstanceID();
		if (!hitColliders.Contains(instanceID))
		{
			Breakable component4;
			Bleeder component5;
			Glass component6;
			Flammable component7;
			if (!hasHitPlayer && other.gameObject.CompareTag("Player"))
			{
				if (Physics.Raycast(vector, normalized, out var _, maxDistance, 2048, QueryTriggerInteraction.Ignore) || (enemy && Physics.Raycast(position, -normalized, num - 0.1f, lmask, QueryTriggerInteraction.Ignore)))
				{
					return;
				}
				hasHitPlayer = true;
				hitColliders.Add(instanceID);
				if (canHit != AffectedSubjects.EnemiesOnly)
				{
					if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && damage > 0)
					{
						MonoSingleton<PlatformerMovement>.Instance.Burn();
						return;
					}
					if (!MonoSingleton<NewMovement>.Instance.exploded && (MonoSingleton<NewMovement>.Instance.safeExplosionLaunchCooldown <= 0f || damage > 0))
					{
						int num2 = 200;
						if (rocketExplosion && damage == 0)
						{
							num2 = Mathf.RoundToInt(100f / ((float)(MonoSingleton<NewMovement>.Instance.rocketJumps + 3) / 3f));
							MonoSingleton<NewMovement>.Instance.rocketJumps++;
						}
						Vector3 vector2 = base.transform.position - position;
						if (new Vector3(vector2.x, 0f, vector2.z).sqrMagnitude < 0.0625f)
						{
							if (isFup)
							{
								MonoSingleton<NewMovement>.Instance.LaunchFromPointAtSpeed(position, 60f);
							}
							else
							{
								MonoSingleton<NewMovement>.Instance.LaunchFromPoint(position, num2, maxSize);
								if (ultrabooster && num < 12f)
								{
									MonoSingleton<NewMovement>.Instance.LaunchFromPoint(position, num2, maxSize);
								}
							}
						}
						else if (isFup)
						{
							MonoSingleton<NewMovement>.Instance.LaunchFromPointAtSpeed(base.transform.position, 60f);
						}
						else
						{
							MonoSingleton<NewMovement>.Instance.LaunchFromPoint(base.transform.position, num2, maxSize);
							if (ultrabooster && num < 12f)
							{
								MonoSingleton<NewMovement>.Instance.LaunchFromPoint(base.transform.position, num2, maxSize);
							}
						}
						if (damage <= 0)
						{
							MonoSingleton<NewMovement>.Instance.safeExplosionLaunchCooldown = 0.5f;
						}
					}
					if (damage > 0)
					{
						int num3 = damage;
						if (ultrabooster)
						{
							num3 = ((num < 3f) ? 35 : 50);
						}
						num3 = ((playerDamageOverride >= 0) ? playerDamageOverride : num3);
						MonoSingleton<NewMovement>.Instance.GetHurt(num3, invincible: true, enemy ? 1 : 0, explosion: true);
					}
				}
			}
			else if ((other.gameObject.layer == 10 || other.gameObject.layer == 11) && canHit != AffectedSubjects.PlayerOnly)
			{
				EnemyIdentifierIdentifier componentInParent = other.GetComponentInParent<EnemyIdentifierIdentifier>();
				if (componentInParent != null && componentInParent.eid != null)
				{
					if (!componentInParent.eid.dead && componentInParent.eid.TryGetComponent<Collider>(out var component))
					{
						int instanceID2 = component.GetInstanceID();
						if (hitColliders.Add(instanceID2) && (HurtCooldownCollection == null || HurtCooldownCollection.TryHurtCheckEnemy(componentInParent.eid)))
						{
							if (componentInParent.eid.enemyType == EnemyType.Idol)
							{
								if (!Physics.Linecast(base.transform.position, component.bounds.center, LayerMaskDefaults.Get(LMD.Environment)))
								{
									componentInParent.eid.hitter = hitterWeapon;
									componentInParent.eid.DeliverDamage(other.gameObject, Vector3.zero, position, 1f, tryForExplode: false, 0f, sourceWeapon, ignoreTotalDamageTakenMultiplier: false, fromExplosion: true);
								}
							}
							else if (componentInParent.eid.enemyType == EnemyType.MaliciousFace && !componentInParent.eid.isGasolined)
							{
								Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.ineffectiveSound, position, Quaternion.identity);
							}
							else if ((!enemy || (componentInParent.eid.enemyType != EnemyType.HideousMass && componentInParent.eid.enemyType != EnemyType.Sisyphus)) && !toIgnore.Contains(componentInParent.eid.enemyType))
							{
								if (componentInParent.eid.enemyType == EnemyType.Gutterman && hitterWeapon == "heavypunch")
								{
									componentInParent.eid.hitter = "heavypunch";
								}
								else if (hitterWeapon == "lightningbolt")
								{
									componentInParent.eid.hitter = "lightningbolt";
								}
								else
								{
									componentInParent.eid.hitter = (friendlyFire ? "ffexplosion" : (enemy ? "enemy" : "explosion"));
								}
								if (!componentInParent.eid.hitterWeapons.Contains(hitterWeapon))
								{
									componentInParent.eid.hitterWeapons.Add(hitterWeapon);
								}
								Vector3 vector3 = normalized;
								if (componentInParent.eid.enemyType == EnemyType.Drone && damage == 0)
								{
									vector3 = Vector3.zero;
								}
								else if (vector3.y <= 0.5f)
								{
									vector3 = new Vector3(vector3.x, vector3.y + 0.5f, vector3.z);
								}
								else if (vector3.y < 1f)
								{
									vector3 = new Vector3(vector3.x, 1f, vector3.z);
								}
								float num4 = (float)damage / 10f * enemyDamageMultiplier;
								if (rocketExplosion && componentInParent.eid.enemyType == EnemyType.Cerberus)
								{
									num4 *= 1.5f;
								}
								if (componentInParent.eid.enemyType != EnemyType.Soldier || componentInParent.eid.isGasolined || unblockable || BlindEnemies.Blind || !componentInParent.eid.TryGetComponent<Zombie>(out var component2) || !component2.grounded || !component2.zp || component2.zp.difficulty < 2)
								{
									if (electric)
									{
										componentInParent.eid.hitterAttributes.Add(HitterAttribute.Electricity);
									}
									componentInParent.eid.DeliverDamage(componentInParent.gameObject, vector3 * 50000f, position, num4, tryForExplode: false, 0f, sourceWeapon, ignoreTotalDamageTakenMultiplier: false, fromExplosion: true);
									if (ignite)
									{
										if (componentInParent.eid.flammables != null && componentInParent.eid.flammables.Count > 0)
										{
											componentInParent.eid.StartBurning(damage / 10);
										}
										else
										{
											Flammable componentInChildren = componentInParent.eid.GetComponentInChildren<Flammable>();
											if (componentInChildren != null)
											{
												componentInChildren.Burn(damage / 10);
											}
										}
									}
								}
								else
								{
									componentInParent.eid.hitter = "blocked";
									if (component2.zp.difficulty <= 3 || electric)
									{
										if (electric)
										{
											componentInParent.eid.hitterAttributes.Add(HitterAttribute.Electricity);
										}
										componentInParent.eid.DeliverDamage(other.gameObject, Vector3.zero, position, num4 * 0.25f, tryForExplode: false, 0f, sourceWeapon, ignoreTotalDamageTakenMultiplier: false, fromExplosion: true);
									}
									component2.zp.Block(base.transform.position);
								}
							}
						}
					}
					else if (componentInParent.eid.dead)
					{
						hitColliders.Add(instanceID);
						componentInParent.eid.hitter = (enemy ? "enemy" : "explosion");
						componentInParent.eid.DeliverDamage(other.gameObject, normalized * 5000f, position, (float)damage / 10f * enemyDamageMultiplier, tryForExplode: false, 0f, sourceWeapon, ignoreTotalDamageTakenMultiplier: false, fromExplosion: true);
						if (ignite && componentInParent.TryGetComponent<Flammable>(out var _))
						{
							Flammable componentInChildren2 = componentInParent.eid.GetComponentInChildren<Flammable>();
							if (componentInChildren2 != null)
							{
								componentInChildren2.Burn(damage / 10);
							}
						}
					}
				}
			}
			else if (other.TryGetComponent<Breakable>(out component4) && !component4.unbreakable && !component4.precisionOnly && (!component4.playerOnly || !enemy))
			{
				if (!component4.accurateExplosionsOnly)
				{
					component4.Break();
				}
				else
				{
					Vector3 vector4 = other.ClosestPoint(base.transform.position);
					if (!Physics.Raycast(vector4 + (vector4 - base.transform.position).normalized * 0.001f, base.transform.position - vector4, Vector3.Distance(base.transform.position, vector4), lmask, QueryTriggerInteraction.Ignore))
					{
						component4.Break();
					}
				}
			}
			else if (other.TryGetComponent<Bleeder>(out component5))
			{
				bool flag = false;
				if (toIgnore.Count > 0 && component5.ignoreTypes.Length != 0)
				{
					EnemyType[] ignoreTypes = component5.ignoreTypes;
					foreach (EnemyType enemyType in ignoreTypes)
					{
						for (int j = 0; j < toIgnore.Count; j++)
						{
							if (enemyType == toIgnore[j])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
				}
				if (!flag)
				{
					component5.GetHit(position, GoreType.Head, fromExplosion: true);
				}
			}
			else if (other.TryGetComponent<Glass>(out component6))
			{
				component6.Shatter();
			}
			else if (ignite && other.TryGetComponent<Flammable>(out component7) && (!enemy || !component7.playerOnly) && (enemy || !component7.enemyOnly))
			{
				component7.Burn(4f);
			}
		}
		if (other.gameObject.CompareTag("Player") && MonoSingleton<PlayerTracker>.Instance.playerType != PlayerType.Platformer)
		{
			return;
		}
		Rigidbody component8 = other.GetComponent<Rigidbody>();
		bool flag2 = other.gameObject.layer == 14;
		if ((!((bool)component8 && flag2) || !other.gameObject.CompareTag("Metal") || !other.TryGetComponent<Nail>(out var component9) || component9.magnets.Count == 0) && (bool)component8 && (!flag2 || component8.useGravity) && !other.gameObject.CompareTag("IgnorePushes"))
		{
			hitColliders.Add(instanceID);
			Vector3 a = normalized * Mathf.Max(5f - num, 0f);
			a = Vector3.Scale(a, new Vector3(7500f, 1f, 7500f));
			if (component8.useGravity)
			{
				a = new Vector3(a.x, 18750f, a.z);
			}
			if (other.gameObject.layer == 27 || other.gameObject.layer == 9)
			{
				a = Vector3.ClampMagnitude(a, 5000f);
			}
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject)
			{
				a *= 30f;
			}
			component8.AddForce(a);
		}
		if (flag2)
		{
			ThrownSword component10 = other.GetComponent<ThrownSword>();
			Projectile component11 = other.GetComponent<Projectile>();
			if (component10 != null)
			{
				component10.deflected = true;
			}
			if (component11 != null && !component11.ignoreExplosions)
			{
				component11.homingType = HomingType.None;
				other.transform.LookAt(position + normalized);
				component11.friendly = true;
				component11.target = null;
				component11.turnSpeed = 0f;
				component11.speed = Mathf.Max(component11.speed, 65f);
			}
		}
	}
}



public class ExplosionChunk : MonoBehaviour
{
	private bool done;

	private Rigidbody rb;

	private void Start()
	{
		Invoke("Gone", 3f);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!done && collision.gameObject.layer == 8)
		{
			done = true;
			rb = GetComponent<Rigidbody>();
			GetComponent<TrailRenderer>().emitting = false;
			Invoke("Gone", 1f);
		}
	}

	private void Gone()
	{
		Object.Destroy(base.gameObject);
	}
}



public class ExplosionController : MonoBehaviour
{
	public bool forceSimple;

	public bool tryIgniteGasoline = true;

	public GameObject[] toActivate;

	public string playerPref;

	private void Start()
	{
		string text = playerPref;
		if (!(text == "SimFir"))
		{
			if (text == "SimExp")
			{
				playerPref = "simpleExplosions";
			}
		}
		else
		{
			playerPref = "simpleFire";
		}
		if (!MonoSingleton<PrefsManager>.Instance.GetBoolLocal(playerPref) && !forceSimple)
		{
			GameObject[] array = toActivate;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: true);
				}
			}
		}
		if (tryIgniteGasoline)
		{
			MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position);
		}
	}
}



public class ExplosiveFish : MonoBehaviour
{
	private Rigidbody rb;

	private bool activated;

	private TimeSince timeSinceActivated;

	[SerializeField]
	private GameObject fire;

	[SerializeField]
	private GameObject explosion;

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (!rb.isKinematic)
		{
			if (!activated)
			{
				timeSinceActivated = 0f;
			}
			activated = true;
			fire.SetActive(value: true);
			if ((float)timeSinceActivated > 3f)
			{
				Object.Instantiate(explosion, base.transform.position, Quaternion.identity);
				Object.Destroy(base.gameObject);
			}
		}
	}
}



public class FadeOut : MonoBehaviour
{
	public bool fadeIn;

	public bool distance;

	private List<float> origVol = new List<float>();

	public AudioSource[] auds;

	private bool fading;

	public float speed;

	public float maxDistance;

	public bool activateOnEnable;

	public bool dontStopOnZero;

	private GameObject player;

	public bool fadeEvenIfNotPlaying;

	private void Start()
	{
		if (auds == null || auds.Length == 0)
		{
			auds = GetComponents<AudioSource>();
		}
		if (fadeIn)
		{
			AudioSource[] array = auds;
			foreach (AudioSource audioSource in array)
			{
				origVol.Add(audioSource.volume);
				audioSource.volume = 0f;
			}
		}
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		if (activateOnEnable)
		{
			BeginFade();
		}
	}

	private void Update()
	{
		if (fading)
		{
			if (fadeIn)
			{
				for (int i = 0; i < auds.Length; i++)
				{
					if (auds[i].isPlaying)
					{
						if (auds[i].volume == origVol[i])
						{
							fading = false;
						}
						else
						{
							auds[i].volume = Mathf.MoveTowards(auds[i].volume, origVol[i], Time.deltaTime * speed);
						}
					}
				}
				return;
			}
			AudioSource[] array = auds;
			foreach (AudioSource audioSource in array)
			{
				if (!audioSource.isPlaying && !fadeEvenIfNotPlaying)
				{
					continue;
				}
				if (audioSource.volume <= 0f)
				{
					if (!dontStopOnZero)
					{
						audioSource.Stop();
					}
					else
					{
						fading = false;
					}
				}
				else
				{
					audioSource.volume -= Time.deltaTime * speed;
				}
			}
		}
		else
		{
			if (!distance)
			{
				return;
			}
			if (fadeIn)
			{
				for (int k = 0; k < auds.Length; k++)
				{
					if (Vector3.Distance(base.transform.position, player.transform.position) > maxDistance)
					{
						auds[k].volume = 0f;
					}
					else
					{
						auds[k].volume = Mathf.Pow((Mathf.Sqrt(maxDistance) - Mathf.Sqrt(Vector3.Distance(base.transform.position, player.transform.position))) / Mathf.Sqrt(maxDistance), 2f) * origVol[k];
					}
				}
			}
			else
			{
				for (int l = 0; l < auds.Length; l++)
				{
					auds[l].volume = Vector3.Distance(base.transform.position, player.transform.position) / maxDistance * origVol[l];
				}
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			BeginFade();
		}
	}

	public void BeginFade()
	{
		fading = true;
		AudioSource[] array = auds;
		for (int i = 0; i < array.Length; i++)
		{
			GetMusicVolume component = array[i].GetComponent<GetMusicVolume>();
			if ((bool)component)
			{
				Object.Destroy(component);
			}
		}
	}
}



public class FadeOutBars : MonoBehaviour
{
	private bool fadeOut;

	public float fadeOutTime;

	private SliderToFillAmount[] slids;

	private void Start()
	{
		CheckState();
		slids = GetComponentsInChildren<SliderToFillAmount>();
		SliderToFillAmount[] array = slids;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].mama = this;
		}
	}

	private void Update()
	{
		if (fadeOut)
		{
			fadeOutTime = Mathf.MoveTowards(fadeOutTime, 0f, Time.unscaledDeltaTime);
		}
	}

	public void CheckState()
	{
		fadeOut = MonoSingleton<PrefsManager>.Instance.GetBool("crossHairHudFade");
		ResetTimer();
	}

	public void ResetTimer()
	{
		bool flag = MonoSingleton<PrefsManager>.Instance.GetInt("crossHairHud") == 0;
		if (!flag && HideUI.Active)
		{
			flag = true;
		}
		fadeOutTime = ((!flag) ? 2 : 0);
	}
}


public enum FadeType
{
	Sprite,
	Line,
	Light,
	Renderer
}



public class FakeDirectoryTree<T> : IDirectoryTree<T>, IDirectoryTree
{
	public string name { get; private set; }

	public IEnumerable<IDirectoryTree<T>> children { get; private set; }

	public IEnumerable<T> files { get; private set; }

	public IDirectoryTree<T> parent { get; set; }

	public FakeDirectoryTree(string name, IEnumerable<T> files = null, IEnumerable<IDirectoryTree<T>> children = null, IDirectoryTree<T> parent = null)
	{
		this.name = name;
		this.children = children ?? new List<IDirectoryTree<T>>();
		this.files = files ?? new List<T>();
		this.parent = parent;
	}

	public FakeDirectoryTree(string name, List<T> files = null, List<FakeDirectoryTree<T>> children = null, IDirectoryTree<T> parent = null)
	{
		this.name = name;
		this.children = children ?? new List<FakeDirectoryTree<T>>();
		this.files = files ?? new List<T>();
		this.parent = parent;
		foreach (IDirectoryTree<T> child in this.children)
		{
			child.parent = this;
		}
	}

	public void Refresh()
	{
	}

	public IEnumerable<T> GetFilesRecursive()
	{
		return children.SelectMany((IDirectoryTree<T> child) => child.GetFilesRecursive()).Concat(files);
	}
}



public class FakeMassActivator : MonoBehaviour
{
	private void OnEnable()
	{
		StatueIntroChecker instance = MonoSingleton<StatueIntroChecker>.Instance;
		base.transform.parent.GetComponentInChildren<MassAnimationReceiver>().GetComponent<Animator>().speed = 1f;
		if (instance != null && instance.beenSeen)
		{
			base.transform.parent.GetComponentInChildren<MassAnimationReceiver>().GetComponent<Animator>().Play("Intro", 0, 0.715f);
		}
		if (instance != null)
		{
			instance.beenSeen = true;
		}
	}
}



public class FakeRoomActivator : MonoBehaviour
{
	public GameObject fake;

	private void OnEnable()
	{
		fake.SetActive(value: false);
	}

	private void OnDisable()
	{
		if ((bool)fake)
		{
			fake.SetActive(value: true);
		}
	}
}



public class Ferryman : MonoBehaviour, IHitTargetCallback
{
	private Animator anim;

	private Machine mach;

	private NavMeshAgent nma;

	private Rigidbody rb;

	private GroundCheckEnemy gce;

	private EnemyIdentifier eid;

	private NavMeshPath path;

	private int difficulty = -1;

	private bool inAction;

	private bool tracking;

	private bool moving;

	private float movingSpeed;

	private bool uppercutting;

	private Vector3 playerPos;

	private bool playerApproaching;

	private bool playerRetreating;

	private bool playerAbove;

	private bool playerBelow;

	private float overheadChance = 0.5f;

	private float stingerChance = 0.5f;

	private float kickComboChance = 0.5f;

	[HideInInspector]
	public float defaultMovementSpeed;

	[SerializeField]
	private GameObject parryableFlash;

	[SerializeField]
	private GameObject unparryableFlash;

	[SerializeField]
	private Transform head;

	[SerializeField]
	private GameObject slamExplosion;

	[SerializeField]
	private GameObject lightningBoltWindup;

	[HideInInspector]
	public GameObject currentWindup;

	[SerializeField]
	private LightningStrikeExplosive lightningBolt;

	[SerializeField]
	private AudioSource lightningBoltChimes;

	[SerializeField]
	private EnemySimplifier oarSimplifier;

	private Material originalOar;

	[SerializeField]
	private Material chargedOar;

	[Header("SwingChecks")]
	[SerializeField]
	private SwingCheck2 mainSwingCheck;

	[SerializeField]
	private SwingCheck2 oarSwingCheck;

	[SerializeField]
	private SwingCheck2 kickSwingCheck;

	private SwingCheck2[] swingChecks;

	[SerializeField]
	private AudioSource swingAudioSource;

	[SerializeField]
	private AudioClip[] swingSounds;

	private bool useMain;

	private bool useOar;

	private bool useKick;

	private bool knockBack;

	[Header("Trails")]
	[SerializeField]
	private TrailRenderer frontTrail;

	[SerializeField]
	private TrailRenderer backTrail;

	[SerializeField]
	private TrailRenderer bodyTrail;

	private bool backTrailActive;

	[Header("Footsteps")]
	[SerializeField]
	private ParticleSystem[] footstepParticles;

	[SerializeField]
	private AudioSource footstepAudio;

	private float rollCooldown;

	private float vaultCooldown;

	[Header("Boss Version")]
	[SerializeField]
	private bool bossVersion;

	[SerializeField]
	private float phaseChangeHealth;

	[SerializeField]
	private Transform[] phaseChangePositions;

	private int currentPosition;

	[SerializeField]
	private UltrakillEvent onPhaseChange;

	private bool inPhaseChange;

	private bool hasPhaseChanged;

	private bool hasReachedFinalPosition;

	private bool jumping;

	private float lightningBoltCooldown = 1.5f;

	private float lightningOutOfReachCharge;

	private bool lightningCancellable;

	private Vector3 lastGroundedPosition;

	private void Start()
	{
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		gce = GetComponentInChildren<GroundCheckEnemy>();
		path = new NavMeshPath();
		swingChecks = GetComponentsInChildren<SwingCheck2>();
		if ((bool)oarSimplifier)
		{
			originalOar = oarSimplifier.originalMaterial;
		}
		SetSpeed();
		SlowUpdate();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (!nma)
		{
			nma = GetComponent<NavMeshAgent>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 2)
		{
			anim.speed = 0.9f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.8f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.6f;
		}
		else
		{
			anim.speed = 1f;
		}
		if (defaultMovementSpeed == 0f)
		{
			defaultMovementSpeed = nma.speed;
		}
		anim.speed *= eid.totalSpeedModifier;
		nma.speed = defaultMovementSpeed * eid.totalSpeedModifier;
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded && (bool)currentWindup)
		{
			currentWindup.SetActive(value: false);
		}
		inAction = false;
		tracking = false;
		moving = false;
		uppercutting = false;
		MonoSingleton<EnemyCooldowns>.Instance.RemoveFerryman(this);
		StopDamage();
	}

	private void OnEnable()
	{
		MonoSingleton<EnemyCooldowns>.Instance.AddFerryman(this);
		if ((bool)currentWindup)
		{
			currentWindup.SetActive(value: true);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.1f);
		if (!nma || (!lightningCancellable && !nma.isOnNavMesh) || eid.target == null)
		{
			return;
		}
		bool flag = false;
		if (inPhaseChange)
		{
			if (!inAction && nma.isOnNavMesh)
			{
				nma.SetDestination(phaseChangePositions[currentPosition].position);
			}
			return;
		}
		if (!inAction || lightningCancellable)
		{
			if ((!eid.target.isOnGround || !NavMesh.CalculatePath(base.transform.position, PredictPlayerPos(vertical: true), nma.areaMask, path)) && Physics.Raycast(eid.target.position, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
			{
				if (NavMesh.SamplePosition(hitInfo.point, out var hit, 1f, nma.areaMask))
				{
					NavMesh.CalculatePath(base.transform.position, hit.position, nma.areaMask, path);
				}
				else
				{
					NavMesh.CalculatePath(base.transform.position, hitInfo.point, nma.areaMask, path);
					flag = true;
				}
			}
			if (!inAction && nma.isOnNavMesh)
			{
				nma.path = path;
			}
		}
		if (eid.target.position.y > base.transform.position.y + 20f || (path.status != 0 && path.corners != null && path.corners.Length != 0 && (!eid.target.isOnGround || Vector3.Distance(path.corners[path.corners.Length - 1], PredictPlayerPos(vertical: true)) > 5f)))
		{
			flag = true;
		}
		else if (inAction && lightningCancellable)
		{
			CancelLightningBolt();
		}
		if (flag && difficulty >= 2)
		{
			lightningOutOfReachCharge += 0.1f * eid.totalSpeedModifier;
			if (!inAction && lightningOutOfReachCharge > 3f && MonoSingleton<EnemyCooldowns>.Instance.ferrymanCooldown <= 0f && eid.zapperer == null)
			{
				lightningOutOfReachCharge = 0f;
				LightningBolt(quick: true);
			}
		}
		else
		{
			lightningOutOfReachCharge = 0f;
		}
	}

	private void Update()
	{
		if (eid.target == null)
		{
			return;
		}
		PlayerStatus();
		anim.SetBool("Falling", !gce.onGround);
		if (mach.health < phaseChangeHealth && bossVersion && !hasPhaseChanged)
		{
			PhaseChange();
		}
		if (lightningBoltCooldown > 0f)
		{
			lightningBoltCooldown = Mathf.MoveTowards(lightningBoltCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier * (inPhaseChange ? 1f : 0.4f));
		}
		if (inPhaseChange && !inAction && eid.target != null)
		{
			if (Vector3.Distance(base.transform.position, phaseChangePositions[currentPosition].position) < 3.5f)
			{
				if (currentPosition < phaseChangePositions.Length - 1)
				{
					currentPosition++;
					nma.destination = phaseChangePositions[currentPosition].position;
					return;
				}
				if (!hasReachedFinalPosition)
				{
					base.transform.position = phaseChangePositions[phaseChangePositions.Length - 1].position;
					rb.isKinematic = true;
					rb.useGravity = false;
					hasReachedFinalPosition = true;
				}
				anim.SetBool("Running", value: false);
				if (!inAction && lightningBoltCooldown <= 0f && eid.zapperer == null)
				{
					LightningBolt();
				}
				if (!inAction)
				{
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(playerPos - base.transform.position), Time.deltaTime * 600f * eid.totalSpeedModifier);
				}
			}
			else if (!nma || !nma.enabled || !nma.isOnNavMesh || !gce.onGround)
			{
				anim.SetBool("Falling", value: true);
				anim.SetBool("Running", value: true);
				rb.isKinematic = false;
				rb.useGravity = true;
				Vector3 vector = new Vector3(phaseChangePositions[currentPosition].position.x, base.transform.position.y, phaseChangePositions[currentPosition].position.z);
				base.transform.position = Vector3.MoveTowards(base.transform.position, vector, Time.deltaTime * Mathf.Max(10f, Vector3.Distance(base.transform.position, vector) * eid.totalSpeedModifier));
			}
			else if (nma.pathStatus != 0 && !jumping)
			{
				anim.SetBool("Falling", value: true);
				anim.SetBool("Running", value: true);
				rb.isKinematic = false;
				rb.useGravity = true;
				nma.enabled = false;
				ParticleSystem[] array = footstepParticles;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Play();
				}
				Footstep();
				base.transform.position += Vector3.up * 5f;
				rb.AddForce(Vector3.up * Mathf.Abs(base.transform.position.y - phaseChangePositions[currentPosition].position.y) * 2f, ForceMode.VelocityChange);
				jumping = true;
				base.transform.rotation = Quaternion.LookRotation(new Vector3(phaseChangePositions[currentPosition].position.x, base.transform.position.y, phaseChangePositions[currentPosition].position.z) - base.transform.position);
			}
			else
			{
				nma.enabled = true;
				anim.SetBool("Running", value: true);
			}
			return;
		}
		if ((bool)nma && nma.isOnNavMesh && nma.velocity.magnitude > 2f && gce.onGround)
		{
			anim.SetBool("Running", value: true);
		}
		else
		{
			anim.SetBool("Running", value: false);
		}
		if (!inAction && eid.target != null)
		{
			if (gce.onGround)
			{
				if (difficulty >= 4 && lightningBoltCooldown <= 0f && MonoSingleton<EnemyCooldowns>.Instance.ferrymanCooldown <= 0f && eid.zapperer == null)
				{
					if (Random.Range(0f, 1f) > 0.5f)
					{
						LightningBolt(quick: true);
					}
					else
					{
						lightningBoltCooldown = 0.4f;
					}
				}
				else if (Vector3.Distance(playerPos, base.transform.position) < 8f && (eid.target.position.y > base.transform.position.y + 5f || (eid.target.GetVelocity().y > 5f && !eid.target.isOnGround)))
				{
					if (playerRetreating && rollCooldown <= 0f)
					{
						Roll();
					}
					else if (Vector3.Distance(playerPos, base.transform.position) < 5f && eid.target.position.y < base.transform.position.y + 20f)
					{
						Uppercut();
					}
				}
				else if (Vector3.Distance(eid.target.position, base.transform.position) > 8f || (playerRetreating && MonoSingleton<NewMovement>.Instance.sliding))
				{
					if (vaultCooldown <= 0f && Vector3.Distance(eid.target.position, base.transform.position) < 35f && Vector3.Distance(eid.target.position, base.transform.position) > 30f && !playerApproaching && eid.target.position.y <= base.transform.position.y + 20f)
					{
						vaultCooldown = 2f;
						if (difficulty >= 3)
						{
							VaultSwing();
						}
						else
						{
							Vault();
						}
					}
					else if (Vector3.Distance(eid.target.position, base.transform.position) < 14f && playerRetreating && !playerAbove)
					{
						if (Random.Range(0f, 1f) < stingerChance || rollCooldown > 0f)
						{
							stingerChance = Mathf.Min(0.25f, stingerChance - 0.25f);
							Stinger();
						}
						else
						{
							stingerChance = Mathf.Max(0.75f, stingerChance + 0.25f);
							Roll();
						}
					}
				}
				else if (playerApproaching)
				{
					if (Random.Range(0f, 1f) < 0.25f)
					{
						if (Random.Range(0f, 1f) < 0.75f && rollCooldown <= 0f)
						{
							Roll(toPlayerSide: true);
						}
						else if (Random.Range(0f, 1f) < 0.5f)
						{
							KickCombo();
						}
						else
						{
							OarCombo();
						}
					}
					else if (Random.Range(0f, 1f) < overheadChance)
					{
						overheadChance = Mathf.Min(0.25f, overheadChance - 0.25f);
						Downslam();
					}
					else
					{
						overheadChance = Mathf.Max(0.75f, overheadChance + 0.25f);
						BackstepAttack();
					}
				}
				else if (Random.Range(0f, 1f) < kickComboChance)
				{
					kickComboChance = Mathf.Min(0.25f, kickComboChance - 0.25f);
					KickCombo();
				}
				else
				{
					kickComboChance = Mathf.Max(0.75f, kickComboChance + 0.25f);
					OarCombo();
				}
			}
		}
		else
		{
			nma.enabled = false;
			if (tracking && eid.target != null)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(PredictPlayerPos() - base.transform.position), Time.deltaTime * 600f * eid.totalSpeedModifier);
			}
			if (moving)
			{
				if (Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward, Vector3.down, out var _, Mathf.Max(22f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
				{
					rb.velocity = base.transform.forward * movingSpeed * anim.speed;
				}
				else
				{
					rb.velocity = Vector3.zero;
				}
			}
			if (uppercutting)
			{
				Vector3 velocity = Vector3.up * 100f * anim.speed;
				if (Vector3.Distance(base.transform.position, playerPos) > 5f)
				{
					velocity += base.transform.forward * Mathf.Min(100f, Vector3.Distance(base.transform.position, playerPos) * 40f) * anim.speed;
				}
				if (Physics.Raycast(lastGroundedPosition + Vector3.up + base.transform.forward, Vector3.down, out var _, Mathf.Max(22f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
				{
					rb.velocity = velocity;
				}
				else
				{
					rb.velocity = Vector3.up * 100f * anim.speed;
				}
			}
		}
		if (rollCooldown > 0f)
		{
			rollCooldown = Mathf.MoveTowards(rollCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (vaultCooldown > 0f)
		{
			vaultCooldown = Mathf.MoveTowards(vaultCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
	}

	private void FixedUpdate()
	{
		if (gce.onGround && !moving && !uppercutting && !jumping)
		{
			nma.enabled = !inAction;
			rb.useGravity = false;
			rb.isKinematic = true;
		}
		else if (!gce.onGround && !inAction)
		{
			rb.useGravity = true;
			rb.isKinematic = false;
			nma.enabled = false;
			jumping = false;
			if ((bool)rb)
			{
				rb.AddForce(Vector3.down * 20f * Time.fixedDeltaTime, ForceMode.VelocityChange);
			}
		}
		if (gce.onGround)
		{
			lastGroundedPosition = base.transform.position;
		}
	}

	private void Downslam()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("Downslam");
		backTrailActive = false;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	private void BackstepAttack()
	{
		SnapToGround();
		inAction = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("BackstepAttack");
		backTrailActive = true;
		StartMoving(-3.5f);
		knockBack = true;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	private void Stinger()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("Stinger");
		backTrailActive = true;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	private void Vault()
	{
		SnapToGround();
		bodyTrail.emitting = true;
		inAction = true;
		tracking = true;
		StartMoving(0.5f);
		anim.SetTrigger("Vault");
		backTrailActive = false;
		useMain = false;
		useOar = false;
		useKick = true;
	}

	private void VaultSwing()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		StartMoving(0.5f);
		anim.SetTrigger("VaultSwing");
		backTrailActive = true;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	private void KickCombo()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("KickCombo");
		useMain = true;
		useOar = false;
		useKick = true;
	}

	private void OarCombo()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("OarCombo");
		backTrailActive = true;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	private void Uppercut()
	{
		SnapToGround();
		inAction = true;
		tracking = true;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		anim.SetTrigger("Uppercut");
		backTrailActive = true;
		useMain = true;
		useOar = true;
		useKick = false;
	}

	public void Roll(bool toPlayerSide = false)
	{
		SnapToGround();
		inAction = true;
		tracking = false;
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		nma.enabled = false;
		anim.SetTrigger("Roll");
		bodyTrail.emitting = true;
		if (!toPlayerSide)
		{
			base.transform.rotation = Quaternion.LookRotation(PredictPlayerPos(vertical: false, 20f) - base.transform.position);
		}
		else
		{
			float num = 5f;
			if (Random.Range(0f, 1f) > 0.5f)
			{
				num = -5f;
			}
			base.transform.rotation = Quaternion.LookRotation(playerPos + MonoSingleton<CameraController>.Instance.transform.right * num - base.transform.position);
		}
		StartMoving(5f);
		if (difficulty < 3)
		{
			rollCooldown = 5.5f - (float)(difficulty * 2);
		}
	}

	public void LightningBolt(bool quick = false)
	{
		MonoSingleton<EnemyCooldowns>.Instance.ferrymanCooldown += 6f;
		inAction = true;
		lightningBoltCooldown = 8 - difficulty * 2;
		if (quick && difficulty >= 4 && lightningBoltCooldown < 3f)
		{
			lightningBoltCooldown = 3f;
		}
		tracking = true;
		if (quick && difficulty >= 4)
		{
			anim.SetTrigger("QuickLightningBolt");
			return;
		}
		anim.SetTrigger("LightningBolt");
		lightningCancellable = true;
	}

	public void LightningBoltWindup(int quick = 0)
	{
		if (eid.dead)
		{
			return;
		}
		if (eid.zapperer != null)
		{
			GotParried();
			return;
		}
		if ((bool)currentWindup)
		{
			Object.Destroy(currentWindup);
		}
		if ((bool)oarSimplifier)
		{
			oarSimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, chargedOar);
		}
		currentWindup = Object.Instantiate(lightningBoltWindup, PredictPlayerPos(), Quaternion.identity);
		Follow[] components;
		if (eid.target != null)
		{
			components = currentWindup.GetComponents<Follow>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].target = eid.target.targetTransform;
			}
		}
		if ((bool)base.transform.parent)
		{
			currentWindup.transform.SetParent(base.transform.parent, worldPositionStays: true);
		}
		components = currentWindup.GetComponents<Follow>();
		foreach (Follow follow in components)
		{
			if (follow.speed != 0f)
			{
				if (difficulty >= 3)
				{
					follow.speed *= 3f;
				}
				else if (difficulty == 2)
				{
					follow.speed *= 2f;
				}
				else if (difficulty == 1)
				{
					follow.speed /= 2f;
				}
				else
				{
					follow.enabled = false;
				}
				follow.speed *= eid.totalSpeedModifier;
			}
		}
		tracking = false;
		lightningBoltChimes.Play();
		if (quick == 1)
		{
			if (currentWindup.TryGetComponent<ObjectActivator>(out var component))
			{
				component.delay = 3f;
			}
			Invoke("LightningBoltWindupOver", 5f);
		}
	}

	public void LightningBoltWindupOver()
	{
		if ((bool)currentWindup)
		{
			GameObject obj = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, currentWindup.transform.position + Vector3.up * 50f, Quaternion.LookRotation(Vector3.down));
			obj.transform.localScale *= 100f;
			obj.transform.SetParent(currentWindup.transform, worldPositionStays: true);
			Invoke("LightningBoltStrike", 0.5f);
		}
	}

	public void LightningBoltStrike()
	{
		SpawnLightningBolt(currentWindup.transform.position);
		Object.Destroy(currentWindup);
		lightningCancellable = false;
	}

	public void SpawnLightningBolt(Vector3 position, bool safeForPlayer = false)
	{
		if ((bool)oarSimplifier)
		{
			oarSimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, originalOar);
		}
		LightningStrikeExplosive lightningStrikeExplosive = Object.Instantiate(lightningBolt, position, Quaternion.identity);
		lightningStrikeExplosive.safeForPlayer = safeForPlayer;
		lightningStrikeExplosive.damageMultiplier = eid.totalDamageModifier;
		if ((bool)base.transform.parent)
		{
			lightningStrikeExplosive.transform.SetParent(base.transform.parent, worldPositionStays: true);
		}
	}

	public void CancelLightningBolt()
	{
		if ((bool)oarSimplifier)
		{
			oarSimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, originalOar);
		}
		if ((bool)currentWindup)
		{
			Object.Destroy(currentWindup);
		}
		lightningCancellable = false;
		anim.Play("Idle");
		StopAction();
	}

	public void OnDeath()
	{
		if ((bool)oarSimplifier)
		{
			oarSimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, originalOar);
		}
		Object.Destroy(this);
	}

	private void StartTracking()
	{
		tracking = true;
	}

	private void StopTracking()
	{
		tracking = false;
	}

	private void StartMoving(float speed)
	{
		movingSpeed = speed * 10f;
		moving = true;
		rb.isKinematic = false;
		ParticleSystem[] array = footstepParticles;
		foreach (ParticleSystem particleSystem in array)
		{
			if (Mathf.Abs(particleSystem.transform.position.y - base.transform.position.y) < 1f)
			{
				particleSystem.Play();
			}
		}
		Footstep(0.75f);
	}

	private void StopMoving()
	{
		bodyTrail.emitting = false;
		moving = false;
		rb.isKinematic = true;
		ParticleSystem[] array = footstepParticles;
		foreach (ParticleSystem particleSystem in array)
		{
			if (Mathf.Abs(particleSystem.transform.position.y - base.transform.position.y) < 1f)
			{
				particleSystem.Play();
			}
		}
		Footstep(0.75f);
	}

	public void SlamHit()
	{
		Object.Instantiate(slamExplosion, new Vector3(frontTrail.transform.position.x, base.transform.position.y, frontTrail.transform.position.z), Quaternion.identity);
		ParticleSystem[] array = footstepParticles;
		foreach (ParticleSystem particleSystem in array)
		{
			if (Mathf.Abs(particleSystem.transform.position.y - base.transform.position.y) < 1f)
			{
				particleSystem.Play();
			}
		}
		Footstep(0.75f);
	}

	private void Footstep(float volume = 0.5f)
	{
		if (volume == 0f)
		{
			volume = 0.5f;
		}
		footstepAudio.volume = volume;
		footstepAudio.pitch = Random.Range(1.15f, 1.35f);
		footstepAudio.Play();
	}

	private void StartUppercut()
	{
		uppercutting = true;
		rb.isKinematic = false;
		StartDamage();
	}

	private void StopUppercut()
	{
		uppercutting = false;
		rb.useGravity = true;
		rb.velocity = Vector3.up * 10f;
		StopDamage();
	}

	private void StartDamage(int damage = 25)
	{
		if (damage == 0)
		{
			damage = 25;
		}
		SwingCheck2[] array = swingChecks;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].damage = damage;
		}
		if (useMain)
		{
			mainSwingCheck.DamageStart();
		}
		if (useOar)
		{
			oarSwingCheck.DamageStart();
		}
		if (useKick)
		{
			kickSwingCheck.DamageStart();
		}
		if (useOar)
		{
			swingAudioSource.pitch = Random.Range(0.65f, 0.9f);
			swingAudioSource.volume = 1f;
		}
		else if (useKick)
		{
			swingAudioSource.pitch = Random.Range(2.1f, 2.55f);
			swingAudioSource.volume = 0.75f;
		}
		swingAudioSource.clip = swingSounds[Random.Range(0, swingSounds.Length)];
		swingAudioSource.Play();
		if (useMain || useOar)
		{
			frontTrail.emitting = true;
		}
		if (backTrailActive)
		{
			backTrail.emitting = true;
		}
	}

	private void StopDamage()
	{
		if (swingChecks != null)
		{
			SwingCheck2[] array = swingChecks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			knockBack = false;
			frontTrail.emitting = false;
			backTrail.emitting = false;
			mach.parryable = false;
		}
	}

	public void TargetBeenHit()
	{
		if (eid.target != null && eid.target.isPlayer && knockBack)
		{
			MonoSingleton<NewMovement>.Instance.Launch((playerPos - base.transform.position).normalized * 2500f + Vector3.up * 250f);
		}
		SwingCheck2[] array = swingChecks;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStop();
		}
	}

	private void StopAction()
	{
		if (moving)
		{
			StopMoving();
		}
		inAction = false;
		nma.enabled = true;
		tracking = false;
		if (bodyTrail.emitting)
		{
			bodyTrail.emitting = false;
		}
	}

	public void ParryableFlash()
	{
		Object.Instantiate(parryableFlash, head.position + (MonoSingleton<CameraController>.Instance.defaultPos - head.position).normalized, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.defaultPos - head.position), head).transform.localScale *= 0.025f;
		mach.ParryableCheck();
	}

	public void UnparryableFlash()
	{
		Object.Instantiate(unparryableFlash, head.position + (MonoSingleton<CameraController>.Instance.defaultPos - head.position).normalized, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.defaultPos - head.position), head).transform.localScale *= 0.025f;
	}

	public void GotParried()
	{
		SpawnLightningBolt(mach.chest.transform.position, safeForPlayer: true);
		eid.hitter = "";
		eid.hitterAttributes.Add(HitterAttribute.Electricity);
		eid.DeliverDamage(base.gameObject, Vector3.zero, base.transform.position, 1E-05f, tryForExplode: false);
		if (currentWindup != null)
		{
			if ((bool)oarSimplifier)
			{
				oarSimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, originalOar);
			}
			Object.Destroy(currentWindup);
		}
	}

	private void PlayerStatus()
	{
		playerPos = new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z);
		playerAbove = eid.target.position.y > base.transform.position.y + 3f;
		playerBelow = eid.target.position.y < base.transform.position.y - 4f;
		Vector3 vector = new Vector3(eid.target.GetVelocity().x, 0f, eid.target.GetVelocity().z);
		if (vector.magnitude < 1f)
		{
			playerApproaching = false;
			playerRetreating = false;
		}
		else
		{
			float num = Mathf.Abs(Vector3.Angle(vector.normalized, playerPos - base.transform.position));
			playerRetreating = num < 80f;
			playerApproaching = num > 135f;
		}
	}

	private Vector3 PredictPlayerPos(bool vertical = false, float maxPrediction = 5f)
	{
		if (eid.target == null)
		{
			return base.transform.position + base.transform.forward;
		}
		if (vertical)
		{
			if (difficulty <= 1)
			{
				return eid.target.position;
			}
			Vector3 vector = Vector3.zero;
			if (eid.target != null && eid.target.isPlayer)
			{
				vector = ((MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer) ? Vector3.down : Vector3.zero);
			}
			return eid.target.position + eid.target.GetVelocity().normalized * Mathf.Min(eid.target.GetVelocity().magnitude, 5f) + vector;
		}
		if (difficulty <= 1)
		{
			return playerPos;
		}
		Vector3 vector2 = new Vector3(eid.target.GetVelocity().x, 0f, eid.target.GetVelocity().z);
		return playerPos + vector2.normalized * Mathf.Min(vector2.magnitude, maxPrediction);
	}

	private void SnapToGround()
	{
		if (!nma.isOnNavMesh && gce.onGround && Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, 2f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			base.transform.position = hitInfo.point;
		}
		base.transform.rotation = Quaternion.LookRotation(playerPos - base.transform.position);
	}

	public void PhaseChange()
	{
		inPhaseChange = true;
		onPhaseChange.Invoke();
	}

	public void EndPhaseChange()
	{
		inPhaseChange = false;
		hasPhaseChanged = true;
		if (!hasReachedFinalPosition)
		{
			base.transform.position = phaseChangePositions[phaseChangePositions.Length - 1].position;
		}
	}
}



public class FerrymanFake : MonoBehaviour
{
	private bool activated;

	private bool trackPlayer;

	private bool jumping;

	private Quaternion originalRotation;

	public UltrakillEvent onCoinBlow;

	public GameObject realFerryman;

	private Rigidbody rb;

	public void CoinCatch()
	{
		originalRotation = base.transform.rotation;
		GetComponent<Animator>().SetTrigger("CatchCoin");
		trackPlayer = true;
		activated = true;
	}

	private void Update()
	{
		if (trackPlayer)
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(new Vector3(MonoSingleton<NewMovement>.Instance.transform.position.x, base.transform.position.y, MonoSingleton<NewMovement>.Instance.transform.position.z) - base.transform.position), Time.deltaTime * 1200f);
		}
		else if (activated)
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, originalRotation, Time.deltaTime * 10f * Mathf.Max(Mathf.Min(Quaternion.Angle(base.transform.rotation, originalRotation), 20f), 0.01f));
		}
		if (jumping)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, new Vector3(realFerryman.transform.position.x, base.transform.position.y, realFerryman.transform.position.z), Time.deltaTime * 10f);
			if (base.transform.position.y < realFerryman.transform.position.y + 1f)
			{
				OnLand();
			}
		}
	}

	private void FixedUpdate()
	{
		if (jumping)
		{
			rb.AddForce(Vector3.down * 9.81f * Time.fixedDeltaTime, ForceMode.VelocityChange);
		}
	}

	public void ReturnToRotation()
	{
		trackPlayer = false;
	}

	public void BlowCoin()
	{
		onCoinBlow.Invoke();
	}

	public void StartFight()
	{
		if (TryGetComponent<Animator>(out var component))
		{
			component.SetTrigger("Jump");
			GetComponent<Collider>().enabled = false;
			rb = GetComponent<Rigidbody>();
			if ((bool)rb)
			{
				rb.isKinematic = false;
				rb.useGravity = true;
				rb.AddForce(base.transform.up * 25f, ForceMode.VelocityChange);
			}
			jumping = true;
		}
	}

	public void OnLand()
	{
		realFerryman.SetActive(value: true);
		Object.Destroy(base.gameObject);
	}
}



public class FileDirectoryTree : IDirectoryTree<FileInfo>, IDirectoryTree
{
	public string name { get; private set; }

	public DirectoryInfo realDirectory { get; private set; }

	public IDirectoryTree<FileInfo> parent { get; set; }

	public IEnumerable<IDirectoryTree<FileInfo>> children { get; private set; }

	public IEnumerable<FileInfo> files { get; private set; }

	public FileDirectoryTree(string path, IDirectoryTree<FileInfo> parent = null)
	{
		realDirectory = new DirectoryInfo(path);
		this.parent = parent;
		Refresh();
	}

	public FileDirectoryTree(DirectoryInfo realDirectory, IDirectoryTree<FileInfo> parent = null)
	{
		this.realDirectory = realDirectory;
		this.parent = parent;
		Refresh();
	}

	public void Refresh()
	{
		realDirectory.Create();
		name = realDirectory.Name;
		children = from dir in realDirectory.GetDirectories()
			select new FileDirectoryTree(dir, this);
		files = realDirectory.GetFiles();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || GetType() != obj.GetType())
		{
			return false;
		}
		return realDirectory.FullName.ToUpperInvariant() == (obj as DirectoryInfo).FullName.ToUpperInvariant();
	}

	public override int GetHashCode()
	{
		return realDirectory.GetHashCode();
	}

	public IEnumerable<FileInfo> GetFilesRecursive()
	{
		return children.SelectMany((IDirectoryTree<FileInfo> child) => child.GetFilesRecursive()).Concat(files);
	}
}



public class FinalCyberRank : MonoBehaviour
{
	public TMP_Text waveText;

	public TMP_Text killsText;

	public TMP_Text styleText;

	public TMP_Text timeText;

	public TMP_Text bestWaveText;

	public TMP_Text bestKillsText;

	public TMP_Text bestStyleText;

	public TMP_Text bestTimeText;

	public TMP_Text pointsText;

	public int totalPoints;

	public GameObject[] toAppear;

	private bool skipping;

	private float timeBetween = 0.25f;

	private bool countTime;

	public float savedTime;

	private float checkedSeconds;

	private float seconds;

	private float minutes;

	private bool countWaves;

	public float savedWaves;

	private float checkedWaves;

	private bool countKills;

	public int savedKills;

	private float checkedKills;

	private bool countStyle;

	public int savedStyle;

	private float checkedStyle;

	private bool flashFade;

	private UnityEngine.Color flashColor;

	private UnityEngine.UI.Image flashPanel;

	private int i;

	private bool gameOver;

	private bool complete;

	private CyberRankData previousBest;

	private bool newBest;

	private TimeController timeController;

	private OptionsManager opm;

	private bool wasPaused;

	private StatsManager sman;

	private bool highScoresDisplayed;

	[SerializeField]
	private GameObject[] previousElements;

	[SerializeField]
	private GameObject highScoreElement;

	[SerializeField]
	private GameObject friendContainer;

	[SerializeField]
	private GameObject globalContainer;

	[SerializeField]
	private GameObject friendPlaceholder;

	[SerializeField]
	private GameObject globalPlaceholder;

	[SerializeField]
	private GameObject template;

	[SerializeField]
	private TMP_Text tRank;

	[SerializeField]
	private TMP_Text tUsername;

	[SerializeField]
	private TMP_Text tScore;

	[SerializeField]
	private TMP_Text tPercent;

	private void Start()
	{
		sman = MonoSingleton<StatsManager>.Instance;
		GameObject[] array = toAppear;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		MonoSingleton<NewMovement>.Instance.endlessMode = true;
	}

	public void GameOver()
	{
		if (gameOver)
		{
			return;
		}
		if (sman == null)
		{
			sman = MonoSingleton<StatsManager>.Instance;
		}
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		gameOver = true;
		sman.StopTimer();
		sman.HideShit();
		MonoSingleton<TimeController>.Instance.controlTimeScale = false;
		savedTime = sman.seconds;
		savedKills = sman.kills;
		savedStyle = sman.stylePoints;
		if (savedStyle < 0)
		{
			savedStyle = 0;
		}
		ActivateNextWave activateNextWave = Object.FindObjectOfType<ActivateNextWave>();
		savedWaves = (float)MonoSingleton<EndlessGrid>.Instance.currentWave + (float)activateNextWave.deadEnemies / (float)MonoSingleton<EndlessGrid>.Instance.enemyAmount;
		previousBest = GameProgressSaver.GetBestCyber();
		bestWaveText.text = Mathf.FloorToInt(previousBest.preciseWavesByDifficulty[@int]) + $"\n<color=#616161><size=20>{CalculatePerc(previousBest.preciseWavesByDifficulty[@int])}%</size></color>";
		bestKillsText.text = string.Concat(previousBest.kills[@int]);
		bestStyleText.text = string.Concat(previousBest.style[@int]);
		int num = 0;
		float num2;
		for (num2 = previousBest.time[@int]; num2 >= 60f; num2 -= 60f)
		{
			num++;
		}
		bestTimeText.text = num + ":" + num2.ToString("00.000");
		if (sman.majorUsed || MonoSingleton<AssistController>.Instance.cheatsEnabled || MonoSingleton<EndlessGrid>.Instance.customPatternMode)
		{
			return;
		}
		if ((bool)SteamController.Instance && GameStateManager.CanSubmitScores)
		{
			MonoSingleton<LeaderboardController>.Instance.SubmitCyberGrindScore(@int, savedWaves, savedKills, savedStyle, sman.seconds);
		}
		if (savedWaves > previousBest.preciseWavesByDifficulty[@int])
		{
			NewBest();
		}
		else
		{
			if (savedWaves < previousBest.preciseWavesByDifficulty[@int])
			{
				return;
			}
			if (savedKills > previousBest.kills[@int])
			{
				NewBest();
			}
			else if (savedKills >= previousBest.kills[@int])
			{
				if (savedStyle > previousBest.style[@int])
				{
					NewBest();
				}
				else if (savedStyle >= previousBest.style[@int] && savedTime > previousBest.time[@int])
				{
					NewBest();
				}
			}
		}
	}

	private void NewBest()
	{
		GameProgressSaver.SetBestCyber(this);
		newBest = true;
	}

	private void Update()
	{
		if (gameOver)
		{
			if (timeController == null)
			{
				timeController = MonoSingleton<TimeController>.Instance;
			}
			if (timeController.timeScale > 0f)
			{
				timeController.timeScale = Mathf.MoveTowards(timeController.timeScale, 0f, Time.unscaledDeltaTime * (timeController.timeScale + 0.01f));
				Time.timeScale = timeController.timeScale * timeController.timeScaleModifier;
				MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", timeController.timeScale);
				if (timeController.timeScale < 0.1f)
				{
					MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allVolume", MonoSingleton<AudioMixerController>.Instance.CalculateVolume(timeController.timeScale * 10f * MonoSingleton<AudioMixerController>.Instance.sfxVolume));
					MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("allVolume", MonoSingleton<AudioMixerController>.Instance.CalculateVolume(timeController.timeScale * 10f * MonoSingleton<AudioMixerController>.Instance.musicVolume));
				}
				MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("allPitch", timeController.timeScale);
				MonoSingleton<MusicManager>.Instance.volume = 0.5f + timeController.timeScale / 2f;
				if (timeController.timeScale <= 0f)
				{
					Appear();
					MonoSingleton<MusicManager>.Instance.forcedOff = true;
					MonoSingleton<MusicManager>.Instance.StopMusic();
				}
			}
		}
		if (countTime)
		{
			if (savedTime >= checkedSeconds)
			{
				if (savedTime > checkedSeconds)
				{
					float num = savedTime - checkedSeconds;
					checkedSeconds += Time.unscaledDeltaTime * 20f + Time.unscaledDeltaTime * num * 1.5f;
					seconds += Time.unscaledDeltaTime * 20f + Time.unscaledDeltaTime * num * 1.5f;
				}
				if (checkedSeconds >= savedTime || skipping)
				{
					checkedSeconds = savedTime;
					seconds = savedTime;
					minutes = 0f;
					while (seconds >= 60f)
					{
						seconds -= 60f;
						minutes += 1f;
					}
					countTime = false;
					timeText.GetComponent<AudioSource>().Stop();
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
				}
				if (seconds >= 60f)
				{
					seconds -= 60f;
					minutes += 1f;
				}
				timeText.text = minutes + ":" + seconds.ToString("00.000");
			}
		}
		else if (countWaves)
		{
			if (savedWaves >= checkedWaves)
			{
				if (savedWaves > checkedWaves)
				{
					checkedWaves += Time.unscaledDeltaTime * 20f + Time.unscaledDeltaTime * (savedWaves - checkedWaves) * 1.5f;
				}
				if (checkedWaves >= savedWaves || skipping)
				{
					checkedWaves = savedWaves;
					countWaves = false;
					waveText.GetComponent<AudioSource>().Stop();
					totalPoints += Mathf.FloorToInt(savedWaves) * 100;
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
				}
				else
				{
					int num2 = totalPoints + Mathf.RoundToInt(checkedWaves) * 100;
					int num3 = 0;
					while (num2 >= 1000)
					{
						num3++;
						num2 -= 1000;
					}
					if (num3 > 0)
					{
						if (num2 < 10)
						{
							pointsText.text = "+" + num3 + ",00" + num2 + "<color=orange>P</color>";
						}
						else if (num2 < 100)
						{
							pointsText.text = "+" + num3 + ",0" + num2 + "<color=orange>P</color>";
						}
						else
						{
							pointsText.text = "+" + num3 + "," + num2 + "<color=orange>P</color>";
						}
					}
					else
					{
						pointsText.text = "+" + num2 + "<color=orange>P</color>";
					}
				}
				waveText.text = Mathf.FloorToInt(checkedWaves) + $"\n<color=#616161><size=20>{CalculatePerc(savedWaves)}%</size></color>";
			}
		}
		else if (countKills)
		{
			if ((float)savedKills >= checkedKills)
			{
				if ((float)savedKills > checkedKills)
				{
					checkedKills += Time.unscaledDeltaTime * 20f + Time.unscaledDeltaTime * ((float)savedKills - checkedKills) * 1.5f;
				}
				if (checkedKills >= (float)savedKills || skipping)
				{
					checkedKills = savedKills;
					countKills = false;
					killsText.GetComponent<AudioSource>().Stop();
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
				}
				killsText.text = checkedKills.ToString("0");
			}
		}
		else if (countStyle && (float)savedStyle >= checkedStyle)
		{
			_ = checkedStyle;
			if ((float)savedStyle > checkedStyle)
			{
				checkedStyle += Time.unscaledDeltaTime * 2500f + Time.unscaledDeltaTime * ((float)savedStyle - checkedStyle) * 1.5f;
			}
			if (checkedStyle >= (float)savedStyle || skipping)
			{
				checkedStyle = savedStyle;
				countStyle = false;
				styleText.GetComponent<AudioSource>().Stop();
				StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
				totalPoints += savedStyle;
				PointsShow();
			}
			else
			{
				int num4 = totalPoints + Mathf.RoundToInt(checkedStyle);
				int num5 = 0;
				while (num4 >= 1000)
				{
					num5++;
					num4 -= 1000;
				}
				if (num5 > 0)
				{
					if (num4 < 10)
					{
						pointsText.text = "+" + num5 + ",00" + num4 + "<color=orange>P</color>";
					}
					else if (num4 < 100)
					{
						pointsText.text = "+" + num5 + ",0" + num4 + "<color=orange>P</color>";
					}
					else
					{
						pointsText.text = "+" + num5 + "," + num4 + "<color=orange>P</color>";
					}
				}
				else
				{
					pointsText.text = "+" + num4 + "<color=orange>P</color>";
				}
			}
			styleText.text = checkedStyle.ToString("0");
		}
		if (flashFade)
		{
			flashColor.a = Mathf.MoveTowards(flashColor.a, 0f, Time.unscaledDeltaTime * 0.5f);
			flashPanel.color = flashColor;
			if (flashColor.a <= 0f)
			{
				flashFade = false;
			}
		}
		if (!gameOver)
		{
			return;
		}
		if (timeController == null)
		{
			timeController = MonoSingleton<TimeController>.Instance;
		}
		if (opm == null)
		{
			opm = MonoSingleton<OptionsManager>.Instance;
		}
		if (opm.paused && !wasPaused)
		{
			wasPaused = true;
		}
		else if (!opm.paused && wasPaused)
		{
			wasPaused = false;
			MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", 0f);
			MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allVolume", 0.5f);
			MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("allPitch", 0f);
			MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("allVolume", 0.5f);
		}
		if (!GameStateManager.ShowLeaderboards || MonoSingleton<EndlessGrid>.Instance.customPatternMode)
		{
			highScoresDisplayed = true;
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame) && complete && !opm.paused)
		{
			if (highScoresDisplayed)
			{
				SceneHelper.RestartScene();
				return;
			}
			highScoresDisplayed = true;
			GameObject[] array = previousElements;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			highScoreElement.SetActive(value: true);
			FetchTheScores();
		}
		else if (timeController.timeScale <= 0f && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame) && !complete && !opm.paused)
		{
			skipping = true;
			timeBetween = 0.01f;
		}
	}

	private int CalculatePerc(float value)
	{
		return Mathf.FloorToInt((value - (float)Mathf.FloorToInt(value)) * 100f);
	}

	private async void FetchTheScores()
	{
		int difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		LeaderboardEntry[] array = await MonoSingleton<LeaderboardController>.Instance.GetCyberGrindScores(difficulty, LeaderboardType.Friends);
		if (!template)
		{
			return;
		}
		int num = 1;
		LeaderboardEntry[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			LeaderboardEntry leaderboardEntry = array2[i];
			TMP_Text tMP_Text = tUsername;
			Friend user = leaderboardEntry.User;
			tMP_Text.text = TruncateUsername(user.Name, 18);
			tScore.text = Mathf.FloorToInt((float)leaderboardEntry.Score / 1000f).ToString();
			tPercent.text = $"<color=#616161>{CalculatePerc((float)leaderboardEntry.Score / 1000f)}%</color>";
			tRank.text = num.ToString();
			GameObject obj = Object.Instantiate(template, friendContainer.transform);
			SteamController.FetchAvatar(obj.GetComponentInChildren<RawImage>(), leaderboardEntry.User);
			obj.SetActive(value: true);
			num++;
		}
		friendPlaceholder.SetActive(value: false);
		friendContainer.SetActive(value: true);
		array = await MonoSingleton<LeaderboardController>.Instance.GetCyberGrindScores(difficulty, LeaderboardType.GlobalAround);
		if ((bool)template)
		{
			array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				LeaderboardEntry leaderboardEntry2 = array2[i];
				TMP_Text tMP_Text2 = tUsername;
				Friend user = leaderboardEntry2.User;
				tMP_Text2.text = TruncateUsername(user.Name, 18);
				tScore.text = Mathf.FloorToInt((float)leaderboardEntry2.Score / 1000f).ToString();
				tPercent.text = $"<color=#616161>{CalculatePerc((float)leaderboardEntry2.Score / 1000f)}%</color>";
				TMP_Text tMP_Text3 = tRank;
				int globalRank = leaderboardEntry2.GlobalRank;
				tMP_Text3.text = globalRank.ToString();
				GameObject obj2 = Object.Instantiate(template, globalContainer.transform);
				SteamController.FetchAvatar(obj2.GetComponentInChildren<RawImage>(), leaderboardEntry2.User);
				obj2.SetActive(value: true);
			}
			globalPlaceholder.SetActive(value: false);
			globalContainer.SetActive(value: true);
		}
	}

	private static string TruncateUsername(string value, int maxChars)
	{
		if (value.Length > maxChars)
		{
			return value.Substring(0, maxChars);
		}
		return value;
	}

	public void Appear()
	{
		if (i < toAppear.Length)
		{
			if (skipping)
			{
				HudOpenEffect component = toAppear[i].GetComponent<HudOpenEffect>();
				if (component != null)
				{
					component.skip = true;
				}
			}
			if (toAppear[i] == timeText.gameObject)
			{
				if (skipping)
				{
					checkedSeconds = savedTime;
					seconds = savedTime;
					minutes = 0f;
					while (seconds >= 60f)
					{
						seconds -= 60f;
						minutes += 1f;
					}
					timeText.GetComponent<AudioSource>().playOnAwake = false;
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
					timeText.text = minutes + ":" + seconds.ToString("00.000");
				}
				else
				{
					countTime = true;
				}
			}
			else if (toAppear[i] == killsText.gameObject)
			{
				if (skipping)
				{
					checkedKills = savedKills;
					killsText.GetComponent<AudioSource>().playOnAwake = false;
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
					killsText.text = checkedKills.ToString("0");
				}
				else
				{
					countKills = true;
				}
			}
			else if (toAppear[i] == waveText.gameObject)
			{
				if (skipping)
				{
					checkedWaves = savedWaves;
					waveText.GetComponent<AudioSource>().playOnAwake = false;
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
					waveText.text = Mathf.FloorToInt(savedWaves) + $"\n<color=#616161><size=20>{CalculatePerc(savedWaves)}%</size></color>";
				}
				else
				{
					countWaves = true;
				}
			}
			else if (toAppear[i] == styleText.gameObject)
			{
				if (skipping)
				{
					checkedStyle = savedStyle;
					styleText.text = checkedStyle.ToString("0");
					styleText.GetComponent<AudioSource>().playOnAwake = false;
					StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween * 2f));
					totalPoints += savedStyle;
					PointsShow();
				}
				else
				{
					countStyle = true;
				}
			}
			else
			{
				StartCoroutine(InvokeRealtimeCoroutine(Appear, timeBetween));
			}
			toAppear[i].gameObject.SetActive(value: true);
			i++;
		}
		else
		{
			if (newBest)
			{
				GameObject gameObject = bestWaveText.transform.parent.parent.parent.GetChild(1).gameObject;
				FlashPanel(gameObject);
				gameObject.GetComponent<AudioSource>().Play();
				bestWaveText.text = waveText.text;
				bestKillsText.text = killsText.text;
				bestStyleText.text = styleText.text;
				bestTimeText.text = timeText.text;
			}
			if (!complete)
			{
				complete = true;
				GameProgressSaver.AddMoney(totalPoints);
			}
		}
	}

	public void FlashPanel(GameObject panel)
	{
		if (flashFade)
		{
			flashColor.a = 0f;
			flashPanel.color = flashColor;
		}
		flashPanel = panel.GetComponent<UnityEngine.UI.Image>();
		flashColor = flashPanel.color;
		flashColor.a = 1f;
		flashPanel.color = flashColor;
		flashFade = true;
	}

	private void PointsShow()
	{
		int num = totalPoints;
		int num2 = 0;
		while (num >= 1000)
		{
			num2++;
			num -= 1000;
		}
		if (num2 > 0)
		{
			if (num < 10)
			{
				pointsText.text = "+" + num2 + ",00" + num + "<color=orange>P</color>";
			}
			else if (num < 100)
			{
				pointsText.text = "+" + num2 + ",0" + num + "<color=orange>P</color>";
			}
			else
			{
				pointsText.text = "+" + num2 + "," + num + "<color=orange>P</color>";
			}
		}
		else
		{
			pointsText.text = "+" + num + "<color=orange>P</color>";
		}
	}

	private IEnumerator InvokeRealtimeCoroutine(UnityAction action, float seconds)
	{
		yield return new WaitForSecondsRealtime(seconds);
		action?.Invoke();
	}
}



public class FinalDoor : MonoBehaviour
{
	public Door[] doors;

	public GameObject doorLight;

	public bool startOpen;

	public Material[] offMaterials;

	public Material[] onMaterials;

	public bool levelNameOnOpen;

	private MeshRenderer[] allRenderers;

	private bool opened;

	[HideInInspector]
	public bool aboutToOpen;

	private AudioSource aud;

	public GameObject closingBlocker;

	private void Start()
	{
		if (doorLight == null)
		{
			doorLight = GetComponentInChildren<Light>().gameObject;
		}
		if (!aboutToOpen)
		{
			doorLight.SetActive(value: false);
		}
		if (startOpen || (aboutToOpen && !opened))
		{
			Open();
		}
		allRenderers = GetComponentsInChildren<MeshRenderer>();
	}

	public void Open()
	{
		aboutToOpen = true;
		MonoSingleton<MusicManager>.Instance.ArenaMusicEnd();
		Invoke("OpenDoors", 1f);
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		aud?.Play();
		doorLight?.SetActive(value: true);
		if (onMaterials.Length == 0)
		{
			return;
		}
		if (allRenderers == null || allRenderers.Length == 0)
		{
			allRenderers = GetComponentsInChildren<MeshRenderer>();
		}
		MeshRenderer[] array = allRenderers;
		foreach (MeshRenderer meshRenderer in array)
		{
			int onMaterial = GetOnMaterial(meshRenderer);
			if (onMaterial >= 0)
			{
				meshRenderer.sharedMaterial = onMaterials[onMaterial];
			}
		}
	}

	public void Close()
	{
		if (!opened && !aboutToOpen)
		{
			return;
		}
		CancelInvoke("OpenDoors");
		aud?.Stop();
		doorLight?.SetActive(value: false);
		if (offMaterials.Length != 0)
		{
			if (allRenderers == null || allRenderers.Length == 0)
			{
				allRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			MeshRenderer[] array = allRenderers;
			foreach (MeshRenderer meshRenderer in array)
			{
				int offMaterial = GetOffMaterial(meshRenderer);
				if (offMaterial >= 0)
				{
					meshRenderer.sharedMaterial = offMaterials[offMaterial];
				}
			}
		}
		if (opened)
		{
			Door[] array2 = doors;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].Close(force: true);
			}
		}
		if ((bool)closingBlocker)
		{
			closingBlocker.SetActive(value: true);
		}
		opened = false;
		aboutToOpen = false;
	}

	private int GetOnMaterial(MeshRenderer mr)
	{
		for (int i = 0; i < offMaterials.Length; i++)
		{
			if (mr.sharedMaterial == offMaterials[i])
			{
				return i;
			}
		}
		return -1;
	}

	private int GetOffMaterial(MeshRenderer mr)
	{
		for (int i = 0; i < onMaterials.Length; i++)
		{
			if (mr.sharedMaterial == onMaterials[i])
			{
				return i;
			}
		}
		return -1;
	}

	public void OpenDoors()
	{
		if (!opened)
		{
			opened = true;
			aboutToOpen = false;
			Door[] array = doors;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Open(enemy: false, skull: true);
			}
			if (levelNameOnOpen)
			{
				Invoke("LevelNameGo", 1f);
			}
			if ((bool)closingBlocker)
			{
				closingBlocker.SetActive(value: false);
			}
			MonoSingleton<PlayerTracker>.Instance.CheckPlayerType();
		}
	}

	private void LevelNameGo()
	{
		MonoSingleton<LevelNamePopup>.Instance.NameAppear();
	}
}



public class FinalDoorOpener : MonoBehaviour
{
	public bool startTimer;

	public bool startMusic;

	private bool opened;

	private bool opening;

	private bool closed;

	private FinalDoor fd;

	private void Awake()
	{
		fd = GetComponentInParent<FinalDoor>();
		if (fd != null)
		{
			fd.Open();
		}
		if (fd != null)
		{
			opening = true;
			Invoke("GoTime", 1f);
		}
		else
		{
			GoTime();
		}
	}

	private void OnEnable()
	{
		if (closed)
		{
			if (fd != null)
			{
				fd.Open();
			}
			if (fd != null)
			{
				Invoke("GoTime", 1f);
			}
			else
			{
				GoTime();
			}
		}
	}

	public void GoTime()
	{
		CancelInvoke("GoTime");
		if (!opened)
		{
			opening = false;
			opened = true;
			if (startTimer)
			{
				MonoSingleton<StatsManager>.Instance.StartTimer();
			}
			if (startMusic)
			{
				MonoSingleton<MusicManager>.Instance.StartMusic();
			}
			if ((bool)MonoSingleton<OutdoorLightMaster>.Instance)
			{
				MonoSingleton<OutdoorLightMaster>.Instance.FirstDoorOpen();
			}
			if ((bool)MonoSingleton<StatsManager>.Instance)
			{
				MonoSingleton<StatsManager>.Instance.levelStarted = true;
			}
		}
	}

	public void Close()
	{
		if (opened || opening)
		{
			closed = true;
			opened = false;
			opening = false;
			CancelInvoke("GoTime");
			if ((bool)fd)
			{
				fd.Close();
			}
		}
	}
}



public class FinalPit : MonoBehaviour
{
	private NewMovement nmov;

	private StatsManager sm;

	private Rigidbody rb;

	private bool rotationReady;

	private GameObject player;

	private bool infoSent;

	public bool rankless;

	public bool secondPit;

	public string targetLevelName;

	private int levelNumber;

	public bool musicFadeOut;

	private Quaternion targetRotation;

	private void Start()
	{
		sm = MonoSingleton<StatsManager>.Instance;
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		targetRotation = Quaternion.Euler(base.transform.rotation.eulerAngles + Vector3.up * 0.01f);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == player && (bool)MonoSingleton<NewMovement>.Instance && MonoSingleton<NewMovement>.Instance.hp > 0)
		{
			if (musicFadeOut)
			{
				MonoSingleton<MusicManager>.Instance.off = true;
			}
			GameStateManager.Instance.RegisterState(new GameState("pit-falling", base.gameObject)
			{
				cursorLock = LockMode.Lock,
				cameraInputLock = LockMode.Lock
			});
			nmov = MonoSingleton<NewMovement>.Instance;
			nmov.gameObject.layer = 15;
			rb = nmov.rb;
			nmov.activated = false;
			nmov.cc.enabled = false;
			nmov.levelOver = true;
			sm.HideShit();
			sm.StopTimer();
			if (nmov.sliding)
			{
				nmov.StopSlide();
			}
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			if ((bool)MonoSingleton<PowerUpMeter>.Instance)
			{
				MonoSingleton<PowerUpMeter>.Instance.juice = 0f;
			}
			MonoSingleton<CrateCounter>.Instance?.SaveStuff();
			MonoSingleton<CrateCounter>.Instance?.CoinsToPoints();
			OutOfBounds[] array = Object.FindObjectsOfType<OutOfBounds>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
			DeathZone[] array2 = Object.FindObjectsOfType<DeathZone>();
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].gameObject.SetActive(value: false);
			}
			Invoke("SendInfo", 5f);
		}
		else if (other.gameObject.CompareTag("Player") && (bool)MonoSingleton<PlatformerMovement>.Instance && !MonoSingleton<PlatformerMovement>.Instance.dead)
		{
			MonoSingleton<PlayerTracker>.Instance.ChangeToFPS();
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!(other.gameObject == player) || !MonoSingleton<NewMovement>.Instance || MonoSingleton<NewMovement>.Instance.hp <= 0)
		{
			return;
		}
		if (nmov == null)
		{
			nmov = other.gameObject.GetComponent<NewMovement>();
			rb = nmov.rb;
		}
		if (other.transform.position.x != base.transform.position.x || other.transform.position.z != base.transform.position.z)
		{
			Vector3 vector = new Vector3(base.transform.position.x, other.transform.position.y, base.transform.position.z);
			float num = Vector3.Distance(other.transform.position, vector);
			other.transform.position = Vector3.MoveTowards(other.transform.position, vector, 1f + num * Time.deltaTime);
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
		}
		if (!rotationReady)
		{
			nmov.cc.transform.rotation = Quaternion.RotateTowards(nmov.cc.transform.rotation, targetRotation, Time.fixedDeltaTime * 10f * (Quaternion.Angle(nmov.cc.transform.rotation, targetRotation) + 1f));
			if (Quaternion.Angle(nmov.cc.transform.rotation, targetRotation) < 0.01f)
			{
				nmov.cc.transform.rotation = targetRotation;
				rotationReady = true;
			}
		}
		if (rotationReady && !infoSent)
		{
			SendInfo();
		}
	}

	private void SendInfo()
	{
		CancelInvoke();
		if (infoSent)
		{
			return;
		}
		infoSent = true;
		if (!rankless)
		{
			FinalRank fr = sm.fr;
			if (!sm.infoSent)
			{
				levelNumber = MonoSingleton<StatsManager>.Instance.levelNumber;
				if (SceneHelper.IsPlayingCustom)
				{
					GameProgressSaver.SaveProgress(SceneHelper.CurrentLevelNumber);
				}
				else if (levelNumber >= 420)
				{
					GameProgressSaver.SaveProgress(0);
				}
				else
				{
					GameProgressSaver.SaveProgress(levelNumber + 1);
				}
				fr.targetLevelName = targetLevelName;
			}
			if (secondPit)
			{
				fr.finalPitPos = base.transform.position;
				fr.reachedSecondPit = true;
			}
			if (!sm.infoSent)
			{
				sm.SendInfo();
			}
		}
		else if (secondPit)
		{
			GameProgressSaver.SetTutorial(beat: true);
			FinalRank fr2 = MonoSingleton<StatsManager>.Instance.fr;
			fr2.gameObject.SetActive(value: true);
			fr2.finalPitPos = base.transform.position;
			fr2.RanklessNextLevel(targetLevelName);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class FinalRank : MonoSingleton<FinalRank>
{
	public bool casual;

	public bool dontSavePos;

	public bool reachedSecondPit;

	public TMP_Text time;

	private float savedTime;

	public TMP_Text timeRank;

	private bool countTime;

	private int minutes;

	private float seconds;

	private float checkedSeconds;

	public TMP_Text kills;

	private int savedKills;

	public TMP_Text killsRank;

	private bool countKills;

	private float checkedKills;

	public TMP_Text style;

	private int savedStyle;

	public TMP_Text styleRank;

	private bool countStyle;

	private float checkedStyle;

	public TMP_Text extraInfo;

	public TMP_Text totalRank;

	public TMP_Text secrets;

	public Image[] secretsInfo;

	private int secretsFound;

	public GameObject[] levelSecrets;

	private int checkedSecrets;

	private int secretsCheckProgress;

	private int allSecrets;

	public List<int> prevSecrets;

	public Image[] challenges;

	public GameObject[] toAppear;

	private int i;

	private bool flashFade;

	private Image flashPanel;

	private Color flashColor;

	private float flashMultiplier = 1f;

	private Vector3 maxPos;

	private Vector3 startingPos;

	private Vector3 goalPos;

	public bool complete;

	public GameObject playerPosInfo;

	public Vector3 finalPitPos;

	private AsyncOperation asyncLoad;

	private string oldBundle;

	private bool rankless;

	public GameObject ppiObject;

	public string targetLevelName;

	public TMP_Text pointsText;

	public int totalPoints;

	private bool loadAndActivateScene;

	public bool dependenciesLoaded;

	private bool sceneBundleLoaded;

	private bool skipping;

	private float timeBetween = 0.25f;

	private bool noRestarts;

	private bool noDamage;

	private bool majorAssists;

	private void Start()
	{
		Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
		GameObject[] array = toAppear;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		startingPos = base.transform.parent.localPosition;
		maxPos = new Vector3(startingPos.x, startingPos.y - 0.15f, startingPos.z);
	}

	private void Update()
	{
		if (base.transform.parent.localPosition == maxPos)
		{
			goalPos = startingPos;
		}
		else if (base.transform.parent.localPosition == startingPos)
		{
			goalPos = maxPos;
		}
		base.transform.parent.localPosition = Vector3.MoveTowards(base.transform.parent.localPosition, goalPos, Time.deltaTime / 100f);
		if (countTime)
		{
			if (savedTime >= checkedSeconds)
			{
				if (savedTime > checkedSeconds)
				{
					float num = savedTime - checkedSeconds;
					checkedSeconds += Time.deltaTime * 20f + Time.deltaTime * num * 1.5f;
					seconds += Time.deltaTime * 20f + Time.deltaTime * num * 1.5f;
				}
				if (checkedSeconds >= savedTime || skipping)
				{
					checkedSeconds = savedTime;
					seconds = savedTime;
					minutes = 0;
					while (seconds >= 60f)
					{
						seconds -= 60f;
						minutes++;
					}
					countTime = false;
					time.GetComponent<AudioSource>().Stop();
					Invoke("Appear", timeBetween * 2f);
				}
				if (seconds >= 60f)
				{
					seconds -= 60f;
					minutes++;
				}
				time.text = minutes + ":" + seconds.ToString("00.000");
			}
		}
		else if (countKills)
		{
			if ((float)savedKills >= checkedKills)
			{
				if ((float)savedKills > checkedKills)
				{
					checkedKills += Time.deltaTime * 45f;
				}
				if (checkedKills >= (float)savedKills || skipping)
				{
					checkedKills = savedKills;
					countKills = false;
					kills.GetComponent<AudioSource>().Stop();
					Invoke("Appear", timeBetween * 2f);
				}
				kills.text = checkedKills.ToString("0");
			}
		}
		else if (countStyle && (float)savedStyle >= checkedStyle)
		{
			_ = checkedStyle;
			if ((float)savedStyle > checkedStyle)
			{
				checkedStyle += Time.deltaTime * 4500f;
			}
			if (checkedStyle >= (float)savedStyle || skipping)
			{
				checkedStyle = savedStyle;
				countStyle = false;
				style.GetComponent<AudioSource>().Stop();
				Invoke("Appear", timeBetween * 2f);
				totalPoints += savedStyle;
				PointsShow();
			}
			else
			{
				int num2 = totalPoints + Mathf.RoundToInt(checkedStyle);
				int num3 = 0;
				while (num2 >= 1000)
				{
					num3++;
					num2 -= 1000;
				}
				if (num3 > 0)
				{
					if (num2 < 10)
					{
						pointsText.text = "+" + num3 + ",00" + num2 + "<color=orange>P</color>";
					}
					else if (num2 < 100)
					{
						pointsText.text = "+" + num3 + ",0" + num2 + "<color=orange>P</color>";
					}
					else
					{
						pointsText.text = "+" + num3 + "," + num2 + "<color=orange>P</color>";
					}
				}
				else
				{
					pointsText.text = "+" + num2 + "<color=orange>P</color>";
				}
			}
			style.text = checkedStyle.ToString("0");
		}
		if (flashFade)
		{
			flashColor.a -= Time.deltaTime * flashMultiplier;
			flashPanel.color = flashColor;
			if (flashColor.a <= 0f)
			{
				flashFade = false;
			}
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && complete && Time.timeScale != 0f && reachedSecondPit)
		{
			LevelChange();
		}
		else if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && !complete && Time.timeScale != 0f)
		{
			skipping = true;
			timeBetween = 0.01f;
		}
		if (rankless && asyncLoad != null && asyncLoad.progress >= 0.9f)
		{
			LevelChange();
		}
	}

	public void SetTime(float seconds, string rank)
	{
		savedTime = seconds;
		timeRank.text = rank;
		SceneManager.GetSceneByName(targetLevelName);
	}

	public void SetKills(int killAmount, string rank)
	{
		savedKills = killAmount;
		killsRank.text = rank;
	}

	public void SetStyle(int styleAmount, string rank)
	{
		savedStyle = styleAmount;
		styleRank.text = rank;
	}

	public void SetInfo(int restarts, bool damage, bool majorUsed, bool cheatsUsed)
	{
		extraInfo.text = "";
		int num = 1;
		if (!damage)
		{
			num++;
		}
		if (majorUsed)
		{
			num++;
		}
		if (cheatsUsed)
		{
			num++;
		}
		if (cheatsUsed)
		{
			extraInfo.text += "- <color=#44FF45>CHEATS USED</color>\n";
		}
		if (majorUsed)
		{
			if (!MonoSingleton<AssistController>.Instance.hidePopup)
			{
				extraInfo.text += "- <color=#4C99E6>MAJOR ASSISTS USED</color>\n";
			}
			majorAssists = true;
		}
		if (restarts == 0)
		{
			if (num >= 3)
			{
				extraInfo.text += "+ NO RESTARTS\n";
			}
			else
			{
				extraInfo.text += "+ NO RESTARTS\n  (+500<color=orange>P</color>)\n";
			}
			noRestarts = true;
		}
		else
		{
			TMP_Text tMP_Text = extraInfo;
			tMP_Text.text = tMP_Text.text + "- <color=red>" + restarts + "</color> RESTARTS\n";
		}
		if (!damage)
		{
			if (num >= 3)
			{
				extraInfo.text += "+ <color=orange>NO DAMAGE</color>\n";
			}
			else
			{
				extraInfo.text += "+ <color=orange>NO DAMAGE\n  (</color>+5,000<color=orange>P)</color>\n";
			}
			noDamage = true;
		}
	}

	public void SetRank(string rank)
	{
		totalRank.text = rank;
	}

	public void SetSecrets(int secretsAmount, int maxSecrets)
	{
		secrets.text = 0 + " / " + maxSecrets;
		allSecrets = maxSecrets;
		secretsFound = secretsAmount;
	}

	public void Appear()
	{
		if (i < toAppear.Length)
		{
			if (!casual)
			{
				if (skipping)
				{
					HudOpenEffect component = toAppear[i].GetComponent<HudOpenEffect>();
					if (component != null)
					{
						component.skip = true;
					}
				}
				if (toAppear[i] == time.gameObject)
				{
					if (skipping)
					{
						checkedSeconds = savedTime;
						seconds = savedTime;
						minutes = 0;
						while (seconds >= 60f)
						{
							seconds -= 60f;
							minutes++;
						}
						time.GetComponent<AudioSource>().playOnAwake = false;
						Invoke("Appear", timeBetween * 2f);
						time.text = minutes + ":" + seconds.ToString("00.000");
					}
					else
					{
						countTime = true;
					}
				}
				else if (toAppear[i] == kills.gameObject)
				{
					if (skipping)
					{
						checkedKills = savedKills;
						kills.GetComponent<AudioSource>().playOnAwake = false;
						Invoke("Appear", timeBetween * 2f);
						kills.text = checkedKills.ToString("0");
					}
					else
					{
						countKills = true;
					}
				}
				else if (toAppear[i] == style.gameObject)
				{
					if (skipping)
					{
						checkedStyle = savedStyle;
						style.text = checkedStyle.ToString("0");
						style.GetComponent<AudioSource>().playOnAwake = false;
						Invoke("Appear", timeBetween * 2f);
						totalPoints += savedStyle;
						PointsShow();
					}
					else
					{
						countStyle = true;
					}
				}
				else if (toAppear[i] == secrets.gameObject)
				{
					if (prevSecrets.Count > 0)
					{
						foreach (int prevSecret in prevSecrets)
						{
							secretsInfo[prevSecret].color = new Color(0.5f, 0.5f, 0.5f);
							checkedSecrets++;
							secrets.text = checkedSecrets + " / " + levelSecrets.Length;
						}
					}
					toAppear[i].gameObject.SetActive(value: true);
					Invoke("CountSecrets", timeBetween);
				}
				else if (toAppear[i] == timeRank.gameObject || toAppear[i] == killsRank.gameObject || toAppear[i] == styleRank.gameObject)
				{
					switch (toAppear[i].GetComponent<TMP_Text>().text)
					{
					case "<color=#0094FF>D</color>":
						AddPoints(500);
						break;
					case "<color=#4CFF00>C</color>":
						AddPoints(1000);
						break;
					case "<color=#FFD800>B</color>":
						AddPoints(1500);
						break;
					case "<color=#FF6A00>A</color>":
						AddPoints(2000);
						break;
					case "<color=#FF0000>S</color>":
						AddPoints(2500);
						break;
					}
					FlashPanel(toAppear[i].transform.parent.GetChild(1).gameObject);
					Invoke("Appear", timeBetween * 2f);
					if (skipping)
					{
						toAppear[i].GetComponentInChildren<AudioSource>().playOnAwake = false;
					}
				}
				else if (toAppear[i] == totalRank.gameObject)
				{
					FlashPanel(toAppear[i].transform.parent.GetChild(1).gameObject);
					flashMultiplier = 0.5f;
					Invoke("Appear", timeBetween * 4f);
				}
				else if (toAppear[i] == extraInfo.gameObject)
				{
					if (noRestarts)
					{
						AddPoints(500);
					}
					if (noDamage)
					{
						AddPoints(5000);
					}
					Invoke("Appear", timeBetween);
				}
				else
				{
					Invoke("Appear", timeBetween);
				}
			}
			else
			{
				Invoke("Appear", timeBetween);
			}
			toAppear[i].gameObject.SetActive(value: true);
			i++;
			if (!toAppear[0].gameObject.activeSelf)
			{
				toAppear[0].gameObject.SetActive(value: true);
			}
			if (i >= toAppear.Length && !complete)
			{
				complete = true;
				GameProgressSaver.AddMoney(totalPoints);
			}
		}
		else if (!complete)
		{
			complete = true;
			GameProgressSaver.AddMoney(totalPoints);
		}
	}

	public void FlashPanel(GameObject panel)
	{
		if (flashFade)
		{
			flashColor.a = 0f;
			flashPanel.color = flashColor;
		}
		flashPanel = panel.GetComponent<Image>();
		flashColor = flashPanel.color;
		flashColor.a = 1f;
		flashPanel.color = flashColor;
		flashFade = true;
	}

	private void CountSecrets()
	{
		if (levelSecrets.Length != 0)
		{
			if (levelSecrets[secretsCheckProgress] == null && !prevSecrets.Contains(secretsCheckProgress))
			{
				checkedSecrets++;
				secrets.text = checkedSecrets + " / " + levelSecrets.Length;
				secrets.GetComponent<AudioSource>().Play();
				secretsInfo[secretsCheckProgress].color = Color.white;
				secretsCheckProgress++;
				AddPoints(1000);
				if (secretsCheckProgress < levelSecrets.Length)
				{
					Invoke("CountSecrets", timeBetween);
				}
				else
				{
					Invoke("Appear", timeBetween);
				}
			}
			else if (secretsCheckProgress < levelSecrets.Length - 1)
			{
				secretsCheckProgress++;
				CountSecrets();
			}
			else
			{
				secretsCheckProgress++;
				Invoke("Appear", timeBetween);
			}
		}
		else
		{
			Invoke("Appear", timeBetween);
		}
	}

	public void RanklessNextLevel(string lvlname)
	{
		if (lvlname != "")
		{
			rankless = true;
			targetLevelName = lvlname;
			SceneHelper.LoadScene(targetLevelName, noBlocker: true);
		}
	}

	public void LevelChange(bool force = false)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			if (force)
			{
				MonoSingleton<OptionsManager>.Instance.QuitMission();
			}
			else if ((bool)MonoSingleton<AdditionalMapDetails>.Instance && MonoSingleton<AdditionalMapDetails>.Instance.hasAuthorLinks)
			{
				base.gameObject.SetActive(value: false);
				MonoSingleton<WorkshopMapEndLinks>.Instance.Show();
			}
			else if (GameStateManager.Instance.currentCustomGame != null && GameStateManager.Instance.currentCustomGame.workshopId.HasValue)
			{
				MonoSingleton<WorkshopMapEndRating>.Instance.enabled = true;
				base.gameObject.SetActive(value: false);
			}
			else
			{
				MonoSingleton<OptionsManager>.Instance.QuitMission();
			}
			return;
		}
		if (playerPosInfo != null)
		{
			if (ppiObject == null)
			{
				ppiObject = Object.Instantiate(playerPosInfo);
			}
			PlayerPosInfo component = ppiObject.GetComponent<PlayerPosInfo>();
			Rigidbody component2 = MonoSingleton<NewMovement>.Instance.gameObject.GetComponent<Rigidbody>();
			component.velocity = component2.velocity;
			component.position = component2.transform.position - finalPitPos;
			component.position = new Vector3(component.position.x, component.position.y, component.position.z - 990f);
			component.wooshTime = component2.GetComponentInChildren<WallCheck>().GetComponent<AudioSource>().time;
			if (dontSavePos || targetLevelName == "Main Menu")
			{
				component.noPosition = true;
			}
		}
		base.gameObject.SetActive(value: false);
		SceneHelper.LoadScene(targetLevelName, noBlocker: true);
	}

	public void AddPoints(int points)
	{
		totalPoints += points;
		PointsShow();
	}

	private void PointsShow()
	{
		int num = totalPoints;
		int num2 = 0;
		while (num >= 1000)
		{
			num2++;
			num -= 1000;
		}
		if (num2 > 0)
		{
			if (num < 10)
			{
				pointsText.text = "+" + num2 + ",00" + num + "<color=orange>P</color>";
			}
			else if (num < 100)
			{
				pointsText.text = "+" + num2 + ",0" + num + "<color=orange>P</color>";
			}
			else
			{
				pointsText.text = "+" + num2 + "," + num + "<color=orange>P</color>";
			}
		}
		else
		{
			pointsText.text = "+" + num + "<color=orange>P</color>";
		}
	}
}



public class FinalRoom : MonoBehaviour
{
	public Transform dropPoint;

	public GameObject doorOpener;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class FireObjectPool : MonoSingleton<FireObjectPool>
{
	public GameObject firePrefab;

	public GameObject simpleFirePrefab;

	public int poolSize = 100;

	private Queue<GameObject> firePool;

	private Queue<GameObject> simpleFirePool;

	private new void Awake()
	{
		firePool = new Queue<GameObject>();
		simpleFirePool = new Queue<GameObject>();
		for (int i = 0; i < poolSize; i++)
		{
			GameObject gameObject = Object.Instantiate(firePrefab, base.transform);
			gameObject.SetActive(value: false);
			firePool.Enqueue(gameObject);
			GameObject gameObject2 = Object.Instantiate(simpleFirePrefab, base.transform);
			gameObject2.SetActive(value: false);
			simpleFirePool.Enqueue(gameObject2);
		}
	}

	public GameObject GetFire(bool isSimple)
	{
		Queue<GameObject> queue = (isSimple ? simpleFirePool : firePool);
		if (queue.Count > 0)
		{
			GameObject gameObject = queue.Dequeue();
			if (gameObject != null)
			{
				gameObject.SetActive(value: true);
				return gameObject;
			}
		}
		return Object.Instantiate(isSimple ? simpleFirePrefab : firePrefab);
	}

	public void ReturnFire(GameObject fireObject, bool isSimple)
	{
		fireObject.transform.SetParent(base.transform);
		fireObject.SetActive(value: false);
		(isSimple ? simpleFirePool : firePool).Enqueue(fireObject);
	}

	public void RemoveAllFiresFromObject(GameObject objectToSearch)
	{
		Flammable[] componentsInChildren = objectToSearch.GetComponentsInChildren<Flammable>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MarkForDestroy();
		}
	}
}



public class FireZone : MonoBehaviour
{
	public HurtCooldownCollection HurtCooldownCollection;

	public FlameSource source;

	public bool canHurtPlayer = true;

	public int playerDamage = 20;

	private Streetcleaner sc;

	private void Start()
	{
		if (HurtCooldownCollection == null)
		{
			HurtCooldownCollection = new HurtCooldownCollection();
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (source == FlameSource.None)
		{
			return;
		}
		float num = 1f;
		bool flag = true;
		bool flag2 = false;
		bool flag3 = true;
		switch (source)
		{
		case FlameSource.Streetcleaner:
			if (sc == null)
			{
				sc = GetComponentInParent<Streetcleaner>();
			}
			if (!sc.damaging || sc.eid.target == null)
			{
				return;
			}
			flag = sc.eid.target.isPlayer;
			flag2 = !flag;
			num = sc.eid.totalDamageModifier;
			break;
		case FlameSource.Napalm:
			flag2 = true;
			break;
		}
		EnemyIdentifierIdentifier component;
		Flammable component2;
		if (other.gameObject.CompareTag("Player"))
		{
			if (canHurtPlayer && flag && HurtCooldownCollection.TryHurtCheckPlayer())
			{
				if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
				{
					MonoSingleton<PlatformerMovement>.Instance.Burn();
				}
				else
				{
					MonoSingleton<NewMovement>.Instance.GetHurt((int)((float)playerDamage * num), invincible: true);
				}
			}
		}
		else if (other.TryGetComponent<EnemyIdentifierIdentifier>(out component) && component != null && component.eid != null)
		{
			if (flag2)
			{
				EnemyIdentifier eid = component.eid;
				if (HurtCooldownCollection.TryHurtCheckEnemy(eid))
				{
					eid.hitter = "fire";
					eid.DeliverDamage(other.gameObject, Vector3.zero, Vector3.zero, 1f, tryForExplode: false);
				}
			}
		}
		else if (other.TryGetComponent<Flammable>(out component2) && flag3 && HurtCooldownCollection.TryHurtCheckFlammable(component2))
		{
			component2.Burn(10f);
		}
	}
}



public class FirstPersonInputModule : StandaloneInputModule
{
	protected override MouseState GetMousePointerEventData(int id)
	{
		CursorLockMode lockState = Cursor.lockState;
		Cursor.lockState = CursorLockMode.None;
		MouseState mousePointerEventData = base.GetMousePointerEventData(id);
		Cursor.lockState = lockState;
		return mousePointerEventData;
	}

	protected override void ProcessMove(PointerEventData pointerEvent)
	{
		CursorLockMode lockState = Cursor.lockState;
		Cursor.lockState = CursorLockMode.None;
		base.ProcessMove(pointerEvent);
		Cursor.lockState = lockState;
	}

	protected override void ProcessDrag(PointerEventData pointerEvent)
	{
		CursorLockMode lockState = Cursor.lockState;
		Cursor.lockState = CursorLockMode.None;
		base.ProcessDrag(pointerEvent);
		Cursor.lockState = lockState;
	}
}



public class FirstRoomPrefab : MonoBehaviour, IPlaceholdableComponent
{
	[HideInInspector]
	public GameObject[] activateOnFirstRoomDoorOpen;

	[HideInInspector]
	public bool levelNameOnOpen = true;

	public Door mainDoor;

	public FinalDoor finalDoor;

	public void WillReplace(GameObject oldObject, GameObject newObject, bool isSelfBeingReplaced)
	{
		if (isSelfBeingReplaced)
		{
			newObject.GetComponent<FirstRoomPrefab>().SwapData(this);
		}
	}

	private void SwapData(FirstRoomPrefab source)
	{
		List<GameObject> list = new List<GameObject>();
		list.AddRange(mainDoor.activatedRooms);
		list.AddRange(source.activateOnFirstRoomDoorOpen);
		mainDoor.activatedRooms = list.ToArray();
		finalDoor.levelNameOnOpen = source.levelNameOnOpen;
	}
}



public class FishBait : MonoBehaviour
{
	public Transform baitPoint;

	[SerializeField]
	private LineRenderer lineRenderer;

	[SerializeField]
	private GameObject splashPrefab;

	[SerializeField]
	private GameObject fishHookedPrefab;

	private GameObject fishHookedSpawned;

	private Transform initialParent;

	private Vector3 landTarget;

	private FishingRodWeapon sourceWeapon;

	public bool landed = true;

	public float flyProgress;

	private float fishPullVelocity;

	private float overrideLastMile = -1f;

	public bool allowedToProgress;

	private bool returnToRod;

	private bool outOfWater;

	private Transform spawnedFish;

	private void Update()
	{
		if (landed && !returnToRod)
		{
			UpdateLineRenderer();
			return;
		}
		if (returnToRod)
		{
			if (allowedToProgress || outOfWater)
			{
				fishPullVelocity += 0.3f * Time.deltaTime;
			}
			else
			{
				fishPullVelocity *= 1f - 0.4f * Time.deltaTime;
			}
			if (fishPullVelocity > 1f)
			{
				fishPullVelocity = 1f;
			}
			if (fishPullVelocity < 0f)
			{
				fishPullVelocity = 0f;
			}
			flyProgress += Time.deltaTime * 0.9f * fishPullVelocity;
			if (fishPullVelocity > 0.1f)
			{
				if (!sourceWeapon.pullSound.isPlaying)
				{
					sourceWeapon.pullSound.Play();
				}
				sourceWeapon.pullSound.pitch = Mathf.Abs(0.7f + fishPullVelocity * 2f);
			}
			else
			{
				sourceWeapon.pullSound.Stop();
			}
			ReturnAnim();
		}
		else
		{
			flyProgress += Time.deltaTime;
			ThrowAnim();
		}
		UpdateLineRenderer();
	}

	private void ThrowAnim()
	{
		if (flyProgress >= 1f)
		{
			flyProgress = 1f;
			UnityEngine.Object.Instantiate(splashPrefab, baitPoint.position + Vector3.down * 0.3f, Quaternion.Euler(-90f, 0f, 0f));
			landed = true;
		}
		float num = Mathf.Sin(flyProgress * (float)Math.PI) * 20f;
		baitPoint.position = Vector3.Lerp(baitPoint.position, landTarget, flyProgress);
		baitPoint.position = new Vector3(baitPoint.position.x, baitPoint.position.y + num, baitPoint.position.z);
	}

	private void ReturnAnim()
	{
		if (flyProgress >= 1f)
		{
			flyProgress = 1f;
			sourceWeapon.FishCaughtAndGrabbed();
			sourceWeapon.pullSound.Stop();
			UnityEngine.Object.Destroy(spawnedFish.gameObject);
			MonoSingleton<LeaderboardController>.Instance.SubmitFishSize(SteamController.FishSizeMulti);
		}
		else
		{
			Vector3 forward = initialParent.position - baitPoint.position;
			spawnedFish.rotation = Quaternion.LookRotation(forward);
			float num = ((overrideLastMile > 0f) ? overrideLastMile : 0.95f);
			float t = (flyProgress - num) / (1f - num);
			float a = landTarget.y - 1f;
			baitPoint.position = Vector3.Lerp(landTarget, initialParent.position, flyProgress);
			RaycastHit hitInfo;
			bool flag = Physics.Raycast(baitPoint.position + Vector3.up * 2f, Vector3.down, out hitInfo, 10f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies));
			baitPoint.position = new Vector3(baitPoint.position.x, Mathf.Max(Mathf.Lerp(a, initialParent.position.y, t), flag ? hitInfo.point.y : float.NegativeInfinity), baitPoint.position.z);
		}
	}

	private void UpdateLineRenderer()
	{
		Camera cam = MonoSingleton<CameraController>.Instance.cam;
		Vector3 position = MonoSingleton<PostProcessV2_Handler>.Instance.hudCam.WorldToScreenPoint(base.transform.position);
		position = cam.ScreenToWorldPoint(position);
		position = lineRenderer.transform.InverseTransformPoint(position);
		lineRenderer.SetPosition(0, position);
		Vector3 position2 = baitPoint.position;
		Vector3 position3 = lineRenderer.transform.InverseTransformPoint(position2);
		lineRenderer.SetPosition(1, position3);
	}

	public void ThrowStart(Vector3 targetWorldPosition, Transform inPar, FishingRodWeapon srcWpn)
	{
		flyProgress = 0f;
		landTarget = targetWorldPosition;
		initialParent = inPar;
		sourceWeapon = srcWpn;
		baitPoint.SetParent(null);
	}

	public void FishHooked()
	{
		fishHookedSpawned = UnityEngine.Object.Instantiate(fishHookedPrefab, baitPoint.position + Vector3.up * 3f, Quaternion.identity);
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(baitPoint.gameObject);
		if ((bool)fishHookedSpawned)
		{
			UnityEngine.Object.Destroy(fishHookedSpawned);
		}
	}

	public void CatchFish(FishObject fish)
	{
		if (!returnToRod)
		{
			returnToRod = true;
			UnityEngine.Object.Destroy(fishHookedSpawned);
			flyProgress = 0f;
			spawnedFish = fish.InstantiateWorld(baitPoint.position).transform;
			spawnedFish.SetParent(baitPoint);
		}
	}

	public void OutOfWater()
	{
		if (returnToRod && !outOfWater)
		{
			outOfWater = true;
			overrideLastMile = flyProgress;
			MonoSingleton<FishingHUD>.Instance.ShowOutOfWater();
		}
	}

	public void OnTriggerExit(Collider other)
	{
		if (returnToRod && other.gameObject.layer == 4)
		{
			if (Physics.Raycast(baitPoint.position, Vector3.down, out var hitInfo, 6f) && hitInfo.collider.gameObject.layer == 4)
			{
				Debug.Log("We're above water, ignore trigger exit");
				return;
			}
			Debug.Log("out of water since trigger exit");
			OutOfWater();
		}
	}

	public void OnCollisionEnter(Collision collision)
	{
		if (returnToRod)
		{
			LayerMask layerMask = LayerMaskDefaults.Get(LMD.Environment);
			if ((int)layerMask == ((int)layerMask | (1 << collision.gameObject.layer)))
			{
				Debug.LogError("touched env!!!");
				OutOfWater();
			}
		}
	}
}



public class FishBaitCollisionProxy : MonoBehaviour
{
	[SerializeField]
	private FishBait fishBait;

	private Vector3 lastPosition;

	private void OnTriggerExit(Collider other)
	{
		fishBait.OnTriggerExit(other);
	}

	private void OnCollisionEnter(Collision collision)
	{
		fishBait.OnCollisionEnter(collision);
	}

	private void Update()
	{
		if (Physics.Raycast(lastPosition, base.transform.position - lastPosition, out var _, Vector3.Distance(lastPosition, base.transform.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
		{
			Debug.Log("Out of water due to col proxy raycast");
			fishBait.OutOfWater();
		}
		lastPosition = base.transform.position;
	}
}



public class FishConstraints : MonoBehaviour
{
	[SerializeField]
	private Collider[] restrictToColliderBounds;

	[NonSerialized]
	public Bounds area;

	private void Awake()
	{
		Collider[] components;
		if (restrictToColliderBounds == null || restrictToColliderBounds.Length == 0)
		{
			components = GetComponents<BoxCollider>();
			restrictToColliderBounds = components;
		}
		if (restrictToColliderBounds == null || restrictToColliderBounds.Length == 0)
		{
			return;
		}
		components = restrictToColliderBounds;
		foreach (Collider collider in components)
		{
			if (!(collider == null))
			{
				_ = area;
				if (area.size == Vector3.zero)
				{
					area = collider.bounds;
				}
				else
				{
					area.Encapsulate(collider.bounds);
				}
			}
		}
	}

	private void OnDrawGizmos()
	{
		Bounds bounds = default(Bounds);
		if (restrictToColliderBounds != null)
		{
			Collider[] array = restrictToColliderBounds;
			foreach (Collider collider in array)
			{
				if (!(collider == null))
				{
					if (bounds.size == Vector3.zero)
					{
						bounds = collider.bounds;
					}
					else
					{
						bounds.Encapsulate(collider.bounds);
					}
				}
			}
		}
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube(bounds.center, bounds.size);
	}
}



public class FishCooker : MonoBehaviour
{
	[SerializeField]
	private bool unusable;

	private TimeSince timeSinceLastError;

	[SerializeField]
	private ItemIdentifier fishPickupTemplate;

	[SerializeField]
	private FishObject cookedFish;

	[SerializeField]
	private FishObject failedFish;

	[SerializeField]
	private GameObject cookedSound;

	[SerializeField]
	private GameObject cookedParticles;

	private void Awake()
	{
		if (unusable)
		{
			timeSinceLastError = 0f;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.TryGetComponent<FishObjectReference>(out var component))
		{
			return;
		}
		if (unusable)
		{
			if ((float)timeSinceLastError > 2f)
			{
				timeSinceLastError = 0f;
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Too small for this fish.\n:^(");
			}
		}
		else if (!(component.fishObject == cookedFish) && !(component.fishObject == failedFish))
		{
			_ = MonoSingleton<FishManager>.Instance.recognizedFishes[cookedFish];
			GameObject obj = FishingRodWeapon.CreateFishPickup(fishPickupTemplate, component.fishObject.canBeCooked ? cookedFish : failedFish, grab: false, unlock: false);
			if (!component.fishObject.canBeCooked)
			{
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Cooking failed.");
			}
			obj.transform.SetPositionAndRotation(base.transform.position, Quaternion.identity);
			obj.GetComponent<Rigidbody>().velocity = (MonoSingleton<NewMovement>.Instance.transform.position - base.transform.position).normalized * 18f + Vector3.up * 10f;
			Object.Instantiate(cookedSound, base.transform.position, Quaternion.identity);
			if ((bool)cookedParticles)
			{
				Object.Instantiate(cookedParticles, base.transform.position, Quaternion.identity);
			}
			Object.Destroy(component.gameObject);
		}
	}
}



[CreateAssetMenu(fileName = "New Fish Database", menuName = "ULTRAKILL/FishDB")]
public class FishDB : ScriptableObject
{
	public string fullName;

	public Color symbolColor = Color.white;

	public GameObject fishGhostPrefab;

	public FishDescriptor[] foundFishes;

	public void SetupWater(Water water)
	{
		if ((bool)fishGhostPrefab)
		{
			Bounds bounds = water.GetComponent<Collider>().bounds;
			int num = (int)(bounds.size.x * bounds.size.y / 100f);
			for (int i = 0; i < num; i++)
			{
				GameObject gameObject = Object.Instantiate(fishGhostPrefab, water.transform, worldPositionStays: true);
				gameObject.transform.position = new Vector3(Random.Range((0f - bounds.size.x) / 4f, bounds.size.x / 4f) + bounds.center.x, 0f, Random.Range((0f - bounds.size.z) / 4f, bounds.size.z / 4f) + bounds.center.z);
				gameObject.transform.position = new Vector3(gameObject.transform.position.x, bounds.center.y + Random.Range(-1f, 1f) * (bounds.size.y / 2f - 0.2f), gameObject.transform.position.z);
				gameObject.transform.localRotation = Quaternion.Euler(0f, Random.Range(0, 360), 0f);
			}
		}
	}

	public FishDescriptor GetRandomFish(FishObject[] attractFish)
	{
		if (attractFish != null && attractFish.Length != 0)
		{
			FishDescriptor fishDescriptor = foundFishes.FirstOrDefault((FishDescriptor f) => attractFish.Any((FishObject a) => a == f.fish));
			if (fishDescriptor != null)
			{
				return fishDescriptor;
			}
		}
		int num = 0;
		FishDescriptor[] array = foundFishes;
		for (int i = 0; i < array.Length; i++)
		{
			int chance = array[i].chance;
			num += chance;
		}
		if (num == 0)
		{
			return null;
		}
		int num2 = Random.Range(0, num);
		int num3 = 0;
		array = foundFishes;
		foreach (FishDescriptor fishDescriptor2 in array)
		{
			int chance2 = fishDescriptor2.chance;
			num3 += chance2;
			if (num2 < num3)
			{
				return fishDescriptor2;
			}
		}
		return foundFishes.Last();
	}
}



[Serializable]
public class FishDescriptor
{
	public FishObject fish;

	public int chance = 1;
}



public class FishEncyclopedia : MonoBehaviour
{
	[SerializeField]
	private GameObject fishPicker;

	[SerializeField]
	private GameObject fishInfoContainer;

	[SerializeField]
	private TMP_Text fishName;

	[SerializeField]
	private TMP_Text fishDescription;

	[Space]
	[SerializeField]
	private Transform fishGrid;

	[SerializeField]
	private FishMenuButton fishButtonTemplate;

	[SerializeField]
	private GameObject fish3dRenderContainer;

	[Space]
	[SerializeField]
	private FishDB[] fishDbs;

	private Dictionary<FishObject, FishMenuButton> fishButtons = new Dictionary<FishObject, FishMenuButton>();

	private void Start()
	{
		fishButtonTemplate.gameObject.SetActive(value: false);
		foreach (KeyValuePair<FishObject, bool> recognizedFish in MonoSingleton<FishManager>.Instance.recognizedFishes)
		{
			FishObject fish = recognizedFish.Key;
			bool value = recognizedFish.Value;
			if (!fishButtons.ContainsKey(fish))
			{
				FishMenuButton fishMenuButton = UnityEngine.Object.Instantiate(fishButtonTemplate, fishGrid, worldPositionStays: false);
				fishButtons.Add(fish, fishMenuButton);
				fishMenuButton.gameObject.SetActive(value: true);
				fishMenuButton.Populate(fish, !value);
				fishMenuButton.GetComponent<ControllerPointer>().OnPressed.RemoveAllListeners();
				fishMenuButton.GetComponent<ControllerPointer>().OnPressed.AddListener(delegate
				{
					SelectFish(fish);
				});
			}
		}
		FishManager instance = MonoSingleton<FishManager>.Instance;
		instance.onFishUnlocked = (Action<FishObject>)Delegate.Combine(instance.onFishUnlocked, new Action<FishObject>(OnFishUnlocked));
	}

	private void OnFishUnlocked(FishObject obj)
	{
		if (fishButtons.ContainsKey(obj))
		{
			fishButtons[obj].Populate(obj, locked: false);
		}
	}

	private void DisplayFish(FishObject fish)
	{
		foreach (Transform item in fish3dRenderContainer.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		if (MonoSingleton<FishManager>.Instance.recognizedFishes[fish])
		{
			GameObject obj = fish.InstantiateDumb();
			obj.transform.SetParent(fish3dRenderContainer.transform);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			SandboxUtils.SetLayerDeep(obj.transform, LayerMask.NameToLayer("VirtualRender"));
		}
	}

	public void SelectFish(FishObject fish)
	{
		fishName.text = (MonoSingleton<FishManager>.Instance.recognizedFishes[fish] ? fish.fishName : "???");
		fishDescription.text = fish.description;
		fishPicker.SetActive(value: false);
		fishInfoContainer.SetActive(value: true);
		DisplayFish(fish);
	}

	public void HideFishInfo()
	{
		fishPicker.SetActive(value: true);
		fishInfoContainer.SetActive(value: false);
	}
}



public class FishGhost : MonoBehaviour
{
	private float speed = 1f;

	private float turnSpeed = 1f;

	private float direction = 1f;

	private float directionChangeTendency;

	private float jitter;

	private float indecisiveness;

	private TimeSince timeSinceLogicTick;

	private bool scared;

	private TimeSince timeSinceSpook;

	private TimeSince timeSinceDifficultAction;

	private FishConstraints constraints;

	public float tiredness => 1f - Mathf.Clamp01(timeSinceDifficultAction);

	private void RollTheDice()
	{
		speed = Random.Range(0.1f, 7f);
		turnSpeed = Random.Range(4f, 50f);
		direction = ((Random.value > 0.5f) ? 1f : (-1f));
		directionChangeTendency = Random.Range(0.0001f, 0.02f);
		jitter = Random.Range(0.1f, 1.5f);
	}

	private void Start()
	{
		base.transform.rotation = Quaternion.Euler(0f, Random.Range(0, 360), 0f);
		indecisiveness = Random.Range(0.003f, 0.1f);
		timeSinceLogicTick = 0f;
		RollTheDice();
		constraints = GetComponent<FishConstraints>();
		if (constraints == null && base.transform.parent != null)
		{
			constraints = base.transform.parent.GetComponent<FishConstraints>();
		}
	}

	private void FixedUpdate()
	{
		if (Random.value < indecisiveness)
		{
			RollTheDice();
		}
		if (Random.value < directionChangeTendency)
		{
			direction *= -1f;
		}
		if (scared && (float)timeSinceSpook > 3f)
		{
			scared = false;
		}
		if (!((float)timeSinceLogicTick > 3f + jitter))
		{
			return;
		}
		RaycastHit hitInfo;
		bool flag = Physics.Raycast(base.transform.position, -base.transform.forward, out hitInfo, 10f, (int)LayerMaskDefaults.Get(LMD.Environment) | 0x10000, QueryTriggerInteraction.Collide);
		Vector3 position = MonoSingleton<NewMovement>.Instance.transform.position;
		bool flag2 = constraints == null || constraints.area.Contains(base.transform.position);
		if ((tiredness < 0.5f && Vector3.Distance(position, base.transform.position) < 15f) || flag || !flag2)
		{
			if (flag)
			{
				base.transform.rotation = Quaternion.LookRotation(hitInfo.point - base.transform.position);
			}
			if (!flag2)
			{
				Vector3 center = constraints.area.center;
				base.transform.rotation = Quaternion.LookRotation(base.transform.position - center);
			}
			base.transform.rotation = Quaternion.Euler(0f, base.transform.rotation.eulerAngles.y, 0f);
			scared = true;
			timeSinceSpook = 0f;
			timeSinceDifficultAction = 0f;
		}
	}

	private void Update()
	{
		base.transform.Translate(-Vector3.forward * Time.deltaTime * speed * (scared ? 4f : (1f * (1f - tiredness))));
		base.transform.Rotate(Vector3.up * Time.deltaTime * turnSpeed * direction * (1f - tiredness));
	}
}



public class FishingExitDoor : MonoBehaviour
{
	[SerializeField]
	private FishManager manager;

	[SerializeField]
	private UltrakillEvent onUnlock;

	private bool isLocked = true;

	private void Update()
	{
		if (isLocked && manager.RemainingFishes <= 0)
		{
			isLocked = false;
			onUnlock.Invoke();
		}
	}
}



public class FishingHUD : MonoSingleton<FishingHUD>
{
	[SerializeField]
	private GameObject powerMeterContainer;

	[SerializeField]
	private Slider powerMeter;

	[SerializeField]
	private GameObject hookedContainer;

	[Space]
	[SerializeField]
	private GameObject fishCaughtContainer;

	[SerializeField]
	private Text fishCaughtText;

	[SerializeField]
	private GameObject fishRenderContainer;

	[SerializeField]
	private GameObject fishSizeContainer;

	[Space]
	[SerializeField]
	private GameObject struggleContainer;

	[SerializeField]
	private GameObject outOfWaterMessage;

	[SerializeField]
	private Image struggleProgressIcon;

	[SerializeField]
	private Image struggleProgressIconOverlay;

	[SerializeField]
	private Image struggleNub;

	[SerializeField]
	private RectTransform desireBar;

	[SerializeField]
	private RectTransform fishIcon;

	[SerializeField]
	private Slider struggleProgressSlider;

	[SerializeField]
	private Text struggleLMB;

	[SerializeField]
	private Text struggleRMB;

	[SerializeField]
	private Image upArrow;

	[SerializeField]
	private Image downArrow;

	[Space]
	[SerializeField]
	private Image fishIconTemplate;

	[SerializeField]
	private Transform fishIconContainer;

	private Dictionary<FishObject, Image> fishHudIcons = new Dictionary<FishObject, Image>();

	private static Color orangeColor = new Color(1f, 0.5f, 0.1f);

	private TimeSince timeSinceLMBReleased;

	private TimeSince timeSinceRMBReleased;

	[HideInInspector]
	public TimeSince timeSinceFishCaught;

	private float containerHeight => struggleNub.rectTransform.parent.GetComponent<RectTransform>().rect.height;

	private void Start()
	{
		fishIconTemplate.gameObject.SetActive(value: false);
		foreach (KeyValuePair<FishObject, bool> recognizedFish in MonoSingleton<FishManager>.Instance.recognizedFishes)
		{
			Image image = UnityEngine.Object.Instantiate(fishIconTemplate, fishIconContainer, worldPositionStays: false);
			image.gameObject.SetActive(value: true);
			image.sprite = recognizedFish.Key.blockedIcon;
			image.color = Color.black;
			fishHudIcons.Add(recognizedFish.Key, image);
			Image component = image.GetComponentInChildren<FishIconGlow>().GetComponent<Image>();
			component.sprite = recognizedFish.Key.blockedIcon;
			component.color = new Color(1f, 1f, 1f, 0f);
		}
		fishIconContainer.gameObject.SetActive(value: false);
	}

	public void ShowHUD()
	{
		fishIconContainer.gameObject.SetActive(value: true);
	}

	public void SetFishHooked(bool hooked)
	{
		hookedContainer.SetActive(hooked);
	}

	private void OnFishUnlocked(FishObject obj)
	{
		fishHudIcons[obj].sprite = obj.icon;
		fishHudIcons[obj].color = Color.white;
		fishHudIcons[obj].GetComponentInChildren<FishIconGlow>().Blink();
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		FishManager fishManager = MonoSingleton<FishManager>.Instance;
		fishManager.onFishUnlocked = (Action<FishObject>)Delegate.Combine(fishManager.onFishUnlocked, new Action<FishObject>(OnFishUnlocked));
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<FishManager>.Instance)
		{
			FishManager fishManager = MonoSingleton<FishManager>.Instance;
			fishManager.onFishUnlocked = (Action<FishObject>)Delegate.Remove(fishManager.onFishUnlocked, new Action<FishObject>(OnFishUnlocked));
		}
	}

	public void SetState(FishingRodState state)
	{
		if (!struggleContainer.activeSelf && state == FishingRodState.FishStruggle)
		{
			outOfWaterMessage.SetActive(value: false);
		}
		powerMeterContainer.SetActive(state == FishingRodState.SelectingPower || state == FishingRodState.Throwing);
		struggleContainer.SetActive(state == FishingRodState.FishStruggle);
	}

	public void SetPowerMeter(float value, bool canFish)
	{
		powerMeter.value = value;
		powerMeter.targetGraphic.color = (canFish ? Color.white : Color.red);
	}

	private void Update()
	{
		float num = Mathf.Sin(struggleProgressSlider.value * 20f);
		fishIcon.localRotation = Quaternion.Euler(0f, 0f, num * 10f);
		if (struggleContainer.activeSelf)
		{
			Color color = Color.Lerp(orangeColor, Color.white, (float)timeSinceLMBReleased * 4f);
			Color color2 = Color.Lerp(orangeColor, Color.white, (float)timeSinceRMBReleased * 4f);
			struggleLMB.color = color;
			struggleRMB.color = color2;
			upArrow.color = color2;
			downArrow.color = color;
		}
	}

	public void ShowFishCaught(bool show = true, FishObject fish = null)
	{
		if (!show)
		{
			StopAllCoroutines();
		}
		else
		{
			timeSinceFishCaught = 0f;
		}
		fishSizeContainer.SetActive(value: false);
		fishCaughtContainer.SetActive(show);
		if (show && fish != null)
		{
			fishCaughtText.text = "<size=28>You caught</size> <color=orange>" + fish.fishName + "</color>";
		}
		foreach (Transform item in fishRenderContainer.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		if (show && fish != null)
		{
			GameObject obj = fish.InstantiateDumb();
			obj.transform.SetParent(fishRenderContainer.transform);
			obj.transform.localPosition = Vector3.zero;
			SandboxUtils.SetLayerDeep(obj.transform, LayerMask.NameToLayer("VirtualRender"));
			obj.transform.localScale *= fish.previewSizeMulti;
			StartCoroutine(AutoDismissFishCaught());
			StartCoroutine(ShowSize());
		}
	}

	public void ShowOutOfWater()
	{
		outOfWaterMessage.SetActive(value: true);
	}

	public void SetStruggleProgress(float progress, Sprite fishIconLocked, Sprite fishIconUnlocked)
	{
		struggleProgressSlider.value = progress;
		struggleProgressIcon.sprite = fishIconUnlocked;
		struggleProgressIconOverlay.sprite = fishIconLocked;
		Color color = struggleProgressIconOverlay.color;
		color.a = 1f - progress;
		struggleProgressIconOverlay.color = color;
	}

	public void SetStruggleSatisfied(bool satisfied)
	{
		struggleNub.color = (satisfied ? Color.green : Color.white);
	}

	public void SetPlayerStrugglePosition(float pos)
	{
		struggleNub.rectTransform.anchoredPosition = new Vector2(0f, (0f - pos) * containerHeight);
		if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
		{
			struggleLMB.text = MonoSingleton<InputManager>.Instance.InputSource.Fire1.Action.bindings.First().ToDisplayString();
			struggleRMB.text = MonoSingleton<InputManager>.Instance.InputSource.Fire2.Action.bindings.First().ToDisplayString();
		}
		else
		{
			struggleLMB.text = "LMB";
			struggleRMB.text = "RMB";
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			struggleLMB.color = new Color(1f, 0.5f, 0.1f);
			downArrow.color = new Color(1f, 0.5f, 0.1f);
			timeSinceLMBReleased = 0f;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed)
		{
			struggleRMB.color = new Color(1f, 0.5f, 0.1f);
			upArrow.color = new Color(1f, 0.5f, 0.1f);
			timeSinceRMBReleased = 0f;
		}
	}

	public void SetFishDesire(float top, float bottom)
	{
		desireBar.offsetMin = new Vector2(desireBar.offsetMin.x, (1f - bottom) * containerHeight);
		desireBar.offsetMax = new Vector2(desireBar.offsetMax.x, (0f - top) * containerHeight);
	}

	private IEnumerator ShowSize()
	{
		yield return new WaitForSeconds(1f);
		fishSizeContainer.SetActive(value: true);
	}

	private IEnumerator AutoDismissFishCaught()
	{
		yield return new WaitForSeconds(4f);
		ShowFishCaught(show: false);
	}
}



public class FishingRodAnimEvents : MonoBehaviour
{
	[SerializeField]
	private FishingRodWeapon weapon;

	public void ThrowBaitEvent()
	{
		weapon.ThrowBaitEvent();
	}
}


public enum FishingRodState
{
	ReadyToThrow,
	SelectingPower,
	Throwing,
	WaitingForFish,
	FishStruggle
}



public class FishingRodTarget : MonoBehaviour
{
	[SerializeField]
	private GameObject goodBadge;

	[SerializeField]
	private GameObject badBadge;

	[SerializeField]
	private Transform canvas;

	public Text waterNameText;

	private void Awake()
	{
		goodBadge.SetActive(value: false);
		badBadge.SetActive(value: false);
	}

	public void SetState(bool isGood, float distance)
	{
		goodBadge.SetActive(isGood);
		badBadge.SetActive(!isGood);
		canvas.localScale = Vector3.one * (0.4f + distance * 0.05f);
	}
}



public class FishingRodWeapon : MonoBehaviour
{
	[SerializeField]
	private Animator animator;

	[SerializeField]
	private FishingRodTarget targetPrefab;

	[SerializeField]
	private FishBait baitPrefab;

	[SerializeField]
	private Transform rodTip;

	[SerializeField]
	private ItemIdentifier fishPickupTemplate;

	public AudioSource pullSound;

	private FishingRodTarget targetingCircle;

	private FishBait spawnedBaitCon;

	private FishingRodState state;

	private float selectedPower;

	private bool climaxed;

	private static readonly int Set = Animator.StringToHash("Set");

	private static readonly int Throw = Animator.StringToHash("Throw");

	private bool baitThrown;

	private float distanceAfterThrow;

	private bool fishHooked;

	private FishDB currentFishPool;

	private Water currentWater;

	private FishDescriptor hookedFishe;

	private static readonly int Pull = Animator.StringToHash("Pull");

	private static readonly int Idle = Animator.StringToHash("Idle");

	private float fishTolerance = 0.5f;

	private float fishDesirePosition = 0.25f;

	private float playerProvidedPosition;

	private float playerPositionVelocity;

	private TimeSince timeSinceBaitInWater;

	private TimeSince timeSinceAction;

	private bool noFishErrorDisplayed;

	public static float suggestedDistanceMulti = 1f;

	public static float minDistanceMulti = 1f;

	private float bottomBound => fishDesirePosition + fishTolerance / 2f;

	private float topBound => fishDesirePosition - fishTolerance / 2f;

	private bool struggleSatisfied
	{
		get
		{
			if (playerProvidedPosition < bottomBound)
			{
				return playerProvidedPosition > topBound;
			}
			return false;
		}
	}

	private Vector3 approximateTargetPosition => MonoSingleton<NewMovement>.Instance.transform.position + (MonoSingleton<NewMovement>.Instance.transform.forward * 10f * minDistanceMulti + MonoSingleton<NewMovement>.Instance.transform.forward * 35f * selectedPower) * suggestedDistanceMulti - Vector3.up * 1.9f;

	public void ThrowBaitEvent()
	{
		if (spawnedBaitCon == null)
		{
			spawnedBaitCon = Object.Instantiate(baitPrefab, rodTip.position, Quaternion.identity, rodTip);
			spawnedBaitCon.landed = false;
			spawnedBaitCon.ThrowStart(targetingCircle.transform.position, rodTip, this);
		}
	}

	private void Awake()
	{
		suggestedDistanceMulti = 1f;
		timeSinceAction = 0f;
	}

	private void OnEnable()
	{
		ResetFishing();
		MonoSingleton<FishingHUD>.Instance.ShowHUD();
	}

	public static GameObject CreateFishPickup(ItemIdentifier template, FishObject fish, bool grab, bool unlock = true)
	{
		if (unlock)
		{
			MonoSingleton<FishManager>.Instance.UnlockFish(fish);
		}
		if (grab)
		{
			if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
			{
				Object.Destroy(MonoSingleton<FistControl>.Instance.heldObject.gameObject);
			}
			MonoSingleton<FistControl>.Instance.currentPunch.ResetHeldState();
		}
		ItemIdentifier itemIdentifier;
		if (fish.customPickup != null)
		{
			itemIdentifier = Object.Instantiate(fish.customPickup);
			if (!itemIdentifier.GetComponent<FishObjectReference>())
			{
				itemIdentifier.gameObject.AddComponent<FishObjectReference>().fishObject = fish;
			}
		}
		else
		{
			itemIdentifier = Object.Instantiate(template);
			itemIdentifier.gameObject.AddComponent<FishObjectReference>().fishObject = fish;
			Transform obj = itemIdentifier.transform.GetChild(0).transform;
			Vector3 localPosition = obj.localPosition;
			Quaternion localRotation = obj.localRotation;
			Vector3 localScale = obj.localScale;
			Object.Destroy(obj.gameObject);
			GameObject obj2 = fish.InstantiateDumb();
			obj2.transform.SetParent(itemIdentifier.transform);
			obj2.transform.localPosition = localPosition;
			obj2.transform.localRotation = localRotation;
			obj2.transform.localScale = localScale;
		}
		if (grab)
		{
			MonoSingleton<FistControl>.Instance.currentPunch.ForceHold(itemIdentifier);
		}
		return itemIdentifier.gameObject;
	}

	public void FishCaughtAndGrabbed()
	{
		animator.SetTrigger(Idle);
		MonoSingleton<FishingHUD>.Instance.ShowFishCaught(show: true, hookedFishe.fish);
		CreateFishPickup(fishPickupTemplate, hookedFishe.fish, grab: true);
		ResetFishing();
	}

	private void ResetFishing()
	{
		state = FishingRodState.ReadyToThrow;
		if ((bool)spawnedBaitCon)
		{
			spawnedBaitCon.Dispose();
			Object.Destroy(spawnedBaitCon.gameObject);
		}
		if ((bool)targetingCircle)
		{
			Object.Destroy(targetingCircle.gameObject);
		}
		selectedPower = 0f;
		climaxed = false;
		baitThrown = false;
		animator.ResetTrigger(Idle);
		animator.ResetTrigger(Throw);
		fishHooked = false;
		timeSinceAction = 0f;
		noFishErrorDisplayed = false;
		MonoSingleton<FishingHUD>.Instance.SetFishHooked(hooked: false);
	}

	private void OnGUI()
	{
	}

	private void Update()
	{
		if (GameStateManager.Instance.PlayerInputLocked || MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo())
		{
			return;
		}
		if ((float)MonoSingleton<FishingHUD>.Instance.timeSinceFishCaught >= 1f && (MonoSingleton<InputManager>.Instance.InputSource.Punch.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame))
		{
			MonoSingleton<FishingHUD>.Instance.ShowFishCaught(show: false);
		}
		MonoSingleton<FishingHUD>.Instance.SetState(state);
		switch (state)
		{
		case FishingRodState.ReadyToThrow:
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && (float)timeSinceAction > 0.1f)
			{
				MonoSingleton<FishingHUD>.Instance.SetPowerMeter(0f, canFish: false);
				selectedPower = 0f;
				climaxed = false;
				fishHooked = false;
				baitThrown = false;
				state = FishingRodState.SelectingPower;
				targetingCircle = Object.Instantiate(targetPrefab, approximateTargetPosition, Quaternion.identity);
				timeSinceAction = 0f;
			}
			break;
		case FishingRodState.SelectingPower:
		{
			selectedPower += (Time.deltaTime * 0.4f + selectedPower * 0.01f) * (climaxed ? (-0.5f) : 1f);
			if (selectedPower > 1f)
			{
				selectedPower = 1f;
				climaxed = true;
			}
			if (selectedPower < 0.1f)
			{
				climaxed = false;
			}
			Vector3 vector = approximateTargetPosition;
			bool flag = false;
			if (Physics.Raycast(vector + Vector3.up * 3f, Vector3.down, out var hitInfo, 30f))
			{
				vector = hitInfo.point;
				if (hitInfo.collider.gameObject.layer == LayerMask.NameToLayer("Water"))
				{
					if (hitInfo.collider.TryGetComponent<Water>(out var component) && (bool)component.fishDB)
					{
						currentFishPool = component.fishDB;
						currentWater = component;
						flag = true;
						if ((bool)component.overrideFishingPoint)
						{
							vector = component.overrideFishingPoint.position;
						}
					}
					else
					{
						currentFishPool = null;
						currentWater = null;
						flag = false;
					}
				}
				else
				{
					currentFishPool = null;
					currentWater = null;
					flag = false;
				}
			}
			else
			{
				currentFishPool = null;
				currentWater = null;
				flag = false;
			}
			MonoSingleton<FishingHUD>.Instance.SetPowerMeter(selectedPower, flag);
			if (flag)
			{
				targetingCircle.transform.position = vector + Vector3.up * 0.5f;
				targetingCircle.SetState(isGood: true, Vector3.Distance(hitInfo.point, MonoSingleton<NewMovement>.Instance.transform.position));
				targetingCircle.waterNameText.text = currentFishPool.fullName;
				targetingCircle.waterNameText.color = currentFishPool.symbolColor;
			}
			else
			{
				targetingCircle.transform.position = vector + Vector3.up * 0.5f;
				targetingCircle.SetState(isGood: false, Vector3.Distance(hitInfo.point, MonoSingleton<NewMovement>.Instance.transform.position));
				targetingCircle.waterNameText.text = "";
			}
			targetingCircle.transform.forward = MonoSingleton<NewMovement>.Instance.transform.forward;
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasCanceledThisFrame && (float)timeSinceAction > 0.1f)
			{
				if (flag)
				{
					targetingCircle.GetComponent<Animator>().SetTrigger(Set);
					animator.ResetTrigger(Throw);
					state = FishingRodState.Throwing;
					timeSinceAction = 0f;
				}
				else
				{
					ResetFishing();
				}
			}
			break;
		}
		case FishingRodState.Throwing:
			targetingCircle.transform.forward = MonoSingleton<NewMovement>.Instance.transform.forward;
			fishHooked = false;
			if (!baitThrown)
			{
				baitThrown = true;
				animator.SetTrigger(Throw);
			}
			if ((bool)spawnedBaitCon && spawnedBaitCon.landed)
			{
				state = FishingRodState.WaitingForFish;
				timeSinceBaitInWater = 0f;
				distanceAfterThrow = Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, spawnedBaitCon.baitPoint.position);
				Object.Destroy(targetingCircle.gameObject);
			}
			break;
		case FishingRodState.WaitingForFish:
			baitThrown = false;
			if (Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, spawnedBaitCon.baitPoint.position) > distanceAfterThrow + 30f)
			{
				Object.Destroy(spawnedBaitCon.gameObject);
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Fishing interrupted");
				ResetFishing();
				break;
			}
			if (!fishHooked && Random.value < 0.002f + (float)timeSinceBaitInWater * 0.01f)
			{
				hookedFishe = currentFishPool.GetRandomFish(currentWater.attractFish);
				if (hookedFishe == null)
				{
					if (!noFishErrorDisplayed)
					{
						noFishErrorDisplayed = true;
						MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Nothing seems to be biting here...");
					}
					break;
				}
				currentWater.attractFish = null;
				fishHooked = true;
				MonoSingleton<FishingHUD>.Instance.SetFishHooked(hooked: true);
				spawnedBaitCon.FishHooked();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed || MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed)
			{
				animator.SetTrigger(Pull);
				if (fishHooked)
				{
					MonoSingleton<FishingHUD>.Instance.SetFishHooked(hooked: false);
					state = FishingRodState.FishStruggle;
					spawnedBaitCon.CatchFish(hookedFishe.fish);
				}
				else
				{
					Object.Destroy(spawnedBaitCon.gameObject);
					animator.SetTrigger(Idle);
					animator.ResetTrigger(Throw);
					animator.Play(Idle);
					ResetFishing();
				}
			}
			break;
		case FishingRodState.FishStruggle:
			fishDesirePosition = Mathf.PerlinNoise(Time.time * 0.3f, 0f);
			fishTolerance = 0.1f + 0.4f * Mathf.PerlinNoise(Time.time * 0.4f, 0f);
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
			{
				playerPositionVelocity += 1.9f * Time.deltaTime;
				animator.SetTrigger(Pull);
			}
			else if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed)
			{
				playerPositionVelocity -= 1.9f * Time.deltaTime;
				animator.SetTrigger(Pull);
			}
			else
			{
				playerPositionVelocity *= 1f - 2f * Time.deltaTime;
			}
			playerProvidedPosition += playerPositionVelocity * Time.deltaTime;
			if (playerProvidedPosition > 1f)
			{
				playerProvidedPosition = 1f;
				playerPositionVelocity = 0f - playerPositionVelocity;
			}
			if (playerProvidedPosition < 0f)
			{
				playerProvidedPosition = 0f;
				playerPositionVelocity = 0f - playerPositionVelocity;
			}
			MonoSingleton<FishingHUD>.Instance.SetPlayerStrugglePosition(playerProvidedPosition);
			MonoSingleton<FishingHUD>.Instance.SetStruggleSatisfied(struggleSatisfied);
			MonoSingleton<FishingHUD>.Instance.SetFishDesire(Mathf.Clamp01(topBound), Mathf.Clamp01(bottomBound));
			spawnedBaitCon.allowedToProgress = struggleSatisfied;
			MonoSingleton<FishingHUD>.Instance.SetStruggleProgress(spawnedBaitCon.flyProgress, hookedFishe.fish.blockedIcon, hookedFishe.fish.icon);
			break;
		}
	}
}



public class FishLeaderboard : MonoBehaviour
{
	[SerializeField]
	private TMP_Text globalText;

	[SerializeField]
	private TMP_Text friendsText;

	private void OnEnable()
	{
		Fetch();
	}

	private async void Fetch()
	{
		LeaderboardEntry[] obj = await MonoSingleton<LeaderboardController>.Instance.GetFishScores(LeaderboardType.Global);
		StringBuilder strBlrd = new StringBuilder();
		strBlrd.AppendLine("<b>GLOBAL</b>");
		int num = 1;
		LeaderboardEntry[] array = obj;
		for (int i = 0; i < array.Length; i++)
		{
			LeaderboardEntry leaderboardEntry = array[i];
			Friend user = leaderboardEntry.User;
			string arg = user.Name;
			user = leaderboardEntry.User;
			if (user.IsMe)
			{
				strBlrd.Append("<color=orange>");
			}
			string text = $"[{num}] {leaderboardEntry.Score} - {arg}";
			if (text.Length > 25)
			{
				text = text.Substring(0, 25);
			}
			strBlrd.AppendLine(text);
			user = leaderboardEntry.User;
			if (user.IsMe)
			{
				strBlrd.Append("</color>");
			}
			num++;
		}
		globalText.text = strBlrd.ToString();
		LeaderboardEntry[] obj2 = await MonoSingleton<LeaderboardController>.Instance.GetFishScores(LeaderboardType.Friends);
		strBlrd.Clear();
		strBlrd.AppendLine("<b>FRIENDS</b>");
		array = obj2;
		for (int i = 0; i < array.Length; i++)
		{
			LeaderboardEntry leaderboardEntry2 = array[i];
			Friend user = leaderboardEntry2.User;
			string arg2 = user.Name;
			user = leaderboardEntry2.User;
			if (user.IsMe)
			{
				strBlrd.Append("<color=orange>");
			}
			string text2 = $"[{leaderboardEntry2.GlobalRank}] {leaderboardEntry2.Score} - {arg2}";
			if (text2.Length > 25)
			{
				text2 = text2.Substring(0, 25);
			}
			strBlrd.AppendLine(text2);
			user = leaderboardEntry2.User;
			if (user.IsMe)
			{
				strBlrd.Append("</color>");
			}
		}
		friendsText.text = strBlrd.ToString();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class FishManager : MonoSingleton<FishManager>
{
	[SerializeField]
	private FishDB[] fishDbs;

	public Dictionary<FishObject, bool> recognizedFishes = new Dictionary<FishObject, bool>();

	public Action<FishObject> onFishUnlocked;

	public int RemainingFishes => recognizedFishes.Count((KeyValuePair<FishObject, bool> f) => !f.Value);

	protected override void Awake()
	{
		FishDB[] array = fishDbs;
		for (int i = 0; i < array.Length; i++)
		{
			FishDescriptor[] foundFishes = array[i].foundFishes;
			for (int j = 0; j < foundFishes.Length; j++)
			{
				FishObject fish = foundFishes[j].fish;
				if (!recognizedFishes.ContainsKey(fish))
				{
					recognizedFishes.Add(fish, value: false);
				}
			}
		}
	}

	public bool UnlockFish(FishObject fish)
	{
		if (!recognizedFishes.ContainsKey(fish))
		{
			return false;
		}
		if (recognizedFishes[fish])
		{
			return false;
		}
		recognizedFishes[fish] = true;
		MonoSingleton<MapVarManager>.Instance.AddInt("UniqueFishCaught", 1);
		onFishUnlocked?.Invoke(fish);
		return true;
	}
}



public class FishMenuButton : MonoBehaviour
{
	[SerializeField]
	private Image fishIcon;

	public void Populate(FishObject fish, bool locked)
	{
		fishIcon.sprite = (locked ? fish.blockedIcon : fish.icon);
		fishIcon.color = (locked ? Color.black : Color.white);
	}
}



[CreateAssetMenu(fileName = "New Fish", menuName = "ULTRAKILL/Fish")]
public class FishObject : ScriptableObject
{
	public string fishName;

	public GameObject worldObject;

	[FormerlySerializedAs("pickup")]
	public ItemIdentifier customPickup;

	public Sprite icon;

	public Sprite blockedIcon;

	public bool canBeCooked = true;

	[TextArea]
	public string description;

	public float previewSizeMulti = 1f;

	public GameObject InstantiateWorld(Vector3 position = default(Vector3))
	{
		GameObject gameObject = Object.Instantiate(worldObject, position, Quaternion.identity);
		gameObject.name = fishName;
		return gameObject;
	}

	public GameObject InstantiateDumb()
	{
		return InstantiateWorld();
	}
}



public class FishObjectReference : MonoBehaviour
{
	public FishObject fishObject;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class FistControl : MonoSingleton<FistControl>
{
	private InputManager inman;

	public ForcedLoadout forcedLoadout;

	public AssetReference blueArm;

	public AssetReference redArm;

	public AssetReference goldArm;

	private int currentOrderNum;

	private int currentVarNum;

	private List<GameObject> spawnedArms = new List<GameObject>();

	private List<int> spawnedArmNums = new List<int>();

	private AudioSource aud;

	public bool shopping;

	private int shopRequests;

	public GameObject[] fistPanels;

	public Image fistIcon;

	public ItemIdentifier heldObject;

	public float fistCooldown;

	public float weightCooldown;

	private bool _activated = true;

	public Punch currentPunch;

	[HideInInspector]
	public int forceNoHold;

	private bool zooming;

	public bool activated
	{
		get
		{
			if (_activated)
			{
				return !MonoSingleton<OptionsManager>.Instance.paused;
			}
			return false;
		}
		set
		{
			_activated = value;
		}
	}

	public GameObject currentArmObject => spawnedArms[currentOrderNum];

	private void Start()
	{
		inman = MonoSingleton<InputManager>.Instance;
		aud = GetComponent<AudioSource>();
		currentVarNum = PlayerPrefs.GetInt("CurArm", 0);
		ResetFists();
		fistCooldown = 0f;
	}

	private void Update()
	{
		if (fistCooldown > -1f)
		{
			fistCooldown = Mathf.MoveTowards(fistCooldown, 0f, Time.deltaTime * 2f);
		}
		if (weightCooldown > 0f)
		{
			weightCooldown = Mathf.MoveTowards(weightCooldown, 0f, Time.deltaTime * (weightCooldown / 2f + 0.1f));
		}
		if (!MonoSingleton<OptionsManager>.Instance.paused && fistCooldown <= 0f)
		{
			if (inman.InputSource.Actions.Fist.PunchFeedbacker.WasPerformedThisFrame() && (currentVarNum == 0 || ForceArm(0)))
			{
				currentPunch.heldAction = MonoSingleton<InputManager>.Instance.InputSource.Actions.Fist.PunchFeedbacker;
				currentPunch.PunchStart();
			}
			if (inman.InputSource.Actions.Fist.PunchKnuckleblaster.WasPerformedThisFrame() && (currentVarNum == 1 || ForceArm(1)))
			{
				currentPunch.heldAction = MonoSingleton<InputManager>.Instance.InputSource.Actions.Fist.PunchKnuckleblaster;
				currentPunch.PunchStart();
			}
		}
		if (!MonoSingleton<OptionsManager>.Instance || MonoSingleton<OptionsManager>.Instance.mainMenu || MonoSingleton<OptionsManager>.Instance.inIntro || MonoSingleton<OptionsManager>.Instance.paused || ((bool)MonoSingleton<ScanningStuff>.Instance && MonoSingleton<ScanningStuff>.Instance.IsReading) || GameStateManager.Instance.PlayerInputLocked)
		{
			return;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && shopping)
		{
			zooming = true;
			MonoSingleton<CameraController>.Instance.Zoom(MonoSingleton<CameraController>.Instance.defaultFov / 2f);
		}
		else if (zooming)
		{
			zooming = false;
			MonoSingleton<CameraController>.Instance.StopZoom();
		}
		if (spawnedArms.Count > 1 && !shopping && (MonoSingleton<SpawnMenu>.Instance == null || !MonoSingleton<SpawnMenu>.Instance.gameObject.activeInHierarchy))
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.ChangeFist.WasPerformedThisFrame)
			{
				ScrollArm();
			}
		}
		else if (spawnedArms.Count > 0 && currentPunch == null)
		{
			ArmChange(0);
		}
		if (spawnedArms.Count == 0 && MonoSingleton<InputManager>.Instance.InputSource.Punch.WasPerformedThisFrame && (forcedLoadout == null || forcedLoadout.arm.blueVariant != VariantOption.ForceOff || forcedLoadout.arm.redVariant != VariantOption.ForceOff))
		{
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=red>CAN'T PUNCH IF YOU HAVE NO ARM EQUIPPED, DUMBASS</color>\nArms can be re-equipped at the shop");
		}
	}

	public void ScrollArm()
	{
		if (currentOrderNum < spawnedArms.Count - 1)
		{
			ArmChange(currentOrderNum + 1);
		}
		else
		{
			ArmChange(0);
		}
		aud.Play();
	}

	public void RefreshArm()
	{
		ArmChange(currentOrderNum);
	}

	public bool ForceArm(int varNum, bool animation = false)
	{
		bool result = false;
		if (spawnedArmNums.Contains(varNum))
		{
			ArmChange(spawnedArmNums.IndexOf(varNum));
			result = true;
		}
		if (animation)
		{
			Punch component;
			if (varNum == 2)
			{
				MonoSingleton<HookArm>.Instance.Inspect();
			}
			else if (spawnedArms[currentOrderNum].TryGetComponent<Punch>(out component))
			{
				component.EquipAnimation();
			}
			aud.Play();
		}
		return result;
	}

	public void ArmChange(int orderNum)
	{
		if (orderNum < spawnedArms.Count)
		{
			if (currentOrderNum < spawnedArms.Count)
			{
				spawnedArms[currentOrderNum].SetActive(value: false);
			}
			spawnedArms[orderNum].SetActive(value: true);
			currentOrderNum = orderNum;
			currentVarNum = spawnedArmNums[orderNum];
			PlayerPrefs.SetInt("CurArm", currentVarNum);
			UpdateFistIcon();
			currentPunch = currentArmObject.GetComponent<Punch>();
		}
	}

	public void UpdateFistIcon()
	{
		if ((bool)fistIcon)
		{
			int num = currentVarNum;
			switch (num)
			{
			case 1:
				num = 2;
				break;
			case 2:
				num = 1;
				break;
			}
			fistIcon.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[num];
		}
	}

	public void NoFist()
	{
		if (spawnedArms.Count > 0)
		{
			spawnedArms[currentOrderNum].SetActive(value: false);
		}
		activated = false;
	}

	public void YesFist()
	{
		if (spawnedArms.Count > 0)
		{
			spawnedArms[currentOrderNum].SetActive(value: true);
		}
		activated = true;
		UpdateFistIcon();
	}

	public void ResetFists()
	{
		if (spawnedArms.Count > 0)
		{
			for (int i = 0; i < spawnedArms.Count; i++)
			{
				Object.Destroy(spawnedArms[i]);
			}
			spawnedArms.Clear();
			spawnedArmNums.Clear();
		}
		MonoSingleton<HookArm>.Instance.equipped = false;
		if ((MonoSingleton<PrefsManager>.Instance.GetInt("weapon.arm0", 1) == 1 && (forcedLoadout == null || forcedLoadout.arm.blueVariant == VariantOption.IfEquipped)) || (forcedLoadout != null && forcedLoadout.arm.blueVariant == VariantOption.ForceOn))
		{
			GameObject item = Object.Instantiate(blueArm.ToAsset(), base.transform);
			spawnedArms.Add(item);
			spawnedArmNums.Add(0);
		}
		CheckFist("arm1");
		CheckFist("arm2");
		CheckFist("arm3");
		if (spawnedArms.Count <= 1 || !MonoSingleton<PrefsManager>.Instance.GetBool("armIcons"))
		{
			GameObject[] array = fistPanels;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: false);
			}
		}
		else
		{
			GameObject[] array = fistPanels;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: true);
			}
		}
		ForceArm(currentVarNum);
		UpdateFistIcon();
	}

	private void CheckFist(string name)
	{
		if (forcedLoadout != null)
		{
			if (!(name == "arm1"))
			{
				if (name == "arm2")
				{
					if (forcedLoadout.arm.greenVariant == VariantOption.ForceOn)
					{
						MonoSingleton<HookArm>.Instance.equipped = true;
						return;
					}
					if (forcedLoadout.arm.greenVariant == VariantOption.ForceOff)
					{
						return;
					}
				}
			}
			else
			{
				if (forcedLoadout.arm.redVariant == VariantOption.ForceOn)
				{
					spawnedArmNums.Add(1);
					spawnedArms.Add(Object.Instantiate(redArm.ToAsset(), base.transform));
					return;
				}
				if (forcedLoadout.arm.redVariant == VariantOption.ForceOff)
				{
					return;
				}
			}
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + name, 1) == 1 && GameProgressSaver.CheckGear(name) == 1)
		{
			GameObject gameObject = null;
			switch (name)
			{
			case "arm1":
				gameObject = Object.Instantiate(redArm.ToAsset(), base.transform);
				spawnedArmNums.Add(1);
				break;
			case "arm2":
				MonoSingleton<HookArm>.Instance.equipped = true;
				break;
			case "arm3":
				gameObject = Object.Instantiate(goldArm.ToAsset(), base.transform);
				spawnedArmNums.Add(3);
				break;
			}
			if (gameObject != null)
			{
				spawnedArms.Add(gameObject);
			}
		}
	}

	public void ShopMode()
	{
		shopping = true;
		shopRequests++;
	}

	public void StopShop()
	{
		shopRequests--;
		if (shopRequests <= 0)
		{
			shopping = false;
		}
	}

	public void ResetHeldItemPosition()
	{
		if (heldObject.reverseTransformSettings)
		{
			heldObject.transform.localPosition = heldObject.putDownPosition;
			heldObject.transform.localScale = heldObject.putDownScale;
			heldObject.transform.localRotation = Quaternion.Euler(heldObject.putDownRotation);
		}
		else
		{
			heldObject.transform.localPosition = Vector3.zero;
			heldObject.transform.localScale = Vector3.one;
			heldObject.transform.localRotation = Quaternion.identity;
		}
		Transform[] componentsInChildren = heldObject.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.layer = 13;
		}
	}

	public void TutorialCheckForArmThatCanPunch()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weapon.arm0", 1) == 0 && MonoSingleton<PrefsManager>.Instance.GetInt("weapon.arm1", 1) == 0)
		{
			MonoSingleton<PrefsManager>.Instance.SetInt("weapon.arm0", 1);
			ResetFists();
		}
	}
}


public enum FistType
{
	Standard,
	Heavy,
	Spear
}



[DisallowMultipleComponent]
public sealed class FixedUpdateMessage : MessageDispatcher
{
	private void FixedUpdate()
	{
		base.Handler.Invoke();
	}
}


public enum FlameSource
{
	None,
	Streetcleaner,
	Napalm
}



public class Flammable : MonoBehaviour
{
	public float heat;

	public float fuel;

	private GameObject currentFire;

	private AudioSource currentFireAud;

	private Light currentFireLight;

	public bool burning;

	private bool fading;

	public bool secondary;

	public bool fuelOnly;

	private bool enemy;

	private EnemyIdentifierIdentifier eidid;

	private Flammable[] flammables;

	public bool wet;

	private Breakable breakable;

	public bool playerOnly;

	public bool enemyOnly;

	public bool specialFlammable;

	public UnityEvent onSpecialActivate;

	private Collider col;

	private bool alwaysSimpleFire;

	private bool markedForDestroy;

	private void Start()
	{
		if (base.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
		{
			enemy = true;
			eidid = component;
		}
		if (base.gameObject.TryGetComponent<Breakable>(out var component2))
		{
			breakable = component2;
		}
		alwaysSimpleFire = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleFire");
	}

	private void OnEnable()
	{
		if (burning)
		{
			Pulse();
		}
	}

	private bool IsLossyScaleInvalid()
	{
		if (base.transform == null)
		{
			return true;
		}
		Vector3 lossyScale = base.transform.lossyScale;
		if (!float.IsNaN(lossyScale.x) && !float.IsNaN(lossyScale.y) && !float.IsNaN(lossyScale.z) && !float.IsInfinity(lossyScale.x) && !float.IsInfinity(lossyScale.y) && !float.IsInfinity(lossyScale.z) && lossyScale.x != 0f && lossyScale.y != 0f)
		{
			return lossyScale.z == 0f;
		}
		return true;
	}

	public void Burn(float newHeat, bool noInstaDamage = false)
	{
		if (markedForDestroy || (fuelOnly && fuel <= 0f))
		{
			return;
		}
		if (IsLossyScaleInvalid())
		{
			MarkForDestroy();
		}
		else if (specialFlammable)
		{
			onSpecialActivate?.Invoke();
		}
		else
		{
			if (wet || (enemy && (bool)eidid && (bool)eidid.eid && eidid.eid.blessed))
			{
				return;
			}
			if (col == null)
			{
				col = GetComponent<Collider>();
			}
			if (col == null)
			{
				MarkForDestroy();
				return;
			}
			if (fuelOnly)
			{
				heat = 0.1f;
			}
			else if (newHeat > heat)
			{
				heat = newHeat;
			}
			if (currentFire == null)
			{
				Bounds bounds = col.bounds;
				currentFire = MonoSingleton<FireObjectPool>.Instance.GetFire(secondary || alwaysSimpleFire);
				currentFire.transform.SetParent(base.transform);
				currentFire.transform.position = bounds.center;
				Vector3 lossyScale = base.transform.lossyScale;
				currentFire.transform.localScale = new Vector3(bounds.size.x / lossyScale.x, bounds.size.y / lossyScale.y, bounds.size.z / lossyScale.z);
				currentFireAud = currentFire.GetComponentInChildren<AudioSource>();
				if (!secondary && !alwaysSimpleFire)
				{
					currentFireLight = currentFire.GetComponent<Light>();
					currentFireLight.enabled = true;
				}
			}
			if ((bool)eidid && (bool)eidid.eid && !eidid.eid.burners.Contains(this))
			{
				eidid.eid.burners.Add(this);
			}
			if (enemy)
			{
				burning = true;
				if (eidid.eid.burners.Count == 1)
				{
					eidid.eid.Burn();
				}
			}
			if (breakable != null)
			{
				breakable.Burn();
			}
			if (!secondary)
			{
				flammables = GetComponentsInChildren<Flammable>();
				Flammable[] array = flammables;
				foreach (Flammable flammable in array)
				{
					if (flammable != this)
					{
						flammable.secondary = true;
						flammable.Burn(heat);
						flammable.Pulse();
					}
				}
			}
			burning = true;
		}
	}

	public void Pulse()
	{
		if (markedForDestroy)
		{
			return;
		}
		if (IsLossyScaleInvalid())
		{
			MarkForDestroy();
		}
		else if (burning)
		{
			if (fuel >= 0.175f)
			{
				fuel -= 0.175f;
			}
			else if (fuel > 0f)
			{
				heat = 0.175f - fuel;
				fuel = 0f;
			}
			else
			{
				heat -= 0.25f;
			}
			if (heat <= 0f)
			{
				burning = false;
				fading = true;
				Invoke("Pulse", Random.Range(0.25f, 0.5f));
			}
			else if (!enemy)
			{
				Invoke("Pulse", 0.5f);
				TryIgniteGasoline();
			}
		}
		else
		{
			if (!fading || !(currentFire != null))
			{
				return;
			}
			if (fuel > 0f)
			{
				Burn(0.1f);
				CancelInvoke("Pulse");
				currentFire.transform.localScale = new Vector3(col.bounds.size.x / base.transform.lossyScale.x, col.bounds.size.y / base.transform.lossyScale.y, col.bounds.size.z / base.transform.lossyScale.z);
				return;
			}
			if (currentFire != null)
			{
				currentFire.transform.localScale *= 0.75f;
				if (currentFireAud == null)
				{
					currentFireAud = currentFire.GetComponentInChildren<AudioSource>();
				}
				currentFireAud.volume *= 0.75f;
				if (!secondary && currentFireLight != null)
				{
					currentFireLight.range *= 0.75f;
				}
			}
			if (currentFire.transform.localScale.x < 0.1f)
			{
				fading = false;
				ReturnToQueue();
			}
			else
			{
				Invoke("Pulse", Random.Range(0.25f, 0.5f));
			}
		}
	}

	private void TryIgniteGasoline()
	{
		MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position);
	}

	public void PutOut(bool getWet = true)
	{
		wet = getWet;
		if ((bool)currentFire)
		{
			heat = 0f;
			burning = false;
			fading = false;
			ReturnToQueue();
		}
		if (secondary || flammables == null)
		{
			return;
		}
		Flammable[] array = flammables;
		foreach (Flammable flammable in array)
		{
			if (flammable != this)
			{
				flammable.PutOut();
			}
		}
	}

	public void MarkForDestroy()
	{
		markedForDestroy = true;
		ReturnToQueue();
		EnemyIdentifierIdentifier component;
		if (fuelOnly)
		{
			Object.Destroy(this, Random.Range(0.001f, 0.01f));
		}
		else if (TryGetComponent<EnemyIdentifierIdentifier>(out component))
		{
			component.Invoke("DestroyLimb", Random.Range(0.001f, 0.01f));
		}
		else
		{
			Object.Destroy(base.gameObject, Random.Range(0.001f, 0.01f));
		}
	}

	public void ReturnToQueue()
	{
		if (currentFire != null)
		{
			MonoSingleton<FireObjectPool>.Instance.ReturnFire(currentFire, secondary || alwaysSimpleFire);
			currentFire = null;
		}
	}
}



public class FlashImage : MonoBehaviour
{
	private Image img;

	private bool flashing;

	public float speed;

	public float flashAlpha;

	public bool dontFlashOnEnable;

	public bool oneTime;

	private bool flashed;

	private void OnEnable()
	{
		if (!dontFlashOnEnable && (!oneTime || !flashed))
		{
			Flash(flashAlpha);
		}
	}

	public void Flash(float amount)
	{
		if (oneTime)
		{
			if (flashed)
			{
				return;
			}
			flashed = true;
		}
		if (!img)
		{
			img = GetComponent<Image>();
		}
		img.color = new Color(img.color.r, img.color.g, img.color.b, amount);
		flashing = true;
	}

	private void Update()
	{
		if (flashing && (bool)img)
		{
			img.color = new Color(img.color.r, img.color.g, img.color.b, Mathf.MoveTowards(img.color.a, 0f, Time.deltaTime * speed));
			if (img.color.a <= 0f)
			{
				flashing = false;
			}
		}
	}
}



public class FlashingText : MonoBehaviour
{
	private TextMeshProUGUI text;

	private Color originalColor;

	public Color flashColor;

	public float fadeTime;

	private float fading = 1f;

	public float delay;

	private float cooldown;

	public bool forcePreciseTiming;

	public AudioSource[] matchToMusic;

	private void Start()
	{
		text = GetComponent<TextMeshProUGUI>();
		originalColor = text.color;
		text.color = flashColor;
		if (forcePreciseTiming)
		{
			Invoke("Flash", fadeTime + delay);
		}
	}

	private void Update()
	{
		if (matchToMusic.Length != 0)
		{
			for (int num = matchToMusic.Length - 1; num >= 0; num--)
			{
				if (matchToMusic[num].isPlaying)
				{
					text.color = Color.Lerp(flashColor, originalColor, matchToMusic[num].time % (fadeTime + delay));
					break;
				}
			}
			return;
		}
		fading = Mathf.MoveTowards(fading, 0f, Time.deltaTime / fadeTime);
		text.color = Color.Lerp(originalColor, flashColor, fading);
		if (fading == 0f)
		{
			if (cooldown != 0f)
			{
				cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
			}
			if (cooldown == 0f)
			{
				fading = 1f;
				cooldown = delay;
			}
		}
	}

	private void Flash()
	{
		fading = 1f;
		cooldown = delay;
		text.color = Color.Lerp(originalColor, flashColor, 1f);
		if (forcePreciseTiming)
		{
			Invoke("Flash", fadeTime + delay);
		}
	}
}



public class FleshPrison : MonoBehaviour
{
	public Transform rotationBone;

	private Collider col;

	private Animator anim;

	public bool altVersion;

	private Texture currentIdleTexture;

	private Texture defaultTexture;

	public Texture[] idleTextures;

	private float idleTimer = 0.5f;

	public Texture hurtTexture;

	public Texture attackTexture;

	[SerializeField]
	private EnemySimplifier mainSimplifier;

	private AudioSource aud;

	private BossHealthBar bossHealth;

	private float secondaryBarValue;

	private bool started;

	private bool inAction;

	private float health;

	private EnemyIdentifier eid;

	private Statue stat;

	private bool hurting;

	private bool shakingCamera;

	private Vector3 origPos;

	public GameObject fleshDrone;

	public GameObject skullDrone;

	private float fleshDroneCooldown = 3f;

	private int droneAmount = 10;

	private int currentDrone;

	private GameObject targeter;

	private bool healing;

	public List<DroneFlesh> currentDrones = new List<DroneFlesh>();

	public GameObject healingTargetEffect;

	public GameObject healingEffect;

	private float rotationSpeed = 45f;

	private float rotationSpeedTarget = 45f;

	private float attackCooldown = 5f;

	private int previousAttack = 666;

	public GameObject insignia;

	private float maxHealth;

	public GameObject homingProjectile;

	private int projectileAmount = 40;

	private int currentProjectile = 40;

	private float homingProjectileCooldown;

	public GameObject attackWindUp;

	public GameObject blackHole;

	private BlackHoleProjectile currentBlackHole;

	private int difficulty;

	public UltrakillEvent onFirstHeal;

	private int timesHealed;

	private bool noDrones;

	private MaterialPropertyBlock texOverride;

	private float maxDroneCooldown => (!started) ? 3 : ((difficulty == 2) ? 25 : 30);

	private void Awake()
	{
		if (!mainSimplifier)
		{
			mainSimplifier = GetComponentInChildren<EnemySimplifier>();
		}
		eid = GetComponent<EnemyIdentifier>();
		stat = GetComponent<Statue>();
		aud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
	}

	private void Start()
	{
		if ((bool)mainSimplifier && !eid.puppet)
		{
			defaultTexture = mainSimplifier.originalMaterial.mainTexture;
		}
		maxHealth = stat.health;
		health = stat.health;
		origPos = rotationBone.localPosition;
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		col = rotationBone.GetComponentInChildren<EnemyIdentifierIdentifier>().GetComponent<Collider>();
		bossHealth = GetComponent<BossHealthBar>();
	}

	private void Update()
	{
		if (eid.puppet)
		{
			_ = (bool)mainSimplifier;
		}
		float num = Mathf.Abs(rotationSpeed);
		if (num < 45f)
		{
			num = 45f;
		}
		if (rotationSpeed != rotationSpeedTarget)
		{
			rotationSpeed = Mathf.MoveTowards(rotationSpeed, rotationSpeedTarget, Time.deltaTime * (num / 2f + 5f));
		}
		rotationBone.Rotate(Vector3.forward, Time.deltaTime * rotationSpeed * eid.totalSpeedModifier, Space.Self);
		if (eid.target == null)
		{
			return;
		}
		if (health > stat.health)
		{
			float num2 = health - stat.health;
			if (currentDrones.Count > 0)
			{
				for (int num3 = currentDrones.Count - 1; num3 >= 0; num3--)
				{
					if (currentDrones[num3] == null)
					{
						currentDrones.RemoveAt(num3);
					}
				}
			}
			if (currentDrones.Count > 8)
			{
				fleshDroneCooldown -= num2 * 1.5f;
			}
			else if (currentDrones.Count > 5)
			{
				fleshDroneCooldown -= num2 / 2.5f;
			}
			else if (currentDrones.Count > 0)
			{
				fleshDroneCooldown -= num2 / 5f;
			}
			else
			{
				fleshDroneCooldown -= num2 / 7.5f;
			}
			health = stat.health;
		}
		else if (health < stat.health)
		{
			health = stat.health;
		}
		if (bossHealth == null)
		{
			bossHealth = GetComponent<BossHealthBar>();
		}
		if ((bool)bossHealth)
		{
			if (!healing)
			{
				secondaryBarValue = Mathf.MoveTowards(secondaryBarValue, fleshDroneCooldown / maxDroneCooldown, (Mathf.Abs(secondaryBarValue - fleshDroneCooldown / maxDroneCooldown) + 1f) * Time.deltaTime);
			}
			bossHealth.UpdateSecondaryBar(secondaryBarValue);
		}
		if ((bool)anim && !noDrones)
		{
			anim.speed = ((!inAction) ? 1 : 5);
		}
		if (!inAction)
		{
			if (health > stat.health)
			{
				idleTimer = 0.15f;
				if (!eid.puppet)
				{
					mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, hurtTexture);
				}
				hurting = true;
			}
			else
			{
				idleTimer = Mathf.MoveTowards(idleTimer, 0f, Time.deltaTime * eid.totalSpeedModifier);
				if (hurting)
				{
					if (idleTimer > 0f)
					{
						rotationBone.transform.localPosition = new Vector3(origPos.x + Random.Range(0f - idleTimer, idleTimer), origPos.y, origPos.z + Random.Range(0f - idleTimer, idleTimer));
					}
					else
					{
						rotationBone.transform.localPosition = origPos;
						hurting = false;
					}
				}
				if (idleTimer == 0f && !eid.puppet)
				{
					if (currentIdleTexture == defaultTexture)
					{
						idleTimer = 0.25f;
						mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, idleTextures[Random.Range(0, idleTextures.Length)]);
					}
					else
					{
						idleTimer = Random.Range(0.5f, 1f);
						mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, defaultTexture);
					}
					mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, defaultTexture);
				}
				if (fleshDroneCooldown <= 0f)
				{
					started = true;
					for (int num4 = currentDrones.Count - 1; num4 >= 0; num4--)
					{
						if (currentDrones[num4] == null)
						{
							currentDrones.RemoveAt(num4);
						}
					}
					if (!eid.puppet)
					{
						mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, attackTexture);
					}
					idleTimer = 0f;
					fleshDroneCooldown = maxDroneCooldown;
					attackCooldown = 3f;
					inAction = true;
					rotationSpeed = 0f;
					rotationSpeedTarget = 0f;
					if (stat.health > maxHealth / 2f)
					{
						droneAmount = 10;
					}
					else
					{
						droneAmount = 12;
					}
					if (difficulty == 1)
					{
						droneAmount = Mathf.RoundToInt((float)droneAmount / 1.5f);
					}
					else if (difficulty == 0)
					{
						droneAmount /= 2;
					}
					if (altVersion)
					{
						droneAmount /= 2;
					}
					if (droneAmount < 3)
					{
						droneAmount = 3;
					}
					if (timesHealed == 1)
					{
						onFirstHeal?.Invoke();
					}
					timesHealed++;
					if (currentDrones.Count <= 0)
					{
						healing = true;
						secondaryBarValue = 0f;
						Invoke("SpawnFleshDrones", 1f / eid.totalSpeedModifier);
					}
					else
					{
						StartHealing();
					}
					shakingCamera = true;
					aud.Play();
				}
				else if (fleshDroneCooldown > 3f)
				{
					if (attackCooldown > 0f)
					{
						float num5 = 1f;
						if (difficulty == 1)
						{
							num5 = 0.9f;
						}
						else if (difficulty == 0)
						{
							num5 = 0.75f;
						}
						attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * num5 * eid.totalSpeedModifier);
					}
					else
					{
						int num6 = 2;
						if (!currentBlackHole && difficulty > 0)
						{
							num6 = 3;
						}
						int num7 = Random.Range(0, num6);
						if (num7 == previousAttack)
						{
							num7++;
						}
						if (num7 >= num6)
						{
							num7 = 0;
						}
						inAction = true;
						Color color = Color.white;
						float time = 1f / eid.totalSpeedModifier;
						switch (num7)
						{
						case 0:
							Invoke("SpawnInsignia", time);
							attackCooldown = 4f;
							break;
						case 1:
							Invoke("HomingProjectileAttack", time);
							color = ((!altVersion) ? new Color(0f, 1f, 0.9f) : new Color(1f, 0.75f, 0f));
							attackCooldown = 1f;
							break;
						case 2:
							Invoke("SpawnBlackHole", time);
							color = new Color(1f, 0f, 1f);
							attackCooldown = 2f;
							break;
						}
						GameObject obj = Object.Instantiate(attackWindUp, rotationBone.position, Quaternion.LookRotation(eid.target.position - rotationBone.position));
						if (obj.TryGetComponent<Light>(out var component))
						{
							component.color = color;
						}
						if (obj.TryGetComponent<SpriteRenderer>(out var component2))
						{
							component2.color = color;
						}
						previousAttack = num7;
					}
				}
			}
		}
		else
		{
			if (!eid.puppet)
			{
				mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, attackTexture);
			}
			idleTimer = 0f;
			if (currentProjectile < projectileAmount)
			{
				homingProjectileCooldown = Mathf.MoveTowards(homingProjectileCooldown, 0f, Time.deltaTime * (Mathf.Abs(rotationSpeed) / 10f) * eid.totalSpeedModifier);
				if (homingProjectileCooldown <= 0f)
				{
					GameObject gameObject = Object.Instantiate(homingProjectile, rotationBone.position + rotationBone.up * 8f, rotationBone.rotation);
					Projectile component3 = gameObject.GetComponent<Projectile>();
					component3.target = eid.target;
					component3.safeEnemyType = (altVersion ? EnemyType.FleshPanopticon : EnemyType.FleshPrison);
					if (difficulty >= 4)
					{
						component3.turningSpeedMultiplier = 0.66f;
					}
					else if (difficulty >= 2)
					{
						component3.turningSpeedMultiplier = 0.5f;
					}
					else if (difficulty == 1)
					{
						component3.turningSpeedMultiplier = 0.45f;
					}
					else
					{
						component3.turningSpeedMultiplier = 0.4f;
					}
					if (altVersion)
					{
						component3.turnSpeed *= 4f;
						component3.turningSpeedMultiplier *= 4f;
						component3.predictiveHomingMultiplier = 1.25f;
					}
					component3.damage *= eid.totalDamageModifier;
					homingProjectileCooldown = 1f;
					currentProjectile++;
					gameObject.transform.SetParent(base.transform, worldPositionStays: true);
					if (altVersion && gameObject.TryGetComponent<Rigidbody>(out var component4))
					{
						component4.AddForce(Vector3.up * 50f, ForceMode.VelocityChange);
					}
				}
				if (currentProjectile >= projectileAmount)
				{
					inAction = false;
					anim?.SetBool("Shooting", value: false);
					if (rotationSpeed >= 0f)
					{
						rotationSpeedTarget = 45f;
					}
					else
					{
						rotationSpeedTarget = -45f;
					}
					if (fleshDroneCooldown < 1f)
					{
						fleshDroneCooldown = 1f;
					}
				}
			}
		}
		if (fleshDroneCooldown > 0f)
		{
			fleshDroneCooldown = Mathf.MoveTowards(fleshDroneCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (shakingCamera)
		{
			MonoSingleton<CameraController>.Instance.CameraShake(0.25f);
		}
	}

	private void SpawnFleshDrones()
	{
		if (eid.target == null)
		{
			return;
		}
		if (currentDrone == 0)
		{
			targeter = new GameObject();
			targeter.transform.position = rotationBone.position;
			if (altVersion)
			{
				targeter.transform.rotation = Quaternion.LookRotation(Vector3.up);
			}
			else
			{
				targeter.transform.rotation = Quaternion.LookRotation(new Vector3(eid.target.position.x, targeter.transform.position.y, eid.target.position.z) - targeter.transform.position);
			}
		}
		if (currentDrone < droneAmount)
		{
			secondaryBarValue = (float)currentDrone / (float)droneAmount;
			GameObject gameObject = (((difficulty != 3 || currentDrone % 5 != 0) && (difficulty != 4 || currentDrone % 3 != 0) && difficulty != 5) ? Object.Instantiate(fleshDrone, targeter.transform.position + targeter.transform.up * (altVersion ? 50 : 20), targeter.transform.rotation) : Object.Instantiate(skullDrone, targeter.transform.position + targeter.transform.up * (altVersion ? 50 : 20), targeter.transform.rotation));
			gameObject.transform.SetParent(base.transform, worldPositionStays: true);
			if (gameObject.TryGetComponent<EnemyIdentifier>(out var component))
			{
				component.dontCountAsKills = true;
				component.damageBuff = eid.damageBuff;
				component.healthBuff = eid.healthBuff;
				component.speedBuff = eid.speedBuff;
			}
			targeter.transform.Rotate((altVersion ? Vector3.forward : Vector3.forward) * (360 / droneAmount));
			if (gameObject.TryGetComponent<DroneFlesh>(out var component2))
			{
				currentDrones.Add(component2);
			}
			currentDrone++;
			Invoke("SpawnFleshDrones", 0.1f / eid.totalSpeedModifier);
		}
		else
		{
			inAction = false;
			if (Random.Range(0, 2) == 0)
			{
				rotationSpeedTarget = 45f;
			}
			else
			{
				rotationSpeedTarget = -45f;
			}
			aud.Stop();
			shakingCamera = false;
			currentDrone = 0;
			Object.Destroy(targeter);
			fleshDroneCooldown = (altVersion ? 30 : 25);
			healing = false;
		}
	}

	private void StartHealing()
	{
		healing = true;
		secondaryBarValue = 0f;
		for (int i = 0; i < currentDrones.Count; i++)
		{
			if (currentDrones[i] == null)
			{
				currentDrones.RemoveAt(i);
				continue;
			}
			if (Object.Instantiate(healingTargetEffect, currentDrones[i].transform).TryGetComponent<LineToPoint>(out var component))
			{
				component.targets[1] = rotationBone;
			}
			if (currentDrones[i].TryGetComponent<Rigidbody>(out var component2))
			{
				component2.isKinematic = true;
			}
		}
		if (difficulty >= 1)
		{
			eid.totalDamageTakenMultiplier = 0.1f;
		}
		if (currentDrones.Count > 0)
		{
			Invoke("HealFromDrone", 5f / eid.totalSpeedModifier);
		}
		else
		{
			Invoke("SpawnFleshDrones", 1f / eid.totalSpeedModifier);
		}
	}

	private void HealFromDrone()
	{
		if (stat.health <= 0f)
		{
			return;
		}
		if (currentDrones.Count > 0)
		{
			if (currentDrones[0] != null)
			{
				float num = 1f;
				if (difficulty == 1)
				{
					num = 0.75f;
				}
				else if (difficulty == 0)
				{
					num = 0.35f;
				}
				num /= eid.totalHealthModifier;
				if (altVersion)
				{
					num *= 2f;
				}
				if (!Physics.Raycast(rotationBone.position, currentDrones[0].transform.position - rotationBone.position, Vector3.Distance(rotationBone.position, currentDrones[0].transform.position), LayerMaskDefaults.Get(LMD.Environment)))
				{
					if (stat.health + 10f * num <= maxHealth)
					{
						stat.health += 10f * num;
					}
					else
					{
						stat.health = maxHealth;
					}
					eid.health = stat.health;
					Object.Instantiate(healingEffect, rotationBone);
				}
				currentDrones[0].Explode();
				currentDrones.RemoveAt(0);
				Invoke("HealFromDrone", 0.25f / eid.totalSpeedModifier);
			}
			else
			{
				currentDrones.RemoveAt(0);
				HealFromDrone();
			}
		}
		else
		{
			eid.totalDamageTakenMultiplier = 1f;
			SpawnFleshDrones();
		}
	}

	private void HomingProjectileAttack()
	{
		inAction = true;
		if (!eid.puppet)
		{
			mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, attackTexture);
		}
		idleTimer = 0f;
		homingProjectileCooldown = 1f;
		currentProjectile = 0;
		anim?.SetBool("Shooting", value: true);
		if (Random.Range(0, 2) == 0)
		{
			rotationSpeedTarget = 360f;
		}
		else
		{
			rotationSpeedTarget = -360f;
		}
		if (altVersion)
		{
			rotationSpeedTarget /= 8f;
		}
		if ((rotationSpeedTarget > 0f && rotationSpeed < 0f) || (rotationSpeedTarget < 0f && rotationSpeed > 0f))
		{
			rotationSpeed = 0f;
		}
		if (stat.health > maxHealth / 2f)
		{
			if (difficulty >= 2)
			{
				projectileAmount = 50;
			}
			else
			{
				projectileAmount = 35;
			}
		}
		else if (difficulty >= 2)
		{
			projectileAmount = 75;
		}
		else
		{
			projectileAmount = 50;
		}
		if (altVersion)
		{
			projectileAmount /= 3;
		}
	}

	private void SpawnInsignia()
	{
		if (eid.target == null)
		{
			return;
		}
		inAction = false;
		GameObject gameObject = Object.Instantiate(insignia, eid.target.position, Quaternion.identity);
		if (altVersion)
		{
			Vector3 velocity = eid.target.GetVelocity();
			velocity.y = 0f;
			if (velocity.magnitude > 0f)
			{
				gameObject.transform.LookAt(eid.target.position + velocity);
			}
			else
			{
				gameObject.transform.Rotate(Vector3.up * Random.Range(0f, 360f), Space.Self);
			}
			gameObject.transform.Rotate(Vector3.right * 90f, Space.Self);
		}
		if (gameObject.TryGetComponent<VirtueInsignia>(out var component))
		{
			component.predictive = true;
			component.noTracking = true;
			component.otherParent = base.transform;
			if (stat.health > maxHealth / 2f)
			{
				component.charges = 2;
			}
			else
			{
				component.charges = 3;
			}
			if (difficulty >= 3)
			{
				component.charges += difficulty - 2;
			}
			component.windUpSpeedMultiplier = 0.5f;
			component.windUpSpeedMultiplier *= eid.totalSpeedModifier;
			component.damage = Mathf.RoundToInt((float)component.damage * eid.totalDamageModifier);
			component.target = eid.target;
			component.predictiveVersion = null;
			Light light = gameObject.AddComponent<Light>();
			light.range = 30f;
			light.intensity = 50f;
		}
		if (difficulty >= 2)
		{
			gameObject.transform.localScale = new Vector3(8f, 2f, 8f);
		}
		else if (difficulty == 1)
		{
			gameObject.transform.localScale = new Vector3(7f, 2f, 7f);
		}
		else
		{
			gameObject.transform.localScale = new Vector3(5f, 2f, 5f);
		}
		GoreZone componentInParent = GetComponentInParent<GoreZone>();
		if ((bool)componentInParent)
		{
			gameObject.transform.SetParent(componentInParent.transform, worldPositionStays: true);
		}
		else
		{
			gameObject.transform.SetParent(base.transform, worldPositionStays: true);
		}
		if (fleshDroneCooldown < 1f)
		{
			fleshDroneCooldown = 1f;
		}
	}

	private void SpawnBlackHole()
	{
		GameObject gameObject = Object.Instantiate(blackHole, base.transform);
		gameObject.transform.position = rotationBone.position;
		currentBlackHole = gameObject.GetComponent<BlackHoleProjectile>();
		currentBlackHole.target = eid.target;
		if ((bool)currentBlackHole)
		{
			currentBlackHole.safeType = EnemyType.FleshPrison;
			currentBlackHole.Activate();
		}
		inAction = false;
		if (!eid.puppet)
		{
			mainSimplifier.ChangeTexture(EnemySimplifier.MaterialState.normal, attackTexture);
		}
		idleTimer = 0.5f;
		if (fleshDroneCooldown < 1f)
		{
			fleshDroneCooldown = 1f;
		}
	}

	public void ForceDronesOff()
	{
		noDrones = true;
		CancelInvoke("HealFromDrone");
		CancelInvoke("SpawnFleshDrones");
		anim?.SetBool("Shooting", value: false);
		if (currentDrones.Count > 0)
		{
			foreach (DroneFlesh currentDrone in currentDrones)
			{
				currentDrone.Explode();
			}
		}
		if ((bool)currentBlackHole)
		{
			currentBlackHole.Explode();
		}
		VirtueInsignia[] array = Object.FindObjectsOfType<VirtueInsignia>();
		foreach (VirtueInsignia virtueInsignia in array)
		{
			if (virtueInsignia.otherParent == base.transform)
			{
				Object.Destroy(virtueInsignia.gameObject);
			}
		}
		Projectile[] componentsInChildren = GetComponentsInChildren<Projectile>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Object.Destroy(componentsInChildren[i].gameObject);
		}
		if ((bool)anim)
		{
			anim.speed = 20f;
		}
	}
}



public class Flicker : MonoBehaviour
{
	private Light light;

	public float delay;

	private AudioSource aud;

	private float intensity;

	private float range;

	public bool onlyOnce;

	public bool quickFlicker;

	public float rangeRandomizer;

	public float intensityRandomizer;

	public float timeRandomizer;

	public bool stopAudio;

	public bool forceOnAfterDisable;

	public GameObject[] flickerDisableObjects;

	private void Start()
	{
		light = GetComponent<Light>();
		aud = GetComponent<AudioSource>();
		intensity = light.intensity;
		range = light.range;
		light.intensity = 0f;
		light.range = 0f;
		GameObject[] array = flickerDisableObjects;
		foreach (GameObject gameObject in array)
		{
			if (gameObject.activeSelf)
			{
				gameObject.SetActive(value: false);
			}
			else
			{
				gameObject.SetActive(value: true);
			}
		}
	}

	private void OnDisable()
	{
		CancelInvoke();
		if (forceOnAfterDisable)
		{
			On();
		}
	}

	private void OnEnable()
	{
		if (timeRandomizer != 0f)
		{
			Invoke("Flickering", delay + Random.Range(0f - timeRandomizer, timeRandomizer));
		}
		else
		{
			Invoke("Flickering", delay);
		}
	}

	private void Flickering()
	{
		if (light.intensity == 0f)
		{
			light.intensity = intensity + Random.Range(0f - intensityRandomizer, intensityRandomizer);
			light.range = range + Random.Range(0f - rangeRandomizer, rangeRandomizer);
			if (aud != null && base.gameObject.activeInHierarchy)
			{
				aud.Play();
			}
			if (quickFlicker)
			{
				Invoke("Off", 0.1f);
			}
		}
		else
		{
			light.intensity = 0f;
			if (aud != null && stopAudio && base.gameObject.activeInHierarchy)
			{
				aud.Stop();
			}
		}
		if (!onlyOnce)
		{
			if (timeRandomizer != 0f)
			{
				Invoke("Flickering", delay + Random.Range(0f - timeRandomizer, timeRandomizer));
			}
			else
			{
				Invoke("Flickering", delay);
			}
		}
		GameObject[] array = flickerDisableObjects;
		foreach (GameObject gameObject in array)
		{
			if (gameObject.activeSelf)
			{
				gameObject.SetActive(value: false);
			}
			else
			{
				gameObject.SetActive(value: true);
			}
		}
	}

	private void On()
	{
		light.intensity = intensity;
		light.range = range;
		if (aud != null && base.gameObject.activeInHierarchy)
		{
			aud.Play();
		}
		GameObject[] array = flickerDisableObjects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	private void Off()
	{
		light.intensity = 0f;
		if (aud != null && stopAudio && base.gameObject.activeInHierarchy)
		{
			aud.Stop();
		}
		GameObject[] array = flickerDisableObjects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}
}



public class FloatingPointErrorPreventer : MonoBehaviour
{
	private bool deactivated;

	private Vector3 startPos;

	public float checkFrequency = 3f;

	private void Start()
	{
		startPos = base.transform.position;
		SlowCheck();
	}

	private void SlowCheck()
	{
		if (!deactivated)
		{
			Invoke("SlowCheck", checkFrequency);
		}
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (base.transform.position.y > 0f && base.transform.position.y < 10000f)
		{
			position.y = startPos.y;
		}
		if (!(Vector3.Distance(position, startPos) > 5000f))
		{
			return;
		}
		deactivated = true;
		CharacterJoint[] componentsInChildren = GetComponentsInChildren<CharacterJoint>();
		Rigidbody[] componentsInChildren2 = GetComponentsInChildren<Rigidbody>();
		CharacterJoint[] array = componentsInChildren;
		foreach (CharacterJoint characterJoint in array)
		{
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
			{
				component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
			Object.Destroy(characterJoint);
		}
		Rigidbody[] array2 = componentsInChildren2;
		foreach (Rigidbody rigidbody in array2)
		{
			if (rigidbody != null)
			{
				rigidbody.useGravity = false;
				rigidbody.isKinematic = true;
			}
		}
		base.gameObject.SetActive(value: false);
		base.transform.position = new Vector3(-100f, -100f, -100f);
		base.transform.localScale = Vector3.zero;
		Object.Destroy(this);
		MonoBehaviour.print("called fperrorprevent");
	}
}



public class FloatOnWater : MonoBehaviour
{
	private Rigidbody rb;

	private Collider waterCol;

	private bool isInWater;

	public float floatiness = 50f;

	public float dampen = 0.9f;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (isInWater && Physics.Raycast(new Vector3(base.transform.position.x, waterCol.bounds.max.y + 0.1f, base.transform.position.z), Vector3.down, out var hitInfo, 900f, 16, QueryTriggerInteraction.Collide))
		{
			Vector3 vector = hitInfo.point - base.transform.position;
			rb.AddForce(vector * floatiness - rb.velocity * dampen);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.TryGetComponent<Water>(out var component))
		{
			component = other.GetComponentInParent<Water>();
		}
		if (component != null)
		{
			isInWater = true;
			waterCol = other;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other == waterCol)
		{
			waterCol = null;
			isInWater = false;
		}
	}
}



public class FogEnabler : MonoBehaviour
{
	public bool disable;

	public bool oneTime;

	private bool activated;

	private bool colliderless;

	private void Awake()
	{
		if (!TryGetComponent<Collider>(out var _) && !TryGetComponent<Rigidbody>(out var _))
		{
			colliderless = true;
		}
	}

	private void OnEnable()
	{
		if (colliderless)
		{
			Activate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.transform == MonoSingleton<NewMovement>.Instance.transform)
		{
			Activate();
		}
	}

	private void Activate()
	{
		if (!oneTime || !activated)
		{
			activated = true;
			RenderSettings.fog = !disable;
		}
	}
}



public class Follow : MonoBehaviour
{
	public float speed;

	public Transform target;

	public bool mimicPosition = true;

	public bool applyPositionLocally;

	public bool followX = true;

	public bool followY = true;

	public bool followZ = true;

	public bool mimicRotation;

	public bool applyRotationLocally;

	public bool rotX = true;

	public bool rotY = true;

	public bool rotZ = true;

	private bool followingPlayer;

	public Collider[] restrictToColliderBounds;

	private Bounds area;

	public bool destroyIfNoTarget;

	private void Awake()
	{
		if (restrictToColliderBounds != null && restrictToColliderBounds.Length != 0)
		{
			for (int i = 0; i < restrictToColliderBounds.Length; i++)
			{
				if (!(restrictToColliderBounds[i] == null))
				{
					_ = area;
					if (area.size == Vector3.zero)
					{
						area = restrictToColliderBounds[i].bounds;
					}
					else
					{
						area.Encapsulate(restrictToColliderBounds[i].bounds);
					}
				}
			}
		}
		if (!(target != null))
		{
			target = MonoSingleton<NewMovement>.Instance.transform;
			followingPlayer = true;
		}
	}

	private void Update()
	{
		if (!target)
		{
			if (destroyIfNoTarget)
			{
				Object.Destroy(base.gameObject);
			}
			return;
		}
		if (mimicRotation)
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			if (followingPlayer)
			{
				if (rotX)
				{
					eulerAngles.x = 0f - MonoSingleton<CameraController>.Instance.rotationX;
				}
			}
			else if (rotX)
			{
				eulerAngles.x = target.eulerAngles.x;
			}
			if (rotY)
			{
				eulerAngles.y = target.eulerAngles.y;
			}
			if (rotZ)
			{
				eulerAngles.z = target.eulerAngles.z;
			}
			if (applyRotationLocally)
			{
				base.transform.localEulerAngles = eulerAngles;
			}
			else
			{
				base.transform.eulerAngles = eulerAngles;
			}
		}
		if (!mimicPosition)
		{
			return;
		}
		Vector3 vector = new Vector3(followX ? target.position.x : base.transform.position.x, followY ? target.position.y : base.transform.position.y, followZ ? target.position.z : base.transform.position.z);
		if (speed == 0f)
		{
			if (restrictToColliderBounds != null && restrictToColliderBounds.Length != 0)
			{
				base.transform.position = area.ClosestPoint(vector);
			}
			else if (applyPositionLocally)
			{
				base.transform.localPosition = vector;
			}
			else
			{
				base.transform.position = vector;
			}
			return;
		}
		float maxDistanceDelta = speed * Time.deltaTime;
		if (applyPositionLocally)
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, vector, maxDistanceDelta);
		}
		else
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, vector, maxDistanceDelta);
		}
		if (restrictToColliderBounds != null && restrictToColliderBounds.Length != 0)
		{
			base.transform.position = area.ClosestPoint(base.transform.position);
		}
	}

	public void SetTarget(Transform newTarget)
	{
		target = newTarget;
		followingPlayer = false;
	}
}



public class FollowNavMesh : MonoBehaviour
{
	public Transform target;

	private NavMeshAgent nma;

	public float trackFrequency = 0.1f;

	public bool chaseEnemies;

	public float chaseEnemiesRange = 50f;

	private void Start()
	{
		nma = GetComponent<NavMeshAgent>();
		if (!target)
		{
			target = MonoSingleton<PlayerTracker>.Instance.GetPlayer();
		}
		Invoke("Track", trackFrequency);
	}

	private void Track()
	{
		Invoke("Track", trackFrequency);
		Transform transform = target;
		if (chaseEnemies)
		{
			List<EnemyIdentifier> currentEnemies = MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies();
			float num = chaseEnemiesRange;
			foreach (EnemyIdentifier item in currentEnemies)
			{
				if (!item.flying && Vector3.Distance(base.transform.position, item.transform.position) < num)
				{
					transform = item.transform;
					num = Vector3.Distance(base.transform.position, item.transform.position);
				}
			}
		}
		if (transform != target)
		{
			nma.stoppingDistance = 0f;
		}
		else
		{
			nma.stoppingDistance = 10f;
		}
		if ((bool)transform && Physics.Raycast(transform.position, Vector3.down, out var _, 50f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			nma.SetDestination(transform.position);
		}
	}
}



public class Footsteps : MonoBehaviour
{
	public GameObject footstep;

	public void Footstep()
	{
		Object.Instantiate(footstep, base.transform.position, base.transform.rotation);
	}
}



[Serializable]
public class ForcedLoadout
{
	public VariantSetting revolver;

	public VariantSetting altRevolver;

	public VariantSetting shotgun;

	public VariantSetting nailgun;

	public VariantSetting altNailgun;

	public VariantSetting railcannon;

	public VariantSetting rocketLauncher;

	[Space]
	public ArmVariantSetting arm;
}



public class ForceLayoutRebuilds : MonoBehaviour
{
	public int iterations = 3;

	public bool onEnable = true;

	public bool allChildLayoutElements = true;

	public ScrollRect scrollRectToReset;

	private RectTransform rectTransform;

	private void Awake()
	{
		if (rectTransform == null)
		{
			rectTransform = (RectTransform)base.transform;
		}
	}

	private void OnEnable()
	{
		if (onEnable)
		{
			ForceRebuild();
			StartCoroutine(DelayedRebuild());
		}
	}

	public void ForceRebuild()
	{
		Awake();
		List<RectTransform> list = new List<RectTransform> { rectTransform };
		if (allChildLayoutElements)
		{
			LayoutGroup[] componentsInChildren = rectTransform.GetComponentsInChildren<LayoutGroup>(includeInactive: true);
			foreach (LayoutGroup layoutGroup in componentsInChildren)
			{
				list.Add((RectTransform)layoutGroup.transform);
			}
		}
		for (int j = 0; j < iterations; j++)
		{
			foreach (RectTransform item in list)
			{
				LayoutRebuilder.ForceRebuildLayoutImmediate(item);
			}
		}
		scrollRectToReset.verticalNormalizedPosition = 1f;
	}

	private IEnumerator DelayedRebuild()
	{
		yield return new WaitForEndOfFrame();
		ForceRebuild();
	}
}



public class Gabriel : MonoBehaviour
{
	private Animator anim;

	private Machine mach;

	private Rigidbody rb;

	private EnemyIdentifier eid;

	private SkinnedMeshRenderer smr;

	private GabrielVoice voice;

	private Collider col;

	public GameObject particles;

	public GameObject particlesEnraged;

	private Material origBody;

	private Material origWing;

	public Material enrageBody;

	public Material enrageWing;

	private int difficulty;

	private bool valuesSet;

	private bool active = true;

	private bool inAction;

	private bool goingLeft;

	private bool goForward;

	private float forwardSpeed;

	private float startCooldown = 2f;

	private float attackCooldown;

	public bool enraged;

	private GameObject currentEnrageEffect;

	public bool secondPhase;

	public float phaseChangeHealth;

	private float outOfSightTime;

	private int teleportAttempts;

	private int teleportInterval = 6;

	public GameObject teleportSound;

	public GameObject decoy;

	private bool overrideRotation;

	private bool stopRotation;

	private Vector3 overrideTarget;

	private LayerMask environmentMask;

	public Transform rightHand;

	public Transform leftHand;

	private GameObject rightHandWeapon;

	private GameObject leftHandWeapon;

	private WeaponTrail rightHandTrail;

	private WeaponTrail leftHandTrail;

	private SwingCheck2 rightSwingCheck;

	private SwingCheck2 leftSwingCheck;

	public GameObject sword;

	public GameObject zweiHander;

	public GameObject axe;

	public GameObject spear;

	public GameObject glaive;

	private bool spearing;

	private int spearAttacks;

	private bool dashing;

	private float forcedDashTime;

	private Vector3 dashTarget;

	public GameObject dashEffect;

	private int throws;

	private GameObject thrownObject;

	private bool threwAxes;

	private float[] moveChanceBonuses = new float[4];

	private int previousMove = -1;

	private int burstLength = 2;

	private bool juggled;

	private float juggleHp;

	private float juggleEndHp;

	private float juggleLength;

	public GameObject juggleEffect;

	private bool juggleFalling;

	public GameObject summonedSwords;

	private GameObject currentSwords;

	public GameObject summonedSwordsWindup;

	private GameObject currentWindup;

	private float summonedSwordsCooldown = 15f;

	public Transform head;

	private bool readyTaunt;

	private float defaultAnimSpeed = 1f;

	private bool bossVersion;

	[SerializeField]
	private GameObject genericOutro;

	private int dashAttempts;

	private EnemyTarget target => eid.target;

	private void Awake()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		eid = GetComponent<EnemyIdentifier>();
		smr = GetComponentInChildren<SkinnedMeshRenderer>();
		voice = GetComponent<GabrielVoice>();
		col = GetComponent<Collider>();
	}

	private void Start()
	{
		SetValues();
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			origBody = smr.sharedMaterials[0];
			origWing = smr.sharedMaterials[1];
			origWing.SetFloat("_OpacScale", 1f);
			if (enraged)
			{
				EnrageNow();
			}
			environmentMask = LayerMaskDefaults.Get(LMD.Environment);
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			if (difficulty >= 3)
			{
				burstLength = 3;
			}
			UpdateSpeed();
			RandomizeDirection();
			bossVersion = TryGetComponent<BossHealthBar>(out var _);
		}
	}

	private void UpdateBuff()
	{
		SetValues();
		UpdateSpeed();
	}

	private void UpdateSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (difficulty <= 1)
		{
			anim.speed = ((difficulty == 1) ? 0.85f : 0.75f);
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
		defaultAnimSpeed = anim.speed;
	}

	private void OnDisable()
	{
		CancelInvoke();
		if ((bool)rightHandWeapon || (bool)leftHandWeapon)
		{
			DisableWeapon();
		}
		DamageStopLeft(0);
		DamageStopRight(0);
		StopAction();
		ResetAnimSpeed();
		overrideRotation = false;
		spearing = false;
		spearAttacks = 0;
		dashing = false;
		if ((bool)currentSwords)
		{
			currentSwords.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		if (juggled)
		{
			JuggleStop();
		}
		if ((bool)currentSwords)
		{
			currentSwords.SetActive(value: true);
		}
	}

	private void UpdateRigidbodySettings()
	{
		if (target == null)
		{
			rb.drag = 3f;
			rb.angularDrag = 3f;
		}
		else
		{
			rb.drag = 0f;
			rb.angularDrag = 0f;
		}
	}

	private void Update()
	{
		UpdateRigidbodySettings();
		if (target == null)
		{
			return;
		}
		if (active)
		{
			if (startCooldown > 0f)
			{
				startCooldown = Mathf.MoveTowards(startCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if ((secondPhase || enraged) && difficulty >= 3 && !currentSwords)
			{
				summonedSwordsCooldown = Mathf.MoveTowards(summonedSwordsCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
				if (summonedSwordsCooldown == 0f && !inAction && readyTaunt)
				{
					summonedSwordsCooldown = 15f;
					SpawnSummonedSwordsWindup();
					Invoke("SpawnSummonedSwords", 1f / eid.totalSpeedModifier);
				}
			}
			if (!inAction && startCooldown <= 0f)
			{
				if (attackCooldown > 0f)
				{
					attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
					if (readyTaunt && (bool)voice)
					{
						voice.Taunt();
						readyTaunt = false;
					}
				}
				else if (Physics.Raycast(base.transform.position, target.headPosition - base.transform.position, Vector3.Distance(base.transform.position, target.headPosition), LayerMaskDefaults.Get(LMD.Environment)))
				{
					Teleport();
				}
				else
				{
					bool flag = false;
					bool flag2 = false;
					if (Vector3.Distance(base.transform.position, target.headPosition) > 10f)
					{
						flag2 = true;
					}
					else if (Vector3.Distance(base.transform.position, target.headPosition) < 5f)
					{
						flag = true;
					}
					float[] array = new float[4];
					int num = -1;
					if (previousMove != 0 && !flag && !threwAxes)
					{
						array[0] = Random.Range(0f, 1f) + moveChanceBonuses[0];
					}
					if (previousMove != 1 && !flag)
					{
						array[1] = Random.Range(0f, 1f) + moveChanceBonuses[1];
					}
					if (previousMove != 2 && !flag2)
					{
						array[2] = Random.Range(0f, 1f) + moveChanceBonuses[2];
					}
					if (previousMove != 3)
					{
						array[3] = Random.Range(0f, 1f) + moveChanceBonuses[3];
					}
					float num2 = 0f;
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i] > num2)
						{
							num2 = array[i];
							num = i;
						}
					}
					switch (num)
					{
					case 0:
						AxeThrow();
						break;
					case 1:
						SpearCombo();
						break;
					case 2:
						StingerCombo();
						break;
					case 3:
						ZweiDash();
						break;
					}
					ResetAnimSpeed();
					previousMove = num;
					for (int j = 0; j < array.Length; j++)
					{
						if (j != num)
						{
							moveChanceBonuses[j] += 0.25f;
						}
						else
						{
							moveChanceBonuses[j] = 0f;
						}
					}
					if (num != 0)
					{
						if (burstLength > 1)
						{
							burstLength--;
						}
						else
						{
							if (difficulty >= 3)
							{
								burstLength = 3;
							}
							else
							{
								burstLength = 2;
							}
							if (difficulty <= 3)
							{
								attackCooldown = 3f;
							}
							else
							{
								attackCooldown = 5 - difficulty;
							}
							threwAxes = false;
							readyTaunt = true;
						}
					}
				}
			}
			if ((Vector3.Distance(base.transform.position, target.headPosition) > 20f || base.transform.position.y > target.headPosition.y + 15f || Physics.Raycast(base.transform.position, target.headPosition - base.transform.position, Vector3.Distance(base.transform.position, target.headPosition), environmentMask)) && startCooldown <= 0f)
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 3f, Time.deltaTime * eid.totalSpeedModifier);
				if (outOfSightTime >= 3f && !inAction)
				{
					Teleport();
				}
			}
			else
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 0f, Time.deltaTime * 2f * eid.totalSpeedModifier);
			}
			if (!stopRotation)
			{
				if (!overrideRotation)
				{
					Quaternion quaternion = Quaternion.LookRotation(target.headPosition - base.transform.position, Vector3.up);
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * (10f * Quaternion.Angle(quaternion, base.transform.rotation) + 2f) * eid.totalSpeedModifier);
				}
				else
				{
					Quaternion quaternion2 = Quaternion.LookRotation(overrideTarget - base.transform.position, Vector3.up);
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion2, Time.deltaTime * (2500f * Quaternion.Angle(quaternion2, base.transform.rotation) + 10f) * eid.totalSpeedModifier);
				}
			}
		}
		if (!secondPhase && mach.health <= phaseChangeHealth)
		{
			if (!juggled)
			{
				JuggleStart();
			}
			secondPhase = true;
		}
		if (!juggled)
		{
			return;
		}
		if (mach.health < juggleHp)
		{
			if (rb.velocity.y < 0f)
			{
				rb.velocity = Vector3.zero;
			}
			rb.AddForce(Vector3.up * (juggleHp - mach.health) * 5f, ForceMode.VelocityChange);
			anim.Play("Juggle", 0, 0f);
			juggleHp = mach.health;
			base.transform.LookAt(new Vector3(target.headPosition.x, base.transform.position.y, target.headPosition.z));
			voice.Hurt();
			if (mach.health < juggleEndHp || juggleLength <= 0f)
			{
				JuggleStop(enrage: true);
			}
		}
		juggleLength = Mathf.MoveTowards(juggleLength, 0f, Time.deltaTime * eid.totalSpeedModifier);
	}

	private void FixedUpdate()
	{
		if (target == null)
		{
			return;
		}
		if (!juggled)
		{
			if (!inAction)
			{
				Vector3 zero = Vector3.zero;
				float num = Vector3.Distance(base.transform.position, target.headPosition);
				if (num > 10f)
				{
					zero += base.transform.forward * 7.5f;
				}
				else if (num > 5f)
				{
					zero += base.transform.forward * 7.5f * (num / 10f);
				}
				RaycastHit hitInfo;
				if (target == null)
				{
					zero = Vector3.zero;
				}
				else if (goingLeft)
				{
					if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right * -1f, out hitInfo, 3f, environmentMask))
					{
						zero += base.transform.right * -5f;
					}
					else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right, out hitInfo, 3f, environmentMask))
					{
						goingLeft = false;
					}
					else
					{
						zero += base.transform.forward * 5f;
					}
				}
				else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right, out hitInfo, 3f, environmentMask))
				{
					zero += base.transform.right * 5f;
				}
				else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right * -1f, out hitInfo, 3f, environmentMask))
				{
					goingLeft = true;
				}
				else
				{
					zero += base.transform.forward * 5f;
				}
				rb.velocity = zero * eid.totalSpeedModifier;
			}
			else if (goForward)
			{
				rb.velocity = base.transform.forward * forwardSpeed * ((difficulty >= 4) ? 1.25f : 1f);
			}
			else
			{
				rb.velocity = Vector3.zero;
			}
		}
		else
		{
			if (rb.velocity.y < 35f)
			{
				rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			}
			else
			{
				rb.velocity = new Vector3(0f, 35f, 0f);
			}
			if (juggleFalling && Physics.SphereCast(base.transform.position, 1.25f, Vector3.down, out var _, 3.6f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				JuggleStop();
			}
			if (rb.velocity.y < 0f)
			{
				juggleFalling = true;
			}
		}
		if (spearing)
		{
			if (!goForward)
			{
				base.transform.position = target.headPosition + Vector3.up * 15f;
			}
			else if (Physics.Raycast(base.transform.position, base.transform.forward, 2f, environmentMask))
			{
				spearing = false;
				DamageStopRight(0);
			}
		}
		if (dashing)
		{
			col.enabled = false;
			if (forcedDashTime > 0f)
			{
				forcedDashTime = Mathf.MoveTowards(forcedDashTime, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (Vector3.Distance(base.transform.position, dashTarget) > (float)(5 + dashAttempts))
			{
				if (!Physics.SphereCast(base.transform.position, 0.75f, dashTarget - base.transform.position, out var hitInfo3, Vector3.Distance(base.transform.position, dashTarget) - 0.75f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore) || (hitInfo3.collider.gameObject.layer == 11 && eid.target != null && eid.target.enemyIdentifier != null && hitInfo3.collider.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && eid.target.enemyIdentifier == component.eid))
				{
					rb.velocity = base.transform.forward * 100f * eid.totalSpeedModifier;
					return;
				}
				dashAttempts++;
				col.enabled = true;
				dashTarget = target.headPosition;
				Teleport(closeRange: false, longrange: true);
				forcedDashTime = 0.35f;
				LookAtTarget();
			}
			else if (forcedDashTime <= 0f)
			{
				dashAttempts = 0;
				dashing = false;
				ZweiCombo();
			}
		}
		else
		{
			col.enabled = true;
			dashAttempts = 0;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!juggleFalling || other.gameObject.layer != 0)
		{
			return;
		}
		DeathZone deathZone = ((!other.attachedRigidbody) ? other.GetComponent<DeathZone>() : other.attachedRigidbody.GetComponent<DeathZone>());
		if ((bool)deathZone)
		{
			if ((bool)voice)
			{
				voice.BigHurt();
			}
			base.transform.position = deathZone.respawnTarget;
			eid.DeliverDamage(head.gameObject, Vector3.zero, head.position, 15f, tryForExplode: false);
			juggleFalling = false;
			JuggleStop();
			MonoSingleton<ChallengeManager>.Instance.ChallengeDone();
		}
	}

	public void Teleport(bool closeRange = false, bool longrange = false, bool firstTime = true, bool horizontal = false, bool vertical = false)
	{
		if (firstTime)
		{
			teleportAttempts = 0;
		}
		outOfSightTime = 0f;
		spearing = false;
		Vector3 normalized = Random.onUnitSphere.normalized;
		if (normalized.y < 0f)
		{
			normalized.y *= -1f;
		}
		float num = Random.Range(8, 15);
		if (closeRange)
		{
			num = Random.Range(5, 8);
		}
		else if (longrange)
		{
			num = Random.Range(15, 20);
		}
		if (target == null)
		{
			return;
		}
		Vector3 vector = target.headPosition + Vector3.up;
		vector = ((!Physics.Raycast(target.headPosition + Vector3.up, normalized, out var hitInfo, num, environmentMask, QueryTriggerInteraction.Ignore)) ? (target.headPosition + Vector3.up + normalized * num) : (hitInfo.point - normalized * 3f));
		bool flag = false;
		bool flag2 = false;
		if (Physics.Raycast(vector, Vector3.up, out var hitInfo2, 8f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag = true;
		}
		if (Physics.Raycast(vector, Vector3.down, out var hitInfo3, 8f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag2 = true;
		}
		bool flag3 = false;
		Vector3 vector2 = base.transform.position;
		if (flag && flag2)
		{
			if (Vector3.Distance(hitInfo2.point, hitInfo3.point) > 7f)
			{
				vector2 = ((!horizontal) ? new Vector3(vector.x, (hitInfo3.point.y + hitInfo2.point.y) / 2f, vector.z) : new Vector3(vector.x, hitInfo3.point.y + 3.5f, vector.z));
				flag3 = true;
			}
			else
			{
				teleportAttempts++;
				if (teleportAttempts <= 10)
				{
					Teleport(closeRange, longrange, firstTime: false, horizontal, vertical);
				}
			}
		}
		else
		{
			flag3 = true;
			vector2 = (flag ? (hitInfo2.point + Vector3.down * Random.Range(5, 10)) : (flag2 ? ((!horizontal) ? (hitInfo3.point + Vector3.up * Random.Range(5, 10)) : new Vector3(hitInfo3.point.x, hitInfo3.point.y + 3.5f, hitInfo3.point.z)) : ((!horizontal) ? vector : new Vector3(vector.x, target.headPosition.y, vector.z))));
		}
		if (flag3)
		{
			Collider[] array = Physics.OverlapCapsule(vector2 + base.transform.up * -2.25f, vector2 + base.transform.up * 1.25f, 1.25f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore);
			if (array != null && array.Length != 0)
			{
				for (int num2 = array.Length - 1; num2 >= 0; num2--)
				{
					if (array[num2].gameObject.layer != 11 || eid.target == null || eid.target.enemyIdentifier == null || !array[num2].TryGetComponent<EnemyIdentifierIdentifier>(out var component) || !component.eid || eid.target.enemyIdentifier != component.eid)
					{
						teleportAttempts++;
						if (teleportAttempts <= 10)
						{
							Teleport(closeRange, longrange, firstTime: false, horizontal, vertical);
						}
						return;
					}
				}
			}
			int num3 = Mathf.RoundToInt(Vector3.Distance(base.transform.position, vector2) / 2.5f);
			for (int i = 0; i < num3; i++)
			{
				CreateDecoy(Vector3.Lerp(base.transform.position, vector2, (float)i / (float)num3), (float)i / (float)num3 + 0.1f);
			}
			base.transform.position = vector2;
			teleportAttempts = 0;
			Object.Instantiate(teleportSound, base.transform.position, Quaternion.identity);
			if (eid.hooked)
			{
				MonoSingleton<HookArm>.Instance.StopThrow(1f, sparks: true);
			}
		}
		if (goingLeft)
		{
			goingLeft = false;
		}
		else
		{
			goingLeft = true;
		}
	}

	public GameObject CreateDecoy(Vector3 position, float transparencyOverride = 1f, Animator animatorOverride = null)
	{
		if ((!anim && !animatorOverride) || target == null)
		{
			return null;
		}
		GameObject gameObject = Object.Instantiate(decoy, position, base.transform.GetChild(0).rotation, base.transform.parent);
		Animator componentInChildren = gameObject.GetComponentInChildren<Animator>();
		AnimatorStateInfo animatorStateInfo = (animatorOverride ? animatorOverride.GetCurrentAnimatorStateInfo(0) : anim.GetCurrentAnimatorStateInfo(0));
		componentInChildren.Play(animatorStateInfo.shortNameHash, 0, animatorStateInfo.normalizedTime);
		componentInChildren.speed = 0f;
		MindflayerDecoy[] componentsInChildren = gameObject.GetComponentsInChildren<MindflayerDecoy>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].fadeOverride = transparencyOverride;
		}
		return gameObject;
	}

	private void StingerCombo()
	{
		forwardSpeed = 100f * anim.speed;
		SpawnLeftHandWeapon(GabrielWeaponType.Sword);
		inAction = true;
		anim.Play("StingerCombo");
	}

	private void SpearCombo()
	{
		if (difficulty >= 2)
		{
			forwardSpeed = 150f;
		}
		else if (difficulty == 1)
		{
			forwardSpeed = 75f;
		}
		else
		{
			forwardSpeed = 60f;
		}
		forwardSpeed *= eid.totalSpeedModifier;
		if (enraged && secondPhase)
		{
			spearAttacks = 3;
		}
		else if (enraged || secondPhase)
		{
			spearAttacks = 2;
		}
		else
		{
			spearAttacks = 1;
		}
		SpawnRightHandWeapon(GabrielWeaponType.Spear);
		inAction = true;
		anim.Play("SpearReady");
	}

	private void ZweiDash()
	{
		if (difficulty >= 2)
		{
			forwardSpeed = 100f;
		}
		else
		{
			forwardSpeed = 40f;
		}
		forwardSpeed *= eid.totalSpeedModifier;
		anim.Play("ZweiDash");
		inAction = true;
		SpawnRightHandWeapon(GabrielWeaponType.Zweihander);
	}

	private void StartDash()
	{
		inAction = true;
		overrideRotation = true;
		dashTarget = target.headPosition;
		overrideTarget = dashTarget;
		dashing = true;
		Object.Instantiate(dashEffect, base.transform.position, base.transform.rotation);
	}

	private void ZweiCombo()
	{
		forwardSpeed = 65f * anim.speed;
		inAction = true;
		anim.Play("ZweiCombo");
		LookAtTarget();
		if (secondPhase || enraged)
		{
			throws = 1;
		}
	}

	private void AxeThrow()
	{
		threwAxes = true;
		inAction = true;
		SpawnRightHandWeapon(GabrielWeaponType.Axe);
		SpawnLeftHandWeapon(GabrielWeaponType.Axe);
		anim.Play("AxeThrow");
	}

	private void SpearAttack()
	{
		if (juggled)
		{
			return;
		}
		if (target == null)
		{
			spearAttacks = 0;
		}
		if (spearAttacks > 0)
		{
			spearing = true;
			goForward = false;
			spearAttacks--;
			float num = Random.Range(0f, 1f);
			if (difficulty <= 1)
			{
				Invoke("SpearAttack", 2f / eid.totalSpeedModifier);
			}
			else if (difficulty == 2)
			{
				Invoke("SpearAttack", 1.5f / eid.totalSpeedModifier);
			}
			else
			{
				Invoke("SpearAttack", 0.75f / eid.totalSpeedModifier);
			}
			bool flag = false;
			Vector3 vector = target.headPosition;
			if (!Physics.Raycast(target.headPosition, Vector3.up, out var hitInfo, 17f, environmentMask, QueryTriggerInteraction.Ignore))
			{
				vector = target.headPosition + Vector3.up * 15f;
				flag = true;
			}
			else if (!Physics.Raycast(target.headPosition, Vector3.down, out hitInfo, 17f, environmentMask, QueryTriggerInteraction.Ignore))
			{
				vector = base.transform.position + Vector3.down * 15f;
				flag = true;
			}
			if (flag && ((difficulty <= 3 && !enraged) || num > 0.5f))
			{
				anim?.Play("SpearDown");
				int num2 = Mathf.RoundToInt(Vector3.Distance(base.transform.position, vector) / 2.5f);
				for (int i = 0; i < num2; i++)
				{
					CreateDecoy(Vector3.Lerp(base.transform.position, vector, (float)i / (float)num2), (float)i / (float)num2 + 0.1f);
				}
				base.transform.position = vector;
				teleportAttempts = 0;
				Object.Instantiate(teleportSound, base.transform.position, Quaternion.identity);
				if (eid.hooked)
				{
					MonoSingleton<HookArm>.Instance.StopThrow(1f, sparks: true);
				}
				LookAtTarget();
				if (difficulty <= 1)
				{
					Invoke("SpearFlash", 0.5f / eid.totalSpeedModifier);
					Invoke("SpearGo", 1f / eid.totalSpeedModifier);
				}
				else if (difficulty == 2)
				{
					Invoke("SpearFlash", 0.375f / eid.totalSpeedModifier);
					Invoke("SpearGo", 0.75f / eid.totalSpeedModifier);
				}
				else
				{
					Invoke("SpearFlash", 0.25f / eid.totalSpeedModifier);
					Invoke("SpearGo", 0.5f / eid.totalSpeedModifier);
				}
			}
			else
			{
				anim.Play("SpearStinger");
				Teleport(closeRange: false, longrange: true, firstTime: true, horizontal: true);
				FollowTarget();
				Invoke("SpearFlash", 0.25f / eid.totalSpeedModifier);
				Invoke("SpearGoHorizontal", 0.5f / eid.totalSpeedModifier);
			}
		}
		else
		{
			SpearThrow();
		}
	}

	private void SpearFlash()
	{
		if (!juggled)
		{
			Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, head);
		}
	}

	private void SpearGoHorizontal()
	{
		if (!juggled)
		{
			LookAtTarget();
			SpearGo();
		}
	}

	private void SpearGo()
	{
		if (!juggled)
		{
			Object.Instantiate(dashEffect, base.transform.position, base.transform.rotation);
			DamageStartRight(25);
		}
	}

	private void JuggleStart()
	{
		if ((bool)leftHandWeapon)
		{
			DamageStopLeft(0);
		}
		if ((bool)rightHandWeapon)
		{
			DamageStopRight(0);
		}
		MonoSingleton<TimeController>.Instance.SlowDown(0.25f);
		voice.BigHurt();
		inAction = true;
		DisableWeapon();
		CancelInvoke();
		dashing = false;
		spearing = false;
		rb.velocity = Vector3.zero;
		rb.AddForce(Vector3.up * 35f, ForceMode.VelocityChange);
		rb.useGravity = true;
		origWing.SetFloat("_OpacScale", 0f);
		base.transform.LookAt(new Vector3(target.headPosition.x, base.transform.position.y, target.headPosition.z));
		overrideRotation = false;
		stopRotation = true;
		juggled = true;
		juggleHp = mach.health;
		juggleEndHp = mach.health - 15f;
		juggleLength = 5f;
		juggleFalling = false;
		Object.Instantiate(juggleEffect, base.transform.position, base.transform.rotation);
		eid.totalDamageTakenMultiplier = 0.5f;
		particles.SetActive(value: false);
		particlesEnraged.SetActive(value: false);
		ResetAnimSpeed();
		anim.Play("Juggle");
	}

	private void JuggleStop(bool enrage = false)
	{
		rb.useGravity = false;
		if (difficulty != 0)
		{
			burstLength = difficulty;
		}
		else
		{
			burstLength = 1;
		}
		voice.PhaseChange();
		origWing.SetFloat("_OpacScale", 1f);
		stopRotation = false;
		juggled = false;
		if (enraged)
		{
			particlesEnraged.SetActive(value: true);
		}
		else
		{
			particles.SetActive(value: true);
		}
		anim.Play("Idle");
		spearing = false;
		eid.totalDamageTakenMultiplier = 1f;
		if ((enrage || mach.health <= phaseChangeHealth) && !currentEnrageEffect)
		{
			Enrage();
			return;
		}
		inAction = false;
		attackCooldown = 1f;
		Teleport();
	}

	private void Enrage()
	{
		anim.Play("Enrage");
		if (difficulty >= 3)
		{
			SpawnSummonedSwordsWindup();
		}
	}

	public void EnrageNow()
	{
		Material[] materials = smr.materials;
		materials[0] = enrageBody;
		materials[1] = enrageWing;
		smr.materials = materials;
		eid.UpdateBuffs(visualsOnly: true);
		if (!currentEnrageEffect)
		{
			currentEnrageEffect = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.enrageEffect, base.transform);
		}
		if (difficulty >= 3)
		{
			SpawnSummonedSwords();
		}
		if (particles.activeSelf)
		{
			particlesEnraged.SetActive(value: true);
			particles.SetActive(value: false);
		}
		burstLength = difficulty;
		if (burstLength == 0)
		{
			burstLength = 1;
		}
		attackCooldown = 0f;
		readyTaunt = false;
	}

	public void UnEnrage()
	{
		Material[] materials = smr.materials;
		materials[0] = origBody;
		materials[1] = origWing;
		smr.materials = materials;
		enraged = false;
		if (particlesEnraged.activeSelf)
		{
			particlesEnraged.SetActive(value: false);
			particles.SetActive(value: true);
		}
		if ((bool)currentEnrageEffect)
		{
			Object.Destroy(currentEnrageEffect);
		}
	}

	private void SpearThrow()
	{
		if (!juggled)
		{
			spearing = false;
			DamageStopRight(0);
			Teleport();
			FollowTarget();
			anim.Play("SpearThrow");
		}
	}

	private void ThrowWeapon(GameObject projectile)
	{
		if (juggled)
		{
			return;
		}
		if (rightHandWeapon != null)
		{
			rightHandWeapon.SetActive(value: false);
			if ((bool)rightHandTrail)
			{
				rightHandTrail.RemoveTrail();
			}
			Object.Destroy(rightHandWeapon);
			if ((bool)rightSwingCheck)
			{
				Object.Destroy(rightSwingCheck.gameObject);
			}
		}
		if (leftHandWeapon != null)
		{
			leftHandWeapon.SetActive(value: false);
			if ((bool)leftHandTrail)
			{
				leftHandTrail.RemoveTrail();
			}
			Object.Destroy(leftHandWeapon);
			if ((bool)leftSwingCheck)
			{
				Object.Destroy(leftSwingCheck.gameObject);
			}
		}
		if (throws > 0)
		{
			throws--;
			Invoke("CheckForThrown", 0.35f / eid.totalSpeedModifier);
		}
		thrownObject = Object.Instantiate(projectile, base.transform.position, base.transform.rotation);
		if (thrownObject.TryGetComponent<AlwaysLookAtCamera>(out var component))
		{
			component.ChangeOverrideTarget(target);
		}
		if (difficulty > 1 && eid.totalSpeedModifier == 1f && eid.totalDamageModifier == 1f)
		{
			return;
		}
		Projectile componentInChildren = thrownObject.GetComponentInChildren<Projectile>();
		componentInChildren.target = target;
		if ((bool)componentInChildren)
		{
			if (difficulty <= 1)
			{
				componentInChildren.speed *= 0.5f;
			}
			componentInChildren.damage *= eid.totalDamageModifier;
		}
	}

	private void CheckForThrown()
	{
		if (juggled)
		{
			return;
		}
		if (thrownObject != null)
		{
			Vector3 position = thrownObject.transform.position;
			Collider[] array = Physics.OverlapCapsule(position + base.transform.up * -2.25f, position + base.transform.up * 1.25f, 1.25f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore);
			if (array != null && array.Length != 0)
			{
				throws = 0;
				return;
			}
			int num = Mathf.RoundToInt(Vector3.Distance(base.transform.position, position) / 2.5f);
			for (int i = 0; i < num; i++)
			{
				CreateDecoy(Vector3.Lerp(base.transform.position, position, (float)i / (float)num), (float)i / (float)num + 0.1f);
			}
			base.transform.position = position;
			teleportAttempts = 0;
			Object.Instantiate(teleportSound, base.transform.position, Quaternion.identity);
			thrownObject.gameObject.SetActive(value: false);
			Object.Destroy(thrownObject);
			base.transform.LookAt(target.headPosition);
			anim.speed = 0f;
			SpearFlash();
			Invoke("ResetAnimSpeed", 0.25f / eid.totalSpeedModifier);
			anim.Play("ZweiCombo", -1, 0.5f);
		}
		else
		{
			throws = 0;
		}
	}

	public void EnableWeapon()
	{
		if (!juggled)
		{
			if ((bool)rightHandWeapon)
			{
				rightHandWeapon.SetActive(value: true);
			}
			if ((bool)leftHandWeapon)
			{
				leftHandWeapon.SetActive(value: true);
			}
		}
	}

	public void DisableWeapon()
	{
		if (juggled)
		{
			return;
		}
		if ((bool)rightHandWeapon)
		{
			if ((bool)rightHandTrail)
			{
				rightHandTrail.RemoveTrail();
			}
			Object.Destroy(rightHandWeapon);
			if ((bool)rightSwingCheck)
			{
				Object.Destroy(rightSwingCheck.gameObject);
			}
		}
		if ((bool)leftHandWeapon)
		{
			if ((bool)leftHandTrail)
			{
				leftHandTrail.RemoveTrail();
			}
			Object.Destroy(leftHandWeapon);
			if ((bool)leftSwingCheck)
			{
				Object.Destroy(leftSwingCheck.gameObject);
			}
		}
	}

	private void RandomizeDirection()
	{
		if (Random.Range(0f, 1f) > 0.5f)
		{
			goingLeft = true;
		}
		else
		{
			goingLeft = false;
		}
	}

	private void SpawnLeftHandWeapon(GabrielWeaponType weapon)
	{
		if (!juggled)
		{
			GameObject weaponGameObject = GetWeaponGameObject(weapon);
			if (weaponGameObject != null)
			{
				leftHandWeapon = Object.Instantiate(weaponGameObject, leftHand.position, leftHand.rotation);
				leftHandWeapon.transform.forward = leftHand.transform.up;
				leftHandWeapon.transform.SetParent(leftHand, worldPositionStays: true);
				leftHandTrail = leftHandWeapon.GetComponentInChildren<WeaponTrail>();
				leftHandWeapon.SetActive(value: false);
				leftSwingCheck = WeaponHitBox(weapon);
			}
		}
	}

	private void SpawnRightHandWeapon(GabrielWeaponType weapon)
	{
		if (!juggled)
		{
			GameObject weaponGameObject = GetWeaponGameObject(weapon);
			if (weaponGameObject != null)
			{
				rightHandWeapon = Object.Instantiate(weaponGameObject, rightHand.position, rightHand.rotation);
				rightHandWeapon.transform.forward = rightHand.transform.up;
				rightHandWeapon.transform.SetParent(rightHand, worldPositionStays: true);
				rightHandTrail = rightHandWeapon.GetComponentInChildren<WeaponTrail>();
				rightHandWeapon.SetActive(value: false);
				rightSwingCheck = WeaponHitBox(weapon);
			}
		}
	}

	private GameObject GetWeaponGameObject(GabrielWeaponType weapon)
	{
		return weapon switch
		{
			GabrielWeaponType.Sword => sword, 
			GabrielWeaponType.Zweihander => zweiHander, 
			GabrielWeaponType.Axe => axe, 
			GabrielWeaponType.Spear => spear, 
			GabrielWeaponType.Glaive => glaive, 
			_ => null, 
		};
	}

	private SwingCheck2 WeaponHitBox(GabrielWeaponType weapon)
	{
		return weapon switch
		{
			GabrielWeaponType.Sword => CreateHitBox(new Vector3(0f, 0f, 1.5f), new Vector3(4f, 5f, 3f)), 
			GabrielWeaponType.Zweihander => CreateHitBox(new Vector3(0f, 0f, 2.5f), new Vector3(8f, 5f, 5f)), 
			GabrielWeaponType.Spear => CreateHitBox(new Vector3(0f, 0f, 2.5f), new Vector3(3.5f, 3.5f, 5f), ignoreSlide: true), 
			_ => null, 
		};
	}

	private SwingCheck2 CreateHitBox(Vector3 position, Vector3 size, bool ignoreSlide = false)
	{
		GameObject obj = new GameObject();
		obj.transform.SetPositionAndRotation(base.transform.position, base.transform.rotation);
		obj.transform.SetParent(base.transform, worldPositionStays: true);
		BoxCollider boxCollider = obj.AddComponent<BoxCollider>();
		boxCollider.enabled = false;
		boxCollider.isTrigger = true;
		boxCollider.center = position;
		boxCollider.size = size;
		SwingCheck2 swingCheck = obj.AddComponent<SwingCheck2>();
		swingCheck.type = EnemyType.Gabriel;
		swingCheck.ignoreSlidingPlayer = ignoreSlide;
		swingCheck.OverrideEnemyIdentifier(eid);
		return swingCheck;
	}

	public void DamageStartLeft(int damage)
	{
		if (!juggled)
		{
			leftHandTrail.AddTrail();
			leftSwingCheck.damage = damage;
			leftSwingCheck.DamageStart();
			goForward = true;
		}
	}

	public void DamageStopLeft(int keepMoving)
	{
		if ((bool)leftHandTrail)
		{
			leftHandTrail.RemoveTrail();
		}
		if ((bool)leftSwingCheck)
		{
			leftSwingCheck.DamageStop();
		}
		if (keepMoving == 0)
		{
			goForward = false;
		}
	}

	public void DamageStartRight(int damage)
	{
		if (!juggled)
		{
			rightHandTrail.AddTrail();
			rightSwingCheck.damage = damage;
			rightSwingCheck.DamageStart();
			goForward = true;
		}
	}

	public void DamageStopRight(int keepMoving)
	{
		if ((bool)rightHandTrail)
		{
			rightHandTrail.RemoveTrail();
		}
		if ((bool)rightSwingCheck)
		{
			rightSwingCheck.DamageStop();
		}
		if (keepMoving == 0)
		{
			goForward = false;
		}
	}

	public void SetForwardSpeed(int newSpeed)
	{
		forwardSpeed = (float)newSpeed * defaultAnimSpeed;
	}

	public void EnrageTeleport(int teleportType = 0)
	{
		if (enraged || secondPhase)
		{
			switch (teleportType)
			{
			case 1:
				Teleport(closeRange: true);
				break;
			case 2:
				Teleport();
				break;
			case 3:
				Teleport(closeRange: true, longrange: false, firstTime: true, horizontal: true);
				break;
			case 4:
				Teleport(closeRange: false, longrange: false, firstTime: true, horizontal: true);
				break;
			case 5:
				Teleport(closeRange: false, longrange: false, firstTime: true, horizontal: false, vertical: true);
				break;
			}
			anim.speed = 0f;
			Invoke("ResetAnimSpeed", 0.25f / eid.totalSpeedModifier);
		}
		if (target != null)
		{
			base.transform.LookAt(target.headPosition);
		}
	}

	private void ResetAnimSpeed()
	{
		if ((bool)anim)
		{
			anim.speed = defaultAnimSpeed;
		}
	}

	public void LookAtTarget(int instant = 0)
	{
		overrideRotation = true;
		if (target == null)
		{
			base.transform.rotation = Quaternion.identity;
			return;
		}
		overrideTarget = base.transform.position + (target.headPosition - base.transform.position).normalized * 999f;
		base.transform.LookAt(base.transform.position + (target.headPosition - base.transform.position).normalized * 999f);
	}

	public void FollowTarget()
	{
		if (!juggled)
		{
			overrideRotation = false;
		}
	}

	public void StopAction()
	{
		if (!juggled)
		{
			FollowTarget();
			inAction = false;
		}
	}

	public void ResetWingMat()
	{
		origWing.SetFloat("_OpacScale", 1f);
	}

	public void Death()
	{
		if ((bool)currentSwords)
		{
			Object.Destroy(currentSwords);
		}
		if ((bool)currentEnrageEffect)
		{
			Object.Destroy(currentEnrageEffect);
		}
		if (!bossVersion)
		{
			Object.Instantiate(genericOutro, base.transform.position, Quaternion.LookRotation(new Vector3(base.transform.forward.x, 0f, base.transform.forward.z)));
			Object.Destroy(base.gameObject);
		}
	}

	private void SpawnSummonedSwordsWindup()
	{
		currentWindup = Object.Instantiate(summonedSwordsWindup, base.transform.position, Quaternion.identity);
		currentWindup.transform.SetParent(base.transform, worldPositionStays: true);
	}

	private void SpawnSummonedSwords()
	{
		if ((bool)currentWindup)
		{
			Object.Destroy(currentWindup);
		}
		currentSwords = Object.Instantiate(summonedSwords, base.transform.position, Quaternion.identity);
		currentSwords.transform.SetParent(base.transform.parent, worldPositionStays: true);
		if (currentSwords.TryGetComponent<SummonedSwords>(out var component))
		{
			component.target = new EnemyTarget(base.transform);
			component.speed *= eid.totalSpeedModifier;
			component.targetEnemy = eid.target;
		}
		Projectile[] componentsInChildren = currentSwords.GetComponentsInChildren<Projectile>();
		foreach (Projectile projectile in componentsInChildren)
		{
			projectile.target = target;
			if (eid.totalDamageModifier != 1f)
			{
				projectile.damage *= eid.totalDamageModifier;
			}
		}
	}
}



public class GabrielCombinedSwordsThrown : MonoBehaviour
{
	public Transform justice;

	public Transform splendor;

	public GameObject teleportSword;

	[HideInInspector]
	public GabrielSecond gabe;

	private Transform parent;

	private void Start()
	{
		if (!gabe)
		{
			gabe = Object.FindObjectOfType<GabrielSecond>();
		}
		parent = base.transform.parent;
	}

	private void OnDestroy()
	{
		if (base.gameObject.scene.isLoaded && (bool)parent && parent.gameObject.activeSelf && (bool)gabe)
		{
			if (gabe.swordsCombined)
			{
				gabe.UnGattai(destroySwords: false);
			}
			CreateTrail(justice, gabe.leftHand);
			CreateTrail(splendor, gabe.rightHand);
			if (Object.Instantiate(gabe.teleportSound, gabe.transform.position, Quaternion.identity).TryGetComponent<AudioSource>(out var component))
			{
				component.pitch = 1.5f;
			}
		}
	}

	private void CreateTrail(Transform start, Transform target)
	{
		if (!start || !target)
		{
			return;
		}
		int num = Mathf.RoundToInt(Vector3.Distance(start.position, target.position) / 2.5f);
		for (int i = 0; i < num; i++)
		{
			MindflayerDecoy[] componentsInChildren = Object.Instantiate(teleportSword, Vector3.Lerp(start.position, target.position, (float)i / (float)num), Quaternion.Lerp(start.rotation, target.rotation, (float)i / (float)num)).GetComponentsInChildren<MindflayerDecoy>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].fadeOverride = (float)i / (float)num + 0.1f;
			}
		}
	}
}



public class GabrielIntro : MonoBehaviour
{
	private Animator anim;

	private bool shaking;

	private bool tracking;

	private Quaternion previousRotation;

	private Vector3 defaultPos;

	private float shakeAmount;

	[SerializeField]
	private Transform root;

	[SerializeField]
	private SkinnedMeshRenderer sword1;

	[SerializeField]
	private GameObject fakeSword1;

	[SerializeField]
	private SkinnedMeshRenderer sword2;

	[SerializeField]
	private GameObject fakeSword2;

	[SerializeField]
	private AudioSource swordUnsheatheSound;

	[SerializeField]
	private GameObject rumbling;

	public void Begin()
	{
		anim = GetComponent<Animator>();
		anim.Play("Intro");
	}

	private void Update()
	{
		if (shaking)
		{
			shakeAmount = Mathf.MoveTowards(shakeAmount, 0.125f, Time.deltaTime * 0.0125f);
			MonoSingleton<CameraController>.Instance.CameraShake(shakeAmount * 2f);
			base.transform.position = new Vector3(defaultPos.x + Random.Range(0f - shakeAmount, shakeAmount), defaultPos.y + Random.Range(0f - shakeAmount, shakeAmount), defaultPos.z + Random.Range(0f - shakeAmount, shakeAmount));
		}
	}

	private void LateUpdate()
	{
		if (tracking)
		{
			root.rotation = Quaternion.RotateTowards(previousRotation, Quaternion.LookRotation(MonoSingleton<PlayerTracker>.Instance.GetTarget().position - root.position), Time.deltaTime * 720f);
			previousRotation = root.rotation;
		}
	}

	private void StartShaking()
	{
		shaking = true;
		defaultPos = base.transform.position;
		rumbling.SetActive(value: true);
	}

	private void StopShaking()
	{
		shaking = false;
		base.transform.position = defaultPos;
		rumbling.SetActive(value: false);
	}

	private void StartTracking()
	{
		tracking = true;
		previousRotation = root.rotation;
	}

	private void SwordPull(int sword)
	{
		switch (sword)
		{
		case 1:
			sword1.enabled = true;
			fakeSword1.SetActive(value: false);
			break;
		case 2:
			sword2.enabled = true;
			fakeSword2.SetActive(value: false);
			break;
		}
		Object.Instantiate(swordUnsheatheSound, root.position, Quaternion.identity);
	}
}



public class GabrielOutro : MonoBehaviour
{
	private Transform target;

	private Animator anim;

	public Vector3 middlePosition;

	public Gabriel gabe;

	public GabrielSecond gabe2;

	public UnityEvent onEnableWings;

	public UnityEvent onRageStart;

	public UnityEvent onDisappear;

	private bool tracking;

	private void Start()
	{
		if (!target)
		{
			target = MonoSingleton<NewMovement>.Instance.transform;
		}
		anim = GetComponent<Animator>();
		Invoke("ToEndAnimation", 0.75f);
	}

	private void OnDisable()
	{
		CancelInvoke();
	}

	private void Update()
	{
		if (tracking)
		{
			Quaternion quaternion = Quaternion.LookRotation(new Vector3(target.position.x, base.transform.position.y, target.position.z) - base.transform.position, Vector3.up);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * Mathf.Clamp(Quaternion.Angle(base.transform.rotation, quaternion) * 2f, 1f, 90f));
		}
	}

	public void SetSource(Transform tf)
	{
		if (!target)
		{
			target = MonoSingleton<NewMovement>.Instance.transform;
		}
		base.transform.position = tf.position;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
	}

	public void ToEndAnimation()
	{
		int num = Mathf.RoundToInt(Vector3.Distance(base.transform.position, middlePosition) / 2.5f);
		for (int i = 0; i < num; i++)
		{
			if ((bool)gabe)
			{
				gabe.CreateDecoy(Vector3.Lerp(base.transform.position, middlePosition, (float)i / (float)num), (float)i / (float)num + 0.1f, anim);
			}
			else
			{
				gabe2.CreateDecoy(Vector3.Lerp(base.transform.position, middlePosition, (float)i / (float)num), (float)i / (float)num + 0.1f, anim);
			}
		}
		base.transform.position = middlePosition;
		Object.Instantiate(gabe ? gabe.teleportSound : gabe2.teleportSound, base.transform.position, Quaternion.identity);
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.Play("Outro");
	}

	public void EnableWings()
	{
		onEnableWings?.Invoke();
		tracking = true;
	}

	public void RageStart()
	{
		onRageStart?.Invoke();
	}

	public void Disappear()
	{
		onDisappear?.Invoke();
	}
}



public class GabrielSecond : MonoBehaviour, IHitTargetCallback
{
	private Animator anim;

	private Machine mach;

	private Rigidbody rb;

	private EnemyIdentifier eid;

	private SkinnedMeshRenderer smr;

	private GabrielVoice voice;

	private Collider col;

	public GameObject particles;

	public GameObject particlesEnraged;

	private Material origBody;

	private Material origWing;

	public Material enrageBody;

	public Material enrageWing;

	private int difficulty;

	private bool valuesSet;

	private bool active = true;

	private bool inAction;

	private bool goingLeft;

	private bool goForward;

	private float forwardSpeed;

	private float forwardSpeedMinimum;

	private float forwardSpeedMaximum;

	private float startCooldown = 2f;

	private float attackCooldown;

	public bool enraged;

	private GameObject currentEnrageEffect;

	public bool secondPhase;

	public float phaseChangeHealth;

	private float outOfSightTime;

	private int teleportAttempts;

	private int teleportInterval = 6;

	public GameObject teleportSound;

	public GameObject decoy;

	private bool overrideRotation;

	private bool stopRotation;

	private Vector3 overrideTarget;

	private LayerMask environmentMask;

	[Header("Swords")]
	public Transform rightHand;

	public Transform leftHand;

	private TrailRenderer rightHandTrail;

	private TrailRenderer leftHandTrail;

	[SerializeField]
	private SwingCheck2 generalSwingCheck;

	private SwingCheck2 rightSwingCheck;

	private SwingCheck2 leftSwingCheck;

	private MeshRenderer rightHandGlow;

	private MeshRenderer leftHandGlow;

	[SerializeField]
	private AudioSource swingSound;

	[SerializeField]
	private AudioSource kickSwingSound;

	[SerializeField]
	private Renderer[] swordRenderers;

	[SerializeField]
	private GameObject fakeCombinedSwords;

	[SerializeField]
	private Projectile combinedSwordsThrown;

	private Projectile currentCombinedSwordsThrown;

	[HideInInspector]
	public bool swordsCombined;

	private float combinedSwordsCooldown;

	[HideInInspector]
	public bool lightSwords;

	[Space(20f)]
	public TrailRenderer kickTrail;

	public GameObject dashEffect;

	private bool dashing;

	private float forcedDashTime;

	private Vector3 dashTarget;

	private float[] moveChanceBonuses = new float[4];

	private int previousMove = -1;

	private int burstLength = 2;

	private bool juggled;

	private float juggleHp;

	private float juggleEndHp;

	private float juggleLength;

	public GameObject juggleEffect;

	private bool juggleFalling;

	public GameObject summonedSwords;

	private GameObject currentSwords;

	public GameObject summonedSwordsWindup;

	private GameObject currentWindup;

	private float summonedSwordsCooldown = 15f;

	public Transform head;

	private bool readyTaunt;

	private float defaultAnimSpeed = 1f;

	private bool bossVersion;

	[SerializeField]
	private GameObject genericOutro;

	public bool ceilingHitChallenge;

	[SerializeField]
	private GameObject ceilingHitEffect;

	private float ceilingHitCooldown;

	[Header("Events")]
	public UltrakillEvent onFirstPhaseEnd;

	public UltrakillEvent onSecondPhaseStart;

	private void Awake()
	{
		anim = GetComponent<Animator>();
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		eid = GetComponent<EnemyIdentifier>();
		smr = GetComponentInChildren<SkinnedMeshRenderer>();
		voice = GetComponent<GabrielVoice>();
		col = GetComponent<Collider>();
	}

	private void Start()
	{
		SetValues();
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			origBody = smr.sharedMaterials[0];
			origWing = smr.sharedMaterials[1];
			origWing.SetFloat("_OpacScale", 1f);
			rightHandTrail = rightHand.GetComponentInChildren<TrailRenderer>();
			rightSwingCheck = rightHand.GetComponentInChildren<SwingCheck2>();
			rightHandGlow = rightHand.GetComponentInChildren<MeshRenderer>(includeInactive: true);
			leftHandTrail = leftHand.GetComponentInChildren<TrailRenderer>();
			leftSwingCheck = leftHand.GetComponentInChildren<SwingCheck2>();
			leftHandGlow = leftHand.GetComponentInChildren<MeshRenderer>(includeInactive: true);
			environmentMask = LayerMaskDefaults.Get(LMD.Environment);
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			if (difficulty >= 3)
			{
				burstLength = 3;
			}
			UpdateSpeed();
			if (enraged)
			{
				EnrageNow();
			}
			RandomizeDirection();
			bossVersion = TryGetComponent<BossHealthBar>(out var _);
		}
	}

	private void UpdateBuff()
	{
		SetValues();
		UpdateSpeed();
	}

	private void UpdateSpeed()
	{
		if (difficulty <= 1)
		{
			anim.speed = ((difficulty == 1) ? 0.85f : 0.75f);
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
		defaultAnimSpeed = anim.speed;
	}

	private void OnDisable()
	{
		CancelInvoke();
		if ((bool)leftSwingCheck)
		{
			DamageStopLeft(0);
		}
		if ((bool)rightSwingCheck)
		{
			DamageStopRight(0);
		}
		StopAction();
		ResetAnimSpeed();
		overrideRotation = false;
		dashing = false;
		if ((bool)currentSwords)
		{
			currentSwords.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		if (juggled)
		{
			JuggleStop();
		}
		if ((bool)currentSwords)
		{
			currentSwords.SetActive(value: true);
		}
	}

	private void UpdateRigidbodySettings()
	{
		if (eid.target == null)
		{
			rb.drag = 3f;
			rb.angularDrag = 3f;
		}
		else
		{
			rb.drag = 0f;
			rb.angularDrag = 0f;
		}
	}

	private void Update()
	{
		UpdateRigidbodySettings();
		if (eid.target == null)
		{
			return;
		}
		if (active)
		{
			if (startCooldown > 0f)
			{
				startCooldown = Mathf.MoveTowards(startCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (secondPhase && difficulty >= 3 && !currentSwords)
			{
				summonedSwordsCooldown = Mathf.MoveTowards(summonedSwordsCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
				if (summonedSwordsCooldown == 0f && !inAction && readyTaunt)
				{
					summonedSwordsCooldown = 15f;
					SpawnSummonedSwordsWindup();
					Invoke("SpawnSummonedSwords", 1f / eid.totalSpeedModifier);
				}
			}
			if (!inAction && startCooldown <= 0f)
			{
				if (attackCooldown > 0f)
				{
					attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
					if (readyTaunt && (bool)voice)
					{
						voice.Taunt();
						readyTaunt = false;
					}
				}
				else if ((secondPhase || !currentCombinedSwordsThrown) && Physics.Raycast(base.transform.position, eid.target.position - base.transform.position, Vector3.Distance(base.transform.position, eid.target.position), LayerMaskDefaults.Get(LMD.Environment)))
				{
					Teleport();
				}
				else if ((bool)currentCombinedSwordsThrown && !secondPhase && (combinedSwordsCooldown > 0f || Vector3.Distance(base.transform.position, combinedSwordsThrown.transform.position) < Vector3.Distance(base.transform.position, eid.target.position)))
				{
					combinedSwordsCooldown = Mathf.MoveTowards(combinedSwordsCooldown, 0f, Time.deltaTime);
				}
				else
				{
					bool flag = false;
					bool flag2 = false;
					if (Vector3.Distance(base.transform.position, eid.target.position) > 20f)
					{
						flag2 = true;
					}
					else if (Vector3.Distance(base.transform.position, eid.target.position) < 5f)
					{
						flag = true;
					}
					float[] array = new float[4];
					int num = -1;
					if (previousMove != 0 && !flag)
					{
						array[0] = Random.Range(0f, 1f) + moveChanceBonuses[0];
					}
					if (previousMove != 1 && !flag)
					{
						array[1] = Random.Range(0f, 1f) + moveChanceBonuses[1];
					}
					if (previousMove != 2 && !flag2)
					{
						array[2] = Random.Range(0f, 1f) + moveChanceBonuses[2];
					}
					if (previousMove != 3 && !flag2)
					{
						array[3] = Random.Range(0f, 1f) + moveChanceBonuses[3];
					}
					float num2 = 0f;
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i] > num2)
						{
							num2 = array[i];
							num = i;
						}
					}
					switch (num)
					{
					case 0:
						CombineSwords();
						break;
					case 1:
						FastComboDash();
						break;
					case 2:
						BasicCombo();
						break;
					case 3:
						ThrowCombo();
						break;
					}
					ResetAnimSpeed();
					previousMove = num;
					for (int j = 0; j < array.Length; j++)
					{
						if (j != num)
						{
							moveChanceBonuses[j] += 0.25f;
						}
						else
						{
							moveChanceBonuses[j] = 0f;
						}
					}
					if (num != 0)
					{
						if (burstLength > 1)
						{
							burstLength--;
						}
						else
						{
							if (difficulty >= 3)
							{
								burstLength = 3;
							}
							else
							{
								burstLength = 2;
							}
							if (difficulty <= 3)
							{
								attackCooldown = 3f;
							}
							else
							{
								attackCooldown = 5 - difficulty;
							}
							readyTaunt = true;
						}
					}
				}
			}
			if ((Vector3.Distance(base.transform.position, eid.target.position) > 20f || base.transform.position.y > eid.target.position.y + 15f || Physics.Raycast(base.transform.position, eid.target.position - base.transform.position, Vector3.Distance(base.transform.position, eid.target.position), environmentMask)) && startCooldown <= 0f)
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 3f, Time.deltaTime * eid.totalSpeedModifier);
				if (outOfSightTime >= 3f && !inAction)
				{
					Teleport();
				}
			}
			else
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 0f, Time.deltaTime * 2f * eid.totalSpeedModifier);
			}
			if (!stopRotation)
			{
				if (!overrideRotation)
				{
					Quaternion quaternion = Quaternion.LookRotation(eid.target.position - base.transform.position, Vector3.up);
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * (10f * Quaternion.Angle(quaternion, base.transform.rotation) + 2f) * eid.totalSpeedModifier);
				}
				else
				{
					Quaternion quaternion2 = Quaternion.LookRotation(overrideTarget - base.transform.position, Vector3.up);
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion2, Time.deltaTime * (2500f * Quaternion.Angle(quaternion2, base.transform.rotation) + 10f) * eid.totalSpeedModifier);
				}
			}
		}
		if (!secondPhase && mach.health <= phaseChangeHealth)
		{
			if (!juggled)
			{
				JuggleStart();
			}
			secondPhase = true;
			voice.secondPhase = true;
		}
		if (!juggled)
		{
			return;
		}
		if (mach.health < juggleHp)
		{
			if (rb.velocity.y < 0f)
			{
				rb.velocity = Vector3.zero;
			}
			rb.AddForce(Vector3.up * (juggleHp - mach.health) * 10f, ForceMode.VelocityChange);
			anim.Play("Juggle", 0, 0f);
			juggleHp = mach.health;
			base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
			voice.Hurt();
			if (mach.health < juggleEndHp || juggleLength <= 0f)
			{
				JuggleStop(enrage: true);
			}
		}
		juggleLength = Mathf.MoveTowards(juggleLength, 0f, Time.deltaTime * eid.totalSpeedModifier);
	}

	private void FixedUpdate()
	{
		if (eid.target == null)
		{
			return;
		}
		if (!juggled)
		{
			if (!inAction)
			{
				Vector3 zero = Vector3.zero;
				float num = Vector3.Distance(base.transform.position, eid.target.position);
				if (num > 10f)
				{
					zero += base.transform.forward * 7.5f;
				}
				else if (num > 5f)
				{
					zero += base.transform.forward * 7.5f * (num / 10f);
				}
				RaycastHit hitInfo;
				if (eid.target == null)
				{
					zero = Vector3.zero;
				}
				else if (goingLeft)
				{
					if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right * -1f, out hitInfo, 3f, environmentMask))
					{
						zero += base.transform.right * -5f;
					}
					else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right, out hitInfo, 3f, environmentMask))
					{
						goingLeft = false;
					}
					else
					{
						zero += base.transform.forward * 5f;
					}
				}
				else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right, out hitInfo, 3f, environmentMask))
				{
					zero += base.transform.right * 5f;
				}
				else if (!Physics.SphereCast(base.transform.position, 1.25f, base.transform.right * -1f, out hitInfo, 3f, environmentMask))
				{
					goingLeft = true;
				}
				else
				{
					zero += base.transform.forward * 5f;
				}
				rb.velocity = zero * eid.totalSpeedModifier;
			}
			else if (goForward)
			{
				if (!MonoSingleton<NewMovement>.Instance.playerCollider.Raycast(new Ray(base.transform.position, base.transform.forward), out var hitInfo2, forwardSpeed * Time.fixedDeltaTime))
				{
					rb.velocity = base.transform.forward * forwardSpeed * ((difficulty >= 4) ? 1.25f : 1f);
				}
				else
				{
					if (hitInfo2.distance > 1f)
					{
						base.transform.position += base.transform.forward * (hitInfo2.distance - 1f);
					}
					rb.velocity = Vector3.zero;
				}
			}
			else
			{
				rb.velocity = Vector3.zero;
			}
		}
		else
		{
			if (rb.velocity.y < 35f)
			{
				rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			}
			else
			{
				rb.velocity = new Vector3(0f, 35f, 0f);
			}
			RaycastHit hitInfo3;
			if (ceilingHitCooldown > 0f)
			{
				ceilingHitCooldown = Mathf.MoveTowards(ceilingHitCooldown, 0f, Time.fixedDeltaTime);
			}
			else if (rb.velocity.y > 1f && Physics.Raycast(base.transform.position, Vector3.up, out hitInfo3, 3f + rb.velocity.y * Time.fixedDeltaTime, LayerMaskDefaults.Get(LMD.Environment)))
			{
				ceilingHitCooldown = 0.5f;
				base.transform.position = hitInfo3.point - Vector3.up * 3f;
				mach.GetHurt(base.gameObject, Vector3.zero, Mathf.Min(rb.velocity.y, 5f), 0f);
				rb.velocity = new Vector3(0f, 0f - rb.velocity.y, 0f);
				anim.Play("Juggle", 0, 0f);
				juggleHp = mach.health;
				voice.Hurt();
				Object.Instantiate(ceilingHitEffect, hitInfo3.point - Vector3.up, Quaternion.LookRotation(Vector3.down));
				MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
				if (ceilingHitChallenge)
				{
					MonoSingleton<ChallengeManager>.Instance.ChallengeDone();
				}
			}
			if (juggleFalling && Physics.SphereCast(base.transform.position, 1.25f, Vector3.down, out hitInfo3, 3.6f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				JuggleStop();
			}
			if (rb.velocity.y < 0f)
			{
				juggleFalling = true;
			}
		}
		if (dashing)
		{
			col.enabled = false;
			if (forcedDashTime > 0f)
			{
				forcedDashTime = Mathf.MoveTowards(forcedDashTime, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (Vector3.Distance(base.transform.position, dashTarget) > 5f)
			{
				if (!Physics.SphereCast(base.transform.position, 0.75f, dashTarget - base.transform.position, out var hitInfo4, Vector3.Distance(base.transform.position, dashTarget) - 0.75f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore) || (hitInfo4.collider.gameObject.layer == 11 && eid.target != null && eid.target.enemyIdentifier != null && hitInfo4.collider.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && eid.target.enemyIdentifier == component.eid))
				{
					rb.velocity = base.transform.forward * 100f * eid.totalSpeedModifier;
					return;
				}
				col.enabled = true;
				dashTarget = eid.target.position;
				Teleport(closeRange: false, longrange: true);
				forcedDashTime = 0.35f;
				LookAtTarget();
			}
			else if (forcedDashTime <= 0f)
			{
				dashing = false;
				FastCombo();
			}
		}
		else
		{
			col.enabled = true;
		}
	}

	private void BasicCombo()
	{
		if (!juggled && eid.target != null)
		{
			CheckIfSwordsCombined();
			forwardSpeedMinimum = 125f;
			forwardSpeedMaximum = 175f;
			inAction = true;
			anim.Play("BasicCombo");
		}
	}

	private void FastComboDash()
	{
		if (!juggled && eid.target != null)
		{
			CheckIfSwordsCombined();
			if (difficulty >= 2)
			{
				forwardSpeed = 100f;
			}
			else
			{
				forwardSpeed = 40f;
			}
			forwardSpeed *= eid.totalSpeedModifier;
			anim.Play("FastComboDash");
			inAction = true;
		}
	}

	private void FastCombo()
	{
		if (!juggled && eid.target != null)
		{
			forwardSpeedMinimum = 75f;
			forwardSpeedMaximum = 125f;
			inAction = true;
			anim.Play("FastCombo");
			LookAtTarget();
		}
	}

	private void ThrowCombo()
	{
		if (!juggled && eid.target != null)
		{
			CheckIfSwordsCombined();
			forwardSpeedMinimum = 125f;
			forwardSpeedMaximum = 175f;
			inAction = true;
			anim.Play("ThrowCombo");
			LookAtTarget();
		}
	}

	private void CombineSwords()
	{
		if (!juggled && eid.target != null)
		{
			if (swordsCombined)
			{
				UnGattai();
			}
			inAction = true;
			anim.Play("SwordsCombine");
		}
	}

	private void Gattai()
	{
		if (swordsCombined)
		{
			UnGattai();
		}
		swordsCombined = true;
		Renderer[] array = swordRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		fakeCombinedSwords.SetActive(value: true);
	}

	private void CombinedSwordAttack()
	{
		if (!juggled)
		{
			anim.Play("SwordsCombinedThrow");
		}
	}

	public void UnGattai(bool destroySwords = true)
	{
		swordsCombined = false;
		Renderer[] array = swordRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		fakeCombinedSwords.SetActive(value: false);
		if (destroySwords && (bool)currentCombinedSwordsThrown)
		{
			Object.Destroy(currentCombinedSwordsThrown.gameObject);
		}
		if (lightSwords)
		{
			lightSwords = false;
			if (!leftSwingCheck.damaging)
			{
				leftHandGlow.enabled = false;
			}
			if (!rightSwingCheck.damaging)
			{
				rightHandGlow.enabled = false;
			}
		}
	}

	private void CheckIfSwordsCombined()
	{
		if (swordsCombined)
		{
			if (secondPhase || currentCombinedSwordsThrown.friendly)
			{
				CreateLightSwords();
			}
			else
			{
				UnGattai();
			}
		}
	}

	private void CreateLightSwords()
	{
		lightSwords = true;
		leftHandGlow.enabled = true;
		rightHandGlow.enabled = true;
	}

	private void ThrowSwords()
	{
		if (!juggled)
		{
			Object.Instantiate(kickSwingSound, base.transform);
			fakeCombinedSwords.SetActive(value: false);
			currentCombinedSwordsThrown = Object.Instantiate(combinedSwordsThrown, fakeCombinedSwords.transform.position, base.transform.rotation, base.transform.parent);
			currentCombinedSwordsThrown.target = eid.target;
			if (difficulty >= 4)
			{
				currentCombinedSwordsThrown.speed *= 1.75f;
			}
			if (difficulty <= 2)
			{
				combinedSwordsCooldown = 2f;
			}
			else
			{
				combinedSwordsCooldown = 1f;
			}
			currentCombinedSwordsThrown.damage *= eid.totalDamageModifier;
			if (currentCombinedSwordsThrown.TryGetComponent<GabrielCombinedSwordsThrown>(out var component))
			{
				component.gabe = this;
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!juggleFalling || other.gameObject.layer != 0)
		{
			return;
		}
		DeathZone deathZone = ((!other.attachedRigidbody) ? other.GetComponent<DeathZone>() : other.attachedRigidbody.GetComponent<DeathZone>());
		if ((bool)deathZone)
		{
			if ((bool)voice)
			{
				voice.BigHurt();
			}
			base.transform.position = deathZone.respawnTarget;
			eid.DeliverDamage(head.gameObject, Vector3.zero, head.position, 15f, tryForExplode: false);
			juggleFalling = false;
			JuggleStop();
		}
	}

	public void Teleport(bool closeRange = false, bool longrange = false, bool firstTime = true, bool horizontal = false, bool vertical = false)
	{
		if (firstTime)
		{
			teleportAttempts = 0;
		}
		outOfSightTime = 0f;
		Vector3 normalized = Random.onUnitSphere.normalized;
		if (normalized.y < 0f)
		{
			normalized.y *= -1f;
		}
		float num = Random.Range(8, 15);
		if (closeRange)
		{
			num = Random.Range(5, 8);
		}
		else if (longrange)
		{
			num = Random.Range(15, 20);
		}
		if (eid.target == null)
		{
			return;
		}
		Vector3 vector = eid.target.position + Vector3.up;
		vector = ((!Physics.Raycast(eid.target.position + Vector3.up, normalized, out var hitInfo, num, environmentMask, QueryTriggerInteraction.Ignore)) ? (eid.target.position + Vector3.up + normalized * num) : (hitInfo.point - normalized * 3f));
		bool flag = false;
		bool flag2 = false;
		if (Physics.Raycast(vector, Vector3.up, out var hitInfo2, 8f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag = true;
		}
		if (Physics.Raycast(vector, Vector3.down, out var hitInfo3, 8f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag2 = true;
		}
		bool flag3 = false;
		Vector3 vector2 = base.transform.position;
		if (flag && flag2)
		{
			if (Vector3.Distance(hitInfo2.point, hitInfo3.point) > 7f)
			{
				vector2 = ((!horizontal) ? new Vector3(vector.x, (hitInfo3.point.y + hitInfo2.point.y) / 2f, vector.z) : new Vector3(vector.x, hitInfo3.point.y + 3.5f, vector.z));
				flag3 = true;
			}
			else
			{
				teleportAttempts++;
				if (teleportAttempts <= 10)
				{
					Teleport(closeRange, longrange, firstTime: false, horizontal, vertical);
				}
			}
		}
		else
		{
			flag3 = true;
			vector2 = (flag ? (hitInfo2.point + Vector3.down * Random.Range(5, 10)) : (flag2 ? ((!horizontal) ? (hitInfo3.point + Vector3.up * Random.Range(5, 10)) : new Vector3(hitInfo3.point.x, hitInfo3.point.y + 3.5f, hitInfo3.point.z)) : ((!horizontal) ? vector : new Vector3(vector.x, eid.target.position.y, vector.z))));
		}
		if (flag3)
		{
			Collider[] array = Physics.OverlapCapsule(vector2 + base.transform.up * -2.25f, vector2 + base.transform.up * 1.25f, 1.25f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore);
			if (array != null && array.Length != 0)
			{
				for (int num2 = array.Length - 1; num2 >= 0; num2--)
				{
					if (array[num2].gameObject.layer != 11 || eid.target == null || eid.target.enemyIdentifier == null || !array[num2].TryGetComponent<EnemyIdentifierIdentifier>(out var component) || !component.eid || eid.target.enemyIdentifier != component.eid)
					{
						teleportAttempts++;
						if (teleportAttempts <= 10)
						{
							Teleport(closeRange, longrange, firstTime: false, horizontal, vertical);
						}
						return;
					}
				}
			}
			int num3 = Mathf.RoundToInt(Vector3.Distance(base.transform.position, vector2) / 2.5f);
			for (int i = 0; i < num3; i++)
			{
				CreateDecoy(Vector3.Lerp(base.transform.position, vector2, (float)i / (float)num3), (float)i / (float)num3 + 0.1f);
			}
			base.transform.position = vector2;
			teleportAttempts = 0;
			Object.Instantiate(teleportSound, base.transform.position, Quaternion.identity);
			if (eid.hooked)
			{
				MonoSingleton<HookArm>.Instance.StopThrow(1f, sparks: true);
			}
		}
		if (goingLeft)
		{
			goingLeft = false;
		}
		else
		{
			goingLeft = true;
		}
	}

	public GameObject CreateDecoy(Vector3 position, float transparencyOverride = 1f, Animator animatorOverride = null)
	{
		if ((!anim && !animatorOverride) || eid.target == null)
		{
			return null;
		}
		GameObject gameObject = Object.Instantiate(decoy, position, base.transform.GetChild(0).rotation);
		Animator componentInChildren = gameObject.GetComponentInChildren<Animator>();
		AnimatorStateInfo animatorStateInfo = (animatorOverride ? animatorOverride.GetCurrentAnimatorStateInfo(0) : anim.GetCurrentAnimatorStateInfo(0));
		componentInChildren.Play(animatorStateInfo.shortNameHash, 0, animatorStateInfo.normalizedTime);
		componentInChildren.speed = 0f;
		MindflayerDecoy[] componentsInChildren = gameObject.GetComponentsInChildren<MindflayerDecoy>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].fadeOverride = transparencyOverride;
		}
		return gameObject;
	}

	private void StartDash()
	{
		if (eid.target != null)
		{
			inAction = true;
			overrideRotation = true;
			dashTarget = eid.target.position;
			overrideTarget = dashTarget;
			dashing = true;
			Object.Instantiate(dashEffect, base.transform.position, base.transform.rotation);
		}
	}

	private void Parryable()
	{
		if (!juggled)
		{
			mach.ParryableCheck();
			AttackFlash();
		}
	}

	private void AttackFlash(int unparryable = 0)
	{
		if (!juggled)
		{
			Object.Instantiate((unparryable == 0) ? MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash : MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, head).transform.localScale *= 3f;
		}
	}

	private void JuggleStart()
	{
		if (eid.target == null)
		{
			return;
		}
		DamageStopLeft(0);
		DamageStopRight(0);
		MonoSingleton<TimeController>.Instance.SlowDown(0.25f);
		voice.BigHurt();
		inAction = true;
		CancelInvoke();
		dashing = false;
		rb.velocity = Vector3.zero;
		rb.AddForce(Vector3.up * 35f, ForceMode.VelocityChange);
		rb.useGravity = true;
		origWing.SetFloat("_OpacScale", 0f);
		base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		overrideRotation = false;
		stopRotation = true;
		juggled = true;
		juggleHp = mach.health;
		juggleEndHp = mach.health - 7.5f;
		juggleLength = 5f;
		juggleFalling = false;
		Object.Instantiate(juggleEffect, base.transform.position, base.transform.rotation);
		eid.totalDamageTakenMultiplier = 0.5f;
		if ((bool)currentEnrageEffect)
		{
			MeshRenderer componentInChildren = currentEnrageEffect.GetComponentInChildren<MeshRenderer>();
			if ((bool)componentInChildren)
			{
				componentInChildren.material.color = new Color(0.5f, 0f, 0f, 0.5f);
			}
			Light componentInChildren2 = currentEnrageEffect.GetComponentInChildren<Light>();
			if ((bool)componentInChildren2)
			{
				componentInChildren2.enabled = false;
			}
		}
		if (swordsCombined)
		{
			UnGattai();
		}
		particles.SetActive(value: false);
		particlesEnraged.SetActive(value: false);
		ResetAnimSpeed();
		anim.Play("Juggle", 0, 0f);
		onFirstPhaseEnd?.Invoke();
	}

	private void JuggleStop(bool enrage = false)
	{
		rb.useGravity = false;
		if (difficulty != 0)
		{
			burstLength = difficulty;
		}
		else
		{
			burstLength = 1;
		}
		voice.PhaseChange();
		origWing.SetFloat("_OpacScale", 1f);
		stopRotation = false;
		juggled = false;
		if (enraged)
		{
			particlesEnraged.SetActive(value: true);
		}
		else
		{
			particles.SetActive(value: true);
		}
		anim.Play("Idle");
		if ((enrage || mach.health <= phaseChangeHealth) && (bool)currentEnrageEffect)
		{
			EnrageAnimation();
			return;
		}
		inAction = false;
		attackCooldown = 1f;
		Teleport();
	}

	private void EnrageAnimation()
	{
		anim.Play("Enrage", 0, 0f);
		if (difficulty >= 3)
		{
			SpawnSummonedSwordsWindup();
		}
		Invoke("ForceUnEnrage", 3f * anim.speed);
	}

	public void EnrageNow()
	{
		Material[] materials = smr.materials;
		materials[0] = enrageBody;
		materials[1] = enrageWing;
		smr.materials = materials;
		eid.UpdateBuffs(visualsOnly: true);
		if (!currentEnrageEffect)
		{
			currentEnrageEffect = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.enrageEffect, base.transform);
		}
		FadeOut fadeOut = currentEnrageEffect.AddComponent<FadeOut>();
		fadeOut.activateOnEnable = true;
		fadeOut.speed = 0.1f;
		if (particles.activeSelf)
		{
			particlesEnraged.SetActive(value: true);
			particles.SetActive(value: false);
		}
		attackCooldown = 0f;
		readyTaunt = false;
	}

	private void ForceUnEnrage()
	{
		UnEnrage();
		anim.Play("Idle");
		StopAction();
	}

	public void UnEnrage()
	{
		CancelInvoke("ForceUnEnrage");
		Material[] materials = smr.materials;
		materials[0] = origBody;
		materials[1] = origWing;
		smr.materials = materials;
		eid.totalDamageTakenMultiplier = 1f;
		enraged = false;
		if (particlesEnraged.activeSelf)
		{
			particlesEnraged.SetActive(value: false);
			particles.SetActive(value: true);
		}
		if (difficulty >= 3)
		{
			SpawnSummonedSwords();
		}
		if ((bool)currentEnrageEffect)
		{
			Object.Destroy(currentEnrageEffect);
		}
		burstLength = difficulty;
		if (burstLength == 0)
		{
			burstLength = 1;
		}
		onSecondPhaseStart?.Invoke();
		attackCooldown = 0f;
	}

	private void RandomizeDirection()
	{
		if (Random.Range(0f, 1f) > 0.5f)
		{
			goingLeft = true;
		}
		else
		{
			goingLeft = false;
		}
	}

	public void DamageStartLeft(int damage)
	{
		if (!juggled)
		{
			leftHandTrail.emitting = true;
			leftHandGlow.gameObject.SetActive(value: true);
			SetDamage(damage);
			leftSwingCheck.DamageStart();
			generalSwingCheck.DamageStart();
			Object.Instantiate(swingSound, base.transform);
			DecideMovementSpeed(forwardSpeedMinimum, forwardSpeedMaximum);
			goForward = true;
		}
	}

	public void DamageStopLeft(int keepMoving)
	{
		leftHandTrail.emitting = false;
		leftSwingCheck.DamageStop();
		if (!lightSwords)
		{
			leftHandGlow.gameObject.SetActive(value: false);
		}
		if (keepMoving == 0)
		{
			goForward = false;
		}
		if (!rightSwingCheck || !rightSwingCheck.damaging)
		{
			mach.parryable = false;
			generalSwingCheck.DamageStop();
		}
	}

	public void DamageStartRight(int damage)
	{
		if (!juggled)
		{
			rightHandTrail.emitting = true;
			rightHandGlow.gameObject.SetActive(value: true);
			SetDamage(damage);
			rightSwingCheck.DamageStart();
			generalSwingCheck.DamageStart();
			Object.Instantiate(swingSound, base.transform);
			DecideMovementSpeed(forwardSpeedMinimum, forwardSpeedMaximum);
			goForward = true;
		}
	}

	public void DamageStopRight(int keepMoving)
	{
		rightHandTrail.emitting = false;
		rightSwingCheck.DamageStop();
		if (!lightSwords)
		{
			rightHandGlow.gameObject.SetActive(value: false);
		}
		if (keepMoving == 0)
		{
			goForward = false;
		}
		if (!leftSwingCheck || !leftSwingCheck.damaging)
		{
			mach.parryable = false;
			generalSwingCheck.DamageStop();
		}
	}

	public void DamageStartKick(int damage)
	{
		if (!juggled)
		{
			kickTrail.emitting = true;
			SetDamage(damage);
			generalSwingCheck.DamageStart();
			Object.Instantiate(kickSwingSound, base.transform);
			DecideMovementSpeed(forwardSpeedMinimum, forwardSpeedMaximum);
			goForward = true;
		}
	}

	public void DamageStopKick(int keepMoving)
	{
		if ((bool)kickTrail)
		{
			kickTrail.emitting = false;
		}
		if (keepMoving == 0)
		{
			goForward = false;
		}
		if ((!leftSwingCheck || !leftSwingCheck.damaging) && (!rightSwingCheck || !rightSwingCheck.damaging))
		{
			mach.parryable = false;
			generalSwingCheck.DamageStop();
		}
	}

	public void DamageStartBoth(int damage)
	{
		DamageStartLeft(damage);
		DamageStartRight(damage);
	}

	public void DamageStopBoth(int keepMoving)
	{
		DamageStopLeft(keepMoving);
		DamageStopRight(keepMoving);
		DamageStopKick(keepMoving);
	}

	public void SetForwardSpeed(int newSpeed)
	{
		forwardSpeedMinimum = newSpeed;
		forwardSpeedMaximum = newSpeed + 50;
		DecideMovementSpeed(forwardSpeedMinimum, forwardSpeedMaximum);
	}

	public void EnrageTeleport(int teleportType = 0)
	{
		if (secondPhase && !currentCombinedSwordsThrown)
		{
			if (teleportType >= 10)
			{
				if (difficulty < 3)
				{
					return;
				}
				teleportType -= 10;
			}
			if (teleportType <= 0)
			{
				teleportType = 2;
			}
			switch (teleportType)
			{
			case 1:
				Teleport(closeRange: true);
				break;
			case 2:
				Teleport();
				break;
			case 3:
				Teleport(closeRange: true, longrange: false, firstTime: true, horizontal: true);
				break;
			case 4:
				Teleport(closeRange: false, longrange: false, firstTime: true, horizontal: true);
				break;
			case 5:
				Teleport(closeRange: false, longrange: false, firstTime: true, horizontal: false, vertical: true);
				break;
			}
			anim.speed = 0f;
			Invoke("ResetAnimSpeed", 0.25f);
		}
		if (eid.target != null)
		{
			base.transform.LookAt(eid.target.position);
		}
	}

	private void ResetAnimSpeed()
	{
		if ((bool)anim)
		{
			anim.speed = defaultAnimSpeed;
		}
	}

	public void LookAtTarget(int instant = 0)
	{
		if (eid.target != null)
		{
			overrideRotation = true;
			overrideTarget = base.transform.position + (eid.target.position - base.transform.position).normalized * 999f;
			base.transform.LookAt(base.transform.position + (eid.target.position - base.transform.position).normalized * 999f);
		}
	}

	public void FollowTarget()
	{
		if (!juggled)
		{
			overrideRotation = false;
		}
	}

	public void StopAction()
	{
		if (!juggled)
		{
			FollowTarget();
			inAction = false;
		}
	}

	public void ResetWingMat()
	{
		origWing.SetFloat("_OpacScale", 1f);
	}

	public void Death()
	{
		if ((bool)currentSwords)
		{
			Object.Destroy(currentSwords);
		}
		if ((bool)currentEnrageEffect)
		{
			Object.Destroy(currentEnrageEffect);
		}
		if (!bossVersion)
		{
			Object.Instantiate(genericOutro, base.transform.position, Quaternion.LookRotation(new Vector3(base.transform.forward.x, 0f, base.transform.forward.z)));
			Object.Destroy(base.gameObject);
		}
	}

	private void SetDamage(int damage)
	{
		leftSwingCheck.damage = damage;
		rightSwingCheck.damage = damage;
		generalSwingCheck.damage = damage;
	}

	public void TargetBeenHit()
	{
		leftSwingCheck.DamageStop();
		rightSwingCheck.DamageStop();
		generalSwingCheck.DamageStop();
		goForward = false;
	}

	private void DecideMovementSpeed(float normal, float longDistance)
	{
		if (eid.target != null)
		{
			if (difficulty <= 1)
			{
				forwardSpeed = normal * anim.speed;
			}
			forwardSpeed = ((Vector3.Distance(eid.target.position + eid.target.GetVelocity() * 0.25f, base.transform.position) > 20f) ? (longDistance * anim.speed * (currentSwords ? 0.85f : 1f)) : (normal * anim.speed));
		}
	}

	private void SpawnSummonedSwordsWindup()
	{
		currentWindup = Object.Instantiate(summonedSwordsWindup, base.transform.position, Quaternion.identity);
		currentWindup.transform.SetParent(base.transform, worldPositionStays: true);
	}

	private void SpawnSummonedSwords()
	{
		if ((bool)currentWindup)
		{
			Object.Destroy(currentWindup);
		}
		currentSwords = Object.Instantiate(summonedSwords, base.transform.position, Quaternion.identity);
		currentSwords.transform.SetParent(base.transform.parent, worldPositionStays: true);
		if (currentSwords.TryGetComponent<SummonedSwords>(out var component))
		{
			component.target = new EnemyTarget(base.transform);
			component.speed *= eid.totalSpeedModifier;
			component.targetEnemy = eid.target;
		}
		if (eid.totalDamageModifier != 1f)
		{
			Projectile[] componentsInChildren = currentSwords.GetComponentsInChildren<Projectile>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].damage *= eid.totalDamageModifier;
			}
		}
	}
}



public class GabrielVoice : MonoBehaviour
{
	private AudioSource aud;

	public AudioClip[] hurt;

	public AudioClip[] bigHurt;

	public AudioClip phaseChange;

	public string phaseChangeSubtitle;

	public AudioClip[] taunt;

	[SerializeField]
	private string[] taunts;

	public bool secondPhase;

	public AudioClip[] tauntSecondPhase;

	[SerializeField]
	private string[] tauntsSecondPhase;

	private List<int> usedTaunts = new List<int>();

	private int priority;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if ((bool)aud && !aud.isPlaying)
		{
			priority = 0;
		}
	}

	public void Hurt()
	{
		if (priority <= 0)
		{
			if (hurt.Length > 1)
			{
				aud.clip = hurt[Random.Range(0, hurt.Length)];
			}
			else
			{
				aud.clip = hurt[0];
			}
			aud.volume = 0.75f;
			aud.Play();
		}
	}

	public void BigHurt()
	{
		if (priority <= 2)
		{
			priority = 2;
			if (bigHurt.Length > 1)
			{
				aud.clip = bigHurt[Random.Range(0, bigHurt.Length)];
			}
			else
			{
				aud.clip = bigHurt[0];
			}
			aud.volume = 1f;
			aud.Play();
		}
	}

	public void PhaseChange()
	{
		if (priority <= 3)
		{
			priority = 3;
			aud.clip = phaseChange;
			aud.volume = 1f;
			aud.Play();
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle(phaseChangeSubtitle);
		}
	}

	public void Taunt()
	{
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		if (secondPhase)
		{
			TauntNow(tauntSecondPhase, tauntsSecondPhase);
		}
		else
		{
			TauntNow(taunt, taunts);
		}
	}

	private void TauntNow(AudioClip[] clips, string[] subs)
	{
		if (priority > 1)
		{
			return;
		}
		priority = 1;
		if (clips.Length > 1)
		{
			int num = Random.Range(0, clips.Length);
			if (usedTaunts.Contains(num))
			{
				for (int i = 0; i < clips.Length; i++)
				{
					if (!usedTaunts.Contains(i))
					{
						num = i;
						break;
					}
				}
			}
			aud.clip = clips[num];
			if (usedTaunts.Count == clips.Length - 1)
			{
				usedTaunts.Clear();
			}
			usedTaunts.Add(num);
			if (subs[num] != "")
			{
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle(subs[num]);
			}
		}
		else
		{
			aud.clip = clips[0];
		}
		aud.volume = 0.85f;
		aud.Play();
	}
}


public enum GabrielWeaponType
{
	Sword,
	Zweihander,
	Axe,
	Spear,
	Glaive
}



[Serializable]
public class GameBuildSettings
{
	public string startScene;

	public bool noTutorial;

	private static GameBuildSettings _instance;

	public static GameBuildSettings Default => new GameBuildSettings
	{
		startScene = null,
		noTutorial = false
	};

	public static GameBuildSettings Agony => new GameBuildSettings
	{
		startScene = "Main Menu",
		noTutorial = true
	};

	public static GameBuildSettings SandboxOnly => new GameBuildSettings
	{
		startScene = "uk_construct",
		noTutorial = true
	};

	public static GameBuildSettings GetInstance()
	{
		if (_instance == null)
		{
			string path = Path.Combine(Application.streamingAssetsPath, "GameBuildSettings.json");
			if (File.Exists(path))
			{
				try
				{
					_instance = JsonConvert.DeserializeObject<GameBuildSettings>(File.ReadAllText(path));
				}
				catch (Exception arg)
				{
					Debug.LogError($"Failed to load GameBuildSettings: {arg}");
					_instance = Default;
				}
			}
			else
			{
				_instance = Default;
			}
		}
		return _instance;
	}
}



public class GameEnd : MonoBehaviour
{
	public AudioSource aud;

	private AudioSource endingSong;

	private void Awake()
	{
		endingSong = GameObject.FindWithTag("EndingSong").GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (endingSong.volume < 1f)
		{
			endingSong.volume += Time.deltaTime / 2f;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			endingSong.volume = 0f;
			aud.volume = 0f;
			Invoke("EndGame", 0.1f);
		}
	}

	private void EndGame()
	{
		Application.Quit();
	}
}



public static class GameObjectExtensions
{
	public static T GetOrAddComponent<T>(this GameObject gameObject) where T : Component
	{
		if (gameObject.TryGetComponent<T>(out var component))
		{
			return component;
		}
		return gameObject.AddComponent<T>();
	}

	public static Component GetOrAddComponent(this GameObject gameObject, Type componentType)
	{
		if (gameObject.TryGetComponent(componentType, out var component))
		{
			return component;
		}
		return gameObject.AddComponent(componentType);
	}
}



internal sealed class GamepadEnableWhileSelected : MonoBehaviour
{
	public GameObject[] GameObjects;

	public GameObject[] Disable;

	public bool DisableWhenDeselected;

	private void Update()
	{
		if (!(MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad))
		{
			return;
		}
		if (EventSystem.current.currentSelectedGameObject == base.gameObject)
		{
			if (GameObjects != null)
			{
				GameObject[] gameObjects = GameObjects;
				for (int i = 0; i < gameObjects.Length; i++)
				{
					gameObjects[i].SetActive(value: true);
				}
			}
			if (Disable != null)
			{
				GameObject[] gameObjects = Disable;
				for (int i = 0; i < gameObjects.Length; i++)
				{
					gameObjects[i]?.SetActive(value: false);
				}
			}
		}
		else if (DisableWhenDeselected && GameObjects != null)
		{
			GameObject[] gameObjects = GameObjects;
			for (int i = 0; i < gameObjects.Length; i++)
			{
				gameObjects[i].SetActive(value: false);
			}
		}
	}
}



[DefaultExecutionOrder(1000)]
public class GamepadObjectSelector : MonoBehaviour
{
	private static Stack<GamepadObjectSelector> s_Selectors = new Stack<GamepadObjectSelector>();

	[SerializeField]
	private bool selectOnEnable = true;

	[SerializeField]
	private bool firstChild;

	[SerializeField]
	private bool allowNonInteractable;

	[SerializeField]
	private bool topOnly;

	[SerializeField]
	private bool dontMarkTop;

	[SerializeField]
	[FormerlySerializedAs("target")]
	private GameObject mainTarget;

	[SerializeField]
	private GameObject fallbackTarget;

	private GameObject target
	{
		get
		{
			if (!(mainTarget != null) || !mainTarget.activeInHierarchy)
			{
				return fallbackTarget;
			}
			return mainTarget;
		}
	}

	private void OnEnable()
	{
		if (!dontMarkTop)
		{
			SetTop();
		}
		if (selectOnEnable && MonoSingleton<InputManager>.Instance?.LastButtonDevice is Gamepad)
		{
			Activate();
		}
	}

	private void OnDisable()
	{
		if (s_Selectors.Peek() == this && EventSystem.current != null && MonoSingleton<InputManager>.Instance?.LastButtonDevice is Gamepad)
		{
			EventSystem.current.SetSelectedGameObject(null);
		}
		PopTop();
	}

	private void Update()
	{
		if (s_Selectors.Count == 0 || s_Selectors.Peek() != this || !(MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad) || (EventSystem.current.currentSelectedGameObject != null && EventSystem.current.currentSelectedGameObject.activeInHierarchy))
		{
			return;
		}
		foreach (GamepadObjectSelector s_Selector in s_Selectors)
		{
			if (topOnly && s_Selectors.Peek() != this)
			{
				break;
			}
			if ((bool)s_Selector)
			{
				if (s_Selector.firstChild && s_Selector.SelectFirstChild(s_Selector.target) != null)
				{
					break;
				}
				if (!(s_Selector.target == null) && s_Selector.target.TryGetComponent<Selectable>(out var component) && component.isActiveAndEnabled && (s_Selector.allowNonInteractable || component.interactable))
				{
					EventSystem.current.SetSelectedGameObject(s_Selector.target);
					break;
				}
			}
		}
	}

	public void Activate()
	{
		if (target == null)
		{
			mainTarget = base.gameObject;
		}
		GameObject gameObject = target;
		if (firstChild && base.gameObject.activeInHierarchy && gameObject != null)
		{
			StartCoroutine(SelectFirstChildOnNextFrame(gameObject));
		}
		else if (base.gameObject.activeInHierarchy && gameObject != null)
		{
			EventSystem.current.SetSelectedGameObject(gameObject);
		}
	}

	public static void DisableTop()
	{
		GamepadObjectSelector gamepadObjectSelector = s_Selectors.Peek();
		if (gamepadObjectSelector != null)
		{
			gamepadObjectSelector.gameObject.SetActive(value: false);
		}
	}

	public void PopTop()
	{
		if (s_Selectors.Peek() == this)
		{
			s_Selectors.Pop();
		}
	}

	public void SetTop()
	{
		if (s_Selectors.Count == 0 || s_Selectors.Peek() != this)
		{
			s_Selectors.Push(this);
		}
	}

	private IEnumerator SelectFirstChildOnNextFrame(GameObject obj)
	{
		yield return null;
		SelectFirstChild(obj);
	}

	private GameObject SelectFirstChild(GameObject obj)
	{
		if (obj == null)
		{
			return null;
		}
		Selectable[] componentsInChildren = obj.GetComponentsInChildren<Selectable>();
		foreach (Selectable selectable in componentsInChildren)
		{
			if (!(selectable.gameObject == obj) && selectable.isActiveAndEnabled && selectable.navigation.mode != 0 && (allowNonInteractable || selectable.interactable))
			{
				obj = selectable.gameObject;
				break;
			}
		}
		EventSystem.current.SetSelectedGameObject(obj);
		return obj;
	}
}



internal class GamepadSelectionBoundsExtension : MonoBehaviour
{
	public RectTransform[] Transforms;
}



public class GamepadSelectionOutline : MonoBehaviour
{
	private static readonly Vector3[] s_Corners = new Vector3[4];

	[SerializeField]
	private Image image;

	[SerializeField]
	private float scrollSpeedPixelsPerSecond = 800f;

	[SerializeField]
	private Vector2 outlineSize = new Vector2(4f, 4f);

	private ScrollRect lastScrollRect;

	private void Update()
	{
		GameObject currentSelectedGameObject = EventSystem.current.currentSelectedGameObject;
		Canvas canvas = (currentSelectedGameObject ? currentSelectedGameObject.GetComponentInParent<Canvas>() : null);
		if (currentSelectedGameObject == null || !currentSelectedGameObject.activeInHierarchy || !currentSelectedGameObject.TryGetComponent<Selectable>(out var _) || MonoSingleton<InputManager>.Instance == null || !(MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad) || canvas.renderMode != 0)
		{
			image.enabled = false;
			return;
		}
		image.enabled = true;
		RectTransform component2 = currentSelectedGameObject.GetComponent<RectTransform>();
		RectTransform rect;
		Bounds selectedBounds = GetSelectedBounds(component2, out rect);
		image.rectTransform.anchoredPosition = selectedBounds.center;
		image.rectTransform.sizeDelta = selectedBounds.size + (Vector3)outlineSize;
		ScrollRect componentInParent = component2.GetComponentInParent<ScrollRect>();
		if (componentInParent != null && !currentSelectedGameObject.TryGetComponent<Scrollbar>(out var _))
		{
			EnsureVisibility(componentInParent, component2, componentInParent != lastScrollRect);
		}
		lastScrollRect = componentInParent;
	}

	private Bounds GetSelectedBounds(RectTransform selected, out RectTransform rect)
	{
		if (selected.TryGetComponent<Selectable>(out var component) && (bool)component.targetGraphic)
		{
			rect = component.targetGraphic.rectTransform;
			return GetRelativeBounds(image.transform.parent, rect);
		}
		rect = selected;
		return GetRelativeBounds(image.transform.parent, selected);
	}

	private Bounds GetRelativeBounds(Transform root, RectTransform child)
	{
		child.GetWorldCorners(s_Corners);
		Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
		Vector3 vector2 = new Vector3(float.MinValue, float.MinValue, float.MinValue);
		for (int i = 0; i < 4; i++)
		{
			Vector3 lhs = root.InverseTransformPoint(s_Corners[i]);
			vector = Vector3.Min(lhs, vector);
			vector2 = Vector3.Max(lhs, vector2);
		}
		Bounds result = new Bounds(vector, Vector3.zero);
		result.Encapsulate(vector2);
		return result;
	}

	private void EnsureVisibility(ScrollRect scrollRect, RectTransform child, bool instantScroll = false)
	{
		Bounds relativeBounds = GetRelativeBounds(scrollRect.content, child);
		if (child.TryGetComponent<GamepadSelectionBoundsExtension>(out var component) && component.Transforms != null)
		{
			RectTransform[] transforms = component.Transforms;
			foreach (RectTransform child2 in transforms)
			{
				relativeBounds.Encapsulate(GetRelativeBounds(scrollRect.content, child2));
			}
		}
		relativeBounds.min -= (Vector3)scrollRect.content.rect.min;
		relativeBounds.max -= (Vector3)scrollRect.content.rect.min;
		float num = scrollRect.content.rect.height - scrollRect.content.rect.height * scrollRect.verticalNormalizedPosition;
		float num2 = scrollRect.content.rect.height - relativeBounds.min.y;
		RectTransform component2;
		float num3 = ((scrollRect.TryGetComponent<RectTransform>(out component2) && num2 < component2.rect.height * 0.75f) ? 1f : ((!(relativeBounds.min.y < num)) ? (relativeBounds.max.y / scrollRect.content.rect.height) : (relativeBounds.min.y / scrollRect.content.rect.height)));
		if (instantScroll)
		{
			scrollRect.verticalNormalizedPosition = num3;
			return;
		}
		float num4 = scrollSpeedPixelsPerSecond / scrollRect.content.rect.height * Time.unscaledDeltaTime;
		if (scrollRect.verticalNormalizedPosition < num3)
		{
			scrollRect.verticalNormalizedPosition = Mathf.Min(scrollRect.verticalNormalizedPosition + num4, num3);
		}
		else if (scrollRect.verticalNormalizedPosition > num3)
		{
			scrollRect.verticalNormalizedPosition = Mathf.Max(scrollRect.verticalNormalizedPosition - num4, num3);
		}
	}
}



[Serializable]
public class GameProgressData
{
	public int levelNum;

	public int difficulty;

	public int[] primeLevels;

	public GameProgressData()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
	}
}



[Serializable]
public class GameProgressMoneyAndGear
{
	public int money;

	public bool introSeen;

	public bool tutorialBeat;

	public bool clashModeUnlocked;

	public bool ghostDroneModeUnlocked;

	public int rev0;

	public int rev1;

	public int rev2;

	public int rev3;

	public int revalt;

	public int sho0;

	public int sho1;

	public int sho2;

	public int sho3;

	public int shoalt;

	public int nai0;

	public int nai1;

	public int nai2;

	public int nai3;

	public int naialt;

	public int rai0;

	public int rai1;

	public int rai2;

	public int rai3;

	public int rock0;

	public int rock1;

	public int rock2;

	public int rock3;

	public int beam0;

	public int beam1;

	public int beam2;

	public int beam3;

	public int arm1;

	public int arm2;

	public int arm3;

	public int[] secretMissions;

	public bool[] limboSwitches;

	public bool[] shotgunSwitches;

	public int[] newEnemiesFound;

	public bool[] unlockablesFound;

	public bool revCustomizationUnlocked;

	public bool shoCustomizationUnlocked;

	public bool naiCustomizationUnlocked;

	public bool raiCustomizationUnlocked;

	public bool rockCustomizationUnlocked;

	public GameProgressMoneyAndGear()
	{
		secretMissions = new int[10];
		newEnemiesFound = new int[Enum.GetValues(typeof(EnemyType)).Length];
	}
}



public static class GameProgressSaver
{
	public enum WeaponCustomizationType
	{
		Revolver,
		Shotgun,
		Nailgun,
		Railcannon,
		RocketLauncher
	}

	public static int currentSlot = 0;

	private static int lastTotalSecrets = -1;

	private static bool initialized;

	private static readonly string[] SlotIgnoreFiles = new string[1] { "prefs" };

	public static string BaseSavePath => Path.Combine((SystemInfo.deviceType == DeviceType.Desktop) ? Directory.GetParent(Application.dataPath).FullName : Application.persistentDataPath, "Saves");

	public static string SavePath => Path.Combine(BaseSavePath, $"Slot{currentSlot + 1}");

	private static string currentDifficultyPath => DifficultySavePath(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"));

	private static string customSavesDir => Path.Combine(SavePath, "Custom");

	private static string customCampaignsDir => Path.Combine(customSavesDir, "Campaigns");

	private static string generalProgressPath => Path.Combine(SavePath, "generalprogress.bepis");

	private static string cyberGrindHighScorePath => Path.Combine(SavePath, "cybergrindhighscore.bepis");

	private static string currentCustomLevelProgressPath => CustomLevelProgressPath(GameStateManager.Instance.currentCustomGame.uniqueIdentifier);

	public static string customMapsPath => Path.Combine(Directory.GetParent(Application.dataPath).FullName, "Mods", "Maps");

	private static string resolveCurrentLevelPath
	{
		get
		{
			if (!SceneHelper.IsPlayingCustom)
			{
				return LevelProgressPath(MonoSingleton<StatsManager>.Instance.levelNumber);
			}
			return currentCustomLevelProgressPath;
		}
	}

	private static string DifficultySavePath(int diff)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			return Path.Combine(SavePath, $"difficulty{diff}progress.bepis");
		}
		if (!string.IsNullOrEmpty(GameStateManager.Instance.currentCustomGame.campaignId))
		{
			return Path.Combine(customCampaignsDir, GameStateManager.Instance.currentCustomGame.campaignId, $"difficulty{diff}progress.bepis");
		}
		return Path.Combine(customCampaignsDir, $"difficulty{diff}progress.bepis");
	}

	private static string CustomLevelProgressPath(string uuid)
	{
		return Path.Combine(customSavesDir, uuid + ".bepis");
	}

	private static string LevelProgressPath(int lvl)
	{
		return Path.Combine(SavePath, $"lvl{lvl}progress.bepis");
	}

	public static void SetSlot(int slot)
	{
		currentSlot = slot;
		lastTotalSecrets = -1;
		MonoSingleton<PrefsManager>.Instance.SetInt("selectedSaveSlot", slot);
		MonoSingleton<BestiaryData>.Instance.CheckSave();
	}

	public static void CreateSaveDirs(bool forceCustom = false)
	{
		if (!Directory.Exists(SavePath))
		{
			Directory.CreateDirectory(SavePath);
		}
		if (SceneHelper.IsPlayingCustom || forceCustom)
		{
			if (!Directory.Exists(customSavesDir))
			{
				Directory.CreateDirectory(customSavesDir);
			}
			if (!Directory.Exists(customCampaignsDir))
			{
				Directory.CreateDirectory(customCampaignsDir);
			}
			if (!Directory.Exists(customMapsPath))
			{
				Directory.CreateDirectory(customMapsPath);
			}
		}
	}

	public static void WipeSlot(int slot)
	{
		int num = currentSlot;
		currentSlot = slot;
		try
		{
			if (Directory.Exists(SavePath))
			{
				string[] files = Directory.GetFiles(SavePath, "*.bepis", SearchOption.TopDirectoryOnly);
				for (int i = 0; i < files.Length; i++)
				{
					File.Delete(files[i]);
				}
			}
		}
		catch (Exception message)
		{
			Debug.LogError(message);
		}
		currentSlot = num;
	}

	private static SaveSlotMenu.SlotData GetDirectorySlotData(string path)
	{
		Debug.Log("Generating SlotData for " + path);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < 6; i++)
		{
			if (ReadFile(Path.Combine(path, $"difficulty{i}progress.bepis")) is GameProgressData gameProgressData && (gameProgressData.levelNum > num || (gameProgressData.levelNum == num && gameProgressData.difficulty > num2)))
			{
				num = gameProgressData.levelNum;
				num2 = gameProgressData.difficulty;
			}
		}
		return new SaveSlotMenu.SlotData
		{
			exists = true,
			highestDifficulty = num2,
			highestLvlNumber = num
		};
	}

	public static SaveSlotMenu.SlotData[] GetSlots()
	{
		int num = currentSlot;
		List<SaveSlotMenu.SlotData> list = new List<SaveSlotMenu.SlotData>();
		for (int i = 0; i < 5; i++)
		{
			currentSlot = i;
			if (!Directory.Exists(SavePath))
			{
				list.Add(new SaveSlotMenu.SlotData
				{
					exists = false
				});
				continue;
			}
			try
			{
				if (!(ReadFile(generalProgressPath) is GameProgressMoneyAndGear))
				{
					list.Add(new SaveSlotMenu.SlotData
					{
						exists = false
					});
					continue;
				}
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
				continue;
			}
			SaveSlotMenu.SlotData directorySlotData = GetDirectorySlotData(SavePath);
			list.Add(directorySlotData);
		}
		currentSlot = num;
		return list.ToArray();
	}

	private static void PrepareFs()
	{
		CreateSaveDirs();
		if (initialized)
		{
			return;
		}
		initialized = true;
		if ((from a in Directory.GetFiles(BaseSavePath, "*.bepis", SearchOption.TopDirectoryOnly)
			where !SlotIgnoreFiles.Contains(Path.GetFileNameWithoutExtension(a))
			select a).ToArray().Length != 0)
		{
			Debug.Log("Old saves found");
			int num = currentSlot;
			currentSlot = 0;
			try
			{
				CreateSaveDirs();
				if (Directory.GetFiles(SavePath, "*.bepis").Length != 0)
				{
					Debug.Log("Slot 1 is populated while old saves also exist. Showing consent screen.");
					SaveSlotMenu.SlotData directorySlotData = GetDirectorySlotData(BaseSavePath);
					SaveSlotMenu.SlotData directorySlotData2 = GetDirectorySlotData(SavePath);
					SaveLoadFailMessage.DisplayMergeConsent(directorySlotData, directorySlotData2);
				}
				else
				{
					MergeRootWithSlotOne(keepRoot: true);
				}
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
			currentSlot = num;
		}
		if (Directory.Exists(Path.Combine(BaseSavePath, "Custom")))
		{
			string[] files = Directory.GetFiles(Path.Combine(BaseSavePath, "Custom"), "*.bepis", SearchOption.TopDirectoryOnly);
			if (files.Length != 0)
			{
				int num2 = currentSlot;
				currentSlot = 0;
				try
				{
					CreateSaveDirs(forceCustom: true);
					string[] array = files;
					foreach (string text in array)
					{
						SafeMove(text, Path.Combine(customSavesDir, Path.GetFileName(text)));
					}
				}
				catch (Exception exception2)
				{
					Debug.LogException(exception2);
				}
				currentSlot = num2;
			}
		}
		currentSlot = MonoSingleton<PrefsManager>.Instance.GetInt("selectedSaveSlot");
	}

	public static void MergeRootWithSlotOne(bool keepRoot)
	{
		string[] array = (from a in Directory.GetFiles(BaseSavePath, "*.bepis", SearchOption.TopDirectoryOnly)
			where !SlotIgnoreFiles.Contains(Path.GetFileNameWithoutExtension(a))
			select a).ToArray();
		foreach (string text in array)
		{
			Debug.Log(text);
			if (!keepRoot)
			{
				File.Delete(text);
			}
			else
			{
				SafeMove(text, Path.Combine(SavePath, Path.GetFileName(text)));
			}
		}
	}

	private static void SafeMove(string source, string target)
	{
		if (File.Exists(target))
		{
			File.Delete(target);
		}
		File.Move(source, target);
	}

	private static object ReadFile(string path)
	{
		PrepareFs();
		if (!File.Exists(path))
		{
			return null;
		}
		using FileStream fileStream = new FileStream(path, FileMode.Open);
		if (fileStream.Length == 0L)
		{
			throw new Exception("Stream Length 0");
		}
		return new BinaryFormatter
		{
			Binder = new RestrictedSerializationBinder
			{
				AllowedTypes = 
				{
					typeof(RankData),
					typeof(CyberRankData),
					typeof(RankScoreData),
					typeof(GameProgressData),
					typeof(GameProgressMoneyAndGear)
				}
			}
		}.Deserialize(fileStream);
	}

	private static void WriteFile(string path, object data)
	{
		PrepareFs();
		Debug.Log("[FS] Writing To " + path);
		Directory.CreateDirectory(Path.GetDirectoryName(path));
		using FileStream fileStream = new FileStream(path, FileMode.OpenOrCreate);
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		try
		{
			binaryFormatter.Serialize(fileStream, data);
			fileStream.Close();
		}
		catch (Exception exception)
		{
			Debug.LogException(exception);
		}
	}

	private static RankData GetRankData(bool returnNull, int lvl = -1)
	{
		string path;
		return GetRankData(out path, lvl, returnNull);
	}

	private static RankData GetRankData(int lvl = -1)
	{
		string path;
		return GetRankData(out path, lvl);
	}

	private static RankData GetRankData(out string path, int lvl = -1, bool returnNull = false)
	{
		PrepareFs();
		path = ((lvl < 0) ? resolveCurrentLevelPath : LevelProgressPath(lvl));
		RankData result;
		if ((result = ReadFile(path) as RankData) == null)
		{
			result = (returnNull ? null : new RankData(MonoSingleton<StatsManager>.Instance));
		}
		return result;
	}

	public static RankData GetCustomRankData(string uuid)
	{
		string text = CustomLevelProgressPath(uuid);
		Debug.Log(text);
		if (!(ReadFile(text) is RankData result))
		{
			return null;
		}
		return result;
	}

	private static GameProgressData GetGameProgress(int difficulty = -1)
	{
		string path;
		return GetGameProgress(out path, difficulty);
	}

	private static GameProgressData GetGameProgress(out string path, int difficulty = -1)
	{
		path = ((difficulty < 0) ? currentDifficultyPath : DifficultySavePath(difficulty));
		GameProgressData gameProgressData;
		if ((gameProgressData = ReadFile(path) as GameProgressData) == null)
		{
			gameProgressData = new GameProgressData();
		}
		if (gameProgressData.primeLevels == null || gameProgressData.primeLevels.Length == 0)
		{
			gameProgressData.primeLevels = new int[3];
		}
		return gameProgressData;
	}

	public static void ChallengeComplete()
	{
		RankData rankData = GetRankData();
		if (!rankData.challenge && (rankData.levelNumber == MonoSingleton<StatsManager>.Instance.levelNumber || SceneHelper.IsPlayingCustom))
		{
			rankData.challenge = true;
			WriteFile(resolveCurrentLevelPath, rankData);
		}
	}

	public static void SaveProgress(int levelNum)
	{
		Debug.Log($"[FS] Saving Progress for Level {levelNum}");
		string path;
		GameProgressData gameProgress = GetGameProgress(out path);
		if (gameProgress.levelNum < levelNum || gameProgress.difficulty != MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"))
		{
			gameProgress.levelNum = levelNum;
			WriteFile(path, gameProgress);
		}
	}

	public static void SaveRank()
	{
		WriteFile(resolveCurrentLevelPath, new RankData(MonoSingleton<StatsManager>.Instance));
	}

	public static RankData GetRank(bool returnNull, int lvl = -1)
	{
		return GetRankData(returnNull, lvl);
	}

	public static void SecretFound(int secretNum)
	{
		lastTotalSecrets = -1;
		string path;
		RankData rankData = GetRankData(out path);
		if ((rankData.levelNumber == MonoSingleton<StatsManager>.Instance.levelNumber || SceneHelper.IsPlayingCustom) && !rankData.secretsFound[secretNum])
		{
			rankData.secretsFound[secretNum] = true;
			WriteFile(path, rankData);
		}
	}

	public static int GetProgress(int difficulty)
	{
		int num = 1;
		for (int i = difficulty; i <= 5; i++)
		{
			GameProgressData gameProgress = GetGameProgress(i);
			if (gameProgress != null && gameProgress.difficulty == i && gameProgress.levelNum > num)
			{
				num = gameProgress.levelNum;
			}
		}
		return num;
	}

	public static RankData GetRank(int levelNumber, bool returnNull = false)
	{
		string path;
		return GetRankData(out path, levelNumber, returnNull);
	}

	public static void SetPrime(int level, int state)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return;
		}
		level--;
		string path;
		GameProgressData gameProgress = GetGameProgress(out path);
		if (level < gameProgress.primeLevels.Length)
		{
			if (state <= gameProgress.primeLevels[level])
			{
				return;
			}
			gameProgress.primeLevels[level] = state;
		}
		else
		{
			int[] array = new int[3];
			for (int i = 0; i < gameProgress.primeLevels.Length; i++)
			{
				array[i] = gameProgress.primeLevels[i];
			}
			for (int j = gameProgress.primeLevels.Length; j < array.Length; j++)
			{
				if (j == level)
				{
					array[j] = state;
				}
				else
				{
					array[j] = 0;
				}
			}
			gameProgress.primeLevels = array;
		}
		WriteFile(path, gameProgress);
	}

	public static int GetPrime(int difficulty, int level)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return 0;
		}
		level--;
		int num = 0;
		for (int i = difficulty; i <= 5; i++)
		{
			GameProgressData gameProgress = GetGameProgress(i);
			if (gameProgress != null && gameProgress.difficulty == i && gameProgress.primeLevels != null && gameProgress.primeLevels.Length > level && gameProgress.primeLevels[level] > num)
			{
				Debug.Log("Highest: . Data: " + gameProgress.primeLevels[level]);
				if (gameProgress.primeLevels[level] >= 2)
				{
					return 2;
				}
				num = gameProgress.primeLevels[level];
			}
		}
		return num;
	}

	public static GameProgressMoneyAndGear GetGeneralProgress()
	{
		PrepareFs();
		GameProgressMoneyAndGear gameProgressMoneyAndGear;
		if ((gameProgressMoneyAndGear = ReadFile(generalProgressPath) as GameProgressMoneyAndGear) == null)
		{
			gameProgressMoneyAndGear = new GameProgressMoneyAndGear();
		}
		if (gameProgressMoneyAndGear.secretMissions == null || gameProgressMoneyAndGear.secretMissions.Length == 0)
		{
			gameProgressMoneyAndGear.secretMissions = new int[10];
		}
		if (gameProgressMoneyAndGear.limboSwitches == null || gameProgressMoneyAndGear.limboSwitches.Length == 0)
		{
			gameProgressMoneyAndGear.limboSwitches = new bool[4];
		}
		if (gameProgressMoneyAndGear.shotgunSwitches == null || gameProgressMoneyAndGear.shotgunSwitches.Length == 0)
		{
			gameProgressMoneyAndGear.shotgunSwitches = new bool[3];
		}
		if (gameProgressMoneyAndGear.newEnemiesFound == null)
		{
			gameProgressMoneyAndGear.newEnemiesFound = new int[Enum.GetValues(typeof(EnemyType)).Length];
		}
		if (gameProgressMoneyAndGear.unlockablesFound == null)
		{
			gameProgressMoneyAndGear.unlockablesFound = new bool[Enum.GetValues(typeof(UnlockableType)).Length];
		}
		return gameProgressMoneyAndGear;
	}

	public static void AddGear(string gear)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			FieldInfo field = typeof(GameProgressMoneyAndGear).GetField(gear, BindingFlags.Instance | BindingFlags.Public);
			if (!(field == null))
			{
				field.SetValue(generalProgress, 1);
				WriteFile(generalProgressPath, generalProgress);
			}
		}
	}

	public static int CheckGear(string gear)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		FieldInfo field = typeof(GameProgressMoneyAndGear).GetField(gear, BindingFlags.Instance | BindingFlags.Public);
		if (field == null)
		{
			return 0;
		}
		object value = field.GetValue(generalProgress);
		if (value == null)
		{
			return 0;
		}
		return (int)value;
	}

	public static void AddMoney(int money)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			if (generalProgress.money + money >= 0)
			{
				generalProgress.money += money;
			}
			else
			{
				generalProgress.money = 0;
			}
			WriteFile(generalProgressPath, generalProgress);
		}
	}

	public static void UnlockWeaponCustomization(WeaponCustomizationType weapon)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		switch (weapon)
		{
		case WeaponCustomizationType.Revolver:
			generalProgress.revCustomizationUnlocked = true;
			break;
		case WeaponCustomizationType.Shotgun:
			generalProgress.shoCustomizationUnlocked = true;
			break;
		case WeaponCustomizationType.Nailgun:
			generalProgress.naiCustomizationUnlocked = true;
			break;
		case WeaponCustomizationType.Railcannon:
			generalProgress.raiCustomizationUnlocked = true;
			break;
		case WeaponCustomizationType.RocketLauncher:
			generalProgress.rockCustomizationUnlocked = true;
			break;
		}
		WriteFile(generalProgressPath, generalProgress);
	}

	public static bool HasWeaponCustomization(WeaponCustomizationType weapon)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		return weapon switch
		{
			WeaponCustomizationType.Revolver => generalProgress.revCustomizationUnlocked, 
			WeaponCustomizationType.Shotgun => generalProgress.shoCustomizationUnlocked, 
			WeaponCustomizationType.Nailgun => generalProgress.naiCustomizationUnlocked, 
			WeaponCustomizationType.Railcannon => generalProgress.raiCustomizationUnlocked, 
			WeaponCustomizationType.RocketLauncher => generalProgress.rockCustomizationUnlocked, 
			_ => false, 
		};
	}

	public static int GetMoney()
	{
		return GetGeneralProgress().money;
	}

	public static void SetTutorial(bool beat)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		generalProgress.tutorialBeat = beat;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static bool GetTutorial()
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return true;
		}
		return GetGeneralProgress().tutorialBeat;
	}

	public static void SetIntro(bool seen)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		generalProgress.introSeen = seen;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static bool GetIntro()
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return true;
		}
		return GetGeneralProgress().introSeen;
	}

	public static void SetClashModeUnlocked(bool unlocked)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		generalProgress.clashModeUnlocked = unlocked;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static bool GetClashModeUnlocked()
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return true;
		}
		return GetGeneralProgress().clashModeUnlocked;
	}

	public static void SetGhostDroneModeUnlocked(bool unlocked)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		generalProgress.ghostDroneModeUnlocked = unlocked;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static bool GetGhostDroneModeUnlocked()
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return true;
		}
		return GetGeneralProgress().ghostDroneModeUnlocked;
	}

	public static void SetUnlockable(UnlockableType unlockable, bool state)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		bool[] array = new bool[Enum.GetValues(typeof(UnlockableType)).Length];
		for (int i = 0; i < generalProgress.unlockablesFound.Length; i++)
		{
			array[i] = generalProgress.unlockablesFound[i];
		}
		for (int j = generalProgress.newEnemiesFound.Length; j < array.Length; j++)
		{
			array[j] = false;
		}
		array[(int)unlockable] = state;
		generalProgress.unlockablesFound = array;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static UnlockableType[] GetUnlockables()
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		List<UnlockableType> list = new List<UnlockableType>();
		for (int i = 0; i < generalProgress.unlockablesFound.Length; i++)
		{
			if (generalProgress.unlockablesFound[i])
			{
				list.Add((UnlockableType)i);
			}
		}
		return list.ToArray();
	}

	public static void SetBestiary(EnemyType enemy, int state)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		int[] array = new int[Enum.GetValues(typeof(EnemyType)).Length];
		for (int i = 0; i < generalProgress.newEnemiesFound.Length; i++)
		{
			array[i] = generalProgress.newEnemiesFound[i];
		}
		for (int j = generalProgress.newEnemiesFound.Length; j < array.Length; j++)
		{
			array[j] = 0;
		}
		array[(int)enemy] = state;
		generalProgress.newEnemiesFound = array;
		WriteFile(generalProgressPath, generalProgress);
	}

	public static int[] GetBestiary()
	{
		return GetGeneralProgress().newEnemiesFound;
	}

	public static void SetLimboSwitch(int switchNum)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			if (switchNum < generalProgress.limboSwitches.Length)
			{
				generalProgress.limboSwitches[switchNum] = true;
			}
			WriteFile(generalProgressPath, generalProgress);
		}
	}

	public static bool GetLimboSwitch(int switchNum)
	{
		return GetGeneralProgress().limboSwitches[switchNum];
	}

	public static void SetShotgunSwitch(int switchNum)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			if (switchNum < generalProgress.shotgunSwitches.Length)
			{
				generalProgress.shotgunSwitches[switchNum] = true;
			}
			WriteFile(generalProgressPath, generalProgress);
		}
	}

	public static bool GetShotgunSwitch(int switchNum)
	{
		return GetGeneralProgress().shotgunSwitches[switchNum];
	}

	public static int GetSecretMission(int missionNumber)
	{
		GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
		if (generalProgress.secretMissions.Length > missionNumber)
		{
			return generalProgress.secretMissions[missionNumber];
		}
		return 0;
	}

	public static void FoundSecretMission(int missionNumber)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			if (generalProgress.secretMissions[missionNumber] != 2)
			{
				generalProgress.secretMissions[missionNumber] = 1;
			}
			WriteFile(generalProgressPath, generalProgress);
		}
	}

	public static void SetSecretMission(int missionNumber)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GameProgressMoneyAndGear generalProgress = GetGeneralProgress();
			generalProgress.secretMissions[missionNumber] = 2;
			WriteFile(generalProgressPath, generalProgress);
		}
	}

	public static int GetTotalSecretsFound()
	{
		if (lastTotalSecrets != -1)
		{
			return lastTotalSecrets;
		}
		FileInfo[] files = new DirectoryInfo(SavePath).GetFiles("lvl*progress.bepis");
		int num = 0;
		FileInfo[] array = files;
		for (int i = 0; i < array.Length; i++)
		{
			if (ReadFile(array[i].FullName) is RankData rankData)
			{
				num += rankData.secretsFound.Count((bool a) => a);
			}
		}
		lastTotalSecrets = num;
		return num;
	}

	private static CyberRankData GetCyberRankData()
	{
		CyberRankData cyberRankData;
		if ((cyberRankData = ReadFile(cyberGrindHighScorePath) as CyberRankData) == null)
		{
			cyberRankData = new CyberRankData();
		}
		if (cyberRankData.preciseWavesByDifficulty == null || cyberRankData.preciseWavesByDifficulty.Length != 6)
		{
			cyberRankData.preciseWavesByDifficulty = new float[6];
		}
		if (cyberRankData.style == null || cyberRankData.style.Length != 6)
		{
			cyberRankData.style = new int[6];
		}
		if (cyberRankData.kills == null || cyberRankData.kills.Length != 6)
		{
			cyberRankData.kills = new int[6];
		}
		if (cyberRankData.time == null || cyberRankData.time.Length != 6)
		{
			cyberRankData.time = new float[6];
		}
		return cyberRankData;
	}

	public static CyberRankData GetBestCyber()
	{
		return GetCyberRankData();
	}

	public static void SetBestCyber(FinalCyberRank fcr)
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			CyberRankData cyberRankData = GetCyberRankData();
			int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			cyberRankData.preciseWavesByDifficulty[@int] = fcr.savedWaves;
			cyberRankData.kills[@int] = fcr.savedKills;
			cyberRankData.style[@int] = fcr.savedStyle;
			cyberRankData.time[@int] = fcr.savedTime;
			WriteFile(cyberGrindHighScorePath, cyberRankData);
		}
	}

	public static void ResetBestCyber()
	{
		if (!SceneHelper.IsPlayingCustom && File.Exists(cyberGrindHighScorePath))
		{
			File.Delete(cyberGrindHighScorePath);
		}
	}
}



public class GameState
{
	public string key;

	private bool tracked;

	public LockMode playerInputLock;

	public LockMode cameraInputLock;

	public LockMode cursorLock;

	public float? timerModifier;

	public int priority = 1;

	[CanBeNull]
	public GameObject trackedObject { get; }

	[CanBeNull]
	public GameObject[] trackedObjects { get; }

	public GameState(string key, GameObject trackedObject)
	{
		this.key = key;
		this.trackedObject = trackedObject;
		tracked = trackedObject != null;
	}

	public GameState(string key, GameObject[] trackedObjects)
	{
		this.key = key;
		this.trackedObjects = trackedObjects;
		tracked = trackedObjects != null;
	}

	public GameState(string key)
	{
		this.key = key;
		tracked = false;
	}

	public bool IsValid()
	{
		if (!tracked)
		{
			return true;
		}
		if (trackedObjects != null)
		{
			GameObject[] array = trackedObjects;
			foreach (GameObject gameObject in array)
			{
				if (gameObject != null && gameObject.activeInHierarchy)
				{
					return true;
				}
			}
			return false;
		}
		if (trackedObject != null)
		{
			return trackedObject.activeInHierarchy;
		}
		return false;
	}
}



[DefaultExecutionOrder(-500)]
public class GameStateManager : MonoBehaviour
{
	public CustomGameDetails currentCustomGame;

	private readonly Dictionary<string, GameState> activeStates = new Dictionary<string, GameState>();

	private readonly List<string> stateOrder = new List<string>();

	public static GameStateManager Instance { get; private set; }

	public Vector3 defaultGravity { get; private set; }

	public bool CameraLocked { get; private set; }

	public bool PlayerInputLocked { get; private set; }

	public bool CursorLocked { get; private set; }

	public float TimerModifier { get; private set; } = 1f;


	public static bool CanSubmitScores
	{
		get
		{
			if (!MonoSingleton<StatsManager>.Instance.majorUsed)
			{
				return !MonoSingleton<AssistController>.Instance.cheatsEnabled;
			}
			return false;
		}
	}

	public static bool ShowLeaderboards => CanSubmitScores;

	public bool IsStateActive(string stateKey)
	{
		return activeStates.ContainsKey(stateKey);
	}

	public void RegisterState(GameState newState)
	{
		if (activeStates.ContainsKey(newState.key))
		{
			Debug.LogWarning("State " + newState.key + " is already registered");
			return;
		}
		activeStates.Add(newState.key, newState);
		int num = stateOrder.Count;
		for (int num2 = stateOrder.Count - 1; num2 >= 0; num2--)
		{
			string key = stateOrder[num2];
			GameState gameState = activeStates[key];
			num = num2;
			if (gameState.priority > newState.priority)
			{
				num++;
				break;
			}
		}
		stateOrder.Insert(num, newState.key);
		EvaluateState();
	}

	public void PopState(string stateKey)
	{
		if (!activeStates.ContainsKey(stateKey))
		{
			Debug.Log("Tried to pop state " + stateKey + ", but it was not registered");
			return;
		}
		activeStates.Remove(stateKey);
		stateOrder.Remove(stateKey);
		EvaluateState();
	}

	public void ResetGravity()
	{
		Physics.gravity = defaultGravity;
	}

	private void EvaluateState()
	{
		float num = 1f;
		for (int num2 = stateOrder.Count - 1; num2 >= 0; num2--)
		{
			string key = stateOrder[num2];
			GameState gameState = activeStates[key];
			if (gameState.cursorLock != 0)
			{
				CursorLocked = gameState.cursorLock == LockMode.Lock;
			}
			if (gameState.playerInputLock != 0)
			{
				PlayerInputLocked = gameState.playerInputLock == LockMode.Lock;
			}
			if (gameState.cameraInputLock != 0)
			{
				CameraLocked = gameState.cameraInputLock == LockMode.Lock;
			}
			if (gameState.timerModifier.HasValue)
			{
				num *= gameState.timerModifier.Value;
			}
		}
		Cursor.lockState = (CursorLocked ? CursorLockMode.Locked : CursorLockMode.None);
		Cursor.visible = !CursorLocked;
		TimerModifier = num;
	}

	private void Update()
	{
		for (int num = stateOrder.Count - 1; num >= 0; num--)
		{
			string text = stateOrder[num];
			if (!activeStates[text].IsValid())
			{
				activeStates.Remove(text);
				stateOrder.Remove(text);
				EvaluateState();
				break;
			}
		}
	}

	private void Awake()
	{
		if (Instance != null)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		Instance = this;
		base.transform.SetParent(null);
		Object.DontDestroyOnLoad(base.gameObject);
		defaultGravity = Physics.gravity;
	}
}



public class GasolineProjectile : MonoBehaviour
{
	[SerializeField]
	private GasolineStain stain;

	[SerializeField]
	private Rigidbody rb;

	[SerializeField]
	private SphereCollider col;

	private bool hitSomething;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 10 || other.gameObject.layer == 11)
		{
			if (!hitSomething && other.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && !component.eid.dead)
			{
				hitSomething = true;
				component.eid.AddFlammable(0.1f);
				Object.Destroy(base.gameObject);
			}
		}
		else if (other.gameObject.layer == 8 || other.gameObject.layer == 24)
		{
			Vector3 position = base.transform.position;
			Vector3 vector = -rb.velocity;
			Ray ray = new Ray(base.transform.position - rb.velocity.normalized * Mathf.Max(2.5f, rb.velocity.magnitude * Time.fixedDeltaTime), rb.velocity.normalized);
			if (other.Raycast(ray, out var hitInfo, 10f) && (hitInfo.transform.gameObject.layer == 8 || hitInfo.transform.gameObject.layer == 24))
			{
				position = hitInfo.point + hitInfo.normal * 0.1f;
				vector = hitInfo.normal;
				GasolineStain gasolineStain = Object.Instantiate(stain, position, base.transform.rotation);
				Transform obj = gasolineStain.transform;
				obj.forward = vector * -1f;
				obj.Rotate(Vector3.forward * Random.Range(0f, 360f));
				gasolineStain.AttachTo(other);
				Object.Destroy(base.gameObject);
			}
		}
	}
}



public class GasolineStain : MonoBehaviour
{
	private Vector3 initialSize;

	public Transform Parent { get; private set; }

	public bool IsStatic { get; private set; } = true;


	public bool IsFloor { get; private set; }

	private void Awake()
	{
		MeshRenderer component = GetComponent<MeshRenderer>();
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		component.GetPropertyBlock(materialPropertyBlock);
		materialPropertyBlock.SetFloat("_IsOil", 1f);
		materialPropertyBlock.SetFloat("_Index", Random.Range(0, 5));
		component.SetPropertyBlock(materialPropertyBlock);
		initialSize = base.transform.localScale;
	}

	private void Start()
	{
		IsFloor = CalculateDot() > 0.25f;
		initialSize = base.transform.localScale;
	}

	private float CalculateDot()
	{
		return Vector3.Dot(-base.transform.forward, Vector3.up);
	}

	public void AttachTo(Collider other)
	{
		Transform transform = other.transform;
		GameObject gameObject = other.gameObject;
		base.transform.SetParent(transform, worldPositionStays: true);
		Parent = transform;
		if (gameObject.CompareTag("Moving") || ((bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Contains(transform)) || (gameObject.TryGetComponent<Rigidbody>(out var component) && !component.isKinematic))
		{
			IsStatic = false;
		}
		else
		{
			IsStatic = true;
		}
		Vector3 forward = base.transform.forward;
		Vector3 worldPosition = base.transform.position + forward * -0.5f;
		StainVoxel stainVoxel = MonoSingleton<StainVoxelManager>.Instance.CreateOrGetVoxel(worldPosition);
		VoxelProxy voxelProxy = stainVoxel.CreateOrGetProxyFor(this);
		MonoSingleton<StainVoxelManager>.Instance.AcknowledgeNewStain(stainVoxel);
		if (!IsStatic && (bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Contains(transform) && transform.TryGetComponent<ScrollingTexture>(out var component2) && !component2.attachedObjects.Contains(voxelProxy.transform))
		{
			component2.attachedObjects.Add(voxelProxy.transform);
		}
	}

	public void OnTransformParentChanged()
	{
		initialSize = base.transform.localScale;
	}

	public void SetSize(float size)
	{
		base.transform.localScale = initialSize * size;
	}
}



public class GearCheckEnabler : MonoBehaviour
{
	public string gear;

	public GameObject[] toActivate;

	public GameObject[] toDisactivate;

	public bool checkForFullIntro;

	private void Start()
	{
		if (GameProgressSaver.CheckGear(gear) > 0 && (!checkForFullIntro || PlayerPrefs.GetInt("FullIntro", 0) == 0))
		{
			GameObject[] array = toActivate;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			array = toDisactivate;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
	}
}



public class GearCheckText : MonoBehaviour
{
	public string gearName;

	private Text target;

	private TMP_Text target2;

	private string originalName;

	private void OnEnable()
	{
		if (!target && !target2)
		{
			target = GetComponent<Text>();
			if ((bool)target)
			{
				originalName = target.text;
			}
			else
			{
				target2 = GetComponent<TMP_Text>();
				if ((bool)target2)
				{
					originalName = target2.text;
				}
			}
		}
		if (GameProgressSaver.CheckGear(gearName) == 0)
		{
			if ((bool)target)
			{
				target.text = "???";
			}
			else
			{
				target2.text = "???";
			}
		}
		else if ((bool)target)
		{
			target.text = originalName;
		}
		else
		{
			target2.text = originalName;
		}
	}
}


public static class GetMissionName
{
	public static string GetMission(int missionNum)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return MapInfoBase.InstanceAnyType.levelName;
		}
		if (missionNum == 0)
		{
			return "MAIN MENU";
		}
		return GetMissionNumberOnly(missionNum) + ": " + GetMissionNameOnly(missionNum);
	}

	public static string GetMissionNumberOnly(int missionNum)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return "";
		}
		return missionNum switch
		{
			1 => "0-1", 
			2 => "0-2", 
			3 => "0-3", 
			4 => "0-4", 
			5 => "0-5", 
			6 => "1-1", 
			7 => "1-2", 
			8 => "1-3", 
			9 => "1-4", 
			10 => "2-1", 
			11 => "2-2", 
			12 => "2-3", 
			13 => "2-4", 
			14 => "3-1", 
			15 => "3-2", 
			16 => "4-1", 
			17 => "4-2", 
			18 => "4-3", 
			19 => "4-4", 
			20 => "5-1", 
			21 => "5-2", 
			22 => "5-3", 
			23 => "5-4", 
			24 => "6-1", 
			25 => "6-2", 
			26 => "7-1", 
			27 => "7-2", 
			28 => "7-3", 
			29 => "7-4", 
			30 => "8-1", 
			31 => "8-2", 
			32 => "8-3", 
			33 => "8-4", 
			34 => "9-1", 
			35 => "9-2", 
			666 => "P-1", 
			667 => "P-2", 
			668 => "P-3", 
			_ => "", 
		};
	}

	public static string GetMissionNameOnly(int missionNum)
	{
		if (SceneHelper.IsPlayingCustom)
		{
			return MapInfoBase.InstanceAnyType.levelName;
		}
		return missionNum switch
		{
			0 => "MAIN MENU", 
			1 => "INTO THE FIRE", 
			2 => "THE MEATGRINDER", 
			3 => "DOUBLE DOWN", 
			4 => "A ONE-MACHINE ARMY", 
			5 => "CERBERUS", 
			6 => "HEART OF THE SUNRISE", 
			7 => "THE BURNING WORLD", 
			8 => "HALLS OF SACRED REMAINS", 
			9 => "CLAIR DE LUNE", 
			10 => "BRIDGEBURNER", 
			11 => "DEATH AT 20,000 VOLTS", 
			12 => "SHEER HEART ATTACK", 
			13 => "COURT OF THE CORPSE KING", 
			14 => "BELLY OF THE BEAST", 
			15 => "IN THE FLESH", 
			16 => "SLAVES TO POWER", 
			17 => "GOD DAMN THE SUN", 
			18 => "A SHOT IN THE DARK", 
			19 => "CLAIR DE SOLEIL", 
			20 => "IN THE WAKE OF POSEIDON", 
			21 => "WAVES OF THE STARLESS SEA", 
			22 => "SHIP OF FOOLS", 
			23 => "LEVIATHAN", 
			24 => "CRY FOR THE WEEPER", 
			25 => "AESTHETICS OF HATE", 
			26 => "GARDEN OF FORKING PATHS", 
			27 => "LIGHT UP THE NIGHT", 
			28 => "NO SOUND, NO MEMORY", 
			29 => "...LIKE ANTENNAS TO HEAVEN", 
			30 => "???", 
			31 => "???", 
			32 => "???", 
			33 => "???", 
			34 => "???", 
			35 => "???", 
			666 => "SOUL SURVIVOR", 
			667 => "WAIT OF THE WORLD", 
			668 => "???", 
			_ => "MISSION NAME NOT FOUND", 
		};
	}

	public static string GetSceneName(int missionNum)
	{
		return missionNum switch
		{
			1 => "Level 0-1", 
			2 => "Level 0-2", 
			3 => "Level 0-3", 
			4 => "Level 0-4", 
			5 => "Level 0-5", 
			6 => "Level 1-1", 
			7 => "Level 1-2", 
			8 => "Level 1-3", 
			9 => "Level 1-4", 
			10 => "Level 2-1", 
			11 => "Level 2-2", 
			12 => "Level 2-3", 
			13 => "Level 2-4", 
			14 => "Level 3-1", 
			15 => "Level 3-2", 
			16 => "Level 4-1", 
			17 => "Level 4-2", 
			18 => "Level 4-3", 
			19 => "Level 4-4", 
			20 => "Level 5-1", 
			21 => "Level 5-2", 
			22 => "Level 5-3", 
			23 => "Level 5-4", 
			24 => "Level 6-1", 
			25 => "Level 6-2", 
			26 => "Level 7-1", 
			27 => "Level 7-2", 
			28 => "Level 7-3", 
			29 => "Level 7-4", 
			30 => "Level 8-1", 
			31 => "Level 8-2", 
			32 => "Level 8-3", 
			33 => "Level 8-4", 
			34 => "Level 9-1", 
			35 => "Level 9-2", 
			36 => "Level 10-1", 
			37 => "Level 10-2", 
			666 => "Level P-1", 
			667 => "Level P-2", 
			668 => "Level P-3", 
			_ => "Main Menu", 
		};
	}
}



public class GetMusicVolume : MonoBehaviour
{
	private MusicManager mman;

	private AudioSource[] auds;

	private List<float> origVol = new List<float>();

	private void Start()
	{
		mman = MonoSingleton<MusicManager>.Instance;
		auds = GetComponentsInChildren<AudioSource>();
		AudioSource[] array = auds;
		foreach (AudioSource audioSource in array)
		{
			origVol.Add(audioSource.volume);
		}
		for (int j = 0; j < auds.Length; j++)
		{
			auds[j].volume = origVol[j] * MonoSingleton<AudioMixerController>.Instance.musicVolume;
		}
	}

	private void Update()
	{
		for (int i = 0; i < auds.Length; i++)
		{
			auds[i].volume = origVol[i] * MonoSingleton<AudioMixerController>.Instance.musicVolume;
		}
	}
}



public class GetPlayerPref : MonoBehaviour
{
	public string pref;

	public int valueToCheckFor;

	public UnityEvent onCheckSuccess;

	public UnityEvent onCheckFail;

	private void Awake()
	{
		string text = pref;
		if (!(text == "DisCha"))
		{
			if (text == "ShoUseTut")
			{
				pref = "hideShotgunPopup";
				if (MonoSingleton<PrefsManager>.Instance.GetBool(pref))
				{
					onCheckSuccess?.Invoke();
				}
				else
				{
					onCheckFail?.Invoke();
				}
			}
			else
			{
				pref = "weapon." + pref;
				if (MonoSingleton<PrefsManager>.Instance.GetInt(pref, 1) == valueToCheckFor)
				{
					onCheckSuccess?.Invoke();
				}
				else
				{
					onCheckFail?.Invoke();
				}
			}
		}
		else if (PlayerPrefs.GetInt(pref, 0) == valueToCheckFor)
		{
			onCheckSuccess?.Invoke();
		}
		else
		{
			onCheckFail?.Invoke();
		}
	}
}



public class GetPlayerTagTest : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Player");
		MonoBehaviour.print(array.Length);
		GameObject[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			MonoBehaviour.print(array2[i].gameObject);
		}
	}
}



public class GhostDrone : MonoBehaviour
{
	private LayerMask avoidanceMask;

	public float detectionAngle = 45f;

	public float detectionDistance = 12f;

	public float idleSpeed = 2f;

	public float attackSpeed = 6f;

	private float variableAttackSpeed;

	[HideInInspector]
	public Vector3 vacuumVelocity;

	private Vector3 originalPos = Vector3.zero;

	private Animator animator;

	private PlayerTracker pt;

	private Coroutine crt;

	private bool isAttacking;

	public bool alwaysAggro;

	[SerializeField]
	private GameObject killZone;

	private Light aggroLight;

	private Color startLightColor;

	private float startLightIntensity;

	private AudioSource aud;

	[SerializeField]
	private AudioClip spottedSound;

	[SerializeField]
	private AudioClip lostSound;

	[SerializeField]
	private AudioClip[] idleSounds;

	private TimeSince lastIdleSound;

	private Rigidbody rb;

	public AudioMixerGroup audioGroup;

	public GameObject deathExplosion;

	[SerializeField]
	private AudioClip ghostDeathSound;

	private bool isSucked;

	private bool wasSuckedLastFrame;

	private static readonly int IsScared = Animator.StringToHash("IsScared");

	[SerializeField]
	private AudioSource scaredAudioSource;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		avoidanceMask = LayerMaskDefaults.Get(LMD.Environment);
		aggroLight = GetComponentInChildren<Light>();
		aud = GetComponent<AudioSource>();
		startLightColor = aggroLight.color;
		startLightIntensity = aggroLight.intensity;
		pt = MonoSingleton<PlayerTracker>.Instance;
		animator = GetComponent<Animator>();
		originalPos = base.transform.position;
		crt = StartCoroutine(Fly());
		variableAttackSpeed = attackSpeed + Random.Range((0f - attackSpeed) / 2f, attackSpeed / 2f);
	}

	private void Update()
	{
		TryFindPlayer();
		if (((float)lastIdleSound > Random.Range(3f, 7f) && isAttacking) || (float)lastIdleSound > Random.Range(8f, 12f))
		{
			if (!aud.isPlaying)
			{
				aud.clip = idleSounds[Random.Range(0, idleSounds.Length)];
				aud.pitch = Random.Range(0.9f, 1.1f);
				aud.Play();
			}
			lastIdleSound = 0f;
		}
	}

	private void LateUpdate()
	{
		isSucked = vacuumVelocity.magnitude > 1E-05f;
		if (isSucked)
		{
			animator.speed = 4f;
			isAttacking = false;
			if (!scaredAudioSource.isPlaying)
			{
				scaredAudioSource.pitch = Random.Range(0.8f, 1.2f);
				scaredAudioSource.Play();
			}
		}
		else
		{
			scaredAudioSource.Stop();
		}
		animator.SetBool(IsScared, isSucked);
		if (wasSuckedLastFrame != isSucked)
		{
			if (isSucked)
			{
				StopCoroutine(crt);
				aggroLight.color = startLightColor;
				aggroLight.intensity = startLightIntensity;
			}
			else
			{
				crt = StartCoroutine(Fly());
			}
		}
		if (isSucked)
		{
			Vector3 normalized = (pt.GetTarget().position - base.transform.position).normalized;
			base.transform.rotation = Quaternion.LookRotation(normalized);
		}
		rb.position += vacuumVelocity * Time.deltaTime;
		vacuumVelocity = Vector3.zero;
		wasSuckedLastFrame = isSucked;
	}

	private void TryFindPlayer()
	{
		if (isAttacking || isSucked)
		{
			return;
		}
		Vector3 position = pt.GetTarget().position;
		Vector3 normalized = (position - base.transform.position).normalized;
		float num = Vector3.Angle(base.transform.forward, normalized);
		float num2 = Vector3.Distance(position, base.transform.position);
		if (alwaysAggro || (num2 <= detectionDistance && num < detectionAngle))
		{
			if (crt != null)
			{
				StopCoroutine(crt);
			}
			aud.clip = spottedSound;
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.Play();
			killZone.SetActive(value: true);
			base.transform.rotation = Quaternion.LookRotation(normalized);
			isAttacking = true;
			crt = StartCoroutine(Attack());
		}
	}

	public void KillGhost()
	{
		GameObject obj = Object.Instantiate(deathExplosion, base.transform.position, base.transform.rotation);
		obj.transform.localScale = Vector3.one * 0.1f;
		obj.GetComponent<AudioSource>().volume = 0.1f;
		obj.transform.GetChild(0).GetComponent<AudioSource>().volume = 0.1f;
		ghostDeathSound.PlayClipAtPoint(audioGroup, base.transform.position, 128, 1f, 1f, Random.Range(0.8f, 1.1f));
		Object.Destroy(base.gameObject);
	}

	private IEnumerator Attack()
	{
		aggroLight.color = Color.red;
		aggroLight.intensity = startLightIntensity * 2f;
		animator.speed = 4f * (variableAttackSpeed / attackSpeed);
		while (alwaysAggro || Vector3.Distance(pt.GetTarget().position, base.transform.position) < 30f)
		{
			Vector3 position = base.transform.position;
			Vector3 position2 = pt.GetTarget().position;
			Quaternion rotation = base.transform.rotation;
			Quaternion b = Quaternion.LookRotation((position2 - position).normalized);
			float num = variableAttackSpeed * Time.deltaTime;
			float t = Mathf.SmoothStep(0f, 1f, num * 4f);
			base.transform.rotation = Quaternion.Slerp(rotation, b, t);
			base.transform.position = Vector3.MoveTowards(base.transform.position, position2, num);
			yield return null;
		}
		aud.clip = lostSound;
		aud.pitch = Random.Range(0.9f, 1.1f);
		aud.Play();
		killZone.SetActive(value: false);
		isAttacking = false;
		StopCoroutine(crt);
		crt = StartCoroutine(Fly());
	}

	private IEnumerator Fly()
	{
		aggroLight.color = startLightColor;
		aggroLight.intensity = startLightIntensity;
		animator.speed = 0.5f;
		while (true)
		{
			Vector3 startPos = base.transform.position;
			bool noTarget = true;
			Vector3 targetPos = Vector3.one;
			while (noTarget)
			{
				targetPos = RandomNavmeshLocation(60f);
				Vector3 normalized = (targetPos - startPos).normalized;
				if (!Physics.Raycast(startPos, normalized, (targetPos - startPos).magnitude, avoidanceMask))
				{
					noTarget = false;
				}
				yield return null;
			}
			if (targetPos != startPos)
			{
				targetPos.y += 5f;
				Quaternion startDir = base.transform.rotation;
				float num = Vector3.Distance(startPos, targetPos);
				Vector3 normalized2 = (targetPos - startPos).normalized;
				Quaternion lookDir = Quaternion.LookRotation(normalized2);
				_ = num / idleSpeed;
				float elapsed = 0f;
				animator.speed = 1f;
				while (Vector3.Distance(base.transform.position, targetPos) > 0.1f)
				{
					elapsed += Time.deltaTime;
					float t = Mathf.SmoothStep(0f, 1f, elapsed);
					base.transform.rotation = Quaternion.Slerp(startDir, lookDir, t);
					float maxDistanceDelta = idleSpeed * Time.deltaTime;
					base.transform.position = Vector3.MoveTowards(base.transform.position, targetPos, maxDistanceDelta);
					yield return null;
				}
				animator.speed = 0.5f;
				yield return new WaitForSeconds(1.5f);
			}
		}
	}

	public Vector3 RandomNavmeshLocation(float radius)
	{
		Vector3 sourcePosition = Random.insideUnitSphere * radius + originalPos;
		Vector3 result = Vector3.zero;
		if (NavMesh.SamplePosition(sourcePosition, out var hit, radius, 1))
		{
			result = hit.position;
		}
		return result;
	}
}



public class GhostMode : MonoBehaviour
{
	public GameObject ghostGroup;

	public GameObject ghostLights;

	private GameObject duplicateGhosts;

	private List<GhostDrone> ghostDrones;

	private bool isInGhostMode;

	public GameObject insideLightsGroup;

	public Light[] otherLights;

	private List<Light> lightsToDim = new List<Light>();

	private List<float> defaultIntensities = new List<float>();

	private Coroutine crt;

	private Color defaultAmbientColor;

	public Color dimmedAmbientColor;

	public Renderer godRays;

	private Color defaultRayTint;

	public UltrakillEvent onFinish;

	private void Start()
	{
		lightsToDim.AddRange(insideLightsGroup.GetComponentsInChildren<Light>());
		lightsToDim.AddRange(otherLights);
		defaultRayTint = godRays.sharedMaterial.GetColor("_TintColor");
		defaultAmbientColor = RenderSettings.ambientLight;
		foreach (Light item in lightsToDim)
		{
			defaultIntensities.Add(item.intensity);
		}
	}

	public void StartGhostMode()
	{
		if (crt == null)
		{
			crt = StartCoroutine(RunGhostMode());
		}
	}

	private IEnumerator RunGhostMode()
	{
		ghostLights.SetActive(value: true);
		duplicateGhosts = Object.Instantiate(ghostGroup, ghostGroup.transform.position, ghostGroup.transform.rotation);
		ghostDrones = duplicateGhosts.GetComponentsInChildren<GhostDrone>().ToList();
		duplicateGhosts.SetActive(value: true);
		isInGhostMode = true;
		float time = 0f;
		MaterialPropertyBlock props = new MaterialPropertyBlock();
		while (time < 1f)
		{
			time += Time.deltaTime;
			for (int i = 0; i < lightsToDim.Count; i++)
			{
				lightsToDim[i].intensity = Mathf.Lerp(defaultIntensities[i], 0f, time);
			}
			RenderSettings.ambientLight = Color.Lerp(defaultAmbientColor, dimmedAmbientColor, time);
			Color value = Color.Lerp(defaultRayTint, defaultRayTint * 0.25f, time);
			props.SetColor("_TintColor", value);
			godRays.SetPropertyBlock(props);
			yield return null;
		}
		while (ghostDrones.Count > 0)
		{
			for (int num = ghostDrones.Count - 1; num >= 0; num--)
			{
				GhostDrone ghostDrone = ghostDrones[num];
				if (ghostDrone == null)
				{
					ghostDrones.Remove(ghostDrone);
				}
			}
			yield return null;
		}
		StartCoroutine(EndGhostMode());
	}

	private IEnumerator EndGhostMode()
	{
		float time = 0f;
		MaterialPropertyBlock props = new MaterialPropertyBlock();
		while (time < 1f)
		{
			time += Time.deltaTime;
			for (int i = 0; i < lightsToDim.Count; i++)
			{
				lightsToDim[i].intensity = Mathf.Lerp(0f, defaultIntensities[i], time);
			}
			RenderSettings.ambientLight = Color.Lerp(dimmedAmbientColor, defaultAmbientColor, time);
			Color value = Color.Lerp(defaultRayTint * 0.25f, defaultRayTint, time);
			props.SetColor("_TintColor", value);
			godRays.SetPropertyBlock(props);
			yield return null;
		}
		GameProgressSaver.SetGhostDroneModeUnlocked(unlocked: true);
		MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=orange>DRONE HAUNTING</color> CHEAT UNLOCKED");
		onFinish.Invoke();
	}

	public void ResetOnRespawn()
	{
		if (isInGhostMode)
		{
			ghostLights.SetActive(value: false);
			if (crt != null)
			{
				StopCoroutine(crt);
			}
			crt = null;
			for (int i = 0; i < lightsToDim.Count; i++)
			{
				lightsToDim[i].intensity = defaultIntensities[i];
			}
			RenderSettings.ambientLight = defaultAmbientColor;
			MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
			materialPropertyBlock.SetColor("_TintColor", defaultRayTint);
			godRays.SetPropertyBlock(materialPropertyBlock);
			foreach (GhostDrone ghostDrone in ghostDrones)
			{
				if (ghostDrone != null)
				{
					Object.Destroy(ghostDrone.gameObject);
				}
			}
		}
		isInGhostMode = false;
	}
}



public class GibDestroyer : MonoBehaviour
{
	[SerializeField]
	private AudioSource soundEffect;

	[SerializeField]
	private AudioSource rareSoundEffect;

	private TimeSince lastSound;

	private void OnTriggerEnter(Collider col)
	{
		if (col.gameObject == null)
		{
			return;
		}
		if (col.transform.TryGetComponent<GoreSplatter>(out var component))
		{
			component.Repool();
		}
		else
		{
			if (!col.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component2) || !component2.eid.dead)
			{
				return;
			}
			if ((float)lastSound > 0.1f)
			{
				lastSound = 0f;
				if ((bool)rareSoundEffect && Random.Range(0f, 1f) < 0.025f)
				{
					Object.Instantiate(rareSoundEffect, col.transform.position, Quaternion.identity);
				}
				else if ((bool)soundEffect)
				{
					Object.Instantiate(soundEffect, col.transform.position, Quaternion.identity);
				}
			}
			LimbBegone(col);
		}
	}

	public static void LimbBegone(Collider col)
	{
		col.transform.localScale = Vector3.zero;
		if (col.transform.parent != null)
		{
			col.transform.position = col.transform.parent.position;
		}
		else
		{
			col.transform.position = Vector3.zero;
		}
		if ((bool)col.attachedRigidbody)
		{
			Joint[] componentsInChildren = col.attachedRigidbody.GetComponentsInChildren<Joint>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Object.Destroy(componentsInChildren[i]);
			}
			Object.Destroy(col.attachedRigidbody);
		}
		col.gameObject.SetActive(value: false);
		Object.Destroy(col);
	}
}


public enum GibType
{
	Brain,
	Skull,
	Eye,
	Jaw,
	Gib
}



public class Glass : MonoBehaviour
{
	public bool broken;

	public bool wall;

	private Transform[] glasses;

	public GameObject shatterParticle;

	private int kills;

	private Collider[] cols;

	private List<GameObject> enemies = new List<GameObject>();

	public void Shatter()
	{
		cols = GetComponentsInChildren<Collider>();
		base.gameObject.layer = 17;
		broken = true;
		glasses = base.transform.GetComponentsInChildren<Transform>();
		Transform[] array = glasses;
		foreach (Transform transform in array)
		{
			if (transform.gameObject != base.gameObject)
			{
				Object.Destroy(transform.gameObject);
			}
		}
		Collider[] array2 = cols;
		foreach (Collider collider in array2)
		{
			if (!collider.isTrigger)
			{
				collider.enabled = false;
			}
		}
		foreach (GameObject enemy in enemies)
		{
			if (enemy.TryGetComponent<GroundCheckEnemy>(out var _))
			{
				kills++;
			}
		}
		Invoke("BecomeObstacle", 0.5f);
		Object.Instantiate(shatterParticle, base.transform);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!broken && other.gameObject.layer == 20 && !enemies.Contains(other.gameObject))
		{
			enemies.Add(other.gameObject);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!broken && other.gameObject.layer == 20 && enemies.Contains(other.gameObject))
		{
			enemies.Remove(other.gameObject);
		}
	}

	private void BecomeObstacle()
	{
		NavMeshObstacle component = GetComponent<NavMeshObstacle>();
		if (wall)
		{
			component.carving = false;
			component.enabled = false;
		}
		else
		{
			component.enabled = true;
			Collider[] array = cols;
			foreach (Collider collider in array)
			{
				if (collider != null && !collider.isTrigger)
				{
					collider.enabled = false;
				}
			}
		}
		if (kills >= 3)
		{
			StatsManager instance = MonoSingleton<StatsManager>.Instance;
			if (instance.maxGlassKills < kills)
			{
				instance.maxGlassKills = kills;
			}
		}
		base.enabled = false;
	}
}



public class GlassBreaker : MonoBehaviour
{
	private void Start()
	{
		GetComponentInParent<Glass>().Shatter();
		Object.Destroy(this);
	}
}



public class GLCoreBandaid : MonoBehaviour
{
	public GameObject optionsToHide;

	public GameObject dialogToShow;

	private void OnEnable()
	{
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLCore)
		{
			optionsToHide.SetActive(value: false);
			dialogToShow.SetActive(value: true);
		}
		else
		{
			optionsToHide.SetActive(value: true);
			dialogToShow.SetActive(value: false);
		}
	}
}



public class GoreDisabler : MonoBehaviour
{
	private void Awake()
	{
		if (!MonoSingleton<BloodsplatterManager>.Instance.forceGibs && !MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled"))
		{
			base.gameObject.SetActive(value: false);
		}
	}
}



public class GoreSplatter : MonoBehaviour
{
	public int bloodAbsorberCount;

	public BSType bloodSplatterType;

	private Rigidbody rb;

	private Vector3 direction;

	private float force;

	private bool goreOver;

	private int touchedCollisions;

	private Vector3 defaultScale;

	private bool freezeGore;

	private bool foundParent;

	private Vector3 startPos;

	private bool detectCollisions = true;

	[HideInInspector]
	public bool beenFlung;

	private void OnEnable()
	{
		Invoke("SlowUpdate", 1f);
		if (!beenFlung)
		{
			beenFlung = true;
			if (!rb)
			{
				TryGetComponent<Rigidbody>(out rb);
			}
			StopGore();
			if (!detectCollisions)
			{
				rb.detectCollisions = true;
			}
			defaultScale = base.transform.localScale;
			direction = new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f));
			force = Random.Range(20, 60);
			startPos = base.transform.position;
			bloodAbsorberCount = 0;
			if (StockMapInfo.Instance.continuousGibCollisions)
			{
				rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
			}
			rb.AddForce(direction * force, ForceMode.VelocityChange);
			rb.rotation = Random.rotation;
			freezeGore = !MonoSingleton<BloodsplatterManager>.Instance.neverFreezeGibs && MonoSingleton<PrefsManager>.Instance.GetBoolLocal("freezeGore");
			if (freezeGore)
			{
				Invoke("Repool", 5f);
			}
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
			{
				Invoke("RepoolIfNoAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
		}
	}

	private void OnDisable()
	{
		CancelInvoke("SlowUpdate");
	}

	private void RepoolIfNoAbsorber()
	{
		if (bloodAbsorberCount <= 0)
		{
			Repool();
		}
		else if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
		{
			Invoke("RepoolIfNoAbsorber", StockMapInfo.Instance.gibRemoveTime);
		}
	}

	public void Repool()
	{
		beenFlung = false;
		MonoSingleton<BloodsplatterManager>.Instance.RepoolGore(base.gameObject, bloodSplatterType);
	}

	private void SlowUpdate()
	{
		if (freezeGore && goreOver && rb.velocity.y > -0.1f && rb.velocity.y < 0.1f)
		{
			StopGore();
		}
		if (Vector3.Distance(base.transform.position, startPos) > 1000f)
		{
			Repool();
		}
		if ((bool)rb && base.transform.position.y > 666f && rb.velocity.y > 0f)
		{
			rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
		}
		Invoke("SlowUpdate", 1f);
	}

	private void OnCollisionEnter(Collision other)
	{
		if (freezeGore && (other.gameObject.layer == 8 || other.gameObject.layer == 24) && (other.gameObject.CompareTag("Wall") || other.gameObject.CompareTag("Floor")))
		{
			touchedCollisions++;
			goreOver = true;
		}
	}

	private void OnCollisionExit(Collision other)
	{
		if (freezeGore && (other.gameObject.layer == 8 || other.gameObject.layer == 24) && (other.gameObject.CompareTag("Wall") || other.gameObject.CompareTag("Floor")))
		{
			touchedCollisions--;
			if (touchedCollisions <= 0)
			{
				goreOver = false;
			}
		}
	}

	private void StopGore()
	{
		detectCollisions = false;
		rb.velocity = Vector3.zero;
		rb.detectCollisions = false;
	}
}


public enum GoreType
{
	Head,
	Limb,
	Body,
	Small,
	Splatter,
	Smallest
}



public class GoreZone : MonoBehaviour
{
	[Header("Optional")]
	public Transform goreZone;

	public Transform gibZone;

	[HideInInspector]
	public CheckPoint checkpoint;

	[HideInInspector]
	public float maxGore;

	[HideInInspector]
	public List<GameObject> outsideGore = new List<GameObject>();

	private bool endlessMode;

	private int maxGibs;

	public float goreRenderDistance;

	private bool goreUnrendered;

	public List<GameObject> toDestroy = new List<GameObject>();

	public Queue<Bloodsplatter> splatterQueue = new Queue<Bloodsplatter>();

	public Queue<GameObject> stainQueue = new Queue<GameObject>();

	private static GoreZone _globalRootAutomaticGz;

	private BloodsplatterManager bsm;

	public static GoreZone ResolveGoreZone(Transform transform)
	{
		if (!transform.parent)
		{
			if ((bool)_globalRootAutomaticGz)
			{
				transform.SetParent(_globalRootAutomaticGz.transform);
				return _globalRootAutomaticGz;
			}
			GoreZone goreZone = new GameObject("Automated Gore Zone").AddComponent<GoreZone>();
			transform.SetParent(goreZone.transform);
			_globalRootAutomaticGz = goreZone;
			return goreZone;
		}
		GoreZone componentInParent = transform.GetComponentInParent<GoreZone>();
		if ((bool)componentInParent)
		{
			return componentInParent;
		}
		GoreZone componentInChildren = transform.parent.GetComponentInChildren<GoreZone>();
		if ((bool)componentInChildren)
		{
			transform.SetParent(componentInChildren.transform);
			return componentInChildren;
		}
		GoreZone obj = new GameObject("Automated Gore Zone").AddComponent<GoreZone>();
		Transform transform2 = obj.transform;
		transform2.SetParent(transform.parent);
		transform.SetParent(transform2);
		return obj;
	}

	private void Awake()
	{
		if (goreZone == null)
		{
			GameObject gameObject = new GameObject("Gore Zone");
			goreZone = gameObject.transform;
			goreZone.SetParent(base.transform, worldPositionStays: true);
		}
		if (gibZone == null)
		{
			GameObject gameObject2 = new GameObject("Gib Zone");
			gibZone = gameObject2.transform;
			gibZone.SetParent(base.transform, worldPositionStays: true);
		}
	}

	private void Start()
	{
		bsm = MonoSingleton<BloodsplatterManager>.Instance;
		maxGore = MonoSingleton<OptionsManager>.Instance.maxGore;
		endlessMode = MonoSingleton<EndlessGrid>.Instance != null;
		if (endlessMode)
		{
			maxGibs = Mathf.RoundToInt(maxGore / 40f);
		}
		else
		{
			maxGibs = Mathf.RoundToInt(maxGore / 20f);
		}
		SlowUpdate();
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 1f);
		if (bsm.forceGibs)
		{
			maxGore = 3000f;
			maxGibs = 150;
		}
		for (int num = Mathf.FloorToInt((float)goreZone.childCount - maxGore) - 1; num >= 0; num--)
		{
			Transform child = goreZone.GetChild(num);
			GameObject gameObject = child.gameObject;
			if (gameObject.activeSelf && !child.TryGetComponent<Bloodsplatter>(out var _) && gameObject.layer != 1)
			{
				Object.Destroy(child.gameObject);
			}
		}
		for (int num2 = Mathf.FloorToInt(gibZone.childCount - maxGibs) - 1; num2 >= 0; num2--)
		{
			GameObject gameObject2 = gibZone.GetChild(num2).gameObject;
			if (!gameObject2.GetComponentInChildren<Bloodsplatter>())
			{
				Object.Destroy(gameObject2);
			}
		}
		for (int num3 = Mathf.FloorToInt((float)outsideGore.Count - maxGore / 5f) - 1; num3 >= 0; num3--)
		{
			GameObject gameObject3 = outsideGore[num3];
			if (gameObject3 != null)
			{
				if (!gameObject3.GetComponentInChildren<Bloodsplatter>())
				{
					Object.Destroy(gameObject3);
					outsideGore.RemoveAt(num3);
				}
			}
			else
			{
				outsideGore.RemoveAt(num3);
			}
		}
		if (toDestroy.Count > 0)
		{
			StartCoroutine(DestroyNextFrame());
		}
	}

	private IEnumerator DestroyNextFrame()
	{
		yield return null;
		for (int num = toDestroy.Count - 1; num >= 0; num--)
		{
			Object.Destroy(toDestroy[num]);
		}
		toDestroy.Clear();
		yield return null;
	}

	public void SetGoreZone(GameObject gib)
	{
		gib.transform.SetParent(gibZone, worldPositionStays: true);
	}

	private void Update()
	{
		if (goreRenderDistance != 0f)
		{
			CheckRenderDistance();
		}
	}

	private void CheckRenderDistance()
	{
		if (Vector3.Distance(MonoSingleton<CameraController>.Instance.transform.position, base.transform.position) > goreRenderDistance)
		{
			if (!goreUnrendered)
			{
				goreUnrendered = true;
				goreZone.gameObject.SetActive(value: false);
				gibZone.gameObject.SetActive(value: false);
			}
		}
		else if (goreUnrendered)
		{
			goreUnrendered = false;
			goreZone.gameObject.SetActive(value: true);
			gibZone.gameObject.SetActive(value: true);
		}
	}

	public void Combine()
	{
		StaticBatchingUtility.Combine(goreZone.gameObject);
	}

	public void AddDeath()
	{
		checkpoint.restartKills++;
	}

	public void AddKillHitterTarget(int id)
	{
		if ((bool)checkpoint && !checkpoint.succesfulHitters.Contains(id))
		{
			checkpoint.succesfulHitters.Add(id);
		}
	}

	public void ResetGibs()
	{
		for (int num = gibZone.childCount - 1; num > 0; num--)
		{
			Transform child = gibZone.GetChild(num);
			GoreSplatter component2;
			if (child.TryGetComponent<Bloodsplatter>(out var component))
			{
				component.Repool();
			}
			else if (child.TryGetComponent<GoreSplatter>(out component2))
			{
				component2.Repool();
			}
			else
			{
				Object.Destroy(child.gameObject);
			}
		}
	}

	public void UpdateMaxGore(float amount)
	{
		maxGore = amount;
		if (endlessMode)
		{
			maxGibs = Mathf.RoundToInt(maxGore / 40f);
		}
		else
		{
			maxGibs = Mathf.RoundToInt(maxGore / 20f);
		}
	}
}



public class GoToTarget : MonoBehaviour
{
	public ToDo onTargetReach;

	public float speed;

	public bool easeIn;

	public float easeInSpeed;

	private float currentSpeed;

	public Transform target;

	private Rigidbody rb;

	private bool stopped;

	public UltrakillEvent events;

	[HideInInspector]
	public bool activated;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		if (!stopped)
		{
			if (easeIn && currentSpeed != speed)
			{
				currentSpeed = Mathf.MoveTowards(currentSpeed, speed, Time.fixedDeltaTime * (Mathf.Abs(currentSpeed + 1f) * easeInSpeed));
			}
			else
			{
				currentSpeed = speed;
			}
			if (Vector3.Distance(base.transform.position, target.position) < rb.velocity.magnitude * Time.fixedDeltaTime)
			{
				Activate();
			}
			else
			{
				rb.velocity = (target.position - base.transform.position).normalized * currentSpeed;
			}
			if (Vector3.Distance(base.transform.position, target.position) < 0.5f)
			{
				Activate();
			}
		}
	}

	private void Activate()
	{
		if (!activated)
		{
			activated = true;
			if (events != null)
			{
				events.Invoke();
			}
			switch (onTargetReach)
			{
			case ToDo.Disable:
				Debug.Log("Try to Disable");
				base.gameObject.SetActive(value: false);
				break;
			case ToDo.Destroy:
				Object.Destroy(base.gameObject);
				break;
			default:
				stopped = true;
				rb.velocity = Vector3.zero;
				break;
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class GraphicsOptions : MonoSingleton<GraphicsOptions>
{
	public TMP_Dropdown pixelization;

	public Slider textureWarping;

	public TMP_Dropdown vertexWarping;

	public TMP_Dropdown colorCompression;

	public Toggle vSync;

	public Slider dithering;

	public Toggle colorPalette;

	public Slider gamma;

	private new void Awake()
	{
		Initialize();
	}

	private void Start()
	{
		Initialize();
	}

	public void ApplyPalette(Texture2D palette)
	{
		MonoSingleton<PostProcessV2_Handler>.Instance.ApplyUserColorPalette(palette);
		ColorPalette(stuff: true);
	}

	public void PCPreset()
	{
		pixelization.value = 0;
		pixelization.RefreshShownValue();
		textureWarping.value = 0f;
		vertexWarping.value = 0;
		vertexWarping.RefreshShownValue();
		colorCompression.value = 2;
		colorCompression.RefreshShownValue();
		dithering.value = 10f;
	}

	public void PSXPreset()
	{
		pixelization.value = 3;
		pixelization.RefreshShownValue();
		textureWarping.value = 100f;
		vertexWarping.value = 2;
		vertexWarping.RefreshShownValue();
		colorCompression.value = 2;
		colorCompression.RefreshShownValue();
		dithering.value = 10f;
	}

	public void Initialize()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("pixelization");
		pixelization.value = @int;
		pixelization.RefreshShownValue();
		Pixelization(@int);
		float @float = MonoSingleton<PrefsManager>.Instance.GetFloat("textureWarping");
		textureWarping.value = @float;
		TextureWarping(@float);
		@float = MonoSingleton<PrefsManager>.Instance.GetFloat("gamma");
		gamma.value = @float;
		Gamma(@float);
		@int = MonoSingleton<PrefsManager>.Instance.GetInt("vertexWarping");
		vertexWarping.value = @int;
		vertexWarping.RefreshShownValue();
		VertexWarping(@int);
		@int = MonoSingleton<PrefsManager>.Instance.GetInt("colorCompression");
		colorCompression.value = @int;
		colorCompression.RefreshShownValue();
		ColorCompression(@int);
		@float = MonoSingleton<PrefsManager>.Instance.GetFloat("dithering");
		dithering.value = @float * 50f;
		Dithering(@float * 50f);
		if (!MonoSingleton<PrefsManager>.Instance.GetBoolLocal("colorPalette"))
		{
			colorPalette.isOn = false;
			ColorPalette(stuff: false);
		}
		else
		{
			Texture2D texture2D = CustomPaletteSelector.LoadSavedPalette();
			if ((bool)texture2D)
			{
				ApplyPalette(texture2D);
				colorPalette.isOn = false;
				colorPalette.isOn = true;
				ColorPalette(stuff: true);
				Shader.SetGlobalInt("_ColorPrecision", 2048);
			}
			else
			{
				colorPalette.isOn = false;
				ColorPalette(stuff: false);
			}
		}
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("vSync"))
		{
			QualitySettings.vSyncCount = 1;
			vSync.isOn = true;
		}
		else
		{
			QualitySettings.vSyncCount = 0;
			vSync.isOn = false;
		}
	}

	public void Gamma(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("gamma", stuff);
		Shader.SetGlobalFloat("_Gamma", stuff);
	}

	public void Pixelization(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("pixelization", stuff);
		float num = 0f;
		switch (stuff)
		{
		case 0:
			num = 0f;
			break;
		case 1:
			num = 720f;
			break;
		case 2:
			num = 480f;
			break;
		case 3:
			num = 360f;
			break;
		case 4:
			num = 240f;
			break;
		case 5:
			num = 144f;
			break;
		case 6:
			num = 36f;
			break;
		}
		Shader.SetGlobalFloat("_ResY", num);
		PostProcessV2_Handler postProcessV2_Handler = MonoSingleton<PostProcessV2_Handler>.Instance;
		if ((bool)postProcessV2_Handler)
		{
			postProcessV2_Handler.downscaleResolution = num;
		}
		DownscaleChangeSprite[] array = Object.FindObjectsOfType<DownscaleChangeSprite>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckScale();
		}
	}

	public void TextureWarping(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("textureWarping", stuff);
		float value = stuff * 0.003f;
		Shader.SetGlobalFloat("_TextureWarping", value);
	}

	public void VertexWarping(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("vertexWarping", stuff);
		float value = 0f;
		switch (stuff)
		{
		case 0:
			value = 0f;
			break;
		case 1:
			value = 400f;
			break;
		case 2:
			value = 160f;
			break;
		case 3:
			value = 80f;
			break;
		case 4:
			value = 40f;
			break;
		case 5:
			value = 16f;
			break;
		}
		Shader.SetGlobalFloat("_VertexWarping", value);
	}

	public void ColorCompression(int stuff)
	{
		ColorCompressionApply(stuff);
	}

	public static void ColorCompressionApply(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("colorCompression", stuff);
		if (!MonoSingleton<PrefsManager>.Instance.GetBoolLocal("colorPalette"))
		{
			switch (stuff)
			{
			case 0:
				Shader.SetGlobalInt("_ColorPrecision", 2048);
				break;
			case 1:
				Shader.SetGlobalInt("_ColorPrecision", 64);
				break;
			case 2:
				Shader.SetGlobalInt("_ColorPrecision", 32);
				break;
			case 3:
				Shader.SetGlobalInt("_ColorPrecision", 16);
				break;
			case 4:
				Shader.SetGlobalInt("_ColorPrecision", 8);
				break;
			case 5:
				Shader.SetGlobalInt("_ColorPrecision", 3);
				break;
			}
		}
	}

	public void Dithering(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("dithering", stuff / 50f);
		Shader.SetGlobalFloat("_DitherStrength", stuff / 50f);
	}

	public void VSync(bool stuff)
	{
		if (stuff)
		{
			QualitySettings.vSyncCount = 1;
			MonoSingleton<PrefsManager>.Instance.SetBoolLocal("vSync", content: true);
		}
		else
		{
			QualitySettings.vSyncCount = 0;
			MonoSingleton<PrefsManager>.Instance.SetBoolLocal("vSync", content: false);
		}
	}

	public void ColorPalette(bool stuff)
	{
		MonoSingleton<PostProcessV2_Handler>.Instance.ColorPalette(stuff);
	}
}



public class GreedDoorTorch : MonoBehaviour
{
	private Door dr;

	private Light lt;

	private SpriteRenderer spr;

	private Color clr;

	private void Start()
	{
		dr = GetComponentInParent<Door>();
		lt = GetComponent<Light>();
		spr = GetComponentInChildren<SpriteRenderer>();
		UpdateColor();
	}

	private void Update()
	{
		if (clr != dr.currentLightsColor)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		clr = dr.currentLightsColor;
		if ((bool)spr)
		{
			spr.color = clr;
		}
		if ((bool)lt)
		{
			lt.color = clr;
		}
	}
}



public class Grenade : MonoBehaviour
{
	public string hitterWeapon;

	public GameObject sourceWeapon;

	public GameObject explosion;

	public GameObject harmlessExplosion;

	public GameObject superExplosion;

	[SerializeField]
	private RevolverBeam grenadeBeam;

	private bool exploded;

	public bool enemy;

	[HideInInspector]
	public EnemyIdentifier originEnemy;

	public float totalDamageMultiplier = 1f;

	public bool rocket;

	[HideInInspector]
	public Rigidbody rb;

	[HideInInspector]
	public List<Magnet> magnets = new List<Magnet>();

	[HideInInspector]
	public Magnet latestEnemyMagnet;

	public float rocketSpeed;

	[SerializeField]
	private GameObject freezeEffect;

	private CapsuleCollider col;

	public bool playerRiding;

	private bool playerInRidingRange = true;

	private float downpull = -0.5f;

	public GameObject playerRideSound;

	[HideInInspector]
	public bool rideable;

	[HideInInspector]
	public bool hooked;

	private bool hasBeenRidden;

	private LayerMask rocketRideMask;

	public EnemyTarget proximityTarget;

	public GameObject proximityWindup;

	private bool selfExploding;

	[HideInInspector]
	public bool levelledUp;

	[HideInInspector]
	public float timeFrozen;

	[SerializeField]
	private GameObject levelUpEffect;

	public List<EnemyType> ignoreEnemyType = new List<EnemyType>();

	public bool frozen
	{
		get
		{
			if (!MonoSingleton<WeaponCharges>.Instance)
			{
				return false;
			}
			return MonoSingleton<WeaponCharges>.Instance.rocketFrozen;
		}
	}

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
		col = GetComponent<CapsuleCollider>();
		if (!enemy)
		{
			CanCollideWithPlayer(can: false);
		}
		MonoSingleton<ObjectTracker>.Instance.AddGrenade(this);
		rocketRideMask = LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies);
		rocketRideMask = (int)rocketRideMask | 0x40000;
	}

	private void Start()
	{
		MonoSingleton<WeaponCharges>.Instance.rocketCount++;
	}

	private void OnDestroy()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<ObjectTracker>.Instance.RemoveGrenade(this);
			if (playerRiding)
			{
				PlayerRideEnd();
			}
		}
		if (rocket && (bool)MonoSingleton<WeaponCharges>.Instance)
		{
			MonoSingleton<WeaponCharges>.Instance.rocketCount--;
			MonoSingleton<WeaponCharges>.Instance.timeSinceIdleFrozen = 0f;
		}
	}

	private void Update()
	{
		if (rocket && rocketSpeed != 0f && (bool)rb && !MonoSingleton<OptionsManager>.Instance.paused && playerRiding)
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame)
			{
				PlayerRideEnd();
				MonoSingleton<NewMovement>.Instance.Jump();
			}
			else if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame)
			{
				PlayerRideEnd();
			}
		}
	}

	private void FixedUpdate()
	{
		if (!rocket || rocketSpeed == 0f || !rb)
		{
			return;
		}
		if (frozen)
		{
			if (magnets.Count > 0)
			{
				ignoreEnemyType.Clear();
			}
			rideable = true;
			rb.velocity = Vector3.zero;
			rb.angularVelocity = Vector3.zero;
			timeFrozen += Time.fixedDeltaTime;
			if (timeFrozen >= 1f && (!enemy || hasBeenRidden) && !levelledUp)
			{
				levelledUp = true;
				if ((bool)levelUpEffect)
				{
					levelUpEffect.SetActive(value: true);
				}
			}
		}
		else if (playerRiding)
		{
			if (NoWeaponCooldown.NoCooldown || MonoSingleton<UnderwaterController>.Instance.inWater || MonoSingleton<WeaponCharges>.Instance.infiniteRocketRide)
			{
				if (MonoSingleton<UnderwaterController>.Instance.inWater && downpull > 0f)
				{
					downpull = 0f;
				}
				rb.velocity = base.transform.forward * rocketSpeed * 0.65f;
			}
			else
			{
				rb.velocity = Vector3.Lerp(base.transform.forward * (rocketSpeed * 0.65f), Vector3.down * 100f, Mathf.Max(0f, downpull));
				downpull += Time.fixedDeltaTime / 4.5f * Mathf.Max(1f, 1f + rb.velocity.normalized.y);
			}
		}
		else
		{
			rb.velocity = base.transform.forward * rocketSpeed;
		}
		if (playerRiding)
		{
			MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.zero;
			Vector3 vector = MonoSingleton<NewMovement>.Instance.transform.position + MonoSingleton<NewMovement>.Instance.playerCollider.center;
			bool flag = false;
			Vector3 vector2 = Vector3.positiveInfinity;
			Collider other = null;
			if (!Physics.CheckCapsule(vector + Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), vector - Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), 0.5f, rocketRideMask, QueryTriggerInteraction.Ignore))
			{
				RaycastHit[] array = Physics.CapsuleCastAll(vector + Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), vector - Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), 0.499f, rb.velocity.normalized, rb.velocity.magnitude * Time.fixedDeltaTime, rocketRideMask, QueryTriggerInteraction.Ignore);
				for (int i = 0; i < array.Length; i++)
				{
					if (!array[i].collider.isTrigger && array[i].collider.gameObject.layer != 12 && array[i].collider.gameObject.layer != 14 && (!array[i].collider.attachedRigidbody || array[i].collider.attachedRigidbody != rb))
					{
						Vector3 vector3 = MonoSingleton<NewMovement>.Instance.playerCollider.ClosestPoint(array[i].point);
						Vector3 vector4 = array[i].point - (array[i].point - vector3).normalized * Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, vector3);
						if (Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, vector4) < Vector3.Distance(MonoSingleton<NewMovement>.Instance.transform.position, vector2))
						{
							new GameObject().transform.position = base.transform.position;
							vector2 = vector4;
							other = array[i].collider;
						}
						flag = true;
					}
					else
					{
						_ = array[i].collider.isTrigger;
						_ = array[i].collider.gameObject.layer;
						_ = 12;
						_ = array[i].collider.gameObject.layer;
						_ = 14;
						if ((bool)array[i].collider.attachedRigidbody)
						{
							_ = array[i].collider.attachedRigidbody == rb;
						}
					}
				}
			}
			else
			{
				vector2 = MonoSingleton<NewMovement>.Instance.transform.position;
				other = Physics.OverlapCapsule(vector + Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), vector - Vector3.up * (MonoSingleton<NewMovement>.Instance.playerCollider.height / 2f), 0.5f, rocketRideMask, QueryTriggerInteraction.Ignore)[0];
				flag = true;
			}
			if (flag)
			{
				PlayerRideEnd();
				MonoSingleton<NewMovement>.Instance.transform.position = vector2;
				base.transform.position = MonoSingleton<NewMovement>.Instance.transform.position;
				Collision(other);
			}
		}
		else
		{
			float num = Vector3.Distance(MonoSingleton<NewMovement>.Instance.gc.transform.position, base.transform.position + base.transform.forward);
			if (num < 2.25f && (MonoSingleton<NewMovement>.Instance.rb.velocity.y < 0f || hooked) && !MonoSingleton<NewMovement>.Instance.gc.onGround && !MonoSingleton<NewMovement>.Instance.dead && rideable && (!enemy || MonoSingleton<NewMovement>.Instance.gc.heavyFall))
			{
				if (!MonoSingleton<NewMovement>.Instance.ridingRocket && !playerInRidingRange)
				{
					PlayerRideStart();
				}
				playerInRidingRange = true;
			}
			else if (playerInRidingRange && (num > 3f || MonoSingleton<NewMovement>.Instance.gc.onGround || (MonoSingleton<NewMovement>.Instance.rb.velocity.y > 0f && !hooked)))
			{
				playerInRidingRange = false;
			}
		}
		if (freezeEffect.activeSelf != frozen)
		{
			freezeEffect.SetActive(frozen);
		}
		if (magnets.Count > 0)
		{
			int num2 = magnets.Count - 1;
			while (num2 >= 0)
			{
				if (magnets[num2] == null)
				{
					magnets.RemoveAt(num2);
					num2--;
					continue;
				}
				if (frozen)
				{
					if ((bool)latestEnemyMagnet && latestEnemyMagnet.gameObject.activeInHierarchy && !Physics.Raycast(base.transform.position, latestEnemyMagnet.transform.position - base.transform.position, Vector3.Distance(latestEnemyMagnet.transform.position, base.transform.position), LayerMaskDefaults.Get(LMD.Environment)))
					{
						base.transform.LookAt(latestEnemyMagnet.transform.position);
					}
					else
					{
						base.transform.LookAt(magnets[num2].transform.position);
					}
				}
				else
				{
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(magnets[num2].transform.position - base.transform.position), Time.fixedDeltaTime * 180f);
				}
				break;
			}
		}
		else if ((bool)latestEnemyMagnet && latestEnemyMagnet.gameObject.activeInHierarchy && !Physics.Raycast(base.transform.position, latestEnemyMagnet.transform.position - base.transform.position, Vector3.Distance(latestEnemyMagnet.transform.position, base.transform.position), LayerMaskDefaults.Get(LMD.Environment)))
		{
			base.transform.LookAt(latestEnemyMagnet.transform.position);
		}
		if (proximityTarget != null && magnets.Count == 0 && !frozen && !playerRiding && !selfExploding && Vector3.Distance(proximityTarget.position, base.transform.position) < Vector3.Distance(proximityTarget.PredictTargetPosition(Time.fixedDeltaTime), base.transform.position + rb.velocity * Time.fixedDeltaTime))
		{
			selfExploding = true;
			rideable = true;
			Object.Instantiate(proximityWindup, col.bounds.center, Quaternion.identity);
			rb.isKinematic = true;
			Invoke("ProximityExplosion", 0.5f);
		}
	}

	private void LateUpdate()
	{
		if (!playerRiding)
		{
			return;
		}
		if (Vector3.Distance(base.transform.position, MonoSingleton<NewMovement>.Instance.transform.position) > 5f + rb.velocity.magnitude * Time.deltaTime)
		{
			PlayerRideEnd();
			return;
		}
		Vector2 vector = MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>();
		base.transform.Rotate(vector.y * Time.deltaTime * 165f, vector.x * Time.deltaTime * 165f, 0f, Space.Self);
		if (Physics.Raycast(base.transform.position + base.transform.forward, base.transform.up, 4f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			if (Physics.Raycast(base.transform.position + base.transform.forward, Vector3.up, out var hitInfo, 2f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				MonoSingleton<NewMovement>.Instance.transform.position = base.transform.position + base.transform.forward - Vector3.up * hitInfo.distance;
			}
			else
			{
				MonoSingleton<NewMovement>.Instance.transform.position = base.transform.position + base.transform.forward;
			}
		}
		else
		{
			MonoSingleton<NewMovement>.Instance.transform.position = base.transform.position + base.transform.up * 2f + base.transform.forward;
		}
		MonoSingleton<CameraController>.Instance.CameraShake(0.1f);
	}

	private void OnCollisionEnter(Collision collision)
	{
		Collision(collision.collider);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (rocket && frozen && (other.gameObject.layer == 10 || other.gameObject.layer == 11) && !other.isTrigger)
		{
			Collision(other);
		}
	}

	public void Collision(Collider other)
	{
		if (exploded || (!enemy && other.CompareTag("Player")) || other.gameObject.layer == 14 || other.gameObject.layer == 20)
		{
			return;
		}
		bool flag = false;
		if ((other.gameObject.layer == 11 || other.gameObject.layer == 10) && (other.attachedRigidbody ? other.attachedRigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out var component) : other.TryGetComponent<EnemyIdentifierIdentifier>(out component)) && (bool)component.eid)
		{
			if (component.eid.enemyType == EnemyType.MaliciousFace && !component.eid.isGasolined)
			{
				flag = true;
			}
			else
			{
				if (ignoreEnemyType.Count > 0 && ignoreEnemyType.Contains(component.eid.enemyType))
				{
					return;
				}
				if (component.eid.dead)
				{
					Physics.IgnoreCollision(col, other, ignore: true);
					return;
				}
			}
		}
		if (!flag && other.gameObject.CompareTag("Armor"))
		{
			flag = true;
		}
		if (flag)
		{
			rb.constraints = RigidbodyConstraints.None;
			if (Physics.Raycast(base.transform.position - base.transform.forward, base.transform.forward, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment)))
			{
				Vector3 velocity = rb.velocity;
				rb.velocity = Vector3.zero;
				rb.AddForce(Vector3.Reflect(velocity.normalized, hitInfo.normal).normalized * velocity.magnitude * 2f, ForceMode.VelocityChange);
				base.transform.forward = Vector3.Reflect(velocity.normalized, hitInfo.normal).normalized;
				rb.AddTorque(Random.insideUnitCircle.normalized * Random.Range(0, 250));
			}
			Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.ineffectiveSound, base.transform.position, Quaternion.identity).GetComponent<AudioSource>().volume = 0.75f;
			return;
		}
		bool harmless = false;
		bool big = false;
		bool flag2 = false;
		if (rocket)
		{
			if (other.gameObject.layer == 10 || other.gameObject.layer == 11)
			{
				EnemyIdentifierIdentifier component2 = other.GetComponent<EnemyIdentifierIdentifier>();
				if ((bool)component2 && (bool)component2.eid)
				{
					if (levelledUp)
					{
						flag2 = true;
					}
					else if (!component2.eid.dead && !component2.eid.flying && (((bool)component2.eid.gce && !component2.eid.gce.onGround) || (float)component2.eid.timeSinceSpawned <= 0.15f))
					{
						flag2 = true;
					}
					if (component2.eid.stuckMagnets.Count > 0)
					{
						foreach (Magnet stuckMagnet in component2.eid.stuckMagnets)
						{
							if (!(stuckMagnet == null))
							{
								stuckMagnet.DamageMagnet((!flag2) ? 1 : 2);
							}
						}
					}
					if (component2.eid == originEnemy && !component2.eid.blessed)
					{
						if (hasBeenRidden && !frozen && originEnemy.enemyType == EnemyType.Guttertank)
						{
							originEnemy.Explode(fromExplosion: true);
							MonoSingleton<StyleHUD>.Instance.AddPoints(300, "ultrakill.roundtrip", null, component2.eid);
						}
						else
						{
							MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.rocketreturn", null, component2.eid);
						}
					}
				}
				MonoSingleton<TimeController>.Instance.HitStop(0.05f);
			}
			else if (!enemy || !other.gameObject.CompareTag("Player"))
			{
				harmless = true;
			}
		}
		else if (other.gameObject.layer != 8)
		{
			MonoSingleton<TimeController>.Instance.HitStop(0.05f);
		}
		Explode(big, harmless, flag2);
	}

	private void ProximityExplosion()
	{
		Explode(big: true);
	}

	public void Explode(bool big = false, bool harmless = false, bool super = false, float sizeMultiplier = 1f, bool ultrabooster = false, GameObject exploderWeapon = null, bool fup = false)
	{
		if (exploded)
		{
			return;
		}
		exploded = true;
		if (MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position))
		{
			harmless = false;
		}
		GameObject gameObject = (harmless ? Object.Instantiate(harmlessExplosion, base.transform.position, Quaternion.identity) : ((!super) ? Object.Instantiate(this.explosion, base.transform.position, Quaternion.identity) : Object.Instantiate(superExplosion, base.transform.position, Quaternion.identity)));
		Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			explosion.sourceWeapon = exploderWeapon ?? sourceWeapon;
			explosion.hitterWeapon = hitterWeapon;
			explosion.isFup = fup;
			if (enemy)
			{
				explosion.enemy = true;
			}
			if (ignoreEnemyType.Count > 0)
			{
				explosion.toIgnore = ignoreEnemyType;
			}
			if (rocket && super && big)
			{
				explosion.maxSize *= 2.5f;
				explosion.speed *= 2.5f;
			}
			else if (big || (rocket && frozen))
			{
				explosion.maxSize *= 1.5f;
				explosion.speed *= 1.5f;
			}
			if (totalDamageMultiplier != 1f)
			{
				explosion.damage = (int)((float)explosion.damage * totalDamageMultiplier);
			}
			explosion.maxSize *= sizeMultiplier;
			explosion.speed *= sizeMultiplier;
			if ((bool)originEnemy)
			{
				explosion.originEnemy = originEnemy;
			}
			if (ultrabooster)
			{
				explosion.ultrabooster = true;
			}
			if (rocket && explosion.damage != 0)
			{
				explosion.rocketExplosion = true;
			}
		}
		gameObject.transform.localScale *= sizeMultiplier;
		Object.Destroy(base.gameObject);
	}

	public void PlayerRideStart()
	{
		CanCollideWithPlayer(can: false);
		if (enemy && proximityTarget != null)
		{
			CancelInvoke("ProximityExplosion");
			proximityTarget = null;
			rb.isKinematic = false;
		}
		ignoreEnemyType.Clear();
		playerRiding = true;
		MonoSingleton<NewMovement>.Instance.ridingRocket = this;
		MonoSingleton<NewMovement>.Instance.gc.heavyFall = false;
		MonoSingleton<NewMovement>.Instance.gc.ForceOff();
		MonoSingleton<NewMovement>.Instance.slopeCheck.ForceOff();
		Object.Instantiate(playerRideSound);
		if (!hasBeenRidden && !enemy)
		{
			MonoSingleton<NewMovement>.Instance.rocketRides++;
			hasBeenRidden = true;
			if (MonoSingleton<NewMovement>.Instance.rocketRides > 3)
			{
				downpull += 0.25f * (float)(MonoSingleton<NewMovement>.Instance.rocketRides - 3);
			}
		}
		else if (!hasBeenRidden)
		{
			hasBeenRidden = true;
		}
	}

	public void PlayerRideEnd()
	{
		playerRiding = false;
		MonoSingleton<NewMovement>.Instance.ridingRocket = null;
		MonoSingleton<NewMovement>.Instance.gc.StopForceOff();
		MonoSingleton<NewMovement>.Instance.slopeCheck.StopForceOff();
	}

	public void CanCollideWithPlayer(bool can = true)
	{
		Physics.IgnoreCollision(col, MonoSingleton<NewMovement>.Instance.playerCollider, !can);
	}

	public void GrenadeBeam(Vector3 targetPoint, GameObject newSourceWeapon = null)
	{
		if (!exploded)
		{
			RevolverBeam revolverBeam = Object.Instantiate(grenadeBeam, base.transform.position, Quaternion.LookRotation(targetPoint - base.transform.position));
			revolverBeam.sourceWeapon = ((newSourceWeapon != null) ? newSourceWeapon : sourceWeapon);
			if (levelledUp)
			{
				revolverBeam.hitParticle = superExplosion;
			}
			exploded = true;
			MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(targetPoint);
			Object.Destroy(base.gameObject);
		}
	}
}


public class GridTile
{
	public string title;

	public string path;

	public bool folder;
}



public class GroundCheck : MonoBehaviour
{
	public bool slopeCheck;

	public bool onGround;

	public bool touchingGround;

	public bool canJump;

	public bool heavyFall;

	public GameObject shockwave;

	public float superJumpChance;

	public float extraJumpChance;

	public TimeSince sinceLastGrounded;

	private NewMovement nmov;

	private PlayerMovementParenting pmov;

	private Collider currentEnemyCol;

	public int forcedOff;

	private LayerMask waterMask;

	public List<Collider> cols = new List<Collider>();

	private void Start()
	{
		nmov = MonoSingleton<NewMovement>.Instance;
		pmov = base.transform.parent.GetComponent<PlayerMovementParenting>();
		if (pmov == null)
		{
			pmov = nmov.GetComponent<PlayerMovementParenting>();
		}
		waterMask = LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies);
		waterMask = (int)waterMask | 4;
	}

	private void OnEnable()
	{
		base.transform.parent.parent = null;
	}

	private void OnDisable()
	{
		touchingGround = false;
		if ((bool)MonoSingleton<NewMovement>.Instance)
		{
			MonoSingleton<NewMovement>.Instance.groundProperties = null;
		}
		cols.Clear();
		canJump = false;
	}

	private void Update()
	{
		if (forcedOff > 0)
		{
			onGround = false;
		}
		else if (onGround != touchingGround)
		{
			onGround = touchingGround;
		}
		if (onGround)
		{
			sinceLastGrounded = 0f;
		}
		if (superJumpChance > 0f)
		{
			superJumpChance = Mathf.MoveTowards(superJumpChance, 0f, Time.deltaTime);
			if (superJumpChance == 0f)
			{
				if (shockwave != null && nmov.stillHolding)
				{
					if (nmov.boostCharge >= 100f)
					{
						Object.Instantiate(shockwave, base.transform.position, Quaternion.identity).GetComponent<PhysicalShockwave>().force *= nmov.slamForce * 2.25f;
						if (!nmov.asscon.majorEnabled || !nmov.asscon.infiniteStamina)
						{
							nmov.boostCharge -= 100f;
						}
						nmov.cc.CameraShake(0.75f);
					}
					else
					{
						Object.Instantiate(nmov.staminaFailSound);
					}
				}
				extraJumpChance = 0.15f;
				nmov.stillHolding = false;
			}
		}
		if (extraJumpChance > 0f)
		{
			extraJumpChance = Mathf.MoveTowards(extraJumpChance, 0f, Time.deltaTime);
			if (extraJumpChance <= 0f)
			{
				nmov.slamForce = 0f;
			}
		}
		if (cols.Count > 0)
		{
			for (int num = cols.Count - 1; num >= 0; num--)
			{
				if (!ColliderIsStillUsable(cols[num]))
				{
					cols.RemoveAt(num);
				}
			}
		}
		if (cols.Count == 0)
		{
			touchingGround = false;
			MonoSingleton<NewMovement>.Instance.groundProperties = null;
		}
		if (canJump && (currentEnemyCol == null || !currentEnemyCol.gameObject.activeInHierarchy || Vector3.Distance(base.transform.position, currentEnemyCol.transform.position) > 40f))
		{
			canJump = false;
		}
	}

	private void FixedUpdate()
	{
		if (!MonoSingleton<UnderwaterController>.Instance.inWater && !slopeCheck && !(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().y >= 0f) && (MonoSingleton<PlayerTracker>.Instance.playerType != 0 || MonoSingleton<NewMovement>.Instance.sliding) && (MonoSingleton<PlayerTracker>.Instance.playerType != PlayerType.Platformer || MonoSingleton<PlatformerMovement>.Instance.sliding) && Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, Mathf.Abs(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().y), waterMask, QueryTriggerInteraction.Collide) && hitInfo.transform.gameObject.layer == 4)
		{
			BounceOnWater(hitInfo.collider);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (ColliderIsCheckable(other) && cols.Contains(other))
		{
			if (cols.IndexOf(other) == cols.Count - 1)
			{
				cols.Remove(other);
				if (cols.Count > 0)
				{
					for (int num = cols.Count - 1; num >= 0; num--)
					{
						if (ColliderIsStillUsable(cols[num]))
						{
							MonoSingleton<NewMovement>.Instance.groundProperties = cols[num].GetComponent<CustomGroundProperties>();
							break;
						}
						cols.RemoveAt(num);
					}
				}
			}
			else
			{
				cols.Remove(other);
			}
			if (cols.Count == 0)
			{
				touchingGround = false;
				MonoSingleton<NewMovement>.Instance.groundProperties = null;
			}
			if (!slopeCheck && (other.gameObject.CompareTag("Moving") || other.gameObject.layer == 11 || other.gameObject.layer == 26) && pmov.IsObjectTracked(other.transform))
			{
				pmov.DetachPlayer(other.transform);
			}
		}
		else if (!other.gameObject.CompareTag("Slippery") && other.gameObject.layer == 12)
		{
			canJump = false;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (ColliderIsCheckable(other) && !cols.Contains(other))
		{
			cols.Add(other);
			touchingGround = true;
			if (other.TryGetComponent<CustomGroundProperties>(out var component))
			{
				MonoSingleton<NewMovement>.Instance.groundProperties = component;
			}
			else
			{
				MonoSingleton<NewMovement>.Instance.groundProperties = null;
			}
			if (!slopeCheck && (other.gameObject.CompareTag("Moving") || other.gameObject.layer == 11 || other.gameObject.layer == 26) && other.attachedRigidbody != null && !pmov.IsObjectTracked(other.transform))
			{
				pmov.AttachPlayer(other.transform);
			}
		}
		else if (!other.gameObject.CompareTag("Slippery") && other.gameObject.layer == 12)
		{
			currentEnemyCol = other;
			canJump = true;
		}
		if (heavyFall)
		{
			if (other.gameObject.layer == 10 || other.gameObject.layer == 11)
			{
				EnemyIdentifierIdentifier component2 = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
				if ((bool)component2 && (bool)component2.eid)
				{
					component2.eid.hitter = "ground slam";
					component2.eid.DeliverDamage(other.gameObject, (base.transform.position - other.transform.position) * 5000f, other.transform.position, 2f, tryForExplode: true);
					if (!component2.eid.exploded)
					{
						heavyFall = false;
					}
				}
			}
			else if (!other.gameObject.CompareTag("Slippery") && (other.gameObject.layer == 8 || other.gameObject.layer == 24))
			{
				Breakable component3 = other.gameObject.GetComponent<Breakable>();
				if (component3 != null && ((component3.weak && !component3.precisionOnly) || component3.forceGroundSlammable) && !component3.unbreakable)
				{
					component3.Break();
				}
				else
				{
					heavyFall = false;
				}
				if (other.gameObject.TryGetComponent<Bleeder>(out var component4))
				{
					component4.GetHit(other.transform.position, GoreType.Body);
				}
				if (other.transform.TryGetComponent<Idol>(out var component5))
				{
					component5.Death();
				}
				superJumpChance = 0.075f;
			}
		}
		if (!slopeCheck && other.gameObject.layer == 4 && ((MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS && nmov.sliding && nmov.rb.velocity.y < 0f) || (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && MonoSingleton<PlatformerMovement>.Instance.sliding && MonoSingleton<PlatformerMovement>.Instance.rb.velocity.y < 0f)))
		{
			Vector3 a = other.ClosestPoint(base.transform.position);
			if (!MonoSingleton<UnderwaterController>.Instance.inWater && (Vector3.Distance(a, base.transform.position) < 0.1f || !Physics.Raycast(base.transform.position, Vector3.down, Vector3.Distance(a, base.transform.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Collide)))
			{
				BounceOnWater(other);
			}
		}
	}

	private void BounceOnWater(Collider other)
	{
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
		{
			nmov.rb.velocity = new Vector3(nmov.rb.velocity.x, 0f, nmov.rb.velocity.z);
			nmov.rb.AddForce(Vector3.up * 10f, ForceMode.VelocityChange);
		}
		else
		{
			MonoSingleton<PlatformerMovement>.Instance.rb.velocity = new Vector3(MonoSingleton<PlatformerMovement>.Instance.rb.velocity.x, 0f, MonoSingleton<PlatformerMovement>.Instance.rb.velocity.z);
			MonoSingleton<PlatformerMovement>.Instance.rb.AddForce(Vector3.up * 10f, ForceMode.VelocityChange);
		}
		Water componentInParent = other.GetComponentInParent<Water>();
		if ((bool)componentInParent)
		{
			Object.Instantiate(componentInParent.smallSplash, base.transform.position, Quaternion.LookRotation(Vector3.up)).GetComponent<AudioSource>().volume = 0.65f;
			ChallengeTrigger component = componentInParent.GetComponent<ChallengeTrigger>();
			if ((bool)component)
			{
				component.Entered();
			}
		}
	}

	public void ForceOff()
	{
		onGround = false;
		forcedOff++;
	}

	public void StopForceOff()
	{
		forcedOff--;
		if (forcedOff <= 0)
		{
			onGround = touchingGround;
		}
	}

	public bool ColliderIsCheckable(Collider col)
	{
		if (!col.isTrigger && !col.gameObject.CompareTag("Slippery"))
		{
			if (col.gameObject.layer != 8 && col.gameObject.layer != 24 && col.gameObject.layer != 11 && col.gameObject.layer != 26)
			{
				if (col.gameObject.layer == 18)
				{
					return col.gameObject.CompareTag("Floor");
				}
				return false;
			}
			return true;
		}
		return false;
	}

	public bool ColliderIsStillUsable(Collider col)
	{
		if (!(col == null) && col.enabled && !col.isTrigger && col.gameObject.activeInHierarchy && col.gameObject.layer != 17)
		{
			return col.gameObject.layer != 10;
		}
		return false;
	}
}



public class GroundCheckEnemy : MonoBehaviour
{
	public bool onGround;

	public bool fallSuppressed;

	public bool touchingGround;

	public List<Collider> cols = new List<Collider>();

	private List<Collider> toRemove = new List<Collider>();

	public bool dontCheckTags;

	[HideInInspector]
	public int forcedOff;

	public List<Collider> toIgnore = new List<Collider>();

	private Collider col;

	private bool waitForPhysicsTick;

	private void Start()
	{
		col = GetComponent<Collider>();
		if ((bool)col)
		{
			col.enabled = false;
			col.enabled = true;
		}
		CheckCols();
	}

	private void OnEnable()
	{
		cols.Clear();
		toRemove.Clear();
	}

	public static bool TaggedAsStandable(GameObject obj)
	{
		if (!obj.CompareTag("Floor") && !obj.CompareTag("Wall") && !obj.CompareTag("GlassFloor") && !obj.CompareTag("Moving") && !obj.CompareTag("Breakable"))
		{
			return obj.CompareTag("SoftFloor");
		}
		return true;
	}

	private void UpdateGrounds()
	{
		bool flag = true;
		for (int i = 0; i < cols.Count; i++)
		{
			if (!(cols[i] != null) || !cols[i].CompareTag("SoftFloor"))
			{
				flag = false;
				break;
			}
		}
		fallSuppressed = flag;
	}

	private void FixedUpdate()
	{
		waitForPhysicsTick = false;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.gameObject.CompareTag("Slippery") && (other.gameObject.layer == 8 || other.gameObject.layer == 24 || other.gameObject.layer == 16) && ((other.gameObject.layer != 16 && dontCheckTags) || TaggedAsStandable(other.gameObject)) && !toIgnore.Contains(other))
		{
			touchingGround = true;
			cols.Add(other);
			UpdateGrounds();
			if (forcedOff <= 0)
			{
				onGround = touchingGround;
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!other.gameObject.CompareTag("Slippery") && (other.gameObject.layer == 8 || other.gameObject.layer == 24 || other.gameObject.layer == 16) && ((other.gameObject.layer != 16 && dontCheckTags) || TaggedAsStandable(other.gameObject)) && cols.Contains(other))
		{
			cols.Remove(other);
			UpdateGrounds();
		}
	}

	private void CheckCols()
	{
		Invoke("CheckCols", 0.1f);
		if (base.transform.up.y < 0.25f)
		{
			touchingGround = false;
			onGround = false;
			waitForPhysicsTick = true;
		}
		else if (!waitForPhysicsTick)
		{
			CheckColsOnce();
			if (forcedOff > 0)
			{
				onGround = false;
			}
			else
			{
				onGround = touchingGround;
			}
		}
	}

	private void CheckColsOnce()
	{
		bool flag = false;
		for (int num = cols.Count - 1; num >= 0; num--)
		{
			Collider collider = cols[num];
			if (collider == null || toIgnore.Contains(collider) || !collider.enabled)
			{
				cols.RemoveAt(num);
			}
			else
			{
				GameObject gameObject = collider.gameObject;
				if (!gameObject.activeInHierarchy)
				{
					cols.RemoveAt(num);
				}
				else if (!gameObject.CompareTag("Slippery") && (gameObject.layer == 8 || gameObject.layer == 24 || gameObject.layer == 16) && ((gameObject.layer != 16 && dontCheckTags) || TaggedAsStandable(gameObject)))
				{
					flag = true;
				}
			}
		}
		touchingGround = flag;
	}

	public void ForceOff()
	{
		forcedOff++;
		onGround = false;
	}

	public void StopForceOff()
	{
		forcedOff--;
		if (forcedOff <= 0)
		{
			onGround = touchingGround;
		}
	}

	public Vector3 ClosestPoint()
	{
		CheckColsOnce();
		if (cols.Count > 0)
		{
			Vector3 result = base.transform.position;
			float num = 999f;
			{
				foreach (Collider col in cols)
				{
					Vector3 vector = col.ClosestPoint(base.transform.position);
					float num2 = Vector3.SqrMagnitude(vector - base.transform.position);
					if (num2 < num && !toIgnore.Contains(col))
					{
						result = vector;
						num = num2;
					}
				}
				return result;
			}
		}
		return base.transform.position;
	}

	public float DistanceToGround()
	{
		if (Physics.Raycast(col.bounds.center, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
		{
			return hitInfo.distance - col.bounds.extents.y;
		}
		return float.PositiveInfinity;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class GunColorController : MonoSingleton<GunColorController>
{
	public static int[] requiredSecrets = new int[5] { 0, 10, 25, 50, 100 };

	public GunColorPreset[] revolverColors;

	public GunColorPreset[] shotgunColors;

	public GunColorPreset[] nailgunColors;

	public GunColorPreset[] railcannonColors;

	public GunColorPreset[] rocketLauncherColors;

	[HideInInspector]
	public GunColorPreset[] currentColors;

	[HideInInspector]
	public GunColorPreset[] currentAltColors;

	[HideInInspector]
	public int[] presets;

	[HideInInspector]
	public int[] altPresets;

	[HideInInspector]
	public bool[] hasUnlockedColors;

	[HideInInspector]
	public MaterialPropertyBlock[] currentPropBlocks;

	[HideInInspector]
	public MaterialPropertyBlock[] currentAltPropBlocks;

	[HideInInspector]
	public int weaponCount;

	private void Start()
	{
		weaponCount = Enum.GetNames(typeof(GameProgressSaver.WeaponCustomizationType)).Length;
		currentColors = new GunColorPreset[weaponCount];
		currentAltColors = new GunColorPreset[weaponCount];
		presets = new int[weaponCount];
		altPresets = new int[weaponCount];
		hasUnlockedColors = new bool[weaponCount];
		currentPropBlocks = new MaterialPropertyBlock[weaponCount];
		currentAltPropBlocks = new MaterialPropertyBlock[weaponCount];
		UpdateGunColors();
	}

	public void UpdateGunColors()
	{
		for (int i = 0; i < weaponCount; i++)
		{
			UpdateColor(i, altVersion: false);
			UpdateColor(i, altVersion: true);
			hasUnlockedColors[i] = GameProgressSaver.HasWeaponCustomization((GameProgressSaver.WeaponCustomizationType)i);
		}
	}

	private void UpdateColor(int gunNumber, bool altVersion)
	{
		GetColorPresets((GameProgressSaver.WeaponCustomizationType)gunNumber);
		int[] array = (altVersion ? altPresets : presets);
		string text = (altVersion ? ".a" : "");
		if (MonoSingleton<PrefsManager>.Instance.GetBool("gunColorType." + (gunNumber + 1) + text) && GameProgressSaver.HasWeaponCustomization((GameProgressSaver.WeaponCustomizationType)gunNumber))
		{
			SetCustomColors(gunNumber, altVersion);
		}
		else
		{
			string key = "gunColorPreset." + (gunNumber + 1) + text;
			array[gunNumber] = MonoSingleton<PrefsManager>.Instance.GetInt(key);
			if (GameProgressSaver.GetTotalSecretsFound() < requiredSecrets[array[gunNumber]])
			{
				array[gunNumber] = 0;
				MonoSingleton<PrefsManager>.Instance.SetInt(key, 0);
			}
			SetCustomColors(gunNumber, altVersion, array);
		}
		if (altVersion)
		{
			altPresets = array;
		}
		else
		{
			presets = array;
		}
	}

	private void SetCustomColors(int gunNumber, bool altVersion, int[] presetArray = null)
	{
		GunColorPreset gunColorPreset = ((presetArray != null) ? GetColorPresets((GameProgressSaver.WeaponCustomizationType)gunNumber)[presetArray[gunNumber]] : CustomGunColorPreset(gunNumber + 1, altVersion));
		if (altVersion)
		{
			currentAltColors[gunNumber] = gunColorPreset;
		}
		else
		{
			currentColors[gunNumber] = gunColorPreset;
		}
	}

	private GunColorPreset[] GetColorPresets(GameProgressSaver.WeaponCustomizationType weaponType)
	{
		switch (weaponType)
		{
		case GameProgressSaver.WeaponCustomizationType.Revolver:
			return revolverColors;
		case GameProgressSaver.WeaponCustomizationType.Shotgun:
			return shotgunColors;
		case GameProgressSaver.WeaponCustomizationType.Nailgun:
			return nailgunColors;
		case GameProgressSaver.WeaponCustomizationType.Railcannon:
			return railcannonColors;
		case GameProgressSaver.WeaponCustomizationType.RocketLauncher:
			return rocketLauncherColors;
		default:
			Debug.LogError($"Invalid WeaponCustomizationType: {weaponType}");
			return null;
		}
	}

	private GunColorPreset CustomGunColorPreset(int gunNumber, bool altVersion)
	{
		return new GunColorPreset(GetGunColor(1, gunNumber, altVersion), GetGunColor(2, gunNumber, altVersion), GetGunColor(3, gunNumber, altVersion));
	}

	private Color GetGunColor(int number, int gunNumber, bool altVersion)
	{
		return new Color(MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + gunNumber + "." + number + (altVersion ? ".a" : ".") + "r", 1f), MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + gunNumber + "." + number + (altVersion ? ".a" : ".") + "g", 1f), MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + gunNumber + "." + number + (altVersion ? ".a" : ".") + "b", 1f), MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + gunNumber + "." + number + (altVersion ? ".a" : ".") + "a"));
	}
}



public class GunColorGetter : MonoBehaviour
{
	private Renderer rend;

	public Material[] defaultMaterials;

	public Material[] coloredMaterials;

	private MaterialPropertyBlock customColors;

	public int weaponNumber;

	public bool altVersion;

	private GunColorPreset currentColors = new GunColorPreset(Color.white, Color.white, Color.white);

	private bool hasCustomColors;

	private void Awake()
	{
		for (int i = 0; i < defaultMaterials.Length; i++)
		{
			defaultMaterials[i] = new Material(defaultMaterials[i]);
		}
		for (int j = 0; j < coloredMaterials.Length; j++)
		{
			coloredMaterials[j] = new Material(coloredMaterials[j]);
		}
	}

	private void OnEnable()
	{
		UpdateColor();
	}

	public void UpdateColor()
	{
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		if (customColors == null)
		{
			customColors = new MaterialPropertyBlock();
		}
		hasCustomColors = MonoSingleton<PrefsManager>.Instance.GetBool("gunColorType." + weaponNumber + (altVersion ? ".a" : "")) && MonoSingleton<GunColorController>.Instance.hasUnlockedColors[weaponNumber - 1];
		GunColorPreset colors = GetColors();
		if (currentColors != colors)
		{
			if (GetPreset() != 0 || hasCustomColors)
			{
				rend.materials = coloredMaterials;
				rend.GetPropertyBlock(customColors);
				customColors.SetColor("_CustomColor1", colors.color1);
				customColors.SetColor("_CustomColor2", colors.color2);
				customColors.SetColor("_CustomColor3", colors.color3);
				rend.SetPropertyBlock(customColors);
			}
			else
			{
				rend.materials = defaultMaterials;
			}
		}
		currentColors = colors;
	}

	private int GetPreset()
	{
		if (weaponNumber > 0 && weaponNumber <= 5)
		{
			if (altVersion)
			{
				return MonoSingleton<GunColorController>.Instance.altPresets[weaponNumber - 1];
			}
			return MonoSingleton<GunColorController>.Instance.presets[weaponNumber - 1];
		}
		return 0;
	}

	private GunColorPreset GetColors()
	{
		if (weaponNumber > 0 && weaponNumber <= 5)
		{
			if (altVersion)
			{
				return MonoSingleton<GunColorController>.Instance.currentAltColors[weaponNumber - 1];
			}
			return MonoSingleton<GunColorController>.Instance.currentColors[weaponNumber - 1];
		}
		return new GunColorPreset(Color.white, Color.white, Color.white);
	}
}



public class GunColorLock : MonoBehaviour
{
	private int weaponNumber;

	public bool alreadyUnlocked;

	public UltrakillEvent onUnlock;

	public Button button;

	public TMP_Text buttonText;

	private void OnEnable()
	{
		if (weaponNumber == 0)
		{
			weaponNumber = GetComponentInParent<GunColorTypeGetter>().weaponNumber;
		}
		if (GameProgressSaver.HasWeaponCustomization((GameProgressSaver.WeaponCustomizationType)(weaponNumber - 1)))
		{
			onUnlock?.Invoke();
		}
		else if (GameProgressSaver.GetMoney() < 1000000)
		{
			button.interactable = false;
			buttonText.text = "<color=red>1,000,000P</color>";
			button.GetComponent<ShopButton>().failure = true;
		}
		else
		{
			button.interactable = true;
			buttonText.text = "1,000,000<color=orange>P</color>";
			button.GetComponent<ShopButton>().failure = false;
		}
	}

	public void Unlock()
	{
		GameProgressSaver.AddMoney(-1000000);
		GameProgressSaver.UnlockWeaponCustomization((GameProgressSaver.WeaponCustomizationType)(weaponNumber - 1));
		onUnlock?.Invoke();
		GetComponentInParent<GunColorTypeGetter>().SetType(isCustom: true);
		MoneyText[] array = Object.FindObjectsOfType<MoneyText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateMoney();
		}
		VariationInfo[] array2 = Object.FindObjectsOfType<VariationInfo>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].UpdateMoney();
		}
	}
}



[Serializable]
public class GunColorPreset
{
	public Color color1;

	public Color color2;

	public Color color3;

	public GunColorPreset(Color a, Color b, Color c)
	{
		color1 = a;
		color2 = b;
		color3 = c;
	}
}



public class GunColorSetter : MonoBehaviour
{
	private int weaponNumber;

	public int colorNumber;

	private bool altVersion;

	private float redAmount;

	private float greenAmount;

	private float blueAmount;

	private float metalAmount;

	public Slider redSlider;

	public Slider greenSlider;

	public Slider blueSlider;

	public Slider metalSlider;

	public Image colorExample;

	public Image metalExample;

	private GunColorTypeGetter gctg;

	private void OnEnable()
	{
		if (gctg == null)
		{
			gctg = GetComponentInParent<GunColorTypeGetter>();
		}
		weaponNumber = gctg.weaponNumber;
		altVersion = gctg.altVersion;
		redAmount = MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "r", 1f);
		greenAmount = MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "g", 1f);
		blueAmount = MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "b", 1f);
		metalAmount = MonoSingleton<PrefsManager>.Instance.GetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "a");
		redSlider.value = redAmount;
		greenSlider.value = greenAmount;
		blueSlider.value = blueAmount;
		metalSlider.value = metalAmount;
		colorExample.color = new Color(redAmount, greenAmount, blueAmount);
		float num = ((Vector3.Dot(Vector3.one, new Vector3(redAmount, greenAmount, blueAmount)) / 3f < 0.9f) ? 1f : 0.7f);
		metalExample.color = new Color(num, num, num, metalAmount);
		gctg.UpdatePreview();
	}

	public void SetRed(float amount)
	{
		redAmount = amount;
		UpdateColor();
	}

	public void SetGreen(float amount)
	{
		greenAmount = amount;
		UpdateColor();
	}

	public void SetBlue(float amount)
	{
		blueAmount = amount;
		UpdateColor();
	}

	public void SetMetal(float amount)
	{
		metalAmount = amount;
		UpdateColor();
	}

	public void UpdateColor()
	{
		if (gctg == null)
		{
			gctg = GetComponentInParent<GunColorTypeGetter>();
		}
		weaponNumber = gctg.weaponNumber;
		altVersion = gctg.altVersion;
		MonoSingleton<PrefsManager>.Instance.SetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "r", redAmount);
		MonoSingleton<PrefsManager>.Instance.SetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "g", greenAmount);
		MonoSingleton<PrefsManager>.Instance.SetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "b", blueAmount);
		MonoSingleton<PrefsManager>.Instance.SetFloat("gunColor." + weaponNumber + "." + colorNumber + (altVersion ? ".a" : ".") + "a", metalAmount);
		colorExample.color = new Color(redAmount, greenAmount, blueAmount);
		float num = ((Vector3.Dot(Vector3.one, new Vector3(redAmount, greenAmount, blueAmount)) / 3f < 0.9f) ? 1f : 0.7f);
		metalExample.color = new Color(num, num, num, metalAmount);
		MonoSingleton<GunColorController>.Instance.UpdateGunColors();
		gctg.UpdatePreview();
	}
}



public class GunColorTypeGetter : MonoBehaviour
{
	public int weaponNumber;

	public bool altVersion;

	public GameObject template;

	public GameObject custom;

	public GameObject altButton;

	public GunColorGetter[] previewModel;

	public Image[] templateButtons;

	private TMP_Text[] templateTexts;

	private string[] originalTemplateTexts;

	private void Awake()
	{
		templateTexts = new TMP_Text[templateButtons.Length];
		for (int i = 0; i < templateTexts.Length; i++)
		{
			templateTexts[i] = templateButtons[i].GetComponentInChildren<TMP_Text>();
		}
		originalTemplateTexts = new string[templateTexts.Length];
		for (int j = 0; j < templateTexts.Length; j++)
		{
			originalTemplateTexts[j] = templateTexts[j].text;
		}
	}

	private void OnEnable()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetBool("gunColorType." + weaponNumber + (altVersion ? ".a" : "")) && GameProgressSaver.HasWeaponCustomization((GameProgressSaver.WeaponCustomizationType)(weaponNumber - 1)))
		{
			template.SetActive(value: false);
			custom.SetActive(value: true);
		}
		else
		{
			template.SetActive(value: true);
			custom.SetActive(value: false);
		}
		UpdateButtons(MonoSingleton<PrefsManager>.Instance.GetInt("gunColorPreset." + weaponNumber + (altVersion ? ".a" : "")));
		if ((bool)altButton)
		{
			string gear = "";
			switch (weaponNumber)
			{
			case 1:
				gear = "revalt";
				break;
			case 2:
				gear = "shoalt";
				break;
			case 3:
				gear = "naialt";
				break;
			}
			if (GameProgressSaver.CheckGear(gear) >= 1)
			{
				altButton.SetActive(value: true);
			}
			else
			{
				altButton.SetActive(value: false);
			}
		}
		for (int i = 1; i < 5; i++)
		{
			bool flag = GameProgressSaver.GetTotalSecretsFound() >= GunColorController.requiredSecrets[i];
			templateButtons[i].GetComponent<Button>().interactable = flag;
			templateButtons[i].GetComponent<ShopButton>().failure = !flag;
			if (flag)
			{
				templateTexts[i].text = originalTemplateTexts[i];
				if (templateTexts[i].color == Color.gray)
				{
					templateTexts[i].color = Color.white;
				}
				continue;
			}
			if (MonoSingleton<PrefsManager>.Instance.GetInt("gunColorPreset." + weaponNumber + (altVersion ? ".a" : "")) == i)
			{
				if (MonoSingleton<PrefsManager>.Instance.GetBool("gunColorType." + weaponNumber + (altVersion ? ".a" : "")))
				{
					MonoSingleton<PrefsManager>.Instance.SetInt("gunColorPreset." + weaponNumber + (altVersion ? ".a" : ""), 0);
					UpdateButtons(0);
				}
				else
				{
					SetPreset(0);
				}
			}
			templateTexts[i].text = "SOUL ORBS: " + GameProgressSaver.GetTotalSecretsFound() + " / " + GunColorController.requiredSecrets[i];
			templateTexts[i].color = Color.gray;
		}
	}

	public void SetType(bool isCustom)
	{
		if (!GameProgressSaver.HasWeaponCustomization((GameProgressSaver.WeaponCustomizationType)(weaponNumber - 1)))
		{
			isCustom = false;
		}
		MonoSingleton<PrefsManager>.Instance.SetBool("gunColorType." + weaponNumber + (altVersion ? ".a" : ""), isCustom);
		MonoSingleton<GunColorController>.Instance.UpdateGunColors();
		UpdatePreview();
	}

	public void SetPreset(int target)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("gunColorPreset." + weaponNumber + (altVersion ? ".a" : ""), target);
		MonoSingleton<GunColorController>.Instance.UpdateGunColors();
		UpdateButtons(target);
		UpdatePreview();
	}

	public void UpdatePreview()
	{
		GunColorGetter[] array = previewModel;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateColor();
		}
	}

	public void UpdateButtons(int target)
	{
		for (int i = 0; i < templateButtons.Length; i++)
		{
			templateButtons[i].fillCenter = i == target;
			if (templateTexts[i].color != Color.gray)
			{
				templateTexts[i].color = ((i == target) ? Color.black : Color.white);
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class GunControl : MonoSingleton<GunControl>
{
	private InputManager inman;

	public bool activated = true;

	private int rememberedSlot;

	public int currentVariation;

	public int currentSlot;

	public GameObject currentWeapon;

	public List<List<GameObject>> slots = new List<List<GameObject>>();

	public List<GameObject> slot1 = new List<GameObject>();

	public List<GameObject> slot2 = new List<GameObject>();

	public List<GameObject> slot3 = new List<GameObject>();

	public List<GameObject> slot4 = new List<GameObject>();

	public List<GameObject> slot5 = new List<GameObject>();

	public List<GameObject> slot6 = new List<GameObject>();

	public List<GameObject> allWeapons = new List<GameObject>();

	public Dictionary<GameObject, int> slotDict = new Dictionary<GameObject, int>();

	public List<WeaponIcon> currentWeaponIcons = new List<WeaponIcon>();

	private AudioSource aud;

	public float killCharge;

	public Slider killMeter;

	public bool noWeapons = true;

	public int lastUsedSlot = 69;

	public int lastUsedVariation = 69;

	private Dictionary<int, int> retainedVariations = new Dictionary<int, int>();

	public float headShotComboTime;

	public int headshots;

	private bool hookCombo;

	private StyleHUD shud;

	public GameObject[] gunPanel;

	private float scrollCooldown;

	private const float WeaponWheelTime = 0.25f;

	[HideInInspector]
	public int dualWieldCount;

	[HideInInspector]
	public bool stayUnarmed;

	[HideInInspector]
	public bool variationMemory;

	private void Start()
	{
		inman = MonoSingleton<InputManager>.Instance;
		currentVariation = PlayerPrefs.GetInt("CurVar", 0);
		currentSlot = PlayerPrefs.GetInt("CurSlo", 1);
		lastUsedVariation = PlayerPrefs.GetInt("LasVar", 69);
		lastUsedSlot = PlayerPrefs.GetInt("LasSlo", 69);
		aud = GetComponent<AudioSource>();
		variationMemory = MonoSingleton<PrefsManager>.Instance.GetBool("variationMemory");
		slots.Add(slot1);
		slots.Add(slot2);
		slots.Add(slot3);
		slots.Add(slot4);
		slots.Add(slot5);
		slots.Add(slot6);
		if (currentSlot > slots.Count)
		{
			currentSlot = 1;
		}
		int num = 0;
		foreach (List<GameObject> slot in slots)
		{
			foreach (GameObject item in slot)
			{
				if (item != null)
				{
					allWeapons.Add(item);
					slotDict.Add(item, num);
				}
			}
			if (slot.Count != 0)
			{
				noWeapons = false;
			}
			num++;
		}
		if (currentWeapon == null && slots[currentSlot - 1].Count > currentVariation)
		{
			currentWeapon = slots[currentSlot - 1][currentVariation];
		}
		else if (currentWeapon == null && slot1.Count != 0)
		{
			currentSlot = 1;
			currentVariation = 0;
			currentWeapon = slot1[0];
		}
		shud = MonoSingleton<StyleHUD>.Instance;
		UpdateWeaponList(firstTime: true);
	}

	private void CalculateSlotCount()
	{
		List<WeaponDescriptor> list = new List<WeaponDescriptor>();
		List<int> list2 = new List<int>();
		foreach (List<GameObject> slot in slots)
		{
			GameObject gameObject = slot.FirstOrDefault();
			if (!(gameObject == null))
			{
				WeaponIcon component = gameObject.GetComponent<WeaponIcon>();
				if (component != null)
				{
					list.Add(component.weaponDescriptor);
				}
				list2.Add(slots.IndexOf(slot));
			}
		}
		MonoSingleton<WeaponWheel>.Instance.SetSegments(list.ToArray(), list2.ToArray());
	}

	private void Update()
	{
		if (activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			PlayerInput inputSource = inman.InputSource;
			if (headShotComboTime > 0f)
			{
				headShotComboTime = Mathf.MoveTowards(headShotComboTime, 0f, Time.deltaTime);
			}
			else
			{
				headshots = 0;
			}
			if (lastUsedSlot == 0)
			{
				lastUsedSlot = 69;
			}
			if (!MonoSingleton<OptionsManager>.Instance.inIntro && !MonoSingleton<OptionsManager>.Instance.paused && !MonoSingleton<NewMovement>.Instance.dead)
			{
				if (inputSource.NextWeapon.IsPressed && inputSource.PrevWeapon.IsPressed)
				{
					hookCombo = true;
					if (MonoSingleton<WeaponWheel>.Instance.gameObject.activeSelf)
					{
						MonoSingleton<WeaponWheel>.Instance.gameObject.SetActive(value: false);
					}
				}
				if (((inputSource.NextWeapon.IsPressed && inputSource.NextWeapon.HoldTime >= 0.25f && !inputSource.PrevWeapon.IsPressed) || (inputSource.PrevWeapon.IsPressed && inputSource.PrevWeapon.HoldTime >= 0.25f && !inputSource.NextWeapon.IsPressed) || (inputSource.LastWeapon.IsPressed && inputSource.LastWeapon.HoldTime >= 0.25f) || (inputSource.PreviousVariation.IsPressed && inputSource.PreviousVariation.HoldTime >= 0.25f)) && !hookCombo)
				{
					MonoSingleton<WeaponWheel>.Instance.Show();
				}
			}
			if (inman.InputSource.Slot1.WasPerformedThisFrame)
			{
				if (slot1.Count > 0 && slot1[0] != null && (slot1.Count > 1 || currentSlot != 1))
				{
					SwitchWeapon(1, slot1);
				}
			}
			else if (inman.InputSource.Slot2.WasPerformedThisFrame)
			{
				if (slot2.Count > 0 && slot2[0] != null && (slot2.Count > 1 || currentSlot != 2))
				{
					SwitchWeapon(2, slot2);
				}
			}
			else if (inman.InputSource.Slot3.WasPerformedThisFrame && (slot3.Count > 1 || currentSlot != 3))
			{
				if (slot3.Count > 0 && slot3[0] != null)
				{
					SwitchWeapon(3, slot3);
				}
			}
			else if (inman.InputSource.Slot4.WasPerformedThisFrame && (slot4.Count > 1 || currentSlot != 4))
			{
				if (slot4.Count > 0 && slot4[0] != null)
				{
					SwitchWeapon(4, slot4);
				}
			}
			else if (inman.InputSource.Slot5.WasPerformedThisFrame && (slot5.Count > 1 || currentSlot != 5))
			{
				if (slot5.Count > 0 && slot5[0] != null)
				{
					SwitchWeapon(5, slot5);
				}
			}
			else if (inman.InputSource.Slot6.WasPerformedThisFrame && (slot6.Count > 1 || currentSlot != 6))
			{
				if (slot6.Count > 0 && slot6[0] != null)
				{
					SwitchWeapon(6, slot6, lastUsedSlot: false, useRetainedVariation: true);
				}
			}
			else if (inman.InputSource.LastWeapon.WasCanceledThisFrame && inman.InputSource.LastWeapon.HoldTime < 0.25f && lastUsedSlot != 69)
			{
				if (slots[lastUsedSlot - 1] != null)
				{
					SwitchWeapon(lastUsedSlot, slots[lastUsedSlot - 1], lastUsedSlot: true);
				}
			}
			else if (inman.InputSource.NextVariation.WasPerformedThisFrame && slots[currentSlot - 1].Count > 1)
			{
				SwitchWeapon(currentSlot, slots[currentSlot - 1], lastUsedSlot: false, useRetainedVariation: false, scrolled: false, isNextVarBind: true);
			}
			else if (inman.InputSource.PreviousVariation.WasCanceledThisFrame && inputSource.PreviousVariation.HoldTime < 0.25f && slots[currentSlot - 1].Count > 1)
			{
				if (currentVariation != 0)
				{
					GameObject weapon = slots[currentSlot - 1][currentVariation - 1];
					ForceWeapon(weapon);
				}
				else
				{
					GameObject weapon2 = slots[currentSlot - 1][slots[currentSlot - 1].Count - 1];
					ForceWeapon(weapon2);
				}
			}
			else if (inman.InputSource.SelectVariant1.WasPerformedThisFrame)
			{
				SwitchVariant(1);
			}
			else if (inman.InputSource.SelectVariant2.WasPerformedThisFrame)
			{
				SwitchVariant(2);
			}
			else if (inman.InputSource.SelectVariant3.WasPerformedThisFrame)
			{
				SwitchVariant(3);
			}
			else if (!noWeapons)
			{
				float num = Mouse.current.scroll.ReadValue().y;
				if (inman.ScrRev)
				{
					num *= -1f;
				}
				if (inputSource.NextWeapon.HoldTime < 0.25f && !hookCombo && ((num > 0f && inman.ScrOn) || inputSource.NextWeapon.WasCanceledThisFrame) && scrollCooldown <= 0f)
				{
					int num2 = 0;
					if (inman.ScrWep && inman.ScrVar)
					{
						foreach (List<GameObject> slot in slots)
						{
							if (slot.Count > 0)
							{
								num2++;
							}
						}
					}
					bool flag = false;
					if (inman.ScrVar)
					{
						if (slots[currentSlot - 1].Count > currentVariation + 1 || ((!inman.ScrWep || num2 <= 1) && slots[currentSlot - 1].Count > 1))
						{
							SwitchWeapon(currentSlot, slots[currentSlot - 1], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
							scrollCooldown = 0.5f;
							flag = true;
						}
						else if (!inman.ScrWep)
						{
							flag = true;
						}
					}
					if (!flag && inman.ScrWep)
					{
						if (!flag && currentSlot < slots.Count)
						{
							for (int i = currentSlot; i < slots.Count; i++)
							{
								if (slots[i].Count > 0)
								{
									flag = true;
									SwitchWeapon(i + 1, slots[i], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
									scrollCooldown = 0.5f;
									break;
								}
							}
						}
						if (!flag)
						{
							for (int j = 0; j < currentSlot; j++)
							{
								if (slots[j].Count > 0)
								{
									if (j != currentSlot - 1)
									{
										SwitchWeapon(j + 1, slots[j], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
										scrollCooldown = 0.5f;
									}
									break;
								}
							}
						}
					}
				}
				else if (inputSource.PrevWeapon.HoldTime < 0.25f && !hookCombo && ((num < 0f && inman.ScrOn) || inputSource.PrevWeapon.WasCanceledThisFrame) && scrollCooldown <= 0f)
				{
					int num3 = 0;
					if (inman.ScrWep && inman.ScrVar)
					{
						foreach (List<GameObject> slot2 in slots)
						{
							if (slot2.Count > 0)
							{
								num3++;
							}
						}
					}
					if ((inman.ScrWep && !inman.ScrVar) || (inman.ScrWep && num3 > 1))
					{
						if (inman.ScrVar)
						{
							if (currentVariation != 0)
							{
								GameObject weapon3 = slots[currentSlot - 1][currentVariation - 1];
								ForceWeapon(weapon3);
								scrollCooldown = 0.5f;
							}
							else if (currentSlot == 1)
							{
								for (int num4 = slots.Count - 1; num4 >= 0; num4--)
								{
									if (slots[num4].Count > 0)
									{
										if (num4 != currentSlot - 1)
										{
											GameObject weapon4 = slots[num4][slots[num4].Count - 1];
											ForceWeapon(weapon4);
											scrollCooldown = 0.5f;
										}
										break;
									}
								}
							}
							else
							{
								bool flag2 = false;
								for (int num5 = currentSlot - 2; num5 >= 0; num5--)
								{
									if (slots[num5].Count > 0)
									{
										GameObject weapon5 = slots[num5][slots[num5].Count - 1];
										ForceWeapon(weapon5);
										scrollCooldown = 0.5f;
										flag2 = true;
										break;
									}
								}
								if (!flag2)
								{
									for (int num6 = slots.Count - 1; num6 >= 0; num6--)
									{
										if (slots[num6].Count > 0)
										{
											if (num6 != currentSlot - 1)
											{
												GameObject weapon6 = slots[num6][slots[num6].Count - 1];
												ForceWeapon(weapon6);
												scrollCooldown = 0.5f;
											}
											break;
										}
									}
								}
							}
						}
						else if (currentSlot == 1)
						{
							for (int num7 = slots.Count - 1; num7 >= 0; num7--)
							{
								if (slots[num7].Count > 0)
								{
									if (num7 != currentSlot - 1)
									{
										SwitchWeapon(num7 + 1, slots[num7], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
										scrollCooldown = 0.5f;
									}
									break;
								}
							}
						}
						else
						{
							bool flag3 = false;
							for (int num8 = currentSlot - 2; num8 >= 0; num8--)
							{
								if (slots[num8].Count > 0)
								{
									SwitchWeapon(num8 + 1, slots[num8], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
									scrollCooldown = 0.5f;
									flag3 = true;
									break;
								}
							}
							if (!flag3)
							{
								for (int num9 = slots.Count - 1; num9 >= 0; num9--)
								{
									if (slots[num9].Count > 0)
									{
										if (num9 != currentSlot - 1)
										{
											SwitchWeapon(num9 + 1, slots[num9], lastUsedSlot: false, useRetainedVariation: false, scrolled: true);
											scrollCooldown = 0.5f;
										}
										break;
									}
								}
							}
						}
					}
					else if (slots[currentSlot - 1].Count > 1)
					{
						if (currentVariation != 0)
						{
							GameObject weapon7 = slots[currentSlot - 1][currentVariation - 1];
							ForceWeapon(weapon7);
							scrollCooldown = 0.5f;
						}
						else
						{
							GameObject weapon8 = slots[currentSlot - 1][slots[currentSlot - 1].Count - 1];
							ForceWeapon(weapon8);
							scrollCooldown = 0.5f;
						}
					}
				}
			}
			if (hookCombo && !inputSource.NextWeapon.IsPressed && !inputSource.PrevWeapon.IsPressed)
			{
				hookCombo = false;
			}
		}
		if (scrollCooldown > 0f)
		{
			scrollCooldown = Mathf.MoveTowards(scrollCooldown, 0f, Time.deltaTime * 5f);
		}
	}

	private void OnGUI()
	{
		if (!GunControlDebug.GunControlActivated)
		{
			return;
		}
		GUILayout.Label("Gun Control");
		GUILayout.Label("Last Used Slot: " + lastUsedSlot);
		GUILayout.Label("Current Slot: " + currentSlot);
		GUILayout.Label("Current Variation: " + currentVariation);
		GUILayout.Space(12f);
		GUILayout.Label("Retained Variations:");
		foreach (KeyValuePair<int, int> retainedVariation in retainedVariations)
		{
			GUILayout.Label(retainedVariation.Key + ": " + retainedVariation.Value);
		}
	}

	public void SwitchVariant(int index)
	{
		List<GameObject> list = slots[currentSlot - 1];
		if (list.Count >= index)
		{
			GameObject weapon = list[index - 1];
			ForceWeapon(weapon);
		}
	}

	public void SwitchWeapon(int target, bool isNextVarBind = false)
	{
		if (target - 1 < slots.Count)
		{
			List<GameObject> list = slots[target - 1];
			if (list != null && list.Count > 0)
			{
				SwitchWeapon(target, slots[target - 1], lastUsedSlot: false, useRetainedVariation: false, scrolled: false, isNextVarBind);
			}
		}
	}

	private void RetainVariation(int slot, int variationIndex)
	{
		if (retainedVariations.ContainsKey(slot))
		{
			retainedVariations[slot] = variationIndex;
		}
		else
		{
			retainedVariations.Add(slot, currentVariation);
		}
	}

	public void SwitchWeapon(int target, List<GameObject> slot, bool lastUsedSlot = false, bool useRetainedVariation = false, bool scrolled = false, bool isNextVarBind = false)
	{
		if (currentWeapon != null)
		{
			currentWeapon.SetActive(value: false);
		}
		target = Mathf.Clamp(target, 1, slots.Count);
		int num = target;
		int value = currentVariation;
		if (useRetainedVariation && target != currentSlot && retainedVariations.TryGetValue(target - 1, out var value2))
		{
			currentVariation = value2;
		}
		else if (lastUsedSlot)
		{
			if (slots[this.lastUsedSlot - 1].Count == 0)
			{
				this.lastUsedSlot = currentSlot;
				slot = slots[currentSlot - 1];
				num = currentSlot;
				if (currentVariation == 0)
				{
					if (slots[this.lastUsedSlot - 1].Count > 1)
					{
						lastUsedVariation = slots[this.lastUsedSlot - 1].Count - 1;
					}
					else
					{
						lastUsedVariation = 0;
					}
				}
				else
				{
					lastUsedVariation = currentVariation - 1;
				}
			}
			int num2 = lastUsedVariation;
			int num3 = currentVariation;
			currentVariation = num2;
			lastUsedVariation = num3;
			RetainVariation(num - 1, currentVariation);
			this.lastUsedSlot = currentSlot;
		}
		else if (currentSlot == target && currentVariation + 1 < slot.Count)
		{
			if (this.lastUsedSlot == 69)
			{
				this.lastUsedSlot = currentSlot;
				lastUsedVariation = currentVariation;
			}
			int @int = MonoSingleton<PrefsManager>.Instance.GetInt("WeaponRedrawBehaviour");
			if (@int == 0 || isNextVarBind || scrolled)
			{
				currentVariation++;
				RetainVariation(target - 1, currentVariation);
			}
			else
			{
				switch (@int)
				{
				case 1:
					currentVariation = 0;
					break;
				}
			}
		}
		else if (currentSlot != target)
		{
			this.lastUsedSlot = currentSlot;
			lastUsedVariation = currentVariation;
			currentVariation = 0;
			RetainVariation(target - 1, currentVariation);
		}
		else
		{
			int num4 = 0;
			foreach (List<GameObject> slot2 in slots)
			{
				if (slot2.Count != 0)
				{
					num4++;
				}
			}
			if (num4 <= 1)
			{
				this.lastUsedSlot = currentSlot;
				lastUsedVariation = currentVariation;
			}
			int int2 = MonoSingleton<PrefsManager>.Instance.GetInt("WeaponRedrawBehaviour");
			if (int2 == 0 || isNextVarBind || scrolled)
			{
				currentVariation++;
			}
			else if (int2 == 1)
			{
				currentVariation = 0;
			}
			else
			{
				_ = 2;
			}
			RetainVariation(target - 1, currentVariation);
		}
		if (variationMemory)
		{
			string key = "Slot" + currentSlot + "Var";
			if (currentSlot != num && (!scrolled || !inman.ScrWep || !inman.ScrVar))
			{
				PlayerPrefs.SetInt(key, value);
				key = "Slot" + num + "Var";
				currentVariation = PlayerPrefs.GetInt(key, 0);
				RetainVariation(num - 1, currentVariation);
			}
			else
			{
				PlayerPrefs.SetInt(key, value);
			}
		}
		currentSlot = num;
		if (slots[currentSlot - 1].Count < currentVariation + 1)
		{
			currentVariation = 0;
			RetainVariation(num - 1, currentVariation);
		}
		if (!noWeapons && currentVariation < slots[currentSlot - 1].Count)
		{
			currentWeapon = slots[currentSlot - 1][currentVariation];
			currentWeapon.SetActive(value: true);
			aud.Play();
			PlayerPrefs.SetInt("CurVar", currentVariation);
			PlayerPrefs.SetInt("CurSlo", currentSlot);
			PlayerPrefs.SetInt("LasVar", lastUsedVariation);
			PlayerPrefs.SetInt("LasSlo", this.lastUsedSlot);
		}
		shud.SnapFreshnessSlider();
	}

	public void ForceWeapon(GameObject weapon, bool setActive = true)
	{
		new List<GameObject>();
		foreach (List<GameObject> slot in slots)
		{
			for (int i = 0; i < slot.Count; i++)
			{
				if (slot[i].name == weapon.name + "(Clone)" || slot[i].name == weapon.name)
				{
					if (currentWeapon != null)
					{
						currentWeapon.SetActive(value: false);
					}
					currentSlot = slots.IndexOf(slot) + 1;
					currentVariation = i;
					RetainVariation(currentSlot - 1, currentVariation);
					currentWeapon = slot[currentVariation];
					if (setActive)
					{
						currentWeapon.SetActive(value: true);
					}
					aud.Play();
					break;
				}
			}
		}
	}

	public void NoWeapon()
	{
		if (currentWeapon != null)
		{
			currentWeapon.SetActive(value: false);
			rememberedSlot = currentSlot;
			activated = false;
		}
	}

	public void YesWeapon()
	{
		if (slots[currentSlot - 1].Count > currentVariation && slots[currentSlot - 1][currentVariation] != null)
		{
			currentWeapon = slots[currentSlot - 1][currentVariation];
			currentWeapon.SetActive(value: true);
		}
		else if (slots[currentSlot - 1].Count > 0)
		{
			currentWeapon = slots[currentSlot - 1][0];
			currentVariation = 0;
			RetainVariation(currentSlot - 1, currentVariation);
			currentWeapon.SetActive(value: true);
		}
		else
		{
			int num = -1;
			for (int i = 0; i < currentSlot; i++)
			{
				if (slots[i].Count > 0)
				{
					num = i;
				}
			}
			if (num == -1)
			{
				num = 99;
				for (int j = currentSlot; j < slots.Count; j++)
				{
					if (slots[j].Count > 0 && j < num)
					{
						num = j;
					}
				}
			}
			if (num != 99)
			{
				currentWeapon = slots[num][0];
				currentSlot = num + 1;
				currentVariation = 0;
			}
			else
			{
				noWeapons = true;
			}
		}
		if (currentWeapon != null)
		{
			currentWeapon.SetActive(value: false);
			activated = true;
			currentWeapon.SetActive(value: true);
		}
	}

	public void AddKill()
	{
		if (killCharge < killMeter.maxValue)
		{
			killCharge += 1f;
			if (killCharge > killMeter.maxValue)
			{
				killCharge = killMeter.maxValue;
			}
			killMeter.value = killCharge;
		}
	}

	public void ClearKills()
	{
		killCharge = 0f;
		killMeter.value = killCharge;
	}

	public void UpdateWeaponList(bool firstTime = false)
	{
		allWeapons.Clear();
		noWeapons = true;
		slotDict.Clear();
		int num = 0;
		foreach (List<GameObject> slot in slots)
		{
			foreach (GameObject item in slot)
			{
				if (item != null)
				{
					allWeapons.Add(item);
					slotDict.Add(item, num);
					if (noWeapons)
					{
						noWeapons = false;
					}
				}
			}
			num++;
		}
		UpdateWeaponIcon(firstTime);
		if (MonoSingleton<RailcannonMeter>.Instance != null)
		{
			MonoSingleton<RailcannonMeter>.Instance.CheckStatus();
		}
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		shud.ResetFreshness();
		CalculateSlotCount();
	}

	public void UpdateWeaponIcon(bool firstTime = false)
	{
		if (gunPanel == null || gunPanel.Length == 0)
		{
			return;
		}
		GameObject[] array;
		if (noWeapons || !MonoSingleton<PrefsManager>.Instance.GetBool("weaponIcons") || MapInfoBase.InstanceAnyType.hideStockHUD)
		{
			array = gunPanel;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: false);
				}
			}
			return;
		}
		array = gunPanel;
		foreach (GameObject gameObject2 in array)
		{
			if (gameObject2 != null && (!firstTime || gameObject2 != gunPanel[0]))
			{
				gameObject2.SetActive(value: true);
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class GunSetter : MonoSingleton<GunSetter>
{
	[HideInInspector]
	public GunControl gunc;

	[HideInInspector]
	public ForcedLoadout forcedLoadout;

	[Header("Revolver")]
	public AssetReference[] revolverPierce;

	public AssetReference[] revolverRicochet;

	public AssetReference[] revolverTwirl;

	[Header("Shotgun")]
	public AssetReference[] shotgunGrenade;

	public AssetReference[] shotgunPump;

	public AssetReference[] shotgunRed;

	[Header("Nailgun")]
	public AssetReference[] nailMagnet;

	public AssetReference[] nailOverheat;

	public AssetReference[] nailRed;

	[Header("Railcannon")]
	public AssetReference[] railCannon;

	public AssetReference[] railHarpoon;

	public AssetReference[] railMalicious;

	[Header("Rocket Launcher")]
	public AssetReference[] rocketBlue;

	public AssetReference[] rocketGreen;

	public AssetReference[] rocketRed;

	private void Start()
	{
		gunc = GetComponent<GunControl>();
		if (base.enabled)
		{
			ResetWeapons(firstTime: true);
		}
	}

	public void ResetWeapons(bool firstTime = false)
	{
		if (gunc == null)
		{
			gunc = GetComponent<GunControl>();
		}
		int b = 5;
		for (int i = 0; i < Mathf.Min(gunc.slots.Count, b); i++)
		{
			List<GameObject> list = gunc.slots[i];
			foreach (GameObject item in list)
			{
				Object.Destroy(item);
			}
			list.Clear();
		}
		List<int> list2 = CheckWeaponOrder("rev");
		for (int j = 1; j < 5; j++)
		{
			switch (list2.IndexOf(j))
			{
			case 0:
				CheckWeapon("rev0", gunc.slot1, revolverPierce.ToAssets());
				break;
			case 1:
				CheckWeapon("rev1", gunc.slot1, revolverTwirl.ToAssets());
				break;
			case 2:
				CheckWeapon("rev2", gunc.slot1, revolverRicochet.ToAssets());
				break;
			}
		}
		list2 = CheckWeaponOrder("sho");
		for (int k = 1; k < 5; k++)
		{
			switch (list2.IndexOf(k))
			{
			case 0:
				CheckWeapon("sho0", gunc.slot2, shotgunGrenade.ToAssets());
				break;
			case 1:
				CheckWeapon("sho1", gunc.slot2, shotgunPump.ToAssets());
				break;
			case 2:
				CheckWeapon("sho2", gunc.slot2, shotgunRed.ToAssets());
				break;
			}
		}
		list2 = CheckWeaponOrder("nai");
		for (int l = 1; l < 5; l++)
		{
			switch (list2.IndexOf(l))
			{
			case 0:
				CheckWeapon("nai0", gunc.slot3, nailMagnet.ToAssets());
				break;
			case 1:
				CheckWeapon("nai1", gunc.slot3, nailOverheat.ToAssets());
				break;
			case 2:
				CheckWeapon("nai2", gunc.slot3, nailRed.ToAssets());
				break;
			}
		}
		list2 = CheckWeaponOrder("rai");
		for (int m = 1; m < 5; m++)
		{
			switch (list2.IndexOf(m))
			{
			case 0:
				CheckWeapon("rai0", gunc.slot4, railCannon.ToAssets());
				break;
			case 1:
				CheckWeapon("rai1", gunc.slot4, railHarpoon.ToAssets());
				break;
			case 2:
				CheckWeapon("rai2", gunc.slot4, railMalicious.ToAssets());
				break;
			}
		}
		list2 = CheckWeaponOrder("rock");
		for (int n = 1; n < 5; n++)
		{
			switch (list2.IndexOf(n))
			{
			case 0:
				CheckWeapon("rock0", gunc.slot5, rocketBlue.ToAssets());
				break;
			case 1:
				CheckWeapon("rock1", gunc.slot5, rocketGreen.ToAssets());
				break;
			case 2:
				CheckWeapon("rock2", gunc.slot5, rocketRed.ToAssets());
				break;
			}
		}
		gunc.UpdateWeaponList(firstTime);
	}

	private List<int> CheckWeaponOrder(string weaponType)
	{
		string text = "1234";
		if (weaponType == "rev")
		{
			text = "1324";
		}
		string text2 = MonoSingleton<PrefsManager>.Instance.GetString("weapon." + weaponType + ".order", text);
		if (text2.Length != 4)
		{
			Debug.LogError("Faulty WeaponOrder: " + weaponType);
			text2 = text;
			MonoSingleton<PrefsManager>.Instance.SetString("weapon." + weaponType + ".order", text);
		}
		List<int> list = new List<int>();
		for (int i = 0; i < text2.Length; i++)
		{
			list.Add(text2[i] - 48);
		}
		return list;
	}

	private void CheckWeapon(string name, List<GameObject> slot, GameObject[] prefabs)
	{
		if (prefabs == null || prefabs.Length == 0)
		{
			return;
		}
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + name, 1);
		VariantOption variantOption = VariantOption.IfEquipped;
		VariantOption variantOption2 = VariantOption.IfEquipped;
		switch (name)
		{
		case "rev0":
			variantOption = forcedLoadout?.revolver.blueVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altRevolver.blueVariant ?? VariantOption.IfEquipped;
			break;
		case "rev1":
			variantOption = forcedLoadout?.revolver.redVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altRevolver.redVariant ?? VariantOption.IfEquipped;
			break;
		case "rev2":
			variantOption = forcedLoadout?.revolver.greenVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altRevolver.greenVariant ?? VariantOption.IfEquipped;
			break;
		case "sho0":
			variantOption = forcedLoadout?.shotgun.blueVariant ?? VariantOption.IfEquipped;
			break;
		case "sho1":
			variantOption = forcedLoadout?.shotgun.greenVariant ?? VariantOption.IfEquipped;
			break;
		case "sho2":
			variantOption = forcedLoadout?.shotgun.redVariant ?? VariantOption.IfEquipped;
			break;
		case "nai0":
			variantOption = forcedLoadout?.nailgun.blueVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altNailgun.blueVariant ?? VariantOption.IfEquipped;
			break;
		case "nai1":
			variantOption = forcedLoadout?.nailgun.greenVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altNailgun.greenVariant ?? VariantOption.IfEquipped;
			break;
		case "nai2":
			variantOption = forcedLoadout?.nailgun.redVariant ?? VariantOption.IfEquipped;
			variantOption2 = forcedLoadout?.altNailgun.redVariant ?? VariantOption.IfEquipped;
			break;
		case "rai0":
			variantOption = forcedLoadout?.railcannon.blueVariant ?? VariantOption.IfEquipped;
			break;
		case "rai1":
			variantOption = forcedLoadout?.railcannon.greenVariant ?? VariantOption.IfEquipped;
			break;
		case "rai2":
			variantOption = forcedLoadout?.railcannon.redVariant ?? VariantOption.IfEquipped;
			break;
		case "rock0":
			variantOption = forcedLoadout?.rocketLauncher.blueVariant ?? VariantOption.IfEquipped;
			break;
		case "rock1":
			variantOption = forcedLoadout?.rocketLauncher.greenVariant ?? VariantOption.IfEquipped;
			break;
		}
		switch (variantOption)
		{
		case VariantOption.ForceOn:
			if (prefabs[0] != null)
			{
				slot.Add(Object.Instantiate(prefabs[0], base.transform));
			}
			break;
		case VariantOption.IfEquipped:
			if (@int > 0 && GameProgressSaver.CheckGear(name) > 0 && (@int <= 1 || prefabs.Length < @int || GameProgressSaver.CheckGear(name.Substring(0, name.Length - 1) + "alt") <= 0) && prefabs[0] != null)
			{
				slot.Add(Object.Instantiate(prefabs[0], base.transform));
			}
			break;
		}
		switch (variantOption2)
		{
		case VariantOption.ForceOn:
			if (prefabs.Length >= 2)
			{
				slot.Add(Object.Instantiate(prefabs[1], base.transform));
			}
			break;
		case VariantOption.IfEquipped:
			if (@int > 0 && GameProgressSaver.CheckGear(name) > 0 && @int > 1 && prefabs.Length >= @int && GameProgressSaver.CheckGear(name.Substring(0, name.Length - 1) + "alt") > 0)
			{
				slot.Add(Object.Instantiate(prefabs[@int - 1], base.transform));
			}
			break;
		}
	}

	public void ForceWeapon(string weaponName)
	{
		if (gunc == null)
		{
			gunc = GetComponent<GunControl>();
		}
		int num = 0;
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + weaponName) == 2)
		{
			num = 1;
		}
		switch (weaponName)
		{
		case "rev0":
			gunc.ForceWeapon(revolverPierce[num].ToAsset());
			break;
		case "rev2":
			gunc.ForceWeapon(revolverRicochet[num].ToAsset());
			break;
		case "sho0":
			gunc.ForceWeapon(shotgunGrenade[num].ToAsset());
			break;
		case "sho1":
			gunc.ForceWeapon(shotgunPump[num].ToAsset());
			break;
		case "nai0":
			gunc.ForceWeapon(nailMagnet[num].ToAsset());
			break;
		case "nai1":
			gunc.ForceWeapon(nailOverheat[num].ToAsset());
			break;
		case "rai0":
			gunc.ForceWeapon(railCannon[num].ToAsset());
			break;
		case "rai1":
			gunc.ForceWeapon(railHarpoon[num].ToAsset());
			break;
		case "rai2":
			gunc.ForceWeapon(railMalicious[num].ToAsset());
			break;
		case "rock0":
			gunc.ForceWeapon(rocketBlue[num].ToAsset());
			break;
		case "rock1":
			gunc.ForceWeapon(rocketGreen[num].ToAsset());
			break;
		}
	}
}



public class Gutterman : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	private bool gotValues;

	private EnemyIdentifier eid;

	private NavMeshAgent nma;

	private Machine mach;

	private Rigidbody rb;

	private Animator anim;

	private int difficulty;

	private float defaultMovementSpeed;

	[HideInInspector]
	public bool dead;

	[HideInInspector]
	public bool fallen;

	[HideInInspector]
	public bool exploded;

	public bool hasShield = true;

	[SerializeField]
	private GameObject[] shield;

	public Transform torsoAimBone;

	public Transform gunAimBone;

	private Quaternion torsoDefaultRotation;

	[SerializeField]
	private SwingCheck2 sc;

	[SerializeField]
	private SwingCheck2 shieldlessSwingcheck;

	private bool inAction;

	private bool attacking;

	private bool moveForward;

	private bool trackInAction;

	public Transform shootPoint;

	public GameObject beam;

	private float windup;

	private float windupSpeed;

	[SerializeField]
	private AudioSource windupAud;

	[SerializeField]
	private Transform windupBarrel;

	private Quaternion barrelRotation;

	private bool slowMode;

	private float slowModeLerp;

	private bool firing;

	private float bulletCooldown;

	private float lineOfSightTimer;

	private float trackingSpeed;

	private float trackingSpeedMultiplier;

	private float defaultTrackingSpeed = 1f;

	private Vector3 trackingPosition;

	private Vector3 lastKnownPosition;

	private TimeSince lastParried;

	[SerializeField]
	private GameObject playerUnstucker;

	[SerializeField]
	private GameObject fallingKillTrigger;

	[SerializeField]
	private GameObject fallEffect;

	[SerializeField]
	private GameObject corpseExplosion;

	[SerializeField]
	private GameObject shieldBreakEffect;

	[SerializeField]
	private AudioSource bonkSound;

	[SerializeField]
	private AudioSource releaseSound;

	[SerializeField]
	private AudioSource deathSound;

	private bool enraged;

	public bool eternalRage;

	[SerializeField]
	private AudioSource enrageEffect;

	private AudioSource currentEnrageEffect;

	private float rageLeft;

	private EnemySimplifier[] ensims;

	public bool isEnraged => enraged;

	public string alterKey => "Gutterman";

	public string alterCategoryName => "Gutterman";

	public AlterOption<bool>[] options => new AlterOption<bool>[2]
	{
		new AlterOption<bool>
		{
			value = isEnraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		},
		new AlterOption<bool>
		{
			value = eternalRage,
			callback = delegate(bool value)
			{
				eternalRage = value;
			},
			key = "eternal-rage",
			name = "Eternal Rage"
		}
	};

	private void Start()
	{
		GetValues();
	}

	private void GetValues()
	{
		if (gotValues)
		{
			return;
		}
		gotValues = true;
		eid = GetComponent<EnemyIdentifier>();
		nma = GetComponent<NavMeshAgent>();
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		anim = GetComponent<Animator>();
		ensims = GetComponentsInChildren<EnemySimplifier>();
		if (dead)
		{
			CheckIfInstaCorpse();
			return;
		}
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (!hasShield)
		{
			GameObject[] array = shield;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		anim.SetBool("Shield", hasShield);
		torsoDefaultRotation = Quaternion.Inverse(base.transform.rotation) * torsoAimBone.rotation;
		lastParried = 5f;
		barrelRotation = windupBarrel.localRotation;
		if (windupAud.pitch != 0f)
		{
			windupAud.Play();
		}
		SetSpeed();
		SlowUpdate();
	}

	private void OnEnable()
	{
		CheckIfInstaCorpse();
	}

	private void OnDisable()
	{
		inAction = false;
		CancelInvoke("DoneDying");
	}

	private void CheckIfInstaCorpse()
	{
		if (dead)
		{
			anim.Play("Death", 0, 1f);
			fallen = true;
			Invoke("DoneDying", 0.5f);
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		GetValues();
		if (difficulty == 0)
		{
			anim.speed = 0.8f;
			defaultMovementSpeed = 8f;
			windupSpeed = 0.5f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.9f;
			defaultMovementSpeed = 9f;
			windupSpeed = 0.75f;
		}
		else
		{
			anim.speed = 1f;
			defaultMovementSpeed = 10f;
			windupSpeed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
		defaultMovementSpeed *= eid.totalSpeedModifier;
		nma.speed = (slowMode ? (defaultMovementSpeed / 2f) : defaultMovementSpeed);
		windupSpeed *= eid.totalSpeedModifier;
		if (difficulty > 2)
		{
			trackingSpeedMultiplier = 1f;
		}
		else if (difficulty == 2)
		{
			trackingSpeedMultiplier = 0.8f;
		}
		else if (difficulty == 1)
		{
			trackingSpeedMultiplier = 0.5f;
		}
		else
		{
			trackingSpeedMultiplier = 0.35f;
		}
		defaultTrackingSpeed = 1f;
		if (trackingSpeed < defaultTrackingSpeed)
		{
			trackingSpeed = defaultTrackingSpeed;
		}
	}

	private void Update()
	{
		if (dead)
		{
			return;
		}
		if (lineOfSightTimer >= 0.9f || (slowMode && lineOfSightTimer > 0f))
		{
			windup = Mathf.MoveTowards(windup, 1f, Time.deltaTime * windupSpeed);
		}
		else
		{
			windup = Mathf.MoveTowards(windup, 0f, Time.deltaTime * windupSpeed);
		}
		windupAud.pitch = windup * 3f;
		if (windupAud.pitch == 0f)
		{
			windupAud.Stop();
		}
		else if (!windupAud.isPlaying)
		{
			windupAud.Play();
		}
		if (inAction)
		{
			firing = false;
			if (nma.enabled)
			{
				nma.updateRotation = false;
			}
			if (difficulty <= 1)
			{
				windup = 0f;
			}
			if (eid.target != null)
			{
				trackingPosition = base.transform.position + base.transform.forward * Mathf.Max(5f, Vector3.Distance(base.transform.position, new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z))) + Vector3.up * (eid.target.position.y - base.transform.position.y);
				if (trackInAction || moveForward)
				{
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z) - base.transform.position), (float)(trackInAction ? 360 : 90) * Time.deltaTime);
				}
			}
		}
		else
		{
			RaycastHit hitInfo;
			bool flag = eid.target != null && !Physics.Raycast(base.transform.position + Vector3.up, eid.target.headPosition - (base.transform.position + Vector3.up), out hitInfo, Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment));
			lineOfSightTimer = Mathf.MoveTowards(lineOfSightTimer, flag ? 1 : 0, Time.deltaTime * 2f);
			if (windup >= 0.5f)
			{
				if (!slowMode)
				{
					trackingPosition = base.transform.position + base.transform.forward * Mathf.Max(30f, Vector3.Distance(base.transform.position, eid.target.headPosition));
				}
				slowMode = true;
			}
			else if (slowMode && windup <= 0f)
			{
				slowMode = false;
				Object.Instantiate(releaseSound, base.transform.position, Quaternion.identity);
			}
			if (firing && !mach.gc.onGround)
			{
				firing = false;
			}
			if (slowMode && firing)
			{
				trackingSpeed += Time.deltaTime * (float)(hasShield ? 2 : 5) * trackingSpeedMultiplier * eid.totalSpeedModifier;
			}
			else if (!slowMode)
			{
				trackingSpeed = defaultTrackingSpeed;
			}
			if (slowMode)
			{
				if (nma.enabled)
				{
					nma.updateRotation = false;
				}
				if (eid.target != null)
				{
					if (lineOfSightTimer > 0f)
					{
						lastKnownPosition = eid.target.headPosition;
					}
					trackingPosition = Vector3.MoveTowards(trackingPosition, lastKnownPosition, (Vector3.Distance(trackingPosition, eid.target.headPosition) + trackingSpeed) * Time.deltaTime);
				}
				base.transform.rotation = Quaternion.LookRotation(new Vector3(trackingPosition.x, base.transform.position.y, trackingPosition.z) - base.transform.position);
			}
			else if (nma.enabled)
			{
				nma.updateRotation = true;
			}
			nma.speed = (slowMode ? (defaultMovementSpeed / 2f) : defaultMovementSpeed);
			if (eid.target != null && lineOfSightTimer >= 0.5f && (float)lastParried > 5f && mach.gc.onGround && Vector3.Distance(base.transform.position, eid.target.position) < 12f)
			{
				ShieldBash();
			}
		}
		slowModeLerp = Mathf.MoveTowards(slowModeLerp, slowMode ? 1 : 0, Time.deltaTime * 2.5f);
		anim.SetFloat("WalkSpeed", slowMode ? 0.5f : 1f);
		anim.SetBool("Walking", nma.velocity.magnitude > 2.5f);
		anim.SetLayerWeight(1, firing ? 1 : 0);
		if (eternalRage || !(rageLeft > 0f))
		{
			return;
		}
		rageLeft = Mathf.MoveTowards(rageLeft, 0f, Time.deltaTime * eid.totalSpeedModifier);
		if (currentEnrageEffect != null && rageLeft < 3f)
		{
			currentEnrageEffect.pitch = rageLeft / 3f;
		}
		if (!(rageLeft <= 0f))
		{
			return;
		}
		enraged = false;
		EnemySimplifier[] array = ensims;
		foreach (EnemySimplifier enemySimplifier in array)
		{
			if ((bool)enemySimplifier)
			{
				enemySimplifier.enraged = false;
			}
		}
		if (currentEnrageEffect != null)
		{
			Object.Destroy(currentEnrageEffect.gameObject);
		}
	}

	private void LateUpdate()
	{
		if (!dead)
		{
			if (inAction)
			{
				Quaternion quaternion = Quaternion.RotateTowards(torsoAimBone.rotation, Quaternion.LookRotation(torsoAimBone.position - trackingPosition, Vector3.up), 60f);
				Quaternion quaternion2 = Quaternion.Inverse(base.transform.rotation * torsoDefaultRotation) * torsoAimBone.rotation;
				torsoAimBone.rotation = quaternion * quaternion2;
				sc.knockBackDirection = trackingPosition - torsoAimBone.position;
			}
			else if (slowModeLerp > 0f)
			{
				torsoAimBone.rotation = Quaternion.Lerp(torsoAimBone.rotation, Quaternion.LookRotation(torsoAimBone.position - trackingPosition), slowModeLerp);
				Quaternion rotation = gunAimBone.rotation;
				gunAimBone.rotation = Quaternion.LookRotation(gunAimBone.position - trackingPosition);
				gunAimBone.Rotate(Vector3.left, 90f, Space.Self);
				gunAimBone.Rotate(Vector3.up, 180f, Space.Self);
				gunAimBone.rotation = Quaternion.Lerp(rotation, gunAimBone.rotation, slowModeLerp);
			}
			windupBarrel.localRotation = barrelRotation;
			if (windup > 0f)
			{
				windupBarrel.Rotate(Vector3.up * -3600f * windup * Time.deltaTime);
				barrelRotation = windupBarrel.localRotation;
			}
		}
	}

	private void FixedUpdate()
	{
		if (dead)
		{
			return;
		}
		if (inAction)
		{
			rb.isKinematic = !moveForward;
			if (moveForward)
			{
				if (Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward, Vector3.down, out var _, (eid.target == null) ? 22f : Mathf.Max(22f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
				{
					rb.velocity = base.transform.forward * (hasShield ? 25 : 45) * anim.speed * eid.totalSpeedModifier;
				}
				else
				{
					rb.velocity = Vector3.zero;
				}
			}
		}
		if (!firing)
		{
			return;
		}
		if (bulletCooldown == 0f)
		{
			Vector3 position = shootPoint.position + shootPoint.right * Random.Range(-0.2f, 0.2f) + shootPoint.up * Random.Range(-0.2f, 0.2f);
			if (Physics.Raycast(shootPoint.position - shootPoint.forward * 4f, shootPoint.forward, 4f, LayerMaskDefaults.Get(LMD.EnvironmentAndPlayer)))
			{
				position = shootPoint.position - shootPoint.forward * 4f;
			}
			Object.Instantiate(beam, position, shootPoint.rotation).transform.Rotate(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)));
			bulletCooldown = 0.05f / windup;
		}
		else
		{
			bulletCooldown = Mathf.MoveTowards(bulletCooldown, 0f, Time.fixedDeltaTime);
		}
	}

	private void SlowUpdate()
	{
		if (dead)
		{
			return;
		}
		Invoke("SlowUpdate", 0.1f);
		if (!inAction && eid.target != null && nma.enabled && nma.isOnNavMesh)
		{
			nma.SetDestination(eid.target.position);
		}
		if (inAction)
		{
			return;
		}
		if (slowMode && windup >= 0.5f && eid.target != null && (firing || windup >= 1f) && mach.gc.onGround)
		{
			firing = true;
			RaycastHit[] array = Physics.RaycastAll(base.transform.position + Vector3.up + base.transform.forward * 3f, eid.target.headPosition - (base.transform.position + Vector3.up), Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Enemies));
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (!(raycastHit.transform == eid.target.targetTransform) && !(raycastHit.transform == shield[0].transform) && (!raycastHit.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component) || !component.eid || (!(component.eid == eid) && !component.eid.dead && !(component.eid == eid.target.enemyIdentifier))))
				{
					firing = false;
					break;
				}
			}
		}
		else
		{
			firing = false;
		}
	}

	private void Death()
	{
		Object.Instantiate(deathSound, base.transform);
		ShieldBashStop();
		dead = true;
		windupAud.Stop();
		anim.SetBool("Dead", value: true);
		anim.SetLayerWeight(1, 0f);
		anim.Play("Death", 0, 0f);
		if (TryGetComponent<Collider>(out var component))
		{
			component.enabled = false;
		}
		if (mach.gc.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.constraints = (RigidbodyConstraints)122;
		}
		if (currentEnrageEffect != null)
		{
			Object.Destroy(currentEnrageEffect.gameObject);
		}
	}

	public void ShieldBreak(bool player = true, bool flash = true)
	{
		anim.Play("ShieldBreak", 0, 0f);
		anim.SetBool("Shield", value: false);
		if (player)
		{
			if (flash)
			{
				MonoSingleton<NewMovement>.Instance.Parry(null, "GUARD BREAK");
			}
			else
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(100, "<color=green>GUARD BREAK</color>");
			}
			if (difficulty >= 4)
			{
				Enrage();
			}
		}
		GameObject[] array = shield;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		hasShield = false;
		Object.Instantiate(bonkSound, base.transform.position, Quaternion.identity);
		Object.Instantiate(shieldBreakEffect, shield[0].transform.position, Quaternion.identity);
		if (inAction)
		{
			ShieldBashStop();
			StopAction();
		}
		sc = shieldlessSwingcheck;
		inAction = true;
		attacking = false;
		trackInAction = false;
		nma.enabled = false;
		moveForward = false;
		firing = false;
		slowMode = false;
		windup = 0f;
	}

	private void ShieldBash()
	{
		if (difficulty <= 2 && hasShield)
		{
			lastParried = 3f;
		}
		anim.Play(hasShield ? "ShieldBash" : "Smack", 0, 0f);
		Object.Instantiate((hasShield || enraged) ? MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash : MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, shield[0].transform.position + base.transform.forward, base.transform.rotation).transform.localScale *= 15f;
		inAction = true;
		nma.enabled = false;
		firing = false;
		attacking = true;
		trackInAction = true;
		if (!hasShield && !enraged)
		{
			mach.parryable = true;
		}
	}

	private void ShieldBashActive()
	{
		if (attacking)
		{
			sc.DamageStart();
			sc.knockBackDirectionOverride = true;
			sc.knockBackDirection = base.transform.forward;
			moveForward = true;
			trackInAction = false;
		}
	}

	private void ShieldBashStop()
	{
		sc.DamageStop();
		moveForward = false;
		mach.parryable = false;
		attacking = false;
	}

	private void StopAction()
	{
		if (!dead)
		{
			inAction = false;
			if (mach.gc.onGround)
			{
				rb.isKinematic = true;
				nma.enabled = true;
			}
			else
			{
				rb.isKinematic = false;
			}
		}
	}

	public void GotParried()
	{
		anim.Play("ShieldBreak", 0, 0f);
		ShieldBashStop();
		StopAction();
		inAction = true;
		trackInAction = false;
		attacking = false;
		nma.enabled = false;
		moveForward = false;
		if (difficulty >= 4)
		{
			Enrage();
		}
		else
		{
			lastParried = 0f;
		}
		windup = 0f;
		trackingSpeed = defaultTrackingSpeed;
		Object.Instantiate(bonkSound, base.transform.position, Quaternion.identity);
	}

	private void FallStart()
	{
		fallingKillTrigger.SetActive(value: true);
	}

	private void FallOver()
	{
		if (!fallEffect)
		{
			return;
		}
		if ((bool)MonoSingleton<EndlessGrid>.Instance)
		{
			Explode();
			return;
		}
		if (mach.gc.onGround)
		{
			for (int i = 0; i < mach.gc.cols.Count; i++)
			{
				if (mach.gc.cols[i].gameObject.CompareTag("Moving"))
				{
					Explode();
					return;
				}
			}
		}
		fallEffect.transform.position = new Vector3(mach.chest.transform.position.x, base.transform.position.y, mach.chest.transform.position.z);
		fallEffect.SetActive(value: true);
		fallingKillTrigger.SetActive(value: false);
		playerUnstucker.SetActive(value: true);
		fallen = true;
		Invoke("DoneDying", 1f);
	}

	public void Explode()
	{
		if (exploded)
		{
			return;
		}
		exploded = true;
		Object.Instantiate(corpseExplosion, torsoAimBone.position, Quaternion.identity);
		if ((bool)mach)
		{
			EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
			{
				if (!(enemyIdentifierIdentifier == null))
				{
					mach.GetHurt(enemyIdentifierIdentifier.gameObject, (base.transform.position - enemyIdentifierIdentifier.transform.position).normalized * 1000f, 999f, 1f);
				}
			}
		}
		Object.Destroy(base.gameObject);
	}

	private void DoneDying()
	{
		playerUnstucker.SetActive(value: false);
		anim.enabled = false;
		base.enabled = false;
	}

	public void Enrage()
	{
		if (enraged)
		{
			return;
		}
		enraged = true;
		rageLeft = 10f;
		EnemySimplifier[] array = ensims;
		foreach (EnemySimplifier enemySimplifier in array)
		{
			if ((bool)enemySimplifier)
			{
				enemySimplifier.enraged = true;
			}
		}
		if (currentEnrageEffect == null)
		{
			currentEnrageEffect = Object.Instantiate(enrageEffect, mach.chest.transform);
			currentEnrageEffect.pitch = 1f;
			currentEnrageEffect.transform.localScale *= 0.01f;
		}
	}

	public void UnEnrage()
	{
		enraged = false;
		rageLeft = 0f;
		EnemySimplifier[] array = ensims;
		foreach (EnemySimplifier enemySimplifier in array)
		{
			if ((bool)enemySimplifier)
			{
				enemySimplifier.enraged = false;
			}
		}
		if (currentEnrageEffect != null)
		{
			Object.Destroy(currentEnrageEffect.gameObject);
		}
	}
}



public class Guttertank : MonoBehaviour, IHitTargetCallback
{
	private bool gotValues;

	private EnemyIdentifier eid;

	private NavMeshAgent nma;

	private Machine mach;

	private Rigidbody rb;

	private Animator anim;

	private AudioSource aud;

	private Collider col;

	private int difficulty;

	public bool stationary;

	private Vector3 stationaryPosition;

	private NavMeshPath path;

	private bool walking;

	private Vector3 walkTarget;

	private bool dead;

	[SerializeField]
	private SwingCheck2 sc;

	private bool inAction;

	private bool moveForward;

	private bool trackInAction;

	private bool overrideTarget;

	private bool lookAtTarget;

	private bool punching;

	private Vector3 overrideTargetPosition;

	private float aimRotationLerp;

	private float punchCooldown;

	private bool punchHit;

	public Transform shootPoint;

	public Grenade rocket;

	public GameObject rocketParticle;

	public Transform aimBone;

	private Quaternion torsoDefaultRotation;

	private float shootCooldown = 1f;

	private float lineOfSightTimer;

	public Landmine landmine;

	private float mineCooldown = 2f;

	private List<Landmine> placedMines = new List<Landmine>();

	private GoreZone gz;

	public AudioSource punchPrepSound;

	public AudioSource rocketPrepSound;

	public AudioSource minePrepSound;

	public AudioSource fallImpactSound;

	private void Start()
	{
		GetValues();
	}

	private void GetValues()
	{
		if (!gotValues)
		{
			gotValues = true;
			eid = GetComponent<EnemyIdentifier>();
			nma = GetComponent<NavMeshAgent>();
			mach = GetComponent<Machine>();
			rb = GetComponent<Rigidbody>();
			anim = GetComponent<Animator>();
			aud = GetComponent<AudioSource>();
			col = GetComponent<Collider>();
			shootCooldown = Random.Range(0.75f, 1.25f);
			mineCooldown = Random.Range(2f, 3f);
			stationaryPosition = base.transform.position;
			torsoDefaultRotation = Quaternion.Inverse(base.transform.rotation) * aimBone.rotation;
			path = new NavMeshPath();
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			gz = GoreZone.ResolveGoreZone(base.transform);
			SetSpeed();
			SlowUpdate();
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		GetValues();
		if (difficulty >= 3)
		{
			anim.speed = 1f;
		}
		else if (difficulty == 2)
		{
			anim.speed = 0.9f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.8f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.6f;
		}
		anim.speed *= eid.totalSpeedModifier;
		nma.speed = 20f * anim.speed;
	}

	private void Update()
	{
		if (dead || eid.target == null)
		{
			return;
		}
		if (inAction)
		{
			Vector3 headPosition = eid.target.headPosition;
			if (overrideTarget)
			{
				headPosition = overrideTargetPosition;
			}
			if (trackInAction || moveForward)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(new Vector3(headPosition.x, base.transform.position.y, headPosition.z) - base.transform.position), (float)(trackInAction ? 360 : 90) * Time.deltaTime);
			}
		}
		else
		{
			RaycastHit hitInfo;
			bool flag = !Physics.Raycast(base.transform.position + Vector3.up, eid.target.headPosition - (base.transform.position + Vector3.up), out hitInfo, Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment));
			lineOfSightTimer = Mathf.MoveTowards(lineOfSightTimer, flag ? 1 : 0, Time.deltaTime * eid.totalSpeedModifier);
			if (shootCooldown > 0f)
			{
				shootCooldown = Mathf.MoveTowards(shootCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (mineCooldown > 0f)
			{
				mineCooldown = Mathf.MoveTowards(mineCooldown, 0f, Time.deltaTime * ((lineOfSightTimer >= 0.5f) ? 0.5f : 1f) * eid.totalSpeedModifier);
			}
			if (lineOfSightTimer >= 0.5f)
			{
				if (difficulty <= 1 && Vector3.Distance(base.transform.position, eid.target.position) > 10f && Vector3.Distance(base.transform.position, eid.target.PredictTargetPosition(0.5f)) > 10f)
				{
					punchCooldown = ((difficulty == 1) ? 1 : 2);
				}
				if (punchCooldown <= 0f && (Vector3.Distance(base.transform.position, eid.target.position) < 10f || Vector3.Distance(base.transform.position, eid.target.PredictTargetPosition(0.5f)) < 10f))
				{
					Punch();
				}
				else if (shootCooldown <= 0f && Vector3.Distance(base.transform.position, eid.target.PredictTargetPosition(1f)) > 15f)
				{
					PrepRocket();
				}
			}
			if (!inAction && mineCooldown <= 0f)
			{
				if (CheckMines())
				{
					PrepMine();
				}
				else
				{
					mineCooldown = 0.5f;
				}
			}
		}
		punchCooldown = Mathf.MoveTowards(punchCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		anim.SetBool("Walking", nma.velocity.magnitude > 2.5f);
	}

	private void LateUpdate()
	{
		if (dead || eid.target == null)
		{
			return;
		}
		aimRotationLerp = Mathf.MoveTowards(aimRotationLerp, (inAction && lookAtTarget) ? 1 : 0, Time.deltaTime * 5f);
		if (aimRotationLerp > 0f)
		{
			Vector3 vector = eid.target.headPosition;
			if (overrideTarget)
			{
				vector = overrideTargetPosition;
			}
			if (punching)
			{
				vector = eid.target.position;
			}
			Quaternion quaternion = Quaternion.LookRotation(aimBone.position - vector, Vector3.up);
			Quaternion quaternion2 = Quaternion.Inverse(base.transform.rotation * torsoDefaultRotation) * aimBone.rotation;
			aimBone.rotation = Quaternion.Lerp(aimBone.rotation, quaternion * quaternion2, aimRotationLerp);
			sc.knockBackDirection = aimBone.forward * -1f;
		}
	}

	private void FixedUpdate()
	{
		if (dead || !inAction)
		{
			return;
		}
		rb.isKinematic = !moveForward;
		if (moveForward && !Physics.SphereCast(new Ray(base.transform.position + Vector3.up * 3f, base.transform.forward), 1.5f, 75f * Time.fixedDeltaTime * eid.totalSpeedModifier, LayerMaskDefaults.Get(LMD.Player)))
		{
			if (Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward, Vector3.down, out var _, (eid.target == null) ? 22f : Mathf.Max(22f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				rb.velocity = base.transform.forward * 75f * anim.speed * eid.totalSpeedModifier;
			}
			else
			{
				rb.velocity = Vector3.zero;
			}
		}
	}

	private void SlowUpdate()
	{
		if (dead)
		{
			return;
		}
		Invoke("SlowUpdate", 0.25f);
		if (eid.target == null)
		{
			return;
		}
		if (!inAction && mach.grounded && nma.isOnNavMesh)
		{
			if (stationary)
			{
				if (!(Vector3.Distance(base.transform.position, stationaryPosition) > 1f))
				{
					return;
				}
				NavMesh.CalculatePath(base.transform.position, stationaryPosition, nma.areaMask, path);
				if (path.status == NavMeshPathStatus.PathComplete)
				{
					nma.path = path;
					return;
				}
			}
			bool flag = false;
			if (Vector3.Distance(base.transform.position, eid.target.position) > 30f || Physics.CheckSphere(aimBone.position - Vector3.up * 0.5f, 1.5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)) || Physics.SphereCast(aimBone.position - Vector3.up * 0.5f, 1.5f, eid.target.position + Vector3.up - aimBone.position, out var hitInfo, Vector3.Distance(eid.target.position + Vector3.up, aimBone.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				if ((eid.target.isPlayer && ((MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS && !MonoSingleton<NewMovement>.Instance.gc.onGround) || (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && !MonoSingleton<PlatformerMovement>.Instance.groundCheck.onGround))) || (eid.target.isEnemy && (!eid.target.enemyIdentifier.gce || !eid.target.enemyIdentifier.gce.onGround)))
				{
					if (Physics.Raycast(eid.target.position, Vector3.down, out hitInfo, 120f, LayerMaskDefaults.Get(LMD.Environment)))
					{
						NavMesh.CalculatePath(base.transform.position, hitInfo.point, nma.areaMask, path);
					}
				}
				else
				{
					NavMesh.CalculatePath(base.transform.position, eid.target.position, nma.areaMask, path);
				}
				if (path.status == NavMeshPathStatus.PathComplete)
				{
					walking = false;
					flag = true;
					nma.path = path;
				}
			}
			if (!walking && !flag)
			{
				Vector3 onUnitSphere = Random.onUnitSphere;
				onUnitSphere = new Vector3(onUnitSphere.x, 0f, onUnitSphere.z);
				RaycastHit hitInfo3;
				if (Physics.Raycast(aimBone.position, onUnitSphere, out var hitInfo2, 25f, LayerMaskDefaults.Get(LMD.Environment)))
				{
					if (NavMesh.SamplePosition(hitInfo2.point, out var hit, 5f, nma.areaMask))
					{
						walkTarget = hit.position;
					}
					else if (Physics.SphereCast(hitInfo2.point, 1f, Vector3.down, out hitInfo2, 25f, LayerMaskDefaults.Get(LMD.Environment)))
					{
						walkTarget = hitInfo2.point;
					}
				}
				else if (Physics.Raycast(aimBone.position + onUnitSphere * 25f, Vector3.down, out hitInfo3, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
				{
					walkTarget = hitInfo3.point;
				}
				NavMesh.CalculatePath(base.transform.position, walkTarget, nma.areaMask, path);
				nma.path = path;
				walking = true;
			}
			else if (Vector3.Distance(base.transform.position, walkTarget) < 1f || nma.path.status != 0)
			{
				walking = false;
			}
		}
		else
		{
			walking = false;
		}
	}

	private bool CheckMines()
	{
		if (placedMines.Count >= 5)
		{
			for (int num = placedMines.Count - 1; num >= 0; num--)
			{
				if (placedMines[num] == null)
				{
					placedMines.RemoveAt(num);
				}
			}
			if (placedMines.Count >= 5)
			{
				return false;
			}
		}
		for (int num2 = MonoSingleton<ObjectTracker>.Instance.landmineList.Count - 1; num2 >= 0; num2--)
		{
			if (MonoSingleton<ObjectTracker>.Instance.landmineList[num2] != null && Vector3.Distance(base.transform.position, MonoSingleton<ObjectTracker>.Instance.landmineList[num2].transform.position) < 15f)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepMine()
	{
		anim.Play("Landmine", 0, 0f);
		Object.Instantiate(minePrepSound, base.transform);
		inAction = true;
		nma.enabled = false;
		lookAtTarget = false;
		mineCooldown = Random.Range(2f, 3f);
	}

	private void PlaceMine()
	{
		Landmine landmine = Object.Instantiate(this.landmine, base.transform.position, base.transform.rotation, gz.transform);
		placedMines.Add(landmine);
		if (landmine.TryGetComponent<Landmine>(out var component))
		{
			component.originEnemy = eid;
		}
	}

	private void PrepRocket()
	{
		anim.Play("Shoot", 0, 0f);
		Object.Instantiate(rocketPrepSound, base.transform);
		inAction = true;
		nma.enabled = false;
		trackInAction = true;
		lookAtTarget = true;
		punching = false;
	}

	private void PredictTarget()
	{
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, shootPoint.position + base.transform.forward, base.transform.rotation).transform.localScale *= 10f;
		if (eid.target != null)
		{
			overrideTarget = true;
			float num = 1f;
			if (difficulty == 1)
			{
				num = 0.75f;
			}
			else if (difficulty == 0)
			{
				num = 0.5f;
			}
			overrideTargetPosition = eid.target.PredictTargetPosition((Random.Range(0.75f, 1f) + Vector3.Distance(shootPoint.position, eid.target.headPosition) / 150f) * num);
			if (Physics.Raycast(eid.target.position, Vector3.down, 15f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				overrideTargetPosition = new Vector3(overrideTargetPosition.x, eid.target.headPosition.y, overrideTargetPosition.z);
			}
			bool flag = false;
			if (Physics.Raycast(aimBone.position, overrideTargetPosition - aimBone.position, out var hitInfo, Vector3.Distance(overrideTargetPosition, aimBone.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)) && (!hitInfo.transform.TryGetComponent<Breakable>(out var component) || !component.playerOnly))
			{
				flag = true;
				overrideTargetPosition = eid.target.headPosition;
			}
			if (!flag && overrideTargetPosition != eid.target.headPosition && col.Raycast(new Ray(eid.target.headPosition, (overrideTargetPosition - eid.target.headPosition).normalized), out hitInfo, Vector3.Distance(eid.target.headPosition, overrideTargetPosition)))
			{
				overrideTargetPosition = eid.target.headPosition;
			}
		}
	}

	private void FireRocket()
	{
		Object.Instantiate(rocketParticle, shootPoint.position, Quaternion.LookRotation(overrideTargetPosition - shootPoint.position));
		Grenade grenade = Object.Instantiate(rocket, MonoSingleton<WeaponCharges>.Instance.rocketFrozen ? (shootPoint.position + shootPoint.forward * 2.5f) : shootPoint.position, Quaternion.LookRotation(overrideTargetPosition - shootPoint.position));
		grenade.proximityTarget = eid.target;
		grenade.ignoreEnemyType.Add(eid.enemyType);
		grenade.originEnemy = eid;
		if (eid.totalDamageModifier != 1f)
		{
			grenade.totalDamageMultiplier = eid.totalDamageModifier;
		}
		if (difficulty == 1)
		{
			grenade.rocketSpeed *= 0.8f;
		}
		else if (difficulty == 0)
		{
			grenade.rocketSpeed *= 0.6f;
		}
		shootCooldown = Random.Range(1.25f, 1.75f) - ((difficulty >= 4) ? 0.5f : 0f);
	}

	private void Death()
	{
		PunchStop();
		dead = true;
		if (TryGetComponent<Collider>(out var component))
		{
			component.enabled = false;
		}
		if (mach.gc.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.constraints = (RigidbodyConstraints)122;
		}
		mach.parryable = false;
		base.enabled = false;
	}

	private void Punch()
	{
		if (difficulty <= 2)
		{
			punchCooldown = 4.5f - (float)difficulty;
		}
		else if (difficulty == 4)
		{
			punchCooldown = 1.5f;
		}
		anim.Play("Punch", 0, 0f);
		Object.Instantiate(punchPrepSound, base.transform);
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, sc.transform.position + base.transform.forward, base.transform.rotation).transform.localScale *= 5f;
		inAction = true;
		nma.enabled = false;
		trackInAction = true;
		lookAtTarget = true;
		punching = true;
		punchHit = false;
	}

	private void PunchActive()
	{
		sc.DamageStart();
		sc.knockBackDirectionOverride = true;
		sc.knockBackDirection = base.transform.forward;
		moveForward = true;
		trackInAction = false;
	}

	public void TargetBeenHit()
	{
		punchHit = true;
	}

	private void PunchStop()
	{
		sc.DamageStop();
		moveForward = false;
		if (!punchHit || difficulty < 3)
		{
			bool flag = difficulty < 4 && !punchHit;
			if (!flag && (!punchHit || difficulty < 3))
			{
				Vector3Int voxelPosition = StainVoxelManager.WorldToVoxelPosition(base.transform.position + Vector3.down * 1.8333334f);
				flag = MonoSingleton<StainVoxelManager>.Instance.HasProxiesAt(voxelPosition, 3, VoxelCheckingShape.VerticalBox, ProxySearchMode.AnyFloor);
			}
			if (flag)
			{
				anim.Play("PunchStagger");
			}
		}
	}

	private void FallImpact()
	{
		Object.Instantiate(fallImpactSound, new Vector3(eid.weakPoint.transform.position.x, base.transform.position.y, eid.weakPoint.transform.position.z), Quaternion.identity);
		eid.hitter = "";
		eid.DeliverDamage(mach.chest, Vector3.zero, mach.chest.transform.position, 0.1f, tryForExplode: false);
		if (!eid.dead)
		{
			mach.parryable = true;
			Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, sc.transform.position + base.transform.forward * 5f, base.transform.rotation).transform.localScale *= 10f;
		}
		else
		{
			mach.parryable = false;
			MonoSingleton<StyleHUD>.Instance.AddPoints(50, "SLIPPED");
		}
	}

	private void GotParried()
	{
		if (!eid.dead && (bool)anim)
		{
			anim.Play("PunchStagger", -1, 0.7f);
		}
		mach.parryable = false;
	}

	private void StopParryable()
	{
		mach.parryable = false;
	}

	private void StopAction()
	{
		if (!dead)
		{
			inAction = false;
			nma.enabled = true;
			overrideTarget = false;
			punching = false;
			lookAtTarget = false;
		}
	}
}



public class HardDamageForcer : MonoBehaviour
{
	[HideInInspector]
	private bool activated;

	public bool activateOnEnable = true;

	private void Start()
	{
		if (!activated && activateOnEnable)
		{
			On();
		}
	}

	private void OnEnable()
	{
		if (!activated && activateOnEnable)
		{
			On();
		}
	}

	private void Update()
	{
		if (activated)
		{
			MonoSingleton<NewMovement>.Instance.ForceAntiHP(99f, silent: true, dontOverwriteHp: true, addToCooldown: false);
		}
	}

	public void On()
	{
		activated = true;
	}

	public void Off()
	{
		activated = false;
	}
}



public class Harpoon : MonoBehaviour
{
	[SerializeField]
	private Magnet magnet;

	public bool drill;

	private bool drilling;

	private float drillCooldown;

	private bool hit;

	private bool stopped;

	private bool punched;

	public float damage;

	private float damageLeft;

	private AudioSource aud;

	public AudioClip environmentHitSound;

	public AudioClip enemyHitSound;

	private Rigidbody rb;

	private EnemyIdentifierIdentifier target;

	public AudioSource drillSound;

	private AudioSource currentDrillSound;

	public int drillHits;

	private int drillHitsLeft;

	private Vector3 startPosition;

	[SerializeField]
	private GameObject breakEffect;

	private FixedJoint fj;

	private TrailRenderer tr;

	[HideInInspector]
	public GameObject sourceWeapon;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		tr = GetComponent<TrailRenderer>();
		damageLeft = damage;
		if (drill)
		{
			drillHitsLeft = drillHits;
		}
		Invoke("DestroyIfNotHit", 5f);
		Invoke("MasterDestroy", 30f);
		Invoke("SlowUpdate", 2f);
		startPosition = base.transform.position;
	}

	private void SlowUpdate()
	{
		if (Vector3.Distance(startPosition, base.transform.position) > 999f)
		{
			Object.Destroy(base.gameObject);
		}
		else
		{
			Invoke("SlowUpdate", 2f);
		}
	}

	private void Update()
	{
		if (!stopped && !punched && rb.velocity.magnitude > 1f)
		{
			base.transform.LookAt(base.transform.position + rb.velocity);
		}
		else if (drilling)
		{
			base.transform.Rotate(Vector3.forward, 14400f * Time.deltaTime);
		}
	}

	private void FixedUpdate()
	{
		if (stopped && drilling && (bool)target)
		{
			if (drillCooldown != 0f)
			{
				drillCooldown = Mathf.MoveTowards(drillCooldown, 0f, Time.deltaTime);
				return;
			}
			drillCooldown = 0.05f;
			if ((bool)target.eid)
			{
				target.eid.hitter = "drill";
				target.eid.DeliverDamage(target.gameObject, Vector3.zero, base.transform.position, 0.0625f, tryForExplode: false, 0f, sourceWeapon);
			}
			if ((bool)currentDrillSound)
			{
				currentDrillSound.pitch = 1.5f - (float)drillHitsLeft / (float)drillHits / 2f;
			}
			if (drillHitsLeft > 0)
			{
				drillHitsLeft--;
			}
			else if (!PauseTimedBombs.Paused)
			{
				Object.Destroy(base.gameObject);
			}
		}
		else if (drilling && target == null)
		{
			drilling = false;
			DelayedDestroyIfOnCorpse();
		}
	}

	private void OnDestroy()
	{
		if ((bool)target && (bool)target.eid && (bool)magnet && target.eid.stuckMagnets.Contains(magnet))
		{
			target.eid.stuckMagnets.Remove(magnet);
		}
		if (drill)
		{
			Object.Instantiate(breakEffect, base.transform.position, base.transform.rotation);
		}
	}

	private void OnEnable()
	{
		if (stopped && (bool)target && (bool)target.eid && drill)
		{
			target.eid.drillers.Add(this);
		}
	}

	private void OnDisable()
	{
		if (stopped && (bool)target && (bool)target.eid && drill && target.eid.drillers.Contains(this))
		{
			target.eid.drillers.Remove(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		GoreZone componentInParent = other.GetComponentInParent<GoreZone>();
		if (!hit && (other.gameObject.layer == 10 || other.gameObject.layer == 11) && (other.gameObject.CompareTag("Armor") || other.gameObject.CompareTag("Head") || other.gameObject.CompareTag("Body") || other.gameObject.CompareTag("Limb") || other.gameObject.CompareTag("EndLimb")))
		{
			if (!other.TryGetComponent<EnemyIdentifierIdentifier>(out var component) || !component.eid || ((bool)target && (bool)target.eid && component.eid == target.eid) || (drill && component.eid.harpooned) || ((bool)magnet && component.eid.dead && component.eid.enemyType != EnemyType.MaliciousFace && component.eid.enemyType != EnemyType.Gutterman) || ((bool)target && component.eid == target.eid))
			{
				return;
			}
			target = component;
			hit = true;
			EnemyIdentifier eid = target.eid;
			eid.hitter = "harpoon";
			float health = eid.health;
			eid.DeliverDamage(other.gameObject, Vector3.zero, base.transform.position, damageLeft, tryForExplode: false, 0f, sourceWeapon);
			if (drill)
			{
				eid.drillers.Add(this);
			}
			if (health < damageLeft)
			{
				damageLeft -= health;
			}
			if (other.gameObject.layer == 10)
			{
				fj = base.gameObject.AddComponent<FixedJoint>();
				fj.connectedBody = other.gameObject.GetComponentInParent<Rigidbody>();
				if (componentInParent != null)
				{
					base.transform.SetParent(componentInParent.transform, worldPositionStays: true);
				}
			}
			else
			{
				rb.velocity = Vector3.zero;
				rb.useGravity = false;
				rb.constraints = RigidbodyConstraints.FreezeAll;
				base.transform.SetParent(other.transform, worldPositionStays: true);
			}
			if (!magnet && eid.dead && !eid.harpooned && other.gameObject.layer == 10 && (!eid.machine || !eid.machine.specialDeath))
			{
				eid.harpooned = true;
				other.gameObject.transform.position = base.transform.position;
				rb?.AddForce(base.transform.forward, ForceMode.VelocityChange);
				if (drill)
				{
					hit = false;
				}
			}
			else
			{
				stopped = true;
				if (drill)
				{
					drilling = true;
					currentDrillSound = Object.Instantiate(drillSound, base.transform.position, base.transform.rotation);
					currentDrillSound.transform.SetParent(base.transform, worldPositionStays: true);
				}
				rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
				tr.emitting = false;
				TimeBomb component2 = GetComponent<TimeBomb>();
				if (component2 != null)
				{
					component2.StartCountdown();
				}
				if (magnet != null)
				{
					magnet.onEnemy = eid;
					magnet.ignoredEids.Add(eid);
					magnet.ExitEnemy(eid);
					if (eid.enemyType != EnemyType.FleshPrison && eid.enemyType != EnemyType.FleshPanopticon)
					{
						magnet.transform.position = other.bounds.center;
					}
					if (!eid.stuckMagnets.Contains(magnet))
					{
						eid.stuckMagnets.Add(magnet);
					}
					if (!component.eid.dead)
					{
						Breakable[] componentsInChildren = GetComponentsInChildren<Breakable>();
						if (componentsInChildren.Length != 0)
						{
							Breakable[] array = componentsInChildren;
							for (int i = 0; i < array.Length; i++)
							{
								Object.Destroy(array[i].gameObject);
							}
						}
					}
				}
			}
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = enemyHitSound;
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.volume = 0.4f;
			aud.Play();
		}
		else
		{
			if (stopped || (other.gameObject.layer != 8 && other.gameObject.layer != 24))
			{
				return;
			}
			if (drill && !hit)
			{
				Object.Destroy(base.gameObject);
				return;
			}
			stopped = true;
			hit = true;
			rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
			rb.isKinematic = true;
			if (other.gameObject.CompareTag("Door") || other.gameObject.CompareTag("Moving") || ((bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Contains(other.transform)))
			{
				Rigidbody component3 = other.gameObject.GetComponent<Rigidbody>();
				if ((bool)component3)
				{
					base.gameObject.AddComponent<FixedJoint>().connectedBody = component3;
					rb.isKinematic = false;
				}
				else
				{
					GameObject gameObject = new GameObject("ScaleFixer");
					gameObject.transform.position = base.transform.position;
					gameObject.transform.rotation = other.transform.rotation;
					gameObject.transform.SetParent(other.transform, worldPositionStays: true);
					base.transform.SetParent(gameObject.transform, worldPositionStays: true);
				}
				hit = true;
				if ((bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Contains(other.transform) && other.transform.TryGetComponent<ScrollingTexture>(out var component4))
				{
					component4.attachedObjects.Add(base.transform);
					if (TryGetComponent<BoxCollider>(out var component5))
					{
						component4.specialScrollers.Add(new WaterDryTracker(base.transform, component5.ClosestPoint(other.ClosestPoint(base.transform.position + base.transform.forward * component5.size.z * base.transform.lossyScale.z)) - base.transform.position));
					}
				}
			}
			else if ((bool)componentInParent)
			{
				base.transform.SetParent(componentInParent.transform, worldPositionStays: true);
			}
			else
			{
				GoreZone[] array2 = Object.FindObjectsOfType<GoreZone>();
				if (array2 != null && array2.Length != 0)
				{
					GoreZone goreZone = array2[0];
					if (array2.Length > 1)
					{
						for (int j = 1; j < array2.Length; j++)
						{
							if (array2[j].gameObject.activeInHierarchy && Vector3.Distance(goreZone.transform.position, base.transform.position) > Vector3.Distance(array2[j].transform.position, base.transform.position))
							{
								goreZone = array2[j];
							}
						}
					}
					base.transform.SetParent(goreZone.transform, worldPositionStays: true);
				}
			}
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = environmentHitSound;
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.volume = 0.4f;
			aud.Play();
			tr.emitting = false;
			TimeBomb component6 = GetComponent<TimeBomb>();
			if (component6 != null)
			{
				component6.StartCountdown();
			}
		}
	}

	public void Punched()
	{
		hit = false;
		stopped = false;
		drilling = false;
		punched = true;
		damageLeft = damage;
		CancelInvoke("DestroyIfNotHit");
		Invoke("DestroyIfNotHit", 5f);
		CancelInvoke("MasterDestroy");
		Invoke("MasterDestroy", 30f);
		CancelInvoke("DestroyIfOnCorpse");
		rb.isKinematic = false;
		rb.useGravity = false;
		rb.AddForce(base.transform.forward * 150f, ForceMode.VelocityChange);
		aud.Stop();
		rb.constraints = RigidbodyConstraints.None;
		base.transform.SetParent(null, worldPositionStays: true);
		if ((bool)tr)
		{
			tr.emitting = true;
		}
		if ((bool)target && (bool)target.eid)
		{
			target.eid.drillers.Remove(this);
			target.eid.hitter = "drillpunch";
			target.eid.DeliverDamage(target.gameObject, base.transform.forward * 150f, base.transform.position, 4f + (float)drillHitsLeft * 0.0625f, tryForExplode: true);
			if ((bool)fj)
			{
				Object.Destroy(fj);
			}
			if ((bool)currentDrillSound)
			{
				Object.Destroy(currentDrillSound);
			}
		}
		drillHitsLeft = drillHits;
	}

	private void DestroyIfNotHit()
	{
		if (!hit && !PauseTimedBombs.Paused)
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void MasterDestroy()
	{
		if (!PauseTimedBombs.Paused && !NoWeaponCooldown.NoCooldown)
		{
			Object.Destroy(base.gameObject);
		}
	}

	public void DelayedDestroyIfOnCorpse(float delay = 1f)
	{
		Invoke("DestroyIfOnCorpse", delay);
	}

	private void DestroyIfOnCorpse()
	{
		if ((bool)target && (!target.eid || target.eid.dead))
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class HarpoonDestroyer : MonoBehaviour
{
	private void OnTriggerEnter(Collider col)
	{
		if (!(col == null) && !(col.attachedRigidbody == null) && col.attachedRigidbody.TryGetComponent<Harpoon>(out var component))
		{
			Object.Destroy(component.gameObject);
		}
	}
}



public class HealthBar : MonoBehaviour
{
	private NewMovement nmov;

	public Slider[] hpSliders;

	public Slider[] afterImageSliders;

	public Slider antiHpSlider;

	public TMP_Text hpText;

	private float hp;

	private float antiHp;

	public bool changeTextColor;

	public Color normalTextColor;

	public bool yellowColor;

	public bool antiHpText;

	private int difficulty;

	private float lastHP;

	private float lastAntiHP;

	private string lowDifHealth = "/200";

	private ColorBlindSettings colorBlindSettings;

	private void Start()
	{
		nmov = MonoSingleton<NewMovement>.Instance;
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		colorBlindSettings = MonoSingleton<ColorBlindSettings>.Instance;
	}

	private void Update()
	{
		if (hp < (float)nmov.hp)
		{
			hp = Mathf.MoveTowards(hp, nmov.hp, Time.deltaTime * (((float)nmov.hp - hp) * 5f + 5f));
		}
		else if (hp > (float)nmov.hp)
		{
			hp = nmov.hp;
		}
		if (hpSliders.Length != 0)
		{
			Slider[] array = hpSliders;
			foreach (Slider slider in array)
			{
				if (slider.value != hp)
				{
					slider.value = hp;
				}
			}
		}
		if (afterImageSliders != null)
		{
			Slider[] array = afterImageSliders;
			foreach (Slider slider2 in array)
			{
				if (slider2.value < hp)
				{
					slider2.value = hp;
				}
				else if (slider2.value > hp)
				{
					slider2.value = Mathf.MoveTowards(slider2.value, hp, Time.deltaTime * ((slider2.value - hp) * 5f + 5f));
				}
			}
		}
		if (antiHpSlider != null && antiHpSlider.value != nmov.antiHp)
		{
			antiHpSlider.value = Mathf.MoveTowards(antiHpSlider.value, nmov.antiHp, Time.deltaTime * (Mathf.Abs(antiHpSlider.value - nmov.antiHp) * 5f + 5f));
		}
		if (!(hpText != null))
		{
			return;
		}
		if (!antiHpText)
		{
			if (lastHP != hp)
			{
				hpText.text = hp.ToString("F0");
				lastHP = hp;
			}
			if (changeTextColor)
			{
				if (hp <= 30f)
				{
					hpText.color = Color.red;
				}
				else if (hp <= 50f && yellowColor)
				{
					hpText.color = Color.yellow;
				}
				else
				{
					hpText.color = normalTextColor;
				}
			}
			else if (normalTextColor == Color.white)
			{
				if (hp <= 30f)
				{
					hpText.color = Color.red;
				}
				else
				{
					hpText.color = colorBlindSettings.GetHudColor(HudColorType.healthText);
				}
			}
		}
		else if (difficulty == 0)
		{
			hpText.text = lowDifHealth;
		}
		else
		{
			antiHp = Mathf.MoveTowards(antiHp, nmov.antiHp, Time.deltaTime * (Mathf.Abs(antiHp - nmov.antiHp) * 5f + 5f));
			float num = 100f - antiHp;
			if (lastAntiHP != num)
			{
				hpText.text = "/" + num.ToString("F0");
				lastAntiHP = num;
			}
		}
	}
}



[Serializable]
public class HealthLayer
{
	public float health;
}



public class HellMap : MonoBehaviour
{
	private Vector3 targetPos;

	private Image targetImage;

	public GameObject arrow;

	public int firstLevelNumber;

	private bool white = true;

	private AudioSource aud;

	private void Start()
	{
		if (MonoSingleton<StatsManager>.Instance.levelNumber < firstLevelNumber)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		Transform child = base.transform.GetChild(0).GetChild(MonoSingleton<StatsManager>.Instance.levelNumber - firstLevelNumber);
		targetPos = new Vector3(arrow.transform.localPosition.x, child.transform.localPosition.y - 25f, arrow.transform.localPosition.z);
		arrow.transform.localPosition = targetPos + Vector3.up * 50f;
		targetImage = arrow.GetComponentInChildren<Image>();
		aud = GetComponent<AudioSource>();
		Invoke("FlashImage", 0.075f);
	}

	private void Update()
	{
		arrow.transform.localPosition = Vector3.MoveTowards(arrow.transform.localPosition, targetPos, Time.deltaTime * 4f * Vector3.Distance(arrow.transform.localPosition, targetPos));
	}

	private void FlashImage()
	{
		if (white)
		{
			white = false;
			targetImage.color = new Color(0f, 0f, 0f, 0f);
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			aud.Play();
		}
		else
		{
			white = true;
			targetImage.color = Color.white;
		}
		if (base.gameObject.activeSelf)
		{
			Invoke("FlashImage", 0.075f);
		}
	}
}


public enum HitterAttribute
{
	None,
	Fire,
	Electricity,
	Antidivine,
	HeavyKnockback
}


public enum HomingType
{
	None,
	Gradual,
	Loose,
	HorizontalOnly,
	Instant
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class HookArm : MonoSingleton<HookArm>
{
	public bool equipped;

	private LineRenderer lr;

	private Animator anim;

	private Vector3 hookPoint;

	private Vector3 previousHookPoint;

	[HideInInspector]
	public HookState state;

	private bool returning;

	[SerializeField]
	private GameObject model;

	private CapsuleCollider playerCollider;

	public Transform hand;

	public Transform hook;

	public GameObject hookModel;

	private Vector3 throwDirection;

	private float returnDistance;

	private LayerMask throwMask;

	private LayerMask enviroMask;

	private LayerMask enemyMask;

	private float throwWarp;

	private Transform caughtTransform;

	private Vector3 caughtPoint;

	private Collider caughtCollider;

	private EnemyIdentifier caughtEid;

	private List<EnemyType> deadIgnoreTypes = new List<EnemyType>();

	private List<EnemyType> lightEnemies = new List<EnemyType>();

	private GroundCheckEnemy enemyGroundCheck;

	private Rigidbody enemyRigidbody;

	private HookPoint caughtHook;

	private bool lightTarget;

	[SerializeField]
	private LineRenderer inspectLr;

	private bool forcingGroundCheck;

	private bool forcingFistControl;

	private AudioSource aud;

	[Header("Sounds")]
	public GameObject throwSound;

	public GameObject hitSound;

	public GameObject pullSound;

	public GameObject pullDoneSound;

	public GameObject catchSound;

	public GameObject errorSound;

	public AudioClip throwLoop;

	public AudioClip pullLoop;

	public GameObject wooshSound;

	private GameObject currentWoosh;

	public GameObject clinkSparks;

	public GameObject clinkObjectSparks;

	private float cooldown;

	private CameraFrustumTargeter targeter;

	[HideInInspector]
	public bool beingPulled;

	private List<Rigidbody> caughtObjects = new List<Rigidbody>();

	private float semiBlocked;

	private Grenade caughtGrenade;

	private Cannonball caughtCannonball;

	private void Start()
	{
		targeter = MonoSingleton<CameraFrustumTargeter>.Instance;
		lr = GetComponent<LineRenderer>();
		lr.enabled = false;
		anim = GetComponent<Animator>();
		playerCollider = MonoSingleton<NewMovement>.Instance.GetComponent<CapsuleCollider>();
		aud = GetComponent<AudioSource>();
		throwMask = (int)throwMask | 0x400;
		throwMask = (int)throwMask | 0x800;
		throwMask = (int)throwMask | 0x1000;
		throwMask = (int)throwMask | 0x4000;
		throwMask = (int)throwMask | 0x10000;
		throwMask = (int)throwMask | 0x400000;
		throwMask = (int)throwMask | 0x4000000;
		enviroMask = (int)enviroMask | 0x100;
		enviroMask = (int)enviroMask | 0x10000;
		enviroMask = (int)enviroMask | 0x40000;
		enviroMask = (int)enviroMask | 0x1000000;
		enemyMask = (int)enemyMask | 0x800;
		enemyMask = (int)enemyMask | 0x4000000;
		enemyMask = (int)enemyMask | 0x1000;
		deadIgnoreTypes.Add(EnemyType.Drone);
		deadIgnoreTypes.Add(EnemyType.MaliciousFace);
		deadIgnoreTypes.Add(EnemyType.Mindflayer);
		deadIgnoreTypes.Add(EnemyType.Gutterman);
		deadIgnoreTypes.Add(EnemyType.Virtue);
		deadIgnoreTypes.Add(EnemyType.HideousMass);
		lightEnemies.Add(EnemyType.Drone);
		lightEnemies.Add(EnemyType.Filth);
		lightEnemies.Add(EnemyType.Schism);
		lightEnemies.Add(EnemyType.Soldier);
		lightEnemies.Add(EnemyType.Stray);
		lightEnemies.Add(EnemyType.Streetcleaner);
		model.SetActive(value: false);
	}

	public void Inspect()
	{
		model.SetActive(value: true);
		inspectLr.enabled = true;
		anim.Play("Inspect", -1, 0f);
	}

	private void Update()
	{
		if (!MonoSingleton<OptionsManager>.Instance || MonoSingleton<OptionsManager>.Instance.paused)
		{
			return;
		}
		if (!equipped || MonoSingleton<FistControl>.Instance.shopping || !MonoSingleton<FistControl>.Instance.activated)
		{
			if (state != 0 || returning)
			{
				Cancel();
			}
			model.SetActive(value: false);
			return;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Hook.WasPerformedThisFrame)
		{
			if (state == HookState.Pulling)
			{
				StopThrow();
			}
			else if (cooldown <= 0f)
			{
				cooldown = 0.5f;
				model.SetActive(value: true);
				if (!forcingFistControl)
				{
					if ((bool)MonoSingleton<FistControl>.Instance.currentPunch)
					{
						MonoSingleton<FistControl>.Instance.currentPunch.CancelAttack();
					}
					MonoSingleton<FistControl>.Instance.forceNoHold++;
					forcingFistControl = true;
					MonoSingleton<FistControl>.Instance.transform.localRotation = Quaternion.identity;
				}
				lr.enabled = true;
				hookPoint = base.transform.position;
				previousHookPoint = hookPoint;
				if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
				{
					throwDirection = (targeter.CurrentTarget.bounds.center - base.transform.position).normalized;
				}
				else
				{
					throwDirection = base.transform.forward;
				}
				returning = false;
				if (caughtObjects.Count > 0)
				{
					foreach (Rigidbody caughtObject in caughtObjects)
					{
						if ((bool)caughtObject)
						{
							caughtObject.velocity = (MonoSingleton<NewMovement>.Instance.transform.position - caughtObject.transform.position).normalized * (100f + returnDistance / 2f);
						}
					}
					caughtObjects.Clear();
				}
				state = HookState.Throwing;
				lightTarget = false;
				throwWarp = 1f;
				anim.Play("Throw", -1, 0f);
				inspectLr.enabled = false;
				hand.transform.localPosition = new Vector3(0.09f, -0.051f, 0.045f);
				if (MonoSingleton<CameraController>.Instance.defaultFov > 105f)
				{
					hand.transform.localPosition += new Vector3(0.225f * ((MonoSingleton<CameraController>.Instance.defaultFov - 105f) / 55f), -0.25f * ((MonoSingleton<CameraController>.Instance.defaultFov - 105f) / 55f), 0.05f * ((MonoSingleton<CameraController>.Instance.defaultFov - 105f) / 55f));
				}
				caughtPoint = Vector3.zero;
				caughtTransform = null;
				caughtCollider = null;
				caughtEid = null;
				UnityEngine.Object.Instantiate(throwSound);
				aud.clip = throwLoop;
				aud.panStereo = 0f;
				aud.Play();
				aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
				semiBlocked = 0f;
				MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.WhiplashThrow, base.gameObject);
			}
		}
		if (cooldown != 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		}
		if (lr.enabled)
		{
			throwWarp = Mathf.MoveTowards(throwWarp, 0f, Time.deltaTime * 6.5f);
			lr.SetPosition(0, hand.position);
			for (int i = 1; i < lr.positionCount - 1; i++)
			{
				float num = 3f;
				if (i % 2 == 0)
				{
					num = -3f;
				}
				lr.SetPosition(i, Vector3.Lerp(hand.position, hookPoint, (float)i / (float)lr.positionCount) + base.transform.up * num * throwWarp * (1f / (float)i));
			}
			lr.SetPosition(lr.positionCount - 1, hookPoint);
		}
		if (state == HookState.Pulling && !lightTarget && MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame)
		{
			if (MonoSingleton<NewMovement>.Instance.rb.velocity.y < 1f)
			{
				MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(MonoSingleton<NewMovement>.Instance.rb.velocity.x, 1f, MonoSingleton<NewMovement>.Instance.rb.velocity.z);
			}
			MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.ClampMagnitude(MonoSingleton<NewMovement>.Instance.rb.velocity, 30f);
			if (!MonoSingleton<NewMovement>.Instance.gc.touchingGround && !Physics.Raycast(MonoSingleton<NewMovement>.Instance.gc.transform.position, Vector3.down, 1.5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				MonoSingleton<NewMovement>.Instance.rb.AddForce(Vector3.up * 15f, ForceMode.VelocityChange);
			}
			else if (!MonoSingleton<NewMovement>.Instance.jumping)
			{
				MonoSingleton<NewMovement>.Instance.Jump();
			}
			StopThrow(1f);
		}
		if (!MonoSingleton<FistControl>.Instance.currentPunch || !MonoSingleton<FistControl>.Instance.currentPunch.holding || !forcingFistControl)
		{
			return;
		}
		MonoSingleton<FistControl>.Instance.currentPunch.heldItem.transform.position = hook.position + hook.up * 0.2f;
		if (state != 0 || returning)
		{
			MonoSingleton<FistControl>.Instance.heldObject.hooked = true;
			if (MonoSingleton<FistControl>.Instance.heldObject.gameObject.layer != 22)
			{
				Transform[] componentsInChildren = MonoSingleton<FistControl>.Instance.heldObject.GetComponentsInChildren<Transform>();
				for (int j = 0; j < componentsInChildren.Length; j++)
				{
					componentsInChildren[j].gameObject.layer = 22;
				}
			}
			return;
		}
		MonoSingleton<FistControl>.Instance.heldObject.hooked = false;
		if (MonoSingleton<FistControl>.Instance.heldObject.gameObject.layer != 13)
		{
			Transform[] componentsInChildren = MonoSingleton<FistControl>.Instance.heldObject.GetComponentsInChildren<Transform>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].gameObject.layer = 13;
			}
		}
	}

	private void LateUpdate()
	{
		if (state != 0 || returning)
		{
			hook.position = hookPoint;
			hook.up = throwDirection;
			hookModel.layer = 2;
		}
		else
		{
			hookModel.layer = 13;
		}
	}

	private void FixedUpdate()
	{
		if ((bool)caughtGrenade && caughtGrenade.playerRiding)
		{
			if (caughtObjects.Contains(caughtGrenade.rb))
			{
				caughtGrenade.hooked = false;
				caughtObjects.Remove(caughtGrenade.rb);
			}
			else
			{
				caughtObjects.Clear();
			}
			caughtGrenade = null;
		}
		if (state == HookState.Ready && returning)
		{
			Vector3 vector = hookPoint;
			hookPoint = Vector3.MoveTowards(hookPoint, hand.position, Time.fixedDeltaTime * (100f + returnDistance / 2f));
			for (int num = caughtObjects.Count - 1; num >= 0; num--)
			{
				if (caughtObjects[num] != null)
				{
					caughtObjects[num].position = hookPoint;
				}
				else
				{
					caughtObjects.RemoveAt(num);
				}
			}
			if (hookPoint == hand.position)
			{
				lr.enabled = false;
				returning = false;
				anim.Play("Catch", -1, 0f);
				UnityEngine.Object.Instantiate(catchSound);
				aud.Stop();
				if (caughtObjects.Count > 0)
				{
					for (int num2 = caughtObjects.Count - 1; num2 >= 0; num2--)
					{
						if (caughtObjects[num2] != null)
						{
							if (caughtObjects[num2].TryGetComponent<Grenade>(out var component))
							{
								component.transform.position = MonoSingleton<NewMovement>.Instance.transform.position;
								component.hooked = false;
								component.ignoreEnemyType.Clear();
								if (component.rocket && !MonoSingleton<NewMovement>.Instance.ridingRocket && Vector3.Angle(Vector3.down, vector - MonoSingleton<NewMovement>.Instance.transform.position) < 45f)
								{
									component.PlayerRideStart();
								}
								else
								{
									component.Explode(big: false, harmless: false, component.rocket && !MonoSingleton<NewMovement>.Instance.gc.onGround, 1f, ultrabooster: false, null, fup: true);
								}
							}
							else
							{
								caughtObjects[num2].velocity = Vector3.zero;
							}
						}
					}
					caughtObjects.Clear();
				}
				caughtGrenade = null;
				caughtCannonball = null;
			}
		}
		if (state == HookState.Throwing)
		{
			if (!MonoSingleton<InputManager>.Instance.InputSource.Hook.IsPressed && (cooldown <= 0.1f || caughtObjects.Count > 0))
			{
				StopThrow();
			}
			else
			{
				float num3 = 250f * Time.fixedDeltaTime;
				bool flag = false;
				if (Physics.Raycast(hookPoint, throwDirection, out var hitInfo, num3, enviroMask, QueryTriggerInteraction.Ignore))
				{
					flag = true;
					num3 = hitInfo.distance;
				}
				RaycastHit[] array = Physics.SphereCastAll(hookPoint, Mathf.Min(Vector3.Distance(base.transform.position, hookPoint) / 15f, 5f), throwDirection, num3, throwMask, QueryTriggerInteraction.Collide);
				Array.Sort(array, (RaycastHit x, RaycastHit y) => x.distance.CompareTo(y.distance));
				bool flag2 = false;
				for (int i = 0; i < array.Length; i++)
				{
					RaycastHit rhit = array[i];
					bool flag3 = false;
					switch (rhit.transform.gameObject.layer)
					{
					case 26:
						if (!rhit.collider.isTrigger)
						{
							StopThrow();
							UnityEngine.Object.Instantiate(clinkSparks, rhit.point, Quaternion.LookRotation(rhit.normal));
							flag2 = true;
							flag3 = true;
						}
						goto default;
					case 14:
						if (caughtObjects.Count < 5 && MonoSingleton<ObjectTracker>.Instance.HasTransform(rhit.transform) && rhit.collider.attachedRigidbody != null && !caughtObjects.Contains(rhit.collider.attachedRigidbody))
						{
							if (caughtGrenade == null && MonoSingleton<ObjectTracker>.Instance.grenadeList.Count > 0 && (bool)MonoSingleton<ObjectTracker>.Instance.GetGrenade(rhit.transform) && MonoSingleton<ObjectTracker>.Instance.GetGrenade(rhit.transform).rocket && !MonoSingleton<ObjectTracker>.Instance.GetGrenade(rhit.transform).playerRiding)
							{
								caughtObjects.Add(rhit.collider.attachedRigidbody);
								UnityEngine.Object.Instantiate(clinkObjectSparks, rhit.point, Quaternion.LookRotation(rhit.normal));
								caughtGrenade = MonoSingleton<ObjectTracker>.Instance.GetGrenade(rhit.transform);
								caughtGrenade.rideable = true;
								caughtGrenade.hooked = true;
								caughtGrenade.ignoreEnemyType.Clear();
							}
							else if (MonoSingleton<ObjectTracker>.Instance.cannonballList.Count > 0 && (bool)MonoSingleton<ObjectTracker>.Instance.GetCannonball(rhit.transform) && MonoSingleton<ObjectTracker>.Instance.GetCannonball(rhit.transform).physicsCannonball)
							{
								Cannonball cannonball = MonoSingleton<ObjectTracker>.Instance.GetCannonball(rhit.transform);
								caughtObjects.Add(rhit.collider.attachedRigidbody);
								UnityEngine.Object.Instantiate(clinkObjectSparks, rhit.point, Quaternion.LookRotation(rhit.normal));
								caughtCannonball = cannonball;
								cannonball.Unlaunch();
								cannonball.forceMaxSpeed = true;
								cannonball.InstaBreakDefenceCancel();
							}
						}
						goto default;
					case 16:
					{
						if (rhit.collider.isTrigger && rhit.transform.TryGetComponent<BulletCheck>(out var component5))
						{
							component5.ForceDodge();
						}
						flag3 = true;
						goto default;
					}
					case 11:
					case 12:
					{
						if (Physics.Raycast(hookPoint, rhit.collider.bounds.center - hookPoint, Vector3.Distance(hookPoint, rhit.collider.bounds.center), enviroMask, QueryTriggerInteraction.Ignore))
						{
							continue;
						}
						caughtEid = rhit.transform.GetComponentInParent<EnemyIdentifier>();
						if ((bool)caughtEid && (caughtEid.enemyType == EnemyType.MaliciousFace || caughtEid.enemyType == EnemyType.Gutterman || caughtEid.enemyType == EnemyType.HideousMass) && caughtEid.dead && !rhit.collider.Raycast(new Ray(hookPoint, throwDirection), out var _, num3))
						{
							caughtEid = null;
							continue;
						}
						if (caughtEid == null && rhit.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component6))
						{
							caughtEid = component6.eid;
						}
						if ((bool)caughtEid)
						{
							if (caughtEid.hookIgnore)
							{
								caughtEid = null;
								goto default;
							}
							if ((bool)caughtCannonball && caughtCannonball.hitEnemies.Contains(caughtEid))
							{
								caughtEid = null;
								flag2 = true;
								StopThrow();
								return;
							}
							if (caughtEid.blessed)
							{
								caughtEid.hitter = "hook";
								caughtEid.DeliverDamage(caughtEid.gameObject, Vector3.zero, rhit.point, 1f, tryForExplode: false);
								caughtEid = null;
								continue;
							}
							if (caughtEid.enemyType == EnemyType.Idol)
							{
								caughtEid.hitter = "hook";
								caughtEid.DeliverDamage(caughtEid.gameObject, Vector3.zero, rhit.point, 1f, tryForExplode: false);
								UnityEngine.Object.Instantiate(clinkObjectSparks, rhit.point, Quaternion.LookRotation(rhit.normal));
								continue;
							}
							caughtEid.hitter = "hook";
							caughtEid.hooked = true;
							if (((caughtEid.enemyType != EnemyType.Drone && caughtEid.enemyType != EnemyType.Virtue) || !caughtEid.dead) && caughtEid.enemyType != EnemyType.Stalker)
							{
								caughtEid.DeliverDamage(caughtEid.gameObject, Vector3.zero, rhit.point, 0.2f, tryForExplode: false);
							}
							if (caughtEid == null)
							{
								return;
							}
							if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
							{
								GameObject gameObject = rhit.transform.gameObject;
								if (rhit.transform.gameObject.layer == 12)
								{
									EnemyIdentifierIdentifier componentInChildren = gameObject.GetComponentInChildren<EnemyIdentifierIdentifier>();
									if ((bool)componentInChildren)
									{
										gameObject = componentInChildren.gameObject;
									}
								}
								MonoSingleton<FistControl>.Instance.heldObject.SendMessage("HitWith", gameObject, SendMessageOptions.DontRequireReceiver);
							}
							if (caughtEid.dead)
							{
								if (!deadIgnoreTypes.Contains(caughtEid.enemyType))
								{
									goto default;
								}
								if (caughtEid.enemyType == EnemyType.Virtue || lightEnemies.Contains(caughtEid.enemyType))
								{
									lightTarget = true;
								}
								caughtEid = null;
							}
							else if (lightEnemies.Contains(caughtEid.enemyType))
							{
								lightTarget = true;
							}
						}
						flag2 = true;
						flag3 = true;
						caughtTransform = rhit.transform;
						hookPoint = rhit.collider.bounds.center;
						caughtPoint = hookPoint - caughtTransform.position;
						state = HookState.Caught;
						caughtCollider = rhit.collider;
						aud.Stop();
						UnityEngine.Object.Instantiate(hitSound, rhit.point, Quaternion.identity);
						goto default;
					}
					case 10:
					{
						if (rhit.transform.gameObject.CompareTag("Coin") && rhit.transform.TryGetComponent<Coin>(out var component4))
						{
							rhit.transform.position = hookPoint + throwDirection.normalized * rhit.distance;
							component4.Bounce();
						}
						goto default;
					}
					case 22:
					{
						if (rhit.transform.TryGetComponent<HookPoint>(out var component2))
						{
							if (component2.active && Vector3.Distance(base.transform.position, rhit.transform.position) > 5f)
							{
								flag2 = true;
								flag3 = true;
								caughtTransform = rhit.transform;
								hookPoint = rhit.transform.position;
								caughtPoint = Vector3.zero;
								state = HookState.Caught;
								caughtCollider = rhit.collider;
								aud.Stop();
								caughtHook = component2;
								component2.Hooked();
								goto default;
							}
						}
						else if ((bool)MonoSingleton<FistControl>.Instance.currentPunch && !MonoSingleton<FistControl>.Instance.currentPunch.holding)
						{
							if (rhit.transform.TryGetComponent<ItemIdentifier>(out var component3))
							{
								if (Physics.Raycast(hookPoint, rhit.transform.position - hookPoint, Vector3.Distance(hookPoint, rhit.transform.position), enviroMask, QueryTriggerInteraction.Ignore))
								{
									continue;
								}
								if (component3.infiniteSource)
								{
									component3 = component3.CreateCopy();
								}
								flag2 = true;
								if (component3.ipz == null || (component3.ipz.CheckDoorBounds(component3.transform.position, previousHookPoint, reverseBounds: false) && component3.ipz.CheckDoorBounds(component3.transform.position, base.transform.position, reverseBounds: false)))
								{
									MonoSingleton<FistControl>.Instance.currentPunch.ForceHold(component3);
								}
								else
								{
									ItemGrabError(rhit);
								}
								previousHookPoint = hookPoint;
							}
						}
						else
						{
							ItemPlaceZone[] components = rhit.transform.GetComponents<ItemPlaceZone>();
							bool flag4 = false;
							ItemPlaceZone[] array2 = components;
							foreach (ItemPlaceZone itemPlaceZone in array2)
							{
								if (itemPlaceZone.acceptedItemType == MonoSingleton<FistControl>.Instance.heldObject.itemType && !itemPlaceZone.CheckDoorBounds(itemPlaceZone.transform.position, previousHookPoint, reverseBounds: true) && !itemPlaceZone.CheckDoorBounds(itemPlaceZone.transform.position, base.transform.position, reverseBounds: true))
								{
									flag4 = true;
								}
							}
							if (components.Length != 0)
							{
								if (Physics.Raycast(hookPoint, rhit.transform.position - hookPoint, Vector3.Distance(hookPoint, rhit.transform.position), enviroMask, QueryTriggerInteraction.Ignore))
								{
									continue;
								}
								flag2 = true;
								if (!flag4)
								{
									MonoSingleton<FistControl>.Instance.currentPunch.PlaceHeldObject(components, rhit.transform);
								}
								else
								{
									ItemGrabError(rhit);
								}
								previousHookPoint = hookPoint;
							}
						}
						if (flag2)
						{
							flag3 = true;
							StopThrow();
						}
						else if (!Physics.Raycast(hookPoint, rhit.transform.position - hookPoint, Vector3.Distance(hookPoint, rhit.transform.position), enviroMask, QueryTriggerInteraction.Ignore))
						{
							flag3 = true;
						}
						goto default;
					}
					default:
						if (flag3 && (bool)MonoSingleton<FistControl>.Instance.heldObject)
						{
							MonoSingleton<FistControl>.Instance.heldObject.SendMessage("HitWith", rhit.transform.gameObject, SendMessageOptions.DontRequireReceiver);
						}
						if (!flag2)
						{
							continue;
						}
						break;
					}
					break;
				}
				Vector3 point = hookPoint;
				if (flag && !flag2)
				{
					if (hitInfo.transform.TryGetComponent<Breakable>(out var component7) && component7.weak && !component7.precisionOnly)
					{
						component7.Break();
					}
					if (hitInfo.transform.gameObject.TryGetComponent<SandboxProp>(out var component8) && (bool)component8.rigidbody)
					{
						component8.rigidbody.AddForceAtPosition(base.transform.forward * -100f, hitInfo.point, ForceMode.VelocityChange);
					}
					else
					{
						UnityEngine.Object.Instantiate(clinkSparks, hitInfo.point, Quaternion.LookRotation(hitInfo.normal));
					}
					point = hitInfo.point;
					StopThrow();
					flag2 = true;
				}
				if (!flag2 && Vector3.Distance(base.transform.position, hookPoint) > 300f)
				{
					StopThrow();
				}
				else if (!flag2)
				{
					hookPoint += throwDirection * num3;
					point = hookPoint;
				}
				for (int num4 = caughtObjects.Count - 1; num4 >= 0; num4--)
				{
					if (caughtObjects[num4] != null)
					{
						caughtObjects[num4].position = point;
						if (flag2)
						{
							if (caughtObjects[num4].TryGetComponent<Grenade>(out var component9))
							{
								if ((bool)caughtEid && (bool)component9.originEnemy && caughtEid == component9.originEnemy)
								{
									MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.rocketreturn", null, caughtEid);
								}
								component9.hooked = false;
								component9.ignoreEnemyType.Clear();
								component9.Explode();
							}
							else
							{
								caughtObjects.RemoveAt(num4);
							}
						}
					}
					else
					{
						caughtObjects.RemoveAt(num4);
					}
				}
			}
		}
		else if (state == HookState.Caught)
		{
			if (caughtEid != null && (caughtEid.dead || caughtEid.hookIgnore || caughtEid.blessed))
			{
				if (!caughtEid.dead || !deadIgnoreTypes.Contains(caughtEid.enemyType))
				{
					StopThrow();
					return;
				}
				SolveDeadIgnore();
			}
			else if (!caughtTransform || Physics.Raycast(hand.position, caughtTransform.position + caughtPoint - hand.position, Vector3.Distance(hand.position, caughtTransform.position + caughtPoint), enviroMask, QueryTriggerInteraction.Ignore))
			{
				StopThrow();
				return;
			}
			hookPoint = caughtTransform.position + caughtPoint;
			if (!MonoSingleton<InputManager>.Instance.InputSource.Hook.IsPressed)
			{
				anim.Play("Pull", -1, 0f);
				hand.transform.localPosition = new Vector3(-0.015f, 0.071f, 0.04f);
				state = HookState.Pulling;
				MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.WhiplashPull, base.gameObject);
				currentWoosh = UnityEngine.Object.Instantiate(wooshSound);
				UnityEngine.Object.Instantiate(pullSound);
				aud.clip = pullLoop;
				aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
				aud.panStereo = -0.5f;
				aud.Play();
				if ((bool)caughtHook && caughtHook.type == hookPointType.Switch)
				{
					caughtHook.SwitchPulled();
					if (!MonoSingleton<NewMovement>.Instance.gc.touchingGround)
					{
						if (MonoSingleton<UnderwaterController>.Instance.inWater)
						{
							MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.zero;
						}
						else
						{
							MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(0f, 15f, 0f);
						}
					}
					StopThrow();
				}
				else if (!forcingGroundCheck && !lightTarget)
				{
					ForceGroundCheck();
				}
				else if (lightTarget)
				{
					Rigidbody component10;
					if ((bool)caughtEid)
					{
						if (enemyGroundCheck != null)
						{
							enemyGroundCheck.StopForceOff();
						}
						enemyGroundCheck = caughtEid.gce;
						if ((bool)enemyGroundCheck)
						{
							enemyGroundCheck.ForceOff();
						}
						enemyRigidbody = caughtEid.GetComponent<Rigidbody>();
					}
					else if (caughtTransform.TryGetComponent<Rigidbody>(out component10))
					{
						enemyRigidbody = component10;
					}
					else
					{
						StopThrow();
					}
					if (!MonoSingleton<NewMovement>.Instance.gc.touchingGround)
					{
						if (!MonoSingleton<UnderwaterController>.Instance.inWater)
						{
							MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(0f, 15f, 0f);
						}
						else
						{
							MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(0f, 5f, 0f);
						}
					}
				}
			}
		}
		if (state == HookState.Pulling)
		{
			if (!caughtTransform || !caughtCollider)
			{
				StopThrow(1f);
				return;
			}
			Vector3 vector2 = caughtTransform.position + caughtPoint - base.transform.position;
			if (Physics.Raycast(base.transform.position, vector2.normalized, out var hitInfo3, vector2.magnitude, enviroMask, QueryTriggerInteraction.Ignore))
			{
				bool flag5 = true;
				EnemyIdentifier component11 = hitInfo3.transform.GetComponent<EnemyIdentifier>();
				if ((bool)component11 && component11.blessed)
				{
					flag5 = false;
				}
				if (flag5)
				{
					StopThrow(1f);
					return;
				}
			}
			if (caughtEid != null && (caughtEid.dead || caughtEid.hookIgnore || caughtEid.blessed))
			{
				if (!caughtEid.dead || !deadIgnoreTypes.Contains(caughtEid.enemyType))
				{
					StopThrow(1f);
					return;
				}
				SolveDeadIgnore();
			}
			if ((bool)caughtEid && !MonoSingleton<UnderwaterController>.Instance.inWater && (!MonoSingleton<AssistController>.Instance || !MonoSingleton<AssistController>.Instance.majorEnabled || !MonoSingleton<AssistController>.Instance.disableWhiplashHardDamage))
			{
				if (MonoSingleton<NewMovement>.Instance.antiHp + Time.fixedDeltaTime * 66f <= 50f)
				{
					MonoSingleton<NewMovement>.Instance.ForceAddAntiHP(Time.fixedDeltaTime * 66f, silent: true, dontOverwriteHp: true);
				}
				else if (MonoSingleton<NewMovement>.Instance.antiHp <= 50f)
				{
					MonoSingleton<NewMovement>.Instance.ForceAntiHP(50f, silent: true, dontOverwriteHp: true);
				}
			}
			Vector3 vector3 = playerCollider.ClosestPoint(hookPoint);
			Collider collider = caughtCollider;
			if (Physics.Raycast(base.transform.position, caughtCollider.bounds.center - base.transform.position, out var hitInfo4, Vector3.Distance(caughtCollider.bounds.center, base.transform.position), enemyMask))
			{
				collider = hitInfo4.collider;
			}
			if (Vector3.Distance(vector3, collider.ClosestPoint(vector3)) < 0.25f)
			{
				if ((bool)enemyRigidbody)
				{
					if (enemyGroundCheck == null || enemyGroundCheck.touchingGround || ((bool)caughtEid && caughtEid.underwater) || caughtEid.enemyType == EnemyType.Mannequin)
					{
						enemyRigidbody.velocity = Vector3.zero;
					}
					else
					{
						enemyRigidbody.velocity = new Vector3(0f, 15f, 0f);
					}
				}
				bool flag6 = false;
				if ((bool)caughtHook)
				{
					if (caughtHook.type == hookPointType.Slingshot)
					{
						flag6 = true;
						if (caughtHook.slingShotForce != 0f)
						{
							MonoSingleton<NewMovement>.Instance.rb.velocity = caughtHook.slingShotForce * MonoSingleton<NewMovement>.Instance.rb.velocity.normalized;
						}
					}
					caughtHook.Reached(MonoSingleton<NewMovement>.Instance.rb.velocity.normalized);
				}
				StopThrow(1f);
				if (!MonoSingleton<NewMovement>.Instance.gc.touchingGround && !flag6)
				{
					if (MonoSingleton<UnderwaterController>.Instance.inWater)
					{
						MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.zero;
					}
					else if (base.transform.position.y < hookPoint.y)
					{
						MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(0f, 15f + (hookPoint.y - base.transform.position.y) * 3f, 0f);
					}
					else
					{
						MonoSingleton<NewMovement>.Instance.rb.velocity = new Vector3(0f, 15f, 0f);
					}
				}
				return;
			}
			if ((bool)caughtEid && (bool)enemyRigidbody && caughtEid.enemyType == EnemyType.Drone)
			{
				if (enemyRigidbody.isKinematic)
				{
					lightTarget = false;
				}
				else
				{
					lightTarget = true;
				}
			}
			if (lightTarget && forcingGroundCheck)
			{
				StopForceGroundCheck();
			}
			else if (!lightTarget && !forcingGroundCheck)
			{
				ForceGroundCheck();
			}
			if (lightTarget)
			{
				if (!enemyRigidbody)
				{
					StopThrow(1f);
					return;
				}
				hookPoint = caughtTransform.position + caughtPoint;
				if (enemyGroundCheck != null)
				{
					enemyRigidbody.velocity = (MonoSingleton<NewMovement>.Instance.transform.position - hookPoint).normalized * 60f;
					caughtEid.transform.LookAt(new Vector3(MonoSingleton<CameraController>.Instance.transform.position.x, caughtEid.transform.position.y, MonoSingleton<CameraController>.Instance.transform.position.z));
					return;
				}
				enemyRigidbody.velocity = (MonoSingleton<CameraController>.Instance.transform.position - hookPoint).normalized * 60f;
				if ((bool)caughtEid)
				{
					caughtEid.transform.LookAt(MonoSingleton<CameraController>.Instance.transform.position);
				}
				else
				{
					caughtTransform.LookAt(MonoSingleton<CameraController>.Instance.transform.position);
				}
			}
			else
			{
				hookPoint = caughtTransform.position + caughtPoint;
				beingPulled = true;
				if (!MonoSingleton<NewMovement>.Instance.boost || MonoSingleton<NewMovement>.Instance.sliding)
				{
					MonoSingleton<NewMovement>.Instance.rb.velocity = (hookPoint - MonoSingleton<NewMovement>.Instance.transform.position).normalized * 60f;
				}
			}
		}
		else
		{
			beingPulled = false;
		}
	}

	private void SolveDeadIgnore()
	{
		if (!caughtEid)
		{
			return;
		}
		switch (caughtEid.enemyType)
		{
		case EnemyType.Virtue:
			lightTarget = true;
			enemyRigidbody = caughtEid.GetComponent<Rigidbody>();
			break;
		case EnemyType.MaliciousFace:
		{
			EnemyIdentifierIdentifier[] componentsInChildren = caughtEid.GetComponentsInChildren<EnemyIdentifierIdentifier>();
			if (componentsInChildren.Length == 0)
			{
				break;
			}
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].gameObject.layer == 11)
				{
					caughtTransform = componentsInChildren[i].transform;
					break;
				}
			}
			break;
		}
		}
		caughtEid = null;
	}

	private void ItemGrabError(RaycastHit rhit)
	{
		UnityEngine.Object.Instantiate(errorSound);
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
		MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=red>ERROR: BLOCKING DOOR WOULD CLOSE</color>", "", "", 0, silent: true);
	}

	public void StopThrow(float animationTime = 0f, bool sparks = false)
	{
		MonoSingleton<RumbleManager>.Instance.StopVibration(RumbleProperties.WhiplashThrow);
		MonoSingleton<RumbleManager>.Instance.StopVibration(RumbleProperties.WhiplashPull);
		if (animationTime == 0f)
		{
			UnityEngine.Object.Instantiate(pullSound);
			aud.clip = pullLoop;
			aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			aud.panStereo = -0.5f;
			aud.Play();
		}
		else
		{
			UnityEngine.Object.Instantiate(pullDoneSound);
		}
		if (forcingGroundCheck)
		{
			StopForceGroundCheck();
		}
		if (lightTarget)
		{
			if ((bool)enemyGroundCheck)
			{
				enemyGroundCheck.StopForceOff();
			}
			lightTarget = false;
			enemyGroundCheck = null;
			enemyRigidbody = null;
		}
		if ((bool)caughtEid)
		{
			caughtEid.hooked = false;
			caughtEid = null;
		}
		if ((bool)caughtHook)
		{
			caughtHook.Unhooked();
			caughtHook = null;
		}
		if (sparks)
		{
			UnityEngine.Object.Instantiate(clinkSparks, hookPoint, Quaternion.LookRotation(base.transform.position - hookPoint));
		}
		state = HookState.Ready;
		anim.Play("Pull", -1, animationTime);
		hand.transform.localPosition = new Vector3(-0.015f, 0.071f, 0.04f);
		if (MonoSingleton<CameraController>.Instance.defaultFov > 105f)
		{
			hand.transform.localPosition += new Vector3(0.25f * ((MonoSingleton<CameraController>.Instance.defaultFov - 105f) / 55f), 0f, 0.05f * ((MonoSingleton<CameraController>.Instance.defaultFov - 105f) / 60f));
		}
		else if (MonoSingleton<CameraController>.Instance.defaultFov < 105f)
		{
			hand.transform.localPosition -= new Vector3(0.05f * ((105f - MonoSingleton<CameraController>.Instance.defaultFov) / 60f), 0.075f * ((105f - MonoSingleton<CameraController>.Instance.defaultFov) / 60f), 0.125f * ((105f - MonoSingleton<CameraController>.Instance.defaultFov) / 60f));
		}
		returnDistance = Mathf.Max(Vector3.Distance(base.transform.position, hookPoint), 25f);
		returning = true;
		throwWarp = 0f;
		if ((bool)currentWoosh)
		{
			UnityEngine.Object.Destroy(currentWoosh);
		}
	}

	public void Cancel()
	{
		if (forcingGroundCheck)
		{
			StopForceGroundCheck();
		}
		if (forcingFistControl)
		{
			MonoSingleton<FistControl>.Instance.forceNoHold--;
			forcingFistControl = false;
			if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
			{
				MonoSingleton<FistControl>.Instance.heldObject.gameObject.layer = 13;
				MonoSingleton<FistControl>.Instance.heldObject.hooked = false;
			}
		}
		if (caughtObjects.Count > 0)
		{
			foreach (Rigidbody caughtObject in caughtObjects)
			{
				if ((bool)caughtObject)
				{
					caughtObject.velocity = (MonoSingleton<NewMovement>.Instance.transform.position - caughtObject.transform.position).normalized * (100f + returnDistance / 2f);
					Grenade component2;
					if (caughtObject.TryGetComponent<Cannonball>(out var component))
					{
						component.hitEnemies.Clear();
						component.forceMaxSpeed = false;
					}
					else if (caughtObject.TryGetComponent<Grenade>(out component2))
					{
						component2.hooked = false;
					}
				}
			}
			caughtObjects.Clear();
		}
		caughtGrenade = null;
		caughtCannonball = null;
		if (lightTarget)
		{
			if ((bool)enemyGroundCheck)
			{
				enemyGroundCheck.StopForceOff();
			}
			lightTarget = false;
			enemyGroundCheck = null;
			enemyRigidbody = null;
		}
		if ((bool)caughtEid)
		{
			caughtEid.hooked = false;
			caughtEid = null;
		}
		if ((bool)caughtHook)
		{
			caughtHook.Unhooked();
			caughtHook = null;
		}
		state = HookState.Ready;
		anim.Play("Idle", -1, 0f);
		returning = false;
		throwWarp = 0f;
		lr.enabled = false;
		hookPoint = hand.position;
		aud.Stop();
		if ((bool)MonoSingleton<FistControl>.Instance.currentPunch && MonoSingleton<FistControl>.Instance.currentPunch.holding)
		{
			MonoSingleton<FistControl>.Instance.ResetHeldItemPosition();
		}
		if ((bool)currentWoosh)
		{
			UnityEngine.Object.Destroy(currentWoosh);
		}
		model.SetActive(value: false);
	}

	public void CatchOver()
	{
		if (state != 0 || returning)
		{
			return;
		}
		if (forcingFistControl)
		{
			MonoSingleton<FistControl>.Instance.forceNoHold--;
			forcingFistControl = false;
			if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
			{
				MonoSingleton<FistControl>.Instance.heldObject.hooked = false;
			}
		}
		if ((bool)MonoSingleton<FistControl>.Instance.currentPunch && MonoSingleton<FistControl>.Instance.currentPunch.holding)
		{
			MonoSingleton<FistControl>.Instance.ResetHeldItemPosition();
		}
		model.SetActive(value: false);
	}

	private void ForceGroundCheck()
	{
		if (MonoSingleton<NewMovement>.Instance.sliding)
		{
			MonoSingleton<NewMovement>.Instance.StopSlide();
		}
		if ((bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
		{
			MonoSingleton<NewMovement>.Instance.ridingRocket.PlayerRideEnd();
		}
		forcingGroundCheck = true;
		MonoSingleton<NewMovement>.Instance.gc.ForceOff();
		MonoSingleton<NewMovement>.Instance.slopeCheck.ForceOff();
	}

	private void StopForceGroundCheck()
	{
		forcingGroundCheck = false;
		MonoSingleton<NewMovement>.Instance.gc.StopForceOff();
		MonoSingleton<NewMovement>.Instance.slopeCheck.StopForceOff();
	}

	private void SemiBlockCheck()
	{
		if (Physics.Raycast(hand.position, caughtTransform.position + caughtPoint - hand.position, out var hitInfo, Vector3.Distance(hand.position, caughtTransform.position + caughtPoint), 2048, QueryTriggerInteraction.Ignore) && hitInfo.collider.transform != caughtCollider.transform)
		{
			semiBlocked = Mathf.MoveTowards(semiBlocked, 1f, Time.fixedDeltaTime);
			if (semiBlocked >= 1f)
			{
				StopThrow();
			}
		}
		else
		{
			semiBlocked = 0f;
		}
	}
}



public class HookPoint : MonoBehaviour, IAlter, IAlterOptions<float>
{
	public bool active = true;

	public hookPointType type;

	public float slingShotForce;

	[HideInInspector]
	public bool valuesSet;

	public MeshRenderer[] renderers;

	[HideInInspector]
	public Material[] origMats;

	[HideInInspector]
	public Spin[] spins;

	[HideInInspector]
	public Light lit;

	public Transform outerOrb;

	public Transform innerOrb;

	public Material disabledMaterial;

	public ParticleSystem activeParticle;

	private bool hooked;

	private AudioSource aud;

	public GameObject grabParticle;

	public GameObject reachParticle;

	public float reactivationTime = 6f;

	[HideInInspector]
	public float timer;

	private float tickTimer;

	public AudioSource reactivationTick;

	[Header("Events")]
	public UltrakillEvent onHook;

	public UltrakillEvent onUnhook;

	public UltrakillEvent onReach;

	public string alterKey => "hook-point";

	public string alterCategoryName => "Hook Point";

	public AlterOption<float>[] options
	{
		get
		{
			if (type != hookPointType.Slingshot)
			{
				return null;
			}
			return new AlterOption<float>[1]
			{
				new AlterOption<float>
				{
					key = "force",
					name = "Force",
					value = slingShotForce,
					callback = delegate(float value)
					{
						slingShotForce = value;
					},
					constraints = new SliderConstraints
					{
						step = 5f,
						min = -50f,
						max = 200f
					}
				}
			};
		}
	}

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if (!valuesSet)
		{
			SetValues();
		}
		if (!active)
		{
			TurnOff();
		}
		else if (activeParticle != null)
		{
			activeParticle.Play();
		}
	}

	private void Update()
	{
		if (timer > 0f)
		{
			timer = Mathf.MoveTowards(timer, 0f, Time.deltaTime);
			tickTimer = Mathf.MoveTowards(tickTimer, 0f, Time.deltaTime);
			if (tickTimer == 0f)
			{
				Object.Instantiate(reactivationTick, base.transform.position, Quaternion.identity);
				if (timer > 3f)
				{
					tickTimer = 1f;
				}
				else if (timer > 1f)
				{
					tickTimer = 0.5f;
				}
				else
				{
					tickTimer = 0.25f;
				}
			}
			if (timer <= 0f)
			{
				TimerStop();
			}
		}
		Vector3 vector;
		Vector3 vector2;
		if (active && Vector3.Distance(MonoSingleton<HookArm>.Instance.transform.position, base.transform.position) < 5f && !hooked)
		{
			vector = Vector3.one * 2.5f;
			vector2 = Vector3.zero;
		}
		else if (active && hooked)
		{
			vector = Vector3.zero;
			vector2 = Vector3.one * 3.5f;
		}
		else
		{
			vector = Vector3.one * 5f;
			vector2 = Vector3.one * 3.5f;
		}
		if (outerOrb.localScale != vector)
		{
			outerOrb.localScale = Vector3.MoveTowards(outerOrb.localScale, vector, Time.deltaTime * 50f);
		}
		if (innerOrb.localScale != vector2)
		{
			innerOrb.localScale = Vector3.MoveTowards(innerOrb.localScale, vector2, Time.deltaTime * 50f);
		}
		if (hooked)
		{
			aud.pitch = 0.75f;
		}
		else
		{
			aud.pitch = Mathf.Max(0.5f, outerOrb.localScale.x / 5f) / 2f;
		}
	}

	public void Hooked()
	{
		if (!valuesSet)
		{
			SetValues();
		}
		hooked = true;
		Spin[] array = spins;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].speed = 450f;
		}
		lit.range = 20f;
		Object.Instantiate(grabParticle, base.transform.position, Quaternion.identity);
		onHook.Invoke();
	}

	public void Unhooked()
	{
		hooked = false;
		Spin[] array = spins;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].speed = 100f;
		}
		lit.range = 10f;
		onUnhook.Invoke();
	}

	public void Reached()
	{
		Reached(Vector3.zero);
	}

	public void Reached(Vector3 direction)
	{
		onReach?.Invoke();
		if ((bool)reachParticle)
		{
			if (direction == Vector3.zero)
			{
				direction = base.transform.position - MonoSingleton<CameraController>.Instance.transform.position;
			}
			Object.Instantiate(reachParticle, base.transform.position, Quaternion.LookRotation(direction));
		}
	}

	public void SwitchPulled()
	{
		onReach.Invoke();
		Deactivate();
		timer = reactivationTime;
		tickTimer = 0f;
	}

	public void Activate()
	{
		if (!valuesSet)
		{
			SetValues();
		}
		if (!active)
		{
			TurnOn();
		}
	}

	public void Deactivate()
	{
		if (!valuesSet)
		{
			SetValues();
		}
		if (active)
		{
			TurnOff();
		}
	}

	private void TurnOn()
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			renderers[i].material = origMats[i];
		}
		activeParticle.Play();
		lit.enabled = true;
		aud.Play();
		Spin[] array = spins;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].enabled = true;
		}
		active = true;
	}

	private void TurnOff()
	{
		MeshRenderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].material = disabledMaterial;
		}
		activeParticle.Stop();
		activeParticle.Clear();
		lit.enabled = false;
		aud.Stop();
		Spin[] array2 = spins;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].enabled = false;
		}
		active = false;
	}

	private void SetValues()
	{
		origMats = new Material[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			origMats[i] = new Material(renderers[i].material);
		}
		spins = GetComponentsInChildren<Spin>();
		lit = GetComponent<Light>();
		valuesSet = true;
	}

	public void TimerStop()
	{
		timer = 0f;
		Object.Instantiate(reactivationTick, base.transform.position, Quaternion.identity).pitch = 3f;
		onReach.Revert();
		Activate();
	}
}


public enum hookPointType
{
	Normal,
	Slingshot,
	Switch
}


public enum HookState
{
	Ready,
	Throwing,
	Caught,
	Pulling
}


public enum HudColorType
{
	health,
	healthAfterImage,
	antiHp,
	overheal,
	healthText,
	stamina,
	staminaCharging,
	staminaEmpty,
	railcannonFull,
	railcannonCharging
}



public class HudController : MonoBehaviour
{
	public static HudController Instance;

	public bool altHud;

	public bool colorless;

	private GameObject altHudObj;

	private HUDPos hudpos;

	public GameObject gunCanvas;

	public GameObject weaponIcon;

	public GameObject armIcon;

	public GameObject styleMeter;

	public GameObject styleInfo;

	public Speedometer speedometer;

	[Space]
	public Image[] hudBackgrounds;

	public TMP_Text[] textElements;

	[Space]
	public Material normalTextMaterial;

	public Material overlayTextMaterial;

	private void Awake()
	{
		if (!altHud && !Instance)
		{
			Instance = this;
		}
		if (altHud && altHudObj == null)
		{
			altHudObj = base.transform.GetChild(0).gameObject;
		}
		if (!altHud && hudpos == null)
		{
			hudpos = gunCanvas.GetComponent<HUDPos>();
		}
	}

	private void OnEnable()
	{
		if (!(MonoSingleton<HUDOptions>.Instance == null))
		{
			HUDOptions instance = MonoSingleton<HUDOptions>.Instance;
			instance.alwaysOnTopChanged = (Action<bool>)Delegate.Combine(instance.alwaysOnTopChanged, new Action<bool>(SetAlwaysOnTop));
		}
	}

	private void OnDisable()
	{
		if (!(MonoSingleton<HUDOptions>.Instance == null))
		{
			HUDOptions instance = MonoSingleton<HUDOptions>.Instance;
			instance.alwaysOnTopChanged = (Action<bool>)Delegate.Remove(instance.alwaysOnTopChanged, new Action<bool>(SetAlwaysOnTop));
		}
	}

	private void Start()
	{
		if (MapInfoBase.InstanceAnyType.hideStockHUD)
		{
			weaponIcon.SetActive(value: false);
			armIcon.SetActive(value: false);
			return;
		}
		CheckSituation();
		if (!MonoSingleton<PrefsManager>.Instance.GetBool("weaponIcons"))
		{
			if (!altHud)
			{
				speedometer.rect.anchoredPosition = new Vector2(-79f, 190f);
				weaponIcon.transform.localPosition = new Vector3(weaponIcon.transform.localPosition.x, weaponIcon.transform.localPosition.y, 45f);
			}
			else
			{
				weaponIcon.SetActive(value: false);
			}
		}
		if (!MonoSingleton<PrefsManager>.Instance.GetBool("armIcons"))
		{
			if (!altHud)
			{
				armIcon.transform.localPosition = new Vector3(armIcon.transform.localPosition.x, armIcon.transform.localPosition.y, 0f);
			}
			else
			{
				armIcon.SetActive(value: false);
			}
		}
		if (!altHud)
		{
			if (!MonoSingleton<PrefsManager>.Instance.GetBool("styleMeter"))
			{
				styleMeter.transform.localPosition = new Vector3(styleMeter.transform.localPosition.x, styleMeter.transform.localPosition.y, -9999f);
			}
			if (!MonoSingleton<PrefsManager>.Instance.GetBool("styleInfo"))
			{
				styleInfo.transform.localPosition = new Vector3(styleInfo.transform.localPosition.x, styleInfo.transform.localPosition.y, -9999f);
				MonoSingleton<StyleHUD>.Instance.GetComponent<AudioSource>().enabled = false;
			}
		}
		float @float = MonoSingleton<PrefsManager>.Instance.GetFloat("hudBackgroundOpacity");
		if (@float != 50f)
		{
			SetOpacity(@float);
		}
	}

	public void CheckSituation()
	{
		if (HideUI.Active)
		{
			if ((bool)gunCanvas)
			{
				gunCanvas.GetComponent<Canvas>().enabled = false;
			}
			if ((bool)altHudObj)
			{
				altHudObj.SetActive(value: false);
			}
			return;
		}
		if (altHud)
		{
			if ((bool)altHudObj)
			{
				if (MonoSingleton<PrefsManager>.Instance.GetInt("hudType") == 2 && !colorless)
				{
					altHudObj.SetActive(value: true);
				}
				else if (MonoSingleton<PrefsManager>.Instance.GetInt("hudType") == 3 && colorless)
				{
					altHudObj.SetActive(value: true);
				}
				else
				{
					altHudObj.SetActive(value: false);
				}
			}
			MonoSingleton<PrefsManager>.Instance.GetBool("speedometer");
			return;
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("hudType") != 1)
		{
			if (gunCanvas == null)
			{
				gunCanvas = base.transform.Find("GunCanvas").gameObject;
			}
			if (hudpos == null)
			{
				hudpos = gunCanvas.GetComponent<HUDPos>();
			}
			gunCanvas.transform.localPosition = new Vector3(gunCanvas.transform.localPosition.x, gunCanvas.transform.localPosition.y, -100f);
			gunCanvas.GetComponent<Canvas>().enabled = false;
			if ((bool)hudpos)
			{
				hudpos.active = false;
			}
			return;
		}
		if (gunCanvas == null)
		{
			gunCanvas = base.transform.Find("GunCanvas").gameObject;
		}
		if (hudpos == null)
		{
			hudpos = gunCanvas.GetComponent<HUDPos>();
		}
		gunCanvas.GetComponent<Canvas>().enabled = true;
		gunCanvas.transform.localPosition = new Vector3(gunCanvas.transform.localPosition.x, gunCanvas.transform.localPosition.y, 1f);
		if ((bool)hudpos)
		{
			hudpos.active = true;
			hudpos.CheckPos();
		}
	}

	public void SetOpacity(float amount)
	{
		Image[] array = hudBackgrounds;
		foreach (Image image in array)
		{
			if ((bool)image)
			{
				Color color = image.color;
				color.a = amount / 100f;
				image.color = color;
			}
		}
	}

	public void SetAlwaysOnTop(bool onTop)
	{
		if (textElements != null)
		{
			TMP_Text[] array = textElements;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].fontSharedMaterial = (onTop ? overlayTextMaterial : normalTextMaterial);
			}
		}
	}
}



public class HudMessage : MonoBehaviour
{
	private HudMessageReceiver messageHud;

	public InputActionReference actionReference;

	public bool timed;

	public bool deactivating;

	public bool notOneTime;

	public bool dontActivateOnTriggerEnter;

	public bool silent;

	public bool deactiveOnTriggerExit;

	public bool deactiveOnDisable;

	private bool activated;

	public string message;

	public string message2;

	private Image img;

	private TMP_Text text;

	public string playerPref;

	private bool colliderless;

	public float timerTime = 5f;

	private string PlayerPref
	{
		get
		{
			string text = playerPref;
			if (!(text == "SecMisTut"))
			{
				if (text == "ShoUseTut")
				{
					return "hideShotgunPopup";
				}
				return playerPref;
			}
			return "secretMissionPopup";
		}
	}

	private void Start()
	{
		if (GetComponent<Collider>() == null)
		{
			colliderless = true;
			if (PlayerPref == "" || playerPref == null)
			{
				PlayMessage();
			}
			else if (!MonoSingleton<PrefsManager>.Instance.GetBool(PlayerPref))
			{
				MonoSingleton<PrefsManager>.Instance.SetBool(PlayerPref, content: true);
				PlayMessage();
			}
		}
	}

	private void OnEnable()
	{
		if (colliderless && (!activated || notOneTime))
		{
			if (PlayerPref == "")
			{
				PlayMessage();
			}
			else if (!MonoSingleton<PrefsManager>.Instance.GetBool(PlayerPref))
			{
				MonoSingleton<PrefsManager>.Instance.SetBool(PlayerPref, content: true);
				PlayMessage();
			}
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded && deactiveOnDisable && activated)
		{
			Done();
		}
	}

	private void Update()
	{
		if (activated && timed)
		{
			img.enabled = true;
			text.enabled = true;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!dontActivateOnTriggerEnter && other.gameObject.CompareTag("Player") && (!activated || notOneTime))
		{
			if (PlayerPref == "")
			{
				PlayMessage();
			}
			else if (!MonoSingleton<PrefsManager>.Instance.GetBool(PlayerPref))
			{
				MonoSingleton<PrefsManager>.Instance.SetBool(PlayerPref, content: true);
				PlayMessage();
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!dontActivateOnTriggerEnter && other.gameObject.CompareTag("Player") && activated && deactiveOnTriggerExit)
		{
			Done();
		}
	}

	private void Done()
	{
		img.enabled = false;
		text.enabled = false;
		activated = false;
		Begone();
	}

	private void Begone()
	{
		if (!notOneTime)
		{
			Object.Destroy(this);
		}
	}

	public void PlayMessage(bool hasToBeEnabled = false)
	{
		if ((!activated || notOneTime) && (!hasToBeEnabled || (base.gameObject.activeInHierarchy && base.enabled)))
		{
			activated = true;
			messageHud = MonoSingleton<HudMessageReceiver>.Instance;
			this.text = messageHud.text;
			if (actionReference == null)
			{
				this.text.text = message;
			}
			else
			{
				string text = "";
				text = MonoSingleton<InputManager>.Instance.GetBindingString(actionReference.action.id);
				this.text.text = message + text + message2;
			}
			this.text.text = this.text.text.Replace('$', '\n');
			this.text.enabled = true;
			if (!img)
			{
				img = messageHud.GetComponent<Image>();
			}
			img.enabled = true;
			if (deactivating)
			{
				Done();
			}
			else if (!silent)
			{
				messageHud.GetComponent<AudioSource>().Play();
			}
			if (timed && notOneTime)
			{
				CancelInvoke("Done");
				Invoke("Done", timerTime);
			}
			else if (timed)
			{
				Invoke("Done", timerTime);
			}
			else if (!deactiveOnTriggerExit && !deactiveOnDisable)
			{
				Invoke("Begone", 1f);
			}
			messageHud.GetComponent<HudOpenEffect>().Force();
		}
	}

	public void ChangeMessage(string newMessage)
	{
		message = newMessage;
		actionReference = null;
		message2 = "";
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class HudMessageReceiver : MonoSingleton<HudMessageReceiver>
{
	private Image img;

	[HideInInspector]
	public TMP_Text text;

	private AudioSource aud;

	private HudOpenEffect hoe;

	private string message;

	private string input;

	private string message2;

	private bool noSound;

	private void Start()
	{
		img = GetComponent<Image>();
		text = GetComponentInChildren<TMP_Text>();
		aud = GetComponent<AudioSource>();
		hoe = GetComponent<HudOpenEffect>();
	}

	private void Done()
	{
		img.enabled = false;
		text.enabled = false;
	}

	public void SendHudMessage(string newmessage, string newinput = "", string newmessage2 = "", int delay = 0, bool silent = false)
	{
		message = newmessage;
		input = newinput;
		message2 = newmessage2;
		noSound = silent;
		Invoke("ShowHudMessage", delay);
	}

	private void ShowHudMessage()
	{
		if (input == "")
		{
			this.text.text = message;
		}
		else
		{
			string text = "";
			KeyCode keyCode = MonoSingleton<InputManager>.Instance.Inputs[input];
			text = keyCode switch
			{
				KeyCode.Mouse0 => "Left Mouse Button", 
				KeyCode.Mouse1 => "Right Mouse Button", 
				KeyCode.Mouse2 => "Middle Mouse Button", 
				_ => keyCode.ToString(), 
			};
			this.text.text = message + text + message2;
		}
		this.text.text = this.text.text.Replace('$', '\n');
		this.text.enabled = true;
		img.enabled = true;
		hoe.Force();
		if (!noSound)
		{
			aud.Play();
		}
		CancelInvoke("Done");
		Invoke("Done", 5f);
	}

	public void ClearMessage()
	{
		CancelInvoke("Done");
		Done();
	}
}



public class HudOpenEffect : MonoBehaviour
{
	private RectTransform tran;

	private Vector2 originalDimensions;

	private bool gotValues;

	private bool animating;

	public bool skip;

	private void Awake()
	{
		if (tran == null)
		{
			tran = GetComponent<RectTransform>();
		}
		if (!gotValues)
		{
			originalDimensions = new Vector2(tran.localScale.x, tran.localScale.y);
			gotValues = true;
		}
	}

	private void OnEnable()
	{
		Reset();
	}

	private void Update()
	{
		if (!animating)
		{
			return;
		}
		float num = tran.localScale.x;
		float num2 = tran.localScale.y;
		if (!skip)
		{
			if (num != originalDimensions.x)
			{
				num = Mathf.MoveTowards(num, originalDimensions.x, Time.unscaledDeltaTime * ((originalDimensions.x - num + 0.1f) * 30f));
			}
			else if (num2 != originalDimensions.y)
			{
				num2 = Mathf.MoveTowards(num2, originalDimensions.y, Time.unscaledDeltaTime * ((originalDimensions.y - num2 + 0.1f) * 30f));
			}
		}
		else
		{
			num = originalDimensions.x;
			num2 = originalDimensions.y;
		}
		tran.localScale = new Vector3(num, num2, tran.localScale.z);
		if (num == originalDimensions.x && num2 == originalDimensions.y)
		{
			animating = false;
		}
	}

	public Vector2 GetOriginalDimensions()
	{
		Awake();
		return originalDimensions;
	}

	public void Force()
	{
		Awake();
	}

	public void Reset()
	{
		Reset(null);
	}

	public void Reset(Vector2? inheritedOriginalDimensions)
	{
		if (inheritedOriginalDimensions.HasValue)
		{
			originalDimensions = inheritedOriginalDimensions.Value;
			gotValues = true;
		}
		Awake();
		if (!skip)
		{
			tran.localScale = new Vector3(0.05f, 0.05f, tran.localScale.z);
			animating = true;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class HUDOptions : MonoSingleton<HUDOptions>
{
	public Action<bool> alwaysOnTopChanged;

	public TMP_Dropdown hudType;

	private HudController[] hudCons;

	public Slider bgOpacity;

	public Toggle alwaysOnTop;

	public Material hudMaterial;

	public Material hudTextMaterial;

	private Mask[] masks;

	public Toggle weaponIcon;

	public Toggle armIcon;

	public Toggle railcannonMeter;

	public Toggle styleMeter;

	public Toggle styleInfo;

	public TMP_Dropdown speedometer;

	[SerializeField]
	private TMP_Dropdown iconPackDropdown;

	public TMP_Dropdown crossHairType;

	public TMP_Dropdown crossHairColor;

	public TMP_Dropdown crossHairHud;

	public Toggle crossHairHudFade;

	[SerializeField]
	private Toggle powerUpMeter;

	[HideInInspector]
	public static bool powerUpMeterEnabled = true;

	public Crosshair crosshair { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		crosshair = GetComponentInChildren<Crosshair>(includeInactive: true);
	}

	private void Start()
	{
		crossHairType.value = MonoSingleton<PrefsManager>.Instance.GetInt("crossHair");
		crossHairType.RefreshShownValue();
		crossHairColor.value = MonoSingleton<PrefsManager>.Instance.GetInt("crossHairColor");
		crossHairColor.RefreshShownValue();
		crossHairHud.value = MonoSingleton<PrefsManager>.Instance.GetInt("crossHairHud");
		crossHairHud.RefreshShownValue();
		hudType.value = MonoSingleton<PrefsManager>.Instance.GetInt("hudType");
		hudType.RefreshShownValue();
		bgOpacity.value = MonoSingleton<PrefsManager>.Instance.GetFloat("hudBackgroundOpacity");
		hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		for (int i = 0; i < hudCons.Length; i++)
		{
			if (!hudCons[i].altHud)
			{
				masks = hudCons[i].GetComponentsInChildren<Mask>(includeInactive: true);
				break;
			}
		}
		if (MonoSingleton<PrefsManager>.Instance.GetBool("hudAlwaysOnTop"))
		{
			alwaysOnTop.isOn = true;
			AlwaysOnTop(stuff: true);
		}
		else
		{
			AlwaysOnTop(stuff: false);
		}
		weaponIcon.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("weaponIcons");
		armIcon.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("armIcons");
		railcannonMeter.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("railcannonMeter");
		styleMeter.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("styleMeter");
		styleInfo.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("styleInfo");
		crossHairHudFade.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("crossHairHudFade");
		powerUpMeter.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("powerUpMeter");
		speedometer.value = MonoSingleton<PrefsManager>.Instance.GetInt("speedometer");
		speedometer.RefreshShownValue();
		iconPackDropdown.options = (from p in MonoSingleton<IconManager>.Instance.AvailableIconPacks()
			select new TMP_Dropdown.OptionData(p)).ToList();
		iconPackDropdown.SetValueWithoutNotify(MonoSingleton<IconManager>.Instance.CurrentIconPackId);
	}

	public void SetIconPack(int packId)
	{
		MonoSingleton<IconManager>.Instance.SetIconPack(packId);
		MonoSingleton<IconManager>.Instance.Reload();
	}

	public void CrossHairType(int stuff)
	{
		if (crosshair == null)
		{
			crosshair = GetComponentInChildren<Crosshair>();
		}
		MonoSingleton<PrefsManager>.Instance.SetInt("crossHair", stuff);
		if (crosshair != null)
		{
			crosshair.CheckCrossHair();
		}
	}

	public void CrossHairColor(int stuff)
	{
		if (crosshair == null)
		{
			crosshair = GetComponentInChildren<Crosshair>();
		}
		MonoSingleton<PrefsManager>.Instance.SetInt("crossHairColor", stuff);
		if (crosshair != null)
		{
			crosshair.CheckCrossHair();
		}
	}

	public void CrossHairHud(int stuff)
	{
		if (crosshair == null)
		{
			crosshair = GetComponentInChildren<Crosshair>();
		}
		MonoSingleton<PrefsManager>.Instance.SetInt("crossHairHud", stuff);
		if (crosshair != null)
		{
			crosshair.CheckCrossHair();
		}
	}

	public void HudType(int stuff)
	{
		if (hudCons == null || hudCons.Length < 4)
		{
			hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		}
		MonoSingleton<PrefsManager>.Instance.SetInt("hudType", stuff);
		HudController[] array = hudCons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckSituation();
		}
		GetComponent<OptionsMenuToManager>().CheckEasterEgg();
	}

	public void HudFade(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("crossHairHudFade", stuff);
		FadeOutBars[] array = UnityEngine.Object.FindObjectsOfType<FadeOutBars>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckState();
		}
	}

	public void PowerUpMeterEnable(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("powerUpMeter", stuff);
		powerUpMeterEnabled = stuff;
		if ((bool)MonoSingleton<PowerUpMeter>.Instance)
		{
			MonoSingleton<PowerUpMeter>.Instance.UpdateMeter();
		}
	}

	public void BgOpacity(float stuff)
	{
		if (hudCons == null || hudCons.Length < 4)
		{
			hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		}
		MonoSingleton<PrefsManager>.Instance.SetFloat("hudBackgroundOpacity", stuff);
		HudController[] array = hudCons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetOpacity(stuff);
		}
	}

	public void AlwaysOnTop(bool stuff)
	{
		alwaysOnTopChanged?.Invoke(stuff);
		MonoSingleton<PrefsManager>.Instance.SetBool("hudAlwaysOnTop", stuff);
		if (stuff)
		{
			hudMaterial.SetFloat("_ZTest", 8f);
			hudTextMaterial.SetFloat("_ZTest", 8f);
		}
		else
		{
			hudMaterial.SetFloat("_ZTest", 4f);
			hudTextMaterial.SetFloat("_ZTest", 4f);
		}
		Mask[] array = masks;
		foreach (Mask mask in array)
		{
			if (mask.enabled)
			{
				mask.enabled = false;
				mask.enabled = true;
			}
		}
	}

	public void WeaponIcon(bool stuff)
	{
		if (hudCons == null || hudCons.Length < 4)
		{
			hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		}
		MonoSingleton<PrefsManager>.Instance.SetBool("weaponIcons", stuff);
		if (stuff)
		{
			HudController[] array = hudCons;
			foreach (HudController hudController in array)
			{
				if (!hudController.altHud)
				{
					hudController.weaponIcon.SetActive(value: true);
					hudController.weaponIcon.transform.localPosition = new Vector3(hudController.weaponIcon.transform.localPosition.x, hudController.weaponIcon.transform.localPosition.y, 45f);
					hudController.speedometer.rect.anchoredPosition = new Vector2(-79f, 590f);
				}
				else
				{
					hudController.weaponIcon.SetActive(value: true);
				}
			}
		}
		else
		{
			HudController[] array = hudCons;
			foreach (HudController hudController2 in array)
			{
				if (!hudController2.altHud)
				{
					hudController2.weaponIcon.transform.localPosition = new Vector3(hudController2.weaponIcon.transform.localPosition.x, hudController2.weaponIcon.transform.localPosition.y, -9999f);
					hudController2.speedometer.rect.anchoredPosition = new Vector2(-79f, 190f);
				}
				else
				{
					hudController2.weaponIcon.SetActive(value: false);
				}
			}
		}
		MonoSingleton<RailcannonMeter>.Instance?.CheckStatus();
	}

	public void ArmIcon(bool stuff)
	{
		if (hudCons == null || hudCons.Length < 4)
		{
			hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		}
		MonoSingleton<PrefsManager>.Instance.SetBool("armIcons", stuff);
		HudController[] array;
		if (stuff)
		{
			array = hudCons;
			foreach (HudController hudController in array)
			{
				if (!hudController.altHud)
				{
					hudController.armIcon.transform.localPosition = new Vector3(hudController.armIcon.transform.localPosition.x, hudController.armIcon.transform.localPosition.y, 0f);
				}
				else
				{
					hudController.armIcon.SetActive(value: true);
				}
			}
			return;
		}
		array = hudCons;
		foreach (HudController hudController2 in array)
		{
			if (!hudController2.altHud)
			{
				hudController2.armIcon.transform.localPosition = new Vector3(hudController2.armIcon.transform.localPosition.x, hudController2.armIcon.transform.localPosition.y, -9999f);
			}
			else
			{
				hudController2.armIcon.SetActive(value: false);
			}
		}
	}

	public void RailcannonMeterOption(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("railcannonMeter", stuff);
		MonoSingleton<RailcannonMeter>.Instance?.CheckStatus();
	}

	public void StyleMeter(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("styleMeter", stuff);
		SetStyleVisibleTemp(stuff);
	}

	public void StyleInfo(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("styleInfo", stuff);
		SetStyleVisibleTemp(null, stuff);
	}

	public void SetStyleVisibleTemp(bool? meterVisible = null, bool? infoVisible = null)
	{
		if (HideUI.Active)
		{
			meterVisible = false;
			infoVisible = false;
		}
		else
		{
			if (!meterVisible.HasValue)
			{
				meterVisible = MonoSingleton<PrefsManager>.Instance.GetBool("styleMeter");
			}
			if (!infoVisible.HasValue)
			{
				infoVisible = MonoSingleton<PrefsManager>.Instance.GetBool("styleInfo");
			}
		}
		if (hudCons == null || hudCons.Length < 4)
		{
			hudCons = UnityEngine.Object.FindObjectsOfType<HudController>();
		}
		HudController[] array = hudCons;
		foreach (HudController hudController in array)
		{
			if (!hudController.altHud)
			{
				hudController.styleMeter.transform.localPosition = new Vector3(hudController.styleMeter.transform.localPosition.x, hudController.styleMeter.transform.localPosition.y, (!meterVisible.Value) ? (-9999) : 0);
				hudController.styleInfo.transform.localPosition = new Vector3(hudController.styleInfo.transform.localPosition.x, hudController.styleInfo.transform.localPosition.y, (!infoVisible.Value) ? (-9999) : 0);
				MonoSingleton<StyleHUD>.Instance.GetComponent<AudioSource>().enabled = infoVisible.Value;
			}
		}
	}
}



public class HUDPos : MonoBehaviour
{
	private bool ready;

	public bool active;

	private Vector3 defaultPos;

	private Vector3 defaultRot;

	public Vector3 reversePos;

	public Vector3 reverseRot;

	[Header("Rect Transform")]
	public bool rectTransform;

	private RectTransform rect;

	private Vector2 anchorsMaxDefault;

	public Vector2 anchorsMax;

	private Vector2 anchorsMinDefault;

	public Vector2 anchorsMin;

	private Vector2 pivotDefault;

	public Vector2 pivot;

	private Vector2 anchoredPositionDefault;

	public Vector2 anchoredPosition;

	private void Start()
	{
		CheckPos();
	}

	private void OnEnable()
	{
		CheckPos();
	}

	public void CheckPos()
	{
		if (!active)
		{
			return;
		}
		if (!ready)
		{
			ready = true;
			if (rectTransform)
			{
				rect = GetComponent<RectTransform>();
				anchoredPositionDefault = rect.anchoredPosition;
				anchorsMaxDefault = rect.anchorMax;
				anchorsMinDefault = rect.anchorMin;
				pivotDefault = rect.pivot;
			}
			else
			{
				defaultPos = base.transform.localPosition;
				defaultRot = base.transform.localRotation.eulerAngles;
			}
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weaponHoldPosition") == 2)
		{
			if (rectTransform)
			{
				rect.anchorMax = anchorsMax;
				rect.anchorMin = anchorsMin;
				rect.pivot = pivot;
				rect.anchoredPosition = anchoredPosition;
			}
			else
			{
				base.transform.localPosition = reversePos;
				base.transform.localRotation = Quaternion.Euler(reverseRot);
			}
		}
		else if (rectTransform)
		{
			rect.anchorMax = anchorsMaxDefault;
			rect.anchorMin = anchorsMinDefault;
			rect.pivot = pivotDefault;
			rect.anchoredPosition = anchoredPositionDefault;
		}
		else
		{
			base.transform.localPosition = defaultPos;
			base.transform.localRotation = Quaternion.Euler(defaultRot);
		}
	}
}



public class HurtCooldownCollection
{
	private static readonly Logger Log = new Logger("HurtCooldownCollection");

	private const float HurtDelay = 0.5f;

	private readonly Dictionary<EnemyIdentifier, TimeSince> timeSinceHurtEnemies = new Dictionary<EnemyIdentifier, TimeSince>();

	private readonly Dictionary<Flammable, TimeSince> timeSinceHurtFlammables = new Dictionary<Flammable, TimeSince>();

	private TimeSince? timeSinceHurtPlayer;

	public bool TryHurtCheckEnemy(EnemyIdentifier eid, bool autoUpdate = true)
	{
		if (timeSinceHurtEnemies.TryGetValue(eid, out var value))
		{
			if ((float)value < 0.5f)
			{
				return false;
			}
			if (autoUpdate)
			{
				timeSinceHurtEnemies[eid] = 0f;
			}
		}
		else if (autoUpdate)
		{
			timeSinceHurtEnemies.Add(eid, 0f);
		}
		return true;
	}

	public void ResetEnemyCooldown(EnemyIdentifier eid)
	{
		timeSinceHurtEnemies.Remove(eid);
	}

	public bool TryHurtCheckPlayer(bool autoUpdate = true)
	{
		if (timeSinceHurtPlayer.HasValue)
		{
			if ((float?)timeSinceHurtPlayer < 0.5f)
			{
				return false;
			}
			if (autoUpdate)
			{
				timeSinceHurtPlayer = 0f;
			}
		}
		else if (autoUpdate)
		{
			timeSinceHurtPlayer = 0f;
		}
		return true;
	}

	public void ResetPlayerCooldown()
	{
		timeSinceHurtPlayer = null;
	}

	public bool TryHurtCheckFlammable(Flammable flammable, bool autoUpdate = true)
	{
		if (timeSinceHurtFlammables.TryGetValue(flammable, out var value))
		{
			if ((float)value < 0.5f)
			{
				return false;
			}
			if (autoUpdate)
			{
				timeSinceHurtFlammables[flammable] = 0f;
			}
		}
		else if (autoUpdate)
		{
			timeSinceHurtFlammables.Add(flammable, 0f);
		}
		return true;
	}

	public void ResetFlammableCooldown(Flammable flammable)
	{
		timeSinceHurtFlammables.Remove(flammable);
	}
}



public class HurtZone : MonoBehaviour, IAlter, IAlterOptions<float>
{
	public EnviroDamageType damageType;

	public bool trigger;

	public AffectedSubjects affected;

	public float bounceForce;

	private Collider col;

	public float hurtCooldown = 1f;

	[FormerlySerializedAs("damage")]
	public float setDamage;

	public float hardDamagePercentage = 0.35f;

	public float enemyDamageOverride;

	private int hurtingPlayer;

	private float playerHurtCooldown;

	private List<HurtZoneEnemyTracker> enemies = new List<HurtZoneEnemyTracker>();

	public GameObject hurtParticle;

	private int difficulty;

	private float damageMultiplier = 1f;

	private NewMovement newMovement;

	private PlayerTracker playerTracker;

	private PlatformerMovement platformerMovement;

	public List<EnemyType> ignoredEnemyTypes = new List<EnemyType>();

	public GameObject sourceWeapon;

	private float damage => setDamage * damageMultiplier;

	public string alterKey => "hurt_zone";

	public string alterCategoryName => "Hurt Zone";

	public AlterOption<float>[] options => new AlterOption<float>[2]
	{
		new AlterOption<float>
		{
			key = "damage",
			name = "Damage",
			value = setDamage,
			callback = delegate(float f)
			{
				setDamage = f;
			},
			constraints = new SliderConstraints
			{
				min = 0f,
				max = 200f
			}
		},
		new AlterOption<float>
		{
			key = "hurt_cooldown",
			name = "Hurt Cooldown",
			value = hurtCooldown,
			callback = delegate(float f)
			{
				hurtCooldown = f;
			},
			constraints = new SliderConstraints
			{
				min = 0f,
				max = 10f,
				step = 0.1f
			}
		}
	};

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		if (difficulty < 2 && damage < 100f)
		{
			if (difficulty == 1)
			{
				damageMultiplier = 0.5f;
			}
			else if (difficulty == 0)
			{
				damageMultiplier = 0.25f;
			}
		}
		col = GetComponent<Collider>();
		newMovement = MonoSingleton<NewMovement>.Instance;
		playerTracker = MonoSingleton<PlayerTracker>.Instance;
		platformerMovement = MonoSingleton<PlatformerMovement>.Instance;
	}

	private void OnDisable()
	{
		hurtingPlayer = 0;
		enemies.Clear();
	}

	private void FixedUpdate()
	{
		if (!base.enabled)
		{
			return;
		}
		if (hurtingPlayer > 0 && playerHurtCooldown <= 0f && damage > 0f)
		{
			if (playerTracker.playerType == PlayerType.FPS)
			{
				if (newMovement == null)
				{
					newMovement = MonoSingleton<NewMovement>.Instance;
				}
				if (!newMovement.dead && newMovement.gameObject.activeInHierarchy)
				{
					if (hardDamagePercentage > 0f)
					{
						newMovement.GetHurt((int)damage, invincible: true, 1f, explosion: false, instablack: false, hardDamagePercentage);
					}
					else
					{
						newMovement.GetHurt((int)damage, invincible: false);
					}
					if ((bool)hurtParticle)
					{
						Object.Instantiate(hurtParticle, newMovement.transform.position, Quaternion.identity);
					}
					if (bounceForce != 0f && (bool)col)
					{
						newMovement.Launch((newMovement.transform.position - col.ClosestPoint(newMovement.transform.position)).normalized * bounceForce);
					}
				}
				else
				{
					hurtingPlayer = 0;
				}
			}
			else
			{
				if (platformerMovement == null)
				{
					platformerMovement = MonoSingleton<PlatformerMovement>.Instance;
				}
				if (!platformerMovement.dead && platformerMovement.gameObject.activeInHierarchy)
				{
					if (damageType == EnviroDamageType.WeakBurn || damageType == EnviroDamageType.Burn || damageType == EnviroDamageType.Acid)
					{
						platformerMovement.Burn();
					}
					else
					{
						platformerMovement.Explode();
						if ((bool)hurtParticle)
						{
							Object.Instantiate(hurtParticle, platformerMovement.transform.position, Quaternion.identity);
						}
					}
				}
				else
				{
					hurtingPlayer = 0;
				}
			}
			playerHurtCooldown = hurtCooldown;
		}
		else if (playerHurtCooldown > 0f)
		{
			playerHurtCooldown -= Time.deltaTime;
		}
		if (enemies.Count <= 0)
		{
			return;
		}
		for (int num = enemies.Count - 1; num >= 0; num--)
		{
			if (enemies[num] == null || enemies[num].target == null || !enemies[num].HasLimbs(col))
			{
				enemies.RemoveAt(num);
				continue;
			}
			EnemyIdentifier target = enemies[num].target;
			float timer = enemies[num].timer;
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				if (!DamageEnemy(target, num))
				{
					continue;
				}
				timer = ((!target.dead || damageType != EnviroDamageType.Acid) ? hurtCooldown : 0.1f);
			}
			enemies[num].timer = timer;
		}
	}

	private bool DamageEnemy(EnemyIdentifier eid, int i)
	{
		if (eid.enemyType == EnemyType.V2 && eid.TryGetComponent<V2>(out var component) && component.inIntro)
		{
			return false;
		}
		if (damageType == EnviroDamageType.Burn || damageType == EnviroDamageType.WeakBurn)
		{
			eid.hitter = "fire";
		}
		else if (damageType == EnviroDamageType.Acid)
		{
			eid.hitter = "acid";
		}
		else if (damageType == EnviroDamageType.Chainsaw)
		{
			eid.hitter = "chainsawzone";
		}
		else
		{
			eid.hitter = "environment";
		}
		GameObject gameObject = eid.gameObject;
		gameObject = ((damageType != EnviroDamageType.Chainsaw || !Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward, out var hitInfo, 15f, LayerMaskDefaults.Get(LMD.Enemies)) || !hitInfo.transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component2) || !component2.eid || !(component2.eid == eid)) ? enemies[i].limbs[enemies[i].limbs.Count - 1].gameObject : hitInfo.transform.gameObject);
		if (eid.dead && damageType != EnviroDamageType.Chainsaw)
		{
			if (eid.enemyClass == EnemyClass.Demon || (eid.enemyClass == EnemyClass.Machine && (bool)eid.machine && !eid.machine.dismemberment))
			{
				enemies.RemoveAt(i);
				return false;
			}
			if (gameObject == eid.gameObject || gameObject.layer == 12 || gameObject.layer == 20 || gameObject.CompareTag("Body"))
			{
				enemies[i].limbs.RemoveAt(enemies[i].limbs.Count - 1);
			}
		}
		Vector3 vector = eid.transform.position;
		if (damageType == EnviroDamageType.Chainsaw)
		{
			vector = (eid.dead ? gameObject.transform.position : ((eid.TryGetComponent<Collider>(out var component3) && component3.Raycast(new Ray(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward), out hitInfo, 15f)) ? hitInfo.point : ((!component3) ? new Vector3(eid.transform.position.x, MonoSingleton<CameraController>.Instance.GetDefaultPos().y, eid.transform.position.z) : component3.ClosestPoint(MonoSingleton<CameraController>.Instance.GetDefaultPos()))));
			MonoSingleton<CameraController>.Instance.CameraShake(0.2f);
		}
		if ((bool)hurtParticle && !eid.dead)
		{
			Object.Instantiate(hurtParticle, vector, Quaternion.identity);
		}
		eid.DeliverDamage(gameObject, Vector3.zero, vector, (enemyDamageOverride == 0f) ? (damage / 2f) : enemyDamageOverride, tryForExplode: false, 0f, sourceWeapon);
		if ((damageType == EnviroDamageType.Burn || damageType == EnviroDamageType.WeakBurn) && !eid.dead)
		{
			Flammable componentInChildren = eid.GetComponentInChildren<Flammable>();
			if (componentInChildren != null)
			{
				componentInChildren.Burn(4f);
			}
		}
		return true;
	}

	private HurtZoneEnemyTracker EnemiesContains(EnemyIdentifier eid)
	{
		if (enemies.Count == 0)
		{
			return null;
		}
		for (int num = enemies.Count - 1; num >= 0; num--)
		{
			if (enemies[num] == null || enemies[num].target == null)
			{
				enemies.RemoveAt(num);
			}
			else if (enemies[num].target == eid)
			{
				return enemies[num];
			}
		}
		return null;
	}

	private void Enter(Collider other)
	{
		if (affected != AffectedSubjects.EnemiesOnly && other.gameObject.CompareTag("Player"))
		{
			hurtingPlayer++;
		}
		else
		{
			if (affected == AffectedSubjects.PlayerOnly || (other.gameObject.layer != 10 && other.gameObject.layer != 11 && other.gameObject.layer != 12 && other.gameObject.layer != 20))
			{
				return;
			}
			EnemyIdentifierIdentifier enemyIdentifierIdentifier = ((other.gameObject.layer == 12) ? other.gameObject.GetComponentInChildren<EnemyIdentifierIdentifier>() : ((other.gameObject.layer != 20 || !other.transform.parent) ? other.gameObject.GetComponent<EnemyIdentifierIdentifier>() : other.transform.parent.GetComponentInChildren<EnemyIdentifierIdentifier>()));
			if (!(enemyIdentifierIdentifier != null) || !(enemyIdentifierIdentifier.eid != null) || (ignoredEnemyTypes.Count != 0 && ignoredEnemyTypes.Contains(enemyIdentifierIdentifier.eid.enemyType)) || (enemyIdentifierIdentifier.eid.dead && ((damageType != EnviroDamageType.Chainsaw && enemyIdentifierIdentifier.eid.enemyClass == EnemyClass.Demon) || other.gameObject.layer == 12 || other.gameObject.layer == 20)) || !(enemyIdentifierIdentifier.transform.localScale != Vector3.zero) || (damageType == EnviroDamageType.WeakBurn && (enemyIdentifierIdentifier.eid.enemyType == EnemyType.Streetcleaner || enemyIdentifierIdentifier.eid.enemyType == EnemyType.Sisyphus || enemyIdentifierIdentifier.eid.enemyType == EnemyType.Stalker)))
			{
				return;
			}
			HurtZoneEnemyTracker hurtZoneEnemyTracker = EnemiesContains(enemyIdentifierIdentifier.eid);
			if (hurtZoneEnemyTracker == null)
			{
				enemies.Add(new HurtZoneEnemyTracker(enemyIdentifierIdentifier.eid, other, hurtCooldown));
				if (base.enabled)
				{
					DamageEnemy(enemyIdentifierIdentifier.eid, enemies.Count - 1);
				}
			}
			else
			{
				hurtZoneEnemyTracker.limbs.Add(other);
			}
		}
	}

	private void Exit(Collider other)
	{
		if (affected != AffectedSubjects.EnemiesOnly && other.gameObject.CompareTag("Player") && hurtingPlayer > 0)
		{
			hurtingPlayer--;
		}
		else
		{
			if (affected == AffectedSubjects.PlayerOnly || (other.gameObject.layer != 10 && other.gameObject.layer != 11 && other.gameObject.layer != 12 && other.gameObject.layer != 20))
			{
				return;
			}
			EnemyIdentifierIdentifier enemyIdentifierIdentifier = ((other.gameObject.layer == 12) ? other.gameObject.GetComponentInChildren<EnemyIdentifierIdentifier>() : ((other.gameObject.layer != 20 || !other.transform.parent) ? other.gameObject.GetComponent<EnemyIdentifierIdentifier>() : other.transform.parent.GetComponentInChildren<EnemyIdentifierIdentifier>()));
			if (!(enemyIdentifierIdentifier != null) || !(enemyIdentifierIdentifier.eid != null))
			{
				return;
			}
			HurtZoneEnemyTracker hurtZoneEnemyTracker = EnemiesContains(enemyIdentifierIdentifier.eid);
			if (hurtZoneEnemyTracker != null && hurtZoneEnemyTracker.limbs.Contains(other))
			{
				hurtZoneEnemyTracker.limbs.Remove(other);
				if (!hurtZoneEnemyTracker.HasLimbs(col))
				{
					enemies.Remove(hurtZoneEnemyTracker);
				}
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (trigger || other.gameObject.layer == 20)
		{
			Enter(other);
		}
	}

	private void OnCollisionEnter(Collision other)
	{
		if (!trigger)
		{
			Enter(other.collider);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (trigger || other.gameObject.layer == 20)
		{
			Exit(other);
		}
	}

	private void OnCollisionExit(Collision other)
	{
		if (!trigger)
		{
			Exit(other.collider);
		}
	}
}



public class HurtZoneEnemyTracker
{
	public EnemyIdentifier target;

	public List<Collider> limbs = new List<Collider>();

	public float timer;

	public HurtZoneEnemyTracker(EnemyIdentifier eid, Collider limb, float hurtCooldown)
	{
		target = eid;
		limbs.Add(limb);
		timer = hurtCooldown;
	}

	public bool HasLimbs(Collider colliderToCheck)
	{
		if (limbs.Count == 0)
		{
			return false;
		}
		int num = limbs.Count - 1;
		while (num >= 0)
		{
			if (limbs[num] == null || !limbs[num].enabled || limbs[num].transform.localScale == Vector3.zero || !limbs[num].gameObject.activeInHierarchy || ((bool)colliderToCheck && !Physics.ComputePenetration(colliderToCheck, colliderToCheck.transform.position, colliderToCheck.transform.rotation, limbs[num], limbs[num].transform.position, limbs[num].transform.rotation, out var _, out var _)))
			{
				limbs.RemoveAt(num);
				num--;
				continue;
			}
			return true;
		}
		return false;
	}
}



public interface IBloodstainReceiver
{
	bool HandleBloodstainHit(ref RaycastHit hit);
}


public interface ICheat
{
	string LongName { get; }

	string Identifier { get; }

	string ButtonEnabledOverride { get; }

	string ButtonDisabledOverride { get; }

	string Icon { get; }

	bool IsActive { get; }

	bool DefaultState { get; }

	StatePersistenceMode PersistenceMode { get; }

	void Enable();

	void Disable();

	void Update();
}


public interface ICheatGUI
{
	void OnGUI();
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class IconManager : MonoSingleton<IconManager>
{
	[SerializeField]
	private CheatAssetObject[] iconPacks;

	private int currentIconPack;

	private bool prefFetched;

	public int CurrentIconPackId
	{
		get
		{
			if (!prefFetched)
			{
				return FetchSavedPref();
			}
			return currentIconPack;
		}
	}

	public CheatAssetObject CurrentIcons => iconPacks[CurrentIconPackId];

	private int FetchSavedPref()
	{
		prefFetched = true;
		currentIconPack = MonoSingleton<PrefsManager>.Instance.GetInt("iconPack");
		return currentIconPack;
	}

	public string[] AvailableIconPacks()
	{
		if (iconPacks == null)
		{
			return Array.Empty<string>();
		}
		return (from ip in iconPacks
			where ip != null
			select ip.name).ToArray();
	}

	public void SetIconPack(int pack)
	{
		Debug.Log("Selecting icon pack " + pack);
		currentIconPack = pack;
		MonoSingleton<PrefsManager>.Instance.SetInt("iconPack", pack);
	}

	public void Reload()
	{
		MonoSingleton<CheatsManager>.Instance.RebuildIcons();
		MonoSingleton<CheatsManager>.Instance.RebuildMenu();
		if ((bool)MonoSingleton<SpawnMenu>.Instance)
		{
			MonoSingleton<SpawnMenu>.Instance.RebuildIcons();
			MonoSingleton<SpawnMenu>.Instance.RebuildMenu();
		}
		if ((bool)MonoSingleton<SandboxArm>.Instance)
		{
			MonoSingleton<SandboxArm>.Instance.ReloadIcon();
		}
	}
}



public class IconPackSprite : MonoBehaviour
{
	[SerializeField]
	private Sprite[] sprites;

	public void Start()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("iconPack");
		GetComponent<Image>().sprite = ((sprites.Length > @int) ? sprites[@int] : sprites[0]);
	}
}



public interface IDirectoryTree
{
}

public interface IDirectoryTree<T> : IDirectoryTree
{
	string name { get; }

	IDirectoryTree<T> parent { get; set; }

	IEnumerable<IDirectoryTree<T>> children { get; }

	IEnumerable<T> files { get; }

	IEnumerable<T> GetFilesRecursive();

	void Refresh();
}



public class Idol : MonoBehaviour
{
	public EnemyIdentifier overrideTarget;

	public bool activeWhileWaitingForOverride;

	[HideInInspector]
	public EnemyIdentifier target;

	private int difficulty;

	[SerializeField]
	private LineRenderer beam;

	private Vector3 beamOffset;

	[SerializeField]
	private GameObject deathParticle;

	private bool dead;

	private EnemyIdentifier eid;

	[HideInInspector]
	public bool damageBuffing;

	[HideInInspector]
	public bool speedBuffing;

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		if ((bool)overrideTarget && overrideTarget.gameObject.activeInHierarchy)
		{
			ChangeTarget(overrideTarget);
		}
		eid = GetComponent<EnemyIdentifier>();
		SlowUpdate();
	}

	private void UpdateBuff()
	{
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (damageBuffing != eid.damageBuff)
		{
			if ((bool)target)
			{
				if (damageBuffing)
				{
					target.DamageUnbuff();
				}
				else
				{
					target.DamageBuff();
				}
			}
			damageBuffing = eid.damageBuff;
		}
		if (speedBuffing == eid.speedBuff)
		{
			return;
		}
		if ((bool)target)
		{
			if (speedBuffing)
			{
				target.SpeedUnbuff();
			}
			else
			{
				target.SpeedBuff();
			}
		}
		speedBuffing = eid.speedBuff;
	}

	private void OnDisable()
	{
		CancelInvoke("SlowUpdate");
		if ((bool)target)
		{
			ChangeTarget(null);
		}
	}

	private void OnEnable()
	{
		CancelInvoke("SlowUpdate");
		SlowUpdate();
	}

	private void Update()
	{
		if ((bool)overrideTarget && target != overrideTarget && !overrideTarget.dead && overrideTarget.gameObject.activeInHierarchy)
		{
			ChangeTarget(overrideTarget);
		}
		if (beam.enabled != (bool)target)
		{
			beam.enabled = target;
		}
		if ((bool)target)
		{
			beam.SetPosition(0, beam.transform.position);
			beam.SetPosition(1, target.transform.position + beamOffset);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.2f);
		if (BlindEnemies.Blind)
		{
			if ((bool)target && (!overrideTarget || target != overrideTarget || overrideTarget.dead))
			{
				ChangeTarget(null);
			}
			return;
		}
		if ((bool)overrideTarget)
		{
			if ((bool)overrideTarget && !overrideTarget.dead && (overrideTarget.gameObject.activeInHierarchy || !activeWhileWaitingForOverride))
			{
				if (target != overrideTarget && overrideTarget.gameObject.activeInHierarchy)
				{
					ChangeTarget(overrideTarget);
				}
				return;
			}
			overrideTarget = null;
			ChangeTarget(null);
		}
		PickNewTarget(ignoreIfAlreadyTargeting: false);
	}

	public void PickNewTarget(bool ignoreIfAlreadyTargeting = true)
	{
		if (ignoreIfAlreadyTargeting && (target != null || (overrideTarget != null && !overrideTarget.Equals(null))))
		{
			return;
		}
		List<EnemyIdentifier> currentEnemies = MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies();
		if (currentEnemies == null || currentEnemies.Count <= 0)
		{
			return;
		}
		bool flag = false;
		float num = float.PositiveInfinity;
		EnemyIdentifier newTarget = null;
		int num2 = 1;
		if ((bool)target && !target.dead)
		{
			num2 = Mathf.Max(MonoSingleton<EnemyTracker>.Instance.GetEnemyRank(target), 2);
		}
		for (int num3 = 6; num3 > num2; num3--)
		{
			for (int i = 0; i < currentEnemies.Count; i++)
			{
				if (((!currentEnemies[i].blessed && currentEnemies[i].enemyType != EnemyType.Idol) || currentEnemies[i] == target) && (MonoSingleton<EnemyTracker>.Instance.GetEnemyRank(currentEnemies[i]) == num3 || (MonoSingleton<EnemyTracker>.Instance.GetEnemyRank(currentEnemies[i]) <= 2 && num3 == 2)))
				{
					float num4 = Vector3.Distance(MonoSingleton<PlayerTracker>.Instance.GetPlayer().position, currentEnemies[i].transform.position);
					if (num4 < num)
					{
						newTarget = currentEnemies[i];
						flag = true;
						num = num4;
					}
				}
			}
			if (flag)
			{
				ChangeTarget(newTarget);
				break;
			}
		}
	}

	public void Death()
	{
		if (dead)
		{
			return;
		}
		dead = true;
		GoreZone goreZone = GoreZone.ResolveGoreZone(base.transform);
		if (TryGetComponent<EnemyIdentifier>(out var component))
		{
			component.Death();
		}
		if ((bool)deathParticle)
		{
			Object.Instantiate(deathParticle, beam.transform.position, Quaternion.identity, goreZone.gibZone);
		}
		GameObject gameObject = null;
		for (int i = 0; i < 3; i++)
		{
			gameObject = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, component);
			if (!gameObject)
			{
				break;
			}
			gameObject.transform.position = beam.transform.position;
			gameObject.transform.SetParent(goreZone.goreZone, worldPositionStays: true);
			gameObject.SetActive(value: true);
			if (gameObject.TryGetComponent<Bloodsplatter>(out var component2))
			{
				component2.GetReady();
			}
		}
		if (!component.dontCountAsKills)
		{
			ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
			if (componentInParent != null)
			{
				componentInParent.AddDeadEnemy();
			}
		}
		MonoSingleton<StyleHUD>.Instance.AddPoints(80, "ultrakill.iconoclasm", null, component);
		base.gameObject.SetActive(value: false);
		Object.Destroy(base.gameObject);
	}

	private void ChangeTarget(EnemyIdentifier newTarget)
	{
		if ((bool)target)
		{
			target.Unbless();
			if (speedBuffing)
			{
				target.SpeedUnbuff();
			}
			if (damageBuffing)
			{
				target.DamageUnbuff();
			}
		}
		if (!newTarget)
		{
			target = null;
			return;
		}
		target = newTarget;
		target.Bless();
		if (speedBuffing)
		{
			target.SpeedBuff();
		}
		if (damageBuffing)
		{
			target.DamageBuff();
		}
		if (target.TryGetComponent<Collider>(out var component))
		{
			beamOffset = component.bounds.center - target.transform.position;
		}
	}

	public void ChangeOverrideTarget(EnemyIdentifier eid)
	{
		overrideTarget = eid;
		ChangeTarget(eid);
	}
}



public class IdolMauricer : MonoBehaviour
{
}


public interface IEnemyHealthDetails
{
	string FullName { get; }

	float Health { get; }

	bool Dead { get; }

	bool Blessed { get; }

	void ForceGetHealth();
}


public interface IEnemyRelationshipLogic
{
	bool ShouldAttackEnemies();

	bool ShouldIgnorePlayer();
}


public interface IEnemyWeapon
{
	void UpdateTarget(EnemyTarget target);

	void Fire();

	void AltFire();

	void CancelAltCharge();
}


public interface IEnrage
{
	bool isEnraged { get; }

	void Enrage();

	void UnEnrage();
}


public interface IHitTargetCallback
{
	void TargetBeenHit();
}



public class ImageFadeIn : MonoBehaviour
{
	private Image img;

	private TMP_Text text;

	public float speed;

	public float maxAlpha = 1f;

	public bool startAt0;

	public UnityEvent onFull;

	private void Start()
	{
		img = GetComponent<Image>();
		text = GetComponent<TMP_Text>();
		if (maxAlpha == 0f)
		{
			maxAlpha = 1f;
		}
		if (startAt0)
		{
			if ((bool)img)
			{
				img.color = new Color(img.color.r, img.color.g, img.color.b, 0f);
			}
			if ((bool)text)
			{
				text.color = new Color(text.color.r, text.color.g, text.color.b, 0f);
			}
		}
	}

	private void Update()
	{
		if ((bool)img && img.color.a != maxAlpha)
		{
			Color color = img.color;
			color.a = Mathf.MoveTowards(color.a, maxAlpha, Time.deltaTime * speed);
			img.color = color;
			if (img.color.a == maxAlpha)
			{
				onFull?.Invoke();
			}
		}
		if ((bool)text && text.color.a != maxAlpha)
		{
			Color color2 = text.color;
			color2.a = Mathf.MoveTowards(color2.a, maxAlpha, Time.deltaTime * speed);
			text.color = color2;
			if (text.color.a == maxAlpha)
			{
				onFull?.Invoke();
			}
		}
	}

	public void ResetFade()
	{
		if ((bool)img)
		{
			img.color = new Color(img.color.r, img.color.g, img.color.b, 0f);
		}
		if ((bool)text)
		{
			text.color = new Color(text.color.r, text.color.g, text.color.b, 0f);
		}
	}

	public void CancelFade()
	{
		ResetFade();
		base.enabled = false;
	}
}



public class InitGame : MonoBehaviour
{
	public static bool hasInitialized;

	private void Awake()
	{
		if (!hasInitialized)
		{
			int intLocal = MonoSingleton<PrefsManager>.Instance.GetIntLocal("resolutionWidth", -1);
			int intLocal2 = MonoSingleton<PrefsManager>.Instance.GetIntLocal("resolutionHeight", -1);
			bool boolLocal = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("fullscreen");
			if (intLocal != -1 && intLocal2 != -1)
			{
				Screen.SetResolution(intLocal, intLocal2, boolLocal);
			}
			else
			{
				Resolution currentResolution = Screen.currentResolution;
				Screen.SetResolution(currentResolution.width, currentResolution.height, boolLocal);
			}
			hasInitialized = true;
		}
	}
}



public class InputActions : IInputActionCollection2, IInputActionCollection, IEnumerable<InputAction>, IEnumerable, IDisposable
{
	public struct UIActions
	{
		private InputActions m_Wrapper;

		public InputAction Navigate => m_Wrapper.m_UI_Navigate;

		public InputAction Submit => m_Wrapper.m_UI_Submit;

		public InputAction Cancel => m_Wrapper.m_UI_Cancel;

		public InputAction Point => m_Wrapper.m_UI_Point;

		public InputAction Click => m_Wrapper.m_UI_Click;

		public InputAction ScrollWheel => m_Wrapper.m_UI_ScrollWheel;

		public InputAction MiddleClick => m_Wrapper.m_UI_MiddleClick;

		public InputAction RightClick => m_Wrapper.m_UI_RightClick;

		public InputAction TrackedDevicePosition => m_Wrapper.m_UI_TrackedDevicePosition;

		public InputAction TrackedDeviceOrientation => m_Wrapper.m_UI_TrackedDeviceOrientation;

		public InputAction ScrollSublist => m_Wrapper.m_UI_ScrollSublist;

		public InputAction Pause => m_Wrapper.m_UI_Pause;

		public bool enabled => Get().enabled;

		public UIActions(InputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_UI;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(UIActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IUIActions instance)
		{
			if (m_Wrapper.m_UIActionsCallbackInterface != null)
			{
				Navigate.started -= m_Wrapper.m_UIActionsCallbackInterface.OnNavigate;
				Navigate.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnNavigate;
				Navigate.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnNavigate;
				Submit.started -= m_Wrapper.m_UIActionsCallbackInterface.OnSubmit;
				Submit.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnSubmit;
				Submit.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnSubmit;
				Cancel.started -= m_Wrapper.m_UIActionsCallbackInterface.OnCancel;
				Cancel.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnCancel;
				Cancel.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnCancel;
				Point.started -= m_Wrapper.m_UIActionsCallbackInterface.OnPoint;
				Point.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnPoint;
				Point.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnPoint;
				Click.started -= m_Wrapper.m_UIActionsCallbackInterface.OnClick;
				Click.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnClick;
				Click.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnClick;
				ScrollWheel.started -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollWheel;
				ScrollWheel.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollWheel;
				ScrollWheel.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollWheel;
				MiddleClick.started -= m_Wrapper.m_UIActionsCallbackInterface.OnMiddleClick;
				MiddleClick.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnMiddleClick;
				MiddleClick.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnMiddleClick;
				RightClick.started -= m_Wrapper.m_UIActionsCallbackInterface.OnRightClick;
				RightClick.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnRightClick;
				RightClick.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnRightClick;
				TrackedDevicePosition.started -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDevicePosition;
				TrackedDevicePosition.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDevicePosition;
				TrackedDevicePosition.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDevicePosition;
				TrackedDeviceOrientation.started -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDeviceOrientation;
				TrackedDeviceOrientation.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDeviceOrientation;
				TrackedDeviceOrientation.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnTrackedDeviceOrientation;
				ScrollSublist.started -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollSublist;
				ScrollSublist.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollSublist;
				ScrollSublist.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnScrollSublist;
				Pause.started -= m_Wrapper.m_UIActionsCallbackInterface.OnPause;
				Pause.performed -= m_Wrapper.m_UIActionsCallbackInterface.OnPause;
				Pause.canceled -= m_Wrapper.m_UIActionsCallbackInterface.OnPause;
			}
			m_Wrapper.m_UIActionsCallbackInterface = instance;
			if (instance != null)
			{
				Navigate.started += instance.OnNavigate;
				Navigate.performed += instance.OnNavigate;
				Navigate.canceled += instance.OnNavigate;
				Submit.started += instance.OnSubmit;
				Submit.performed += instance.OnSubmit;
				Submit.canceled += instance.OnSubmit;
				Cancel.started += instance.OnCancel;
				Cancel.performed += instance.OnCancel;
				Cancel.canceled += instance.OnCancel;
				Point.started += instance.OnPoint;
				Point.performed += instance.OnPoint;
				Point.canceled += instance.OnPoint;
				Click.started += instance.OnClick;
				Click.performed += instance.OnClick;
				Click.canceled += instance.OnClick;
				ScrollWheel.started += instance.OnScrollWheel;
				ScrollWheel.performed += instance.OnScrollWheel;
				ScrollWheel.canceled += instance.OnScrollWheel;
				MiddleClick.started += instance.OnMiddleClick;
				MiddleClick.performed += instance.OnMiddleClick;
				MiddleClick.canceled += instance.OnMiddleClick;
				RightClick.started += instance.OnRightClick;
				RightClick.performed += instance.OnRightClick;
				RightClick.canceled += instance.OnRightClick;
				TrackedDevicePosition.started += instance.OnTrackedDevicePosition;
				TrackedDevicePosition.performed += instance.OnTrackedDevicePosition;
				TrackedDevicePosition.canceled += instance.OnTrackedDevicePosition;
				TrackedDeviceOrientation.started += instance.OnTrackedDeviceOrientation;
				TrackedDeviceOrientation.performed += instance.OnTrackedDeviceOrientation;
				TrackedDeviceOrientation.canceled += instance.OnTrackedDeviceOrientation;
				ScrollSublist.started += instance.OnScrollSublist;
				ScrollSublist.performed += instance.OnScrollSublist;
				ScrollSublist.canceled += instance.OnScrollSublist;
				Pause.started += instance.OnPause;
				Pause.performed += instance.OnPause;
				Pause.canceled += instance.OnPause;
			}
		}
	}

	public struct MovementActions
	{
		private InputActions m_Wrapper;

		public InputAction Move => m_Wrapper.m_Movement_Move;

		public InputAction Look => m_Wrapper.m_Movement_Look;

		public InputAction Dodge => m_Wrapper.m_Movement_Dodge;

		public InputAction Slide => m_Wrapper.m_Movement_Slide;

		public InputAction Jump => m_Wrapper.m_Movement_Jump;

		public bool enabled => Get().enabled;

		public MovementActions(InputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_Movement;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(MovementActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IMovementActions instance)
		{
			if (m_Wrapper.m_MovementActionsCallbackInterface != null)
			{
				Move.started -= m_Wrapper.m_MovementActionsCallbackInterface.OnMove;
				Move.performed -= m_Wrapper.m_MovementActionsCallbackInterface.OnMove;
				Move.canceled -= m_Wrapper.m_MovementActionsCallbackInterface.OnMove;
				Look.started -= m_Wrapper.m_MovementActionsCallbackInterface.OnLook;
				Look.performed -= m_Wrapper.m_MovementActionsCallbackInterface.OnLook;
				Look.canceled -= m_Wrapper.m_MovementActionsCallbackInterface.OnLook;
				Dodge.started -= m_Wrapper.m_MovementActionsCallbackInterface.OnDodge;
				Dodge.performed -= m_Wrapper.m_MovementActionsCallbackInterface.OnDodge;
				Dodge.canceled -= m_Wrapper.m_MovementActionsCallbackInterface.OnDodge;
				Slide.started -= m_Wrapper.m_MovementActionsCallbackInterface.OnSlide;
				Slide.performed -= m_Wrapper.m_MovementActionsCallbackInterface.OnSlide;
				Slide.canceled -= m_Wrapper.m_MovementActionsCallbackInterface.OnSlide;
				Jump.started -= m_Wrapper.m_MovementActionsCallbackInterface.OnJump;
				Jump.performed -= m_Wrapper.m_MovementActionsCallbackInterface.OnJump;
				Jump.canceled -= m_Wrapper.m_MovementActionsCallbackInterface.OnJump;
			}
			m_Wrapper.m_MovementActionsCallbackInterface = instance;
			if (instance != null)
			{
				Move.started += instance.OnMove;
				Move.performed += instance.OnMove;
				Move.canceled += instance.OnMove;
				Look.started += instance.OnLook;
				Look.performed += instance.OnLook;
				Look.canceled += instance.OnLook;
				Dodge.started += instance.OnDodge;
				Dodge.performed += instance.OnDodge;
				Dodge.canceled += instance.OnDodge;
				Slide.started += instance.OnSlide;
				Slide.performed += instance.OnSlide;
				Slide.canceled += instance.OnSlide;
				Jump.started += instance.OnJump;
				Jump.performed += instance.OnJump;
				Jump.canceled += instance.OnJump;
			}
		}
	}

	public struct FistActions
	{
		private InputActions m_Wrapper;

		public InputAction Punch => m_Wrapper.m_Fist_Punch;

		public InputAction ChangeFist => m_Wrapper.m_Fist_ChangeFist;

		public InputAction PunchFeedbacker => m_Wrapper.m_Fist_PunchFeedbacker;

		public InputAction PunchKnuckleblaster => m_Wrapper.m_Fist_PunchKnuckleblaster;

		public InputAction Hook => m_Wrapper.m_Fist_Hook;

		public bool enabled => Get().enabled;

		public FistActions(InputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_Fist;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(FistActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IFistActions instance)
		{
			if (m_Wrapper.m_FistActionsCallbackInterface != null)
			{
				Punch.started -= m_Wrapper.m_FistActionsCallbackInterface.OnPunch;
				Punch.performed -= m_Wrapper.m_FistActionsCallbackInterface.OnPunch;
				Punch.canceled -= m_Wrapper.m_FistActionsCallbackInterface.OnPunch;
				ChangeFist.started -= m_Wrapper.m_FistActionsCallbackInterface.OnChangeFist;
				ChangeFist.performed -= m_Wrapper.m_FistActionsCallbackInterface.OnChangeFist;
				ChangeFist.canceled -= m_Wrapper.m_FistActionsCallbackInterface.OnChangeFist;
				PunchFeedbacker.started -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchFeedbacker;
				PunchFeedbacker.performed -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchFeedbacker;
				PunchFeedbacker.canceled -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchFeedbacker;
				PunchKnuckleblaster.started -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchKnuckleblaster;
				PunchKnuckleblaster.performed -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchKnuckleblaster;
				PunchKnuckleblaster.canceled -= m_Wrapper.m_FistActionsCallbackInterface.OnPunchKnuckleblaster;
				Hook.started -= m_Wrapper.m_FistActionsCallbackInterface.OnHook;
				Hook.performed -= m_Wrapper.m_FistActionsCallbackInterface.OnHook;
				Hook.canceled -= m_Wrapper.m_FistActionsCallbackInterface.OnHook;
			}
			m_Wrapper.m_FistActionsCallbackInterface = instance;
			if (instance != null)
			{
				Punch.started += instance.OnPunch;
				Punch.performed += instance.OnPunch;
				Punch.canceled += instance.OnPunch;
				ChangeFist.started += instance.OnChangeFist;
				ChangeFist.performed += instance.OnChangeFist;
				ChangeFist.canceled += instance.OnChangeFist;
				PunchFeedbacker.started += instance.OnPunchFeedbacker;
				PunchFeedbacker.performed += instance.OnPunchFeedbacker;
				PunchFeedbacker.canceled += instance.OnPunchFeedbacker;
				PunchKnuckleblaster.started += instance.OnPunchKnuckleblaster;
				PunchKnuckleblaster.performed += instance.OnPunchKnuckleblaster;
				PunchKnuckleblaster.canceled += instance.OnPunchKnuckleblaster;
				Hook.started += instance.OnHook;
				Hook.performed += instance.OnHook;
				Hook.canceled += instance.OnHook;
			}
		}
	}

	public struct WeaponActions
	{
		private InputActions m_Wrapper;

		public InputAction PrimaryFire => m_Wrapper.m_Weapon_PrimaryFire;

		public InputAction SecondaryFire => m_Wrapper.m_Weapon_SecondaryFire;

		public InputAction NextVariation => m_Wrapper.m_Weapon_NextVariation;

		public InputAction PreviousVariation => m_Wrapper.m_Weapon_PreviousVariation;

		public InputAction Revolver => m_Wrapper.m_Weapon_Revolver;

		public InputAction Shotgun => m_Wrapper.m_Weapon_Shotgun;

		public InputAction Nailgun => m_Wrapper.m_Weapon_Nailgun;

		public InputAction Railcannon => m_Wrapper.m_Weapon_Railcannon;

		public InputAction RocketLauncher => m_Wrapper.m_Weapon_RocketLauncher;

		public InputAction SpawnerArm => m_Wrapper.m_Weapon_SpawnerArm;

		public InputAction NextWeapon => m_Wrapper.m_Weapon_NextWeapon;

		public InputAction PreviousWeapon => m_Wrapper.m_Weapon_PreviousWeapon;

		public InputAction LastUsedWeapon => m_Wrapper.m_Weapon_LastUsedWeapon;

		public InputAction WheelLook => m_Wrapper.m_Weapon_WheelLook;

		public InputAction VariationSlot1 => m_Wrapper.m_Weapon_VariationSlot1;

		public InputAction VariationSlot2 => m_Wrapper.m_Weapon_VariationSlot2;

		public InputAction VariationSlot3 => m_Wrapper.m_Weapon_VariationSlot3;

		public bool enabled => Get().enabled;

		public WeaponActions(InputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_Weapon;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(WeaponActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IWeaponActions instance)
		{
			if (m_Wrapper.m_WeaponActionsCallbackInterface != null)
			{
				PrimaryFire.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPrimaryFire;
				PrimaryFire.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPrimaryFire;
				PrimaryFire.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPrimaryFire;
				SecondaryFire.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSecondaryFire;
				SecondaryFire.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSecondaryFire;
				SecondaryFire.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSecondaryFire;
				NextVariation.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextVariation;
				NextVariation.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextVariation;
				NextVariation.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextVariation;
				PreviousVariation.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousVariation;
				PreviousVariation.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousVariation;
				PreviousVariation.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousVariation;
				Revolver.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRevolver;
				Revolver.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRevolver;
				Revolver.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRevolver;
				Shotgun.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnShotgun;
				Shotgun.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnShotgun;
				Shotgun.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnShotgun;
				Nailgun.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNailgun;
				Nailgun.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNailgun;
				Nailgun.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNailgun;
				Railcannon.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRailcannon;
				Railcannon.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRailcannon;
				Railcannon.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRailcannon;
				RocketLauncher.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRocketLauncher;
				RocketLauncher.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRocketLauncher;
				RocketLauncher.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnRocketLauncher;
				SpawnerArm.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSpawnerArm;
				SpawnerArm.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSpawnerArm;
				SpawnerArm.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnSpawnerArm;
				NextWeapon.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextWeapon;
				NextWeapon.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextWeapon;
				NextWeapon.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnNextWeapon;
				PreviousWeapon.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousWeapon;
				PreviousWeapon.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousWeapon;
				PreviousWeapon.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnPreviousWeapon;
				LastUsedWeapon.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnLastUsedWeapon;
				LastUsedWeapon.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnLastUsedWeapon;
				LastUsedWeapon.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnLastUsedWeapon;
				WheelLook.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnWheelLook;
				WheelLook.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnWheelLook;
				WheelLook.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnWheelLook;
				VariationSlot1.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot1;
				VariationSlot1.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot1;
				VariationSlot1.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot1;
				VariationSlot2.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot2;
				VariationSlot2.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot2;
				VariationSlot2.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot2;
				VariationSlot3.started -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot3;
				VariationSlot3.performed -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot3;
				VariationSlot3.canceled -= m_Wrapper.m_WeaponActionsCallbackInterface.OnVariationSlot3;
			}
			m_Wrapper.m_WeaponActionsCallbackInterface = instance;
			if (instance != null)
			{
				PrimaryFire.started += instance.OnPrimaryFire;
				PrimaryFire.performed += instance.OnPrimaryFire;
				PrimaryFire.canceled += instance.OnPrimaryFire;
				SecondaryFire.started += instance.OnSecondaryFire;
				SecondaryFire.performed += instance.OnSecondaryFire;
				SecondaryFire.canceled += instance.OnSecondaryFire;
				NextVariation.started += instance.OnNextVariation;
				NextVariation.performed += instance.OnNextVariation;
				NextVariation.canceled += instance.OnNextVariation;
				PreviousVariation.started += instance.OnPreviousVariation;
				PreviousVariation.performed += instance.OnPreviousVariation;
				PreviousVariation.canceled += instance.OnPreviousVariation;
				Revolver.started += instance.OnRevolver;
				Revolver.performed += instance.OnRevolver;
				Revolver.canceled += instance.OnRevolver;
				Shotgun.started += instance.OnShotgun;
				Shotgun.performed += instance.OnShotgun;
				Shotgun.canceled += instance.OnShotgun;
				Nailgun.started += instance.OnNailgun;
				Nailgun.performed += instance.OnNailgun;
				Nailgun.canceled += instance.OnNailgun;
				Railcannon.started += instance.OnRailcannon;
				Railcannon.performed += instance.OnRailcannon;
				Railcannon.canceled += instance.OnRailcannon;
				RocketLauncher.started += instance.OnRocketLauncher;
				RocketLauncher.performed += instance.OnRocketLauncher;
				RocketLauncher.canceled += instance.OnRocketLauncher;
				SpawnerArm.started += instance.OnSpawnerArm;
				SpawnerArm.performed += instance.OnSpawnerArm;
				SpawnerArm.canceled += instance.OnSpawnerArm;
				NextWeapon.started += instance.OnNextWeapon;
				NextWeapon.performed += instance.OnNextWeapon;
				NextWeapon.canceled += instance.OnNextWeapon;
				PreviousWeapon.started += instance.OnPreviousWeapon;
				PreviousWeapon.performed += instance.OnPreviousWeapon;
				PreviousWeapon.canceled += instance.OnPreviousWeapon;
				LastUsedWeapon.started += instance.OnLastUsedWeapon;
				LastUsedWeapon.performed += instance.OnLastUsedWeapon;
				LastUsedWeapon.canceled += instance.OnLastUsedWeapon;
				WheelLook.started += instance.OnWheelLook;
				WheelLook.performed += instance.OnWheelLook;
				WheelLook.canceled += instance.OnWheelLook;
				VariationSlot1.started += instance.OnVariationSlot1;
				VariationSlot1.performed += instance.OnVariationSlot1;
				VariationSlot1.canceled += instance.OnVariationSlot1;
				VariationSlot2.started += instance.OnVariationSlot2;
				VariationSlot2.performed += instance.OnVariationSlot2;
				VariationSlot2.canceled += instance.OnVariationSlot2;
				VariationSlot3.started += instance.OnVariationSlot3;
				VariationSlot3.performed += instance.OnVariationSlot3;
				VariationSlot3.canceled += instance.OnVariationSlot3;
			}
		}
	}

	public struct HUDActions
	{
		private InputActions m_Wrapper;

		public InputAction Stats => m_Wrapper.m_HUD_Stats;

		public bool enabled => Get().enabled;

		public HUDActions(InputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_HUD;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(HUDActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IHUDActions instance)
		{
			if (m_Wrapper.m_HUDActionsCallbackInterface != null)
			{
				Stats.started -= m_Wrapper.m_HUDActionsCallbackInterface.OnStats;
				Stats.performed -= m_Wrapper.m_HUDActionsCallbackInterface.OnStats;
				Stats.canceled -= m_Wrapper.m_HUDActionsCallbackInterface.OnStats;
			}
			m_Wrapper.m_HUDActionsCallbackInterface = instance;
			if (instance != null)
			{
				Stats.started += instance.OnStats;
				Stats.performed += instance.OnStats;
				Stats.canceled += instance.OnStats;
			}
		}
	}

	public interface IUIActions
	{
		void OnNavigate(InputAction.CallbackContext context);

		void OnSubmit(InputAction.CallbackContext context);

		void OnCancel(InputAction.CallbackContext context);

		void OnPoint(InputAction.CallbackContext context);

		void OnClick(InputAction.CallbackContext context);

		void OnScrollWheel(InputAction.CallbackContext context);

		void OnMiddleClick(InputAction.CallbackContext context);

		void OnRightClick(InputAction.CallbackContext context);

		void OnTrackedDevicePosition(InputAction.CallbackContext context);

		void OnTrackedDeviceOrientation(InputAction.CallbackContext context);

		void OnScrollSublist(InputAction.CallbackContext context);

		void OnPause(InputAction.CallbackContext context);
	}

	public interface IMovementActions
	{
		void OnMove(InputAction.CallbackContext context);

		void OnLook(InputAction.CallbackContext context);

		void OnDodge(InputAction.CallbackContext context);

		void OnSlide(InputAction.CallbackContext context);

		void OnJump(InputAction.CallbackContext context);
	}

	public interface IFistActions
	{
		void OnPunch(InputAction.CallbackContext context);

		void OnChangeFist(InputAction.CallbackContext context);

		void OnPunchFeedbacker(InputAction.CallbackContext context);

		void OnPunchKnuckleblaster(InputAction.CallbackContext context);

		void OnHook(InputAction.CallbackContext context);
	}

	public interface IWeaponActions
	{
		void OnPrimaryFire(InputAction.CallbackContext context);

		void OnSecondaryFire(InputAction.CallbackContext context);

		void OnNextVariation(InputAction.CallbackContext context);

		void OnPreviousVariation(InputAction.CallbackContext context);

		void OnRevolver(InputAction.CallbackContext context);

		void OnShotgun(InputAction.CallbackContext context);

		void OnNailgun(InputAction.CallbackContext context);

		void OnRailcannon(InputAction.CallbackContext context);

		void OnRocketLauncher(InputAction.CallbackContext context);

		void OnSpawnerArm(InputAction.CallbackContext context);

		void OnNextWeapon(InputAction.CallbackContext context);

		void OnPreviousWeapon(InputAction.CallbackContext context);

		void OnLastUsedWeapon(InputAction.CallbackContext context);

		void OnWheelLook(InputAction.CallbackContext context);

		void OnVariationSlot1(InputAction.CallbackContext context);

		void OnVariationSlot2(InputAction.CallbackContext context);

		void OnVariationSlot3(InputAction.CallbackContext context);
	}

	public interface IHUDActions
	{
		void OnStats(InputAction.CallbackContext context);
	}

	private readonly InputActionMap m_UI;

	private IUIActions m_UIActionsCallbackInterface;

	private readonly InputAction m_UI_Navigate;

	private readonly InputAction m_UI_Submit;

	private readonly InputAction m_UI_Cancel;

	private readonly InputAction m_UI_Point;

	private readonly InputAction m_UI_Click;

	private readonly InputAction m_UI_ScrollWheel;

	private readonly InputAction m_UI_MiddleClick;

	private readonly InputAction m_UI_RightClick;

	private readonly InputAction m_UI_TrackedDevicePosition;

	private readonly InputAction m_UI_TrackedDeviceOrientation;

	private readonly InputAction m_UI_ScrollSublist;

	private readonly InputAction m_UI_Pause;

	private readonly InputActionMap m_Movement;

	private IMovementActions m_MovementActionsCallbackInterface;

	private readonly InputAction m_Movement_Move;

	private readonly InputAction m_Movement_Look;

	private readonly InputAction m_Movement_Dodge;

	private readonly InputAction m_Movement_Slide;

	private readonly InputAction m_Movement_Jump;

	private readonly InputActionMap m_Fist;

	private IFistActions m_FistActionsCallbackInterface;

	private readonly InputAction m_Fist_Punch;

	private readonly InputAction m_Fist_ChangeFist;

	private readonly InputAction m_Fist_PunchFeedbacker;

	private readonly InputAction m_Fist_PunchKnuckleblaster;

	private readonly InputAction m_Fist_Hook;

	private readonly InputActionMap m_Weapon;

	private IWeaponActions m_WeaponActionsCallbackInterface;

	private readonly InputAction m_Weapon_PrimaryFire;

	private readonly InputAction m_Weapon_SecondaryFire;

	private readonly InputAction m_Weapon_NextVariation;

	private readonly InputAction m_Weapon_PreviousVariation;

	private readonly InputAction m_Weapon_Revolver;

	private readonly InputAction m_Weapon_Shotgun;

	private readonly InputAction m_Weapon_Nailgun;

	private readonly InputAction m_Weapon_Railcannon;

	private readonly InputAction m_Weapon_RocketLauncher;

	private readonly InputAction m_Weapon_SpawnerArm;

	private readonly InputAction m_Weapon_NextWeapon;

	private readonly InputAction m_Weapon_PreviousWeapon;

	private readonly InputAction m_Weapon_LastUsedWeapon;

	private readonly InputAction m_Weapon_WheelLook;

	private readonly InputAction m_Weapon_VariationSlot1;

	private readonly InputAction m_Weapon_VariationSlot2;

	private readonly InputAction m_Weapon_VariationSlot3;

	private readonly InputActionMap m_HUD;

	private IHUDActions m_HUDActionsCallbackInterface;

	private readonly InputAction m_HUD_Stats;

	private int m_KeyboardMouseSchemeIndex = -1;

	private int m_GamepadSchemeIndex = -1;

	public InputActionAsset asset { get; }

	public InputBinding? bindingMask
	{
		get
		{
			return asset.bindingMask;
		}
		set
		{
			asset.bindingMask = value;
		}
	}

	public ReadOnlyArray<InputDevice>? devices
	{
		get
		{
			return asset.devices;
		}
		set
		{
			asset.devices = value;
		}
	}

	public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

	public IEnumerable<InputBinding> bindings => asset.bindings;

	public UIActions UI => new UIActions(this);

	public MovementActions Movement => new MovementActions(this);

	public FistActions Fist => new FistActions(this);

	public WeaponActions Weapon => new WeaponActions(this);

	public HUDActions HUD => new HUDActions(this);

	public InputControlScheme KeyboardMouseScheme
	{
		get
		{
			if (m_KeyboardMouseSchemeIndex == -1)
			{
				m_KeyboardMouseSchemeIndex = asset.FindControlSchemeIndex("Keyboard & Mouse");
			}
			return asset.controlSchemes[m_KeyboardMouseSchemeIndex];
		}
	}

	public InputControlScheme GamepadScheme
	{
		get
		{
			if (m_GamepadSchemeIndex == -1)
			{
				m_GamepadSchemeIndex = asset.FindControlSchemeIndex("Gamepad");
			}
			return asset.controlSchemes[m_GamepadSchemeIndex];
		}
	}

	public InputActions()
	{
		asset = InputActionAsset.FromJson("{\n    \"name\": \"InputActions\",\n    \"maps\": [\n        {\n            \"name\": \"UI\",\n            \"id\": \"272f6d14-89ba-496f-b7ff-215263d3219f\",\n            \"actions\": [\n                {\n                    \"name\": \"Navigate\",\n                    \"type\": \"Value\",\n                    \"id\": \"c95b2375-e6d9-4b88-9c4c-c5e76515df4b\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Submit\",\n                    \"type\": \"Button\",\n                    \"id\": \"7607c7b6-cd76-4816-beef-bd0341cfe950\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Cancel\",\n                    \"type\": \"Button\",\n                    \"id\": \"15cef263-9014-4fd5-94d9-4e4a6234a6ef\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Point\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"32b35790-4ed0-4e9a-aa41-69ac6d629449\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Click\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"3c7022bf-7922-4f7c-a998-c437916075ad\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"ScrollWheel\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"0489e84a-4833-4c40-bfae-cea84b696689\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"MiddleClick\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"dad70c86-b58c-4b17-88ad-f5e53adf419e\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"RightClick\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"44b200b1-1557-4083-816c-b22cbdf77ddf\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"TrackedDevicePosition\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"24908448-c609-4bc3-a128-ea258674378a\",\n                    \"expectedControlType\": \"Vector3\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"TrackedDeviceOrientation\",\n                    \"type\": \"PassThrough\",\n                    \"id\": \"9caa3d8a-6b2f-4e8e-8bad-6ede561bd9be\",\n                    \"expectedControlType\": \"Quaternion\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"ScrollSublist\",\n                    \"type\": \"Value\",\n                    \"id\": \"6a48eebe-4a36-47fa-a511-0489aa7c315f\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Pause\",\n                    \"type\": \"Button\",\n                    \"id\": \"97668417-6564-4b1c-8acf-ec55ca459e96\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"Gamepad\",\n                    \"id\": \"809f371f-c5e2-4e7a-83a1-d867598f40dd\",\n                    \"path\": \"2DVector\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"up\",\n                    \"id\": \"14a5d6e8-4aaf-4119-a9ef-34b8c2c548bf\",\n                    \"path\": \"<Gamepad>/leftStick/up\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Gamepad\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"down\",\n                    \"id\": \"2db08d65-c5fb-421b-983f-c71163608d67\",\n                    \"path\": \"<Gamepad>/leftStick/down\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Gamepad\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"left\",\n                    \"id\": \"8ba04515-75aa-45de-966d-393d9bbd1c14\",\n                    \"path\": \"<Gamepad>/leftStick/left\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Gamepad\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"right\",\n                    \"id\": \"fcd248ae-a788-4676-a12e-f4d81205600b\",\n                    \"path\": \"<Gamepad>/leftStick/right\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Gamepad\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"fb8277d4-c5cd-4663-9dc7-ee3f0b506d90\",\n                    \"path\": \"<Gamepad>/dpad\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"Joystick\",\n                    \"id\": \"e25d9774-381c-4a61-b47c-7b6b299ad9f9\",\n                    \"path\": \"2DVector\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"Keyboard\",\n                    \"id\": \"ff527021-f211-4c02-933e-5976594c46ed\",\n                    \"path\": \"2DVector\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"up\",\n                    \"id\": \"eb480147-c587-4a33-85ed-eb0ab9942c43\",\n                    \"path\": \"<Keyboard>/upArrow\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"down\",\n                    \"id\": \"85d264ad-e0a0-4565-b7ff-1a37edde51ac\",\n                    \"path\": \"<Keyboard>/downArrow\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"left\",\n                    \"id\": \"cea9b045-a000-445b-95b8-0c171af70a3b\",\n                    \"path\": \"<Keyboard>/leftArrow\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"right\",\n                    \"id\": \"4cda81dc-9edd-4e03-9d7c-a71a14345d0b\",\n                    \"path\": \"<Keyboard>/rightArrow\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Navigate\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"9e92bb26-7e3b-4ec4-b06b-3c8f8e498ddc\",\n                    \"path\": \"*/{Submit}\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Submit\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"82627dcc-3b13-4ba9-841d-e4b746d6553e\",\n                    \"path\": \"*/{Cancel}\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Cancel\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"c52c8e0b-8179-41d3-b8a1-d149033bbe86\",\n                    \"path\": \"<Mouse>/position\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Point\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"e1394cbc-336e-44ce-9ea8-6007ed6193f7\",\n                    \"path\": \"<Pen>/position\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Point\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4faf7dc9-b979-4210-aa8c-e808e1ef89f5\",\n                    \"path\": \"<Mouse>/leftButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Keyboard & Mouse\",\n                    \"action\": \"Click\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"8d66d5ba-88d7-48e6-b1cd-198bbfef7ace\",\n                    \"path\": \"<Pen>/tip\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Keyboard & Mouse\",\n                    \"action\": \"Click\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"38c99815-14ea-4617-8627-164d27641299\",\n                    \"path\": \"<Mouse>/scroll\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Keyboard & Mouse\",\n                    \"action\": \"ScrollWheel\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"24066f69-da47-44f3-a07e-0015fb02eb2e\",\n                    \"path\": \"<Mouse>/middleButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Keyboard & Mouse\",\n                    \"action\": \"MiddleClick\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4c191405-5738-4d4b-a523-c6a301dbf754\",\n                    \"path\": \"<Mouse>/rightButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \";Keyboard & Mouse\",\n                    \"action\": \"RightClick\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"Gamepad\",\n                    \"id\": \"9463292f-a2ff-4649-a9c3-067667e79776\",\n                    \"path\": \"2DVector\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"ScrollSublist\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"up\",\n                    \"id\": \"9bc3b935-5dc2-4404-8371-7b2485dff1ce\",\n                    \"path\": \"<Gamepad>/rightStick/up\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"ScrollSublist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"down\",\n                    \"id\": \"7ade12cb-a9f7-4a5a-96ae-e9fe630b2134\",\n                    \"path\": \"<Gamepad>/rightStick/down\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"ScrollSublist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"left\",\n                    \"id\": \"5f79f2a3-f8fc-432c-ae63-af30cb39d55d\",\n                    \"path\": \"<Gamepad>/rightStick/left\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"ScrollSublist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"right\",\n                    \"id\": \"2868eca4-a73a-4197-9c69-ddeb36bcf151\",\n                    \"path\": \"<Gamepad>/rightStick/right\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"ScrollSublist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"5b1930a7-f80a-47a3-a5fc-ae79cf605e47\",\n                    \"path\": \"<Keyboard>/escape\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Pause\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4fa5dbc3-d196-44a5-b7b0-0ea98081c9de\",\n                    \"path\": \"<Gamepad>/start\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Pause\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"Movement\",\n            \"id\": \"e96bd924-debe-467e-b08f-8b58a3e62a8e\",\n            \"actions\": [\n                {\n                    \"name\": \"Move\",\n                    \"type\": \"Value\",\n                    \"id\": \"cb0ce271-47aa-4c76-82e1-9c39bb2a7eb3\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Look\",\n                    \"type\": \"Value\",\n                    \"id\": \"7ef2043f-2b68-4e31-9373-8e06a7366297\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Dodge\",\n                    \"type\": \"Button\",\n                    \"id\": \"33b91605-d5d0-4013-9789-7592610c7cf8\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Slide\",\n                    \"type\": \"Button\",\n                    \"id\": \"624c1b28-2b1e-4f89-bbb5-17cc64cba594\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Jump\",\n                    \"type\": \"Button\",\n                    \"id\": \"0fb09bdc-b16f-45ea-b0e1-9ae06cd92ce9\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"WASD\",\n                    \"id\": \"a431c87e-8bbb-44ed-9798-da71bb2c7d86\",\n                    \"path\": \"2DVector\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Move\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"up\",\n                    \"id\": \"8d3ef497-0b3d-4b31-86a5-5663b2ba2ffa\",\n                    \"path\": \"<Keyboard>/w\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"down\",\n                    \"id\": \"4ef08ab9-0134-405a-b2ba-eac89353df45\",\n                    \"path\": \"<Keyboard>/s\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"left\",\n                    \"id\": \"2e9b3987-e852-45b8-b589-b6fb48e6ff84\",\n                    \"path\": \"<Keyboard>/a\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"right\",\n                    \"id\": \"6cea9ced-9601-4881-b8df-2faf804438b7\",\n                    \"path\": \"<Keyboard>/d\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"d82497ad-d674-4a6b-b956-80038bb4412f\",\n                    \"path\": \"<Gamepad>/leftStick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"a29c100e-7b84-4f6f-8dfd-b76e859796d6\",\n                    \"path\": \"<Mouse>/delta\",\n                    \"interactions\": \"\",\n                    \"processors\": \"ScaleVector2(x=0.05,y=0.05)\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Look\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"5ae79f6e-9f44-48f0-ba8c-1e011df2ef42\",\n                    \"path\": \"<Gamepad>/rightStick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"StickDeadzone,ScaleVector2DeltaTime,ScaleVector2(x=50,y=50)\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Look\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"27ff067c-1c14-4964-938d-802b6623cdff\",\n                    \"path\": \"<Keyboard>/leftShift\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Dodge\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"5382b377-bc60-452a-ad20-9d6bf609c9af\",\n                    \"path\": \"<Gamepad>/leftStickPress\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Dodge\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"ebd4e61a-b0c2-4c72-9496-26b0f5b21e11\",\n                    \"path\": \"<Keyboard>/leftCtrl\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Slide\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"bbf96605-8c7d-4975-8ba4-d68695687bda\",\n                    \"path\": \"<Gamepad>/buttonEast\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Slide\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"0903b737-349d-4732-81f0-48b0ca8de9bd\",\n                    \"path\": \"<Gamepad>/rightStickPress\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Slide\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"a4c4b550-cd65-4036-af7a-ef2378e4308e\",\n                    \"path\": \"<Keyboard>/space\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Jump\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"cea2ad63-b360-4664-b975-b8504e6ff901\",\n                    \"path\": \"<Gamepad>/buttonSouth\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Jump\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"Fist\",\n            \"id\": \"40b954b6-30b1-4981-92c3-1d4f9a6c17f2\",\n            \"actions\": [\n                {\n                    \"name\": \"Punch\",\n                    \"type\": \"Button\",\n                    \"id\": \"869113fb-bc1d-4a2b-9dec-eb22e9945d80\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Change Fist\",\n                    \"type\": \"Button\",\n                    \"id\": \"522acb46-9df3-45f6-939e-a51a03d400d9\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Punch (Feedbacker)\",\n                    \"type\": \"Button\",\n                    \"id\": \"c445e670-6075-441b-8b22-7dba0e8d42d4\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Punch (Knuckleblaster)\",\n                    \"type\": \"Button\",\n                    \"id\": \"bb0cab8e-f957-4032-8191-8ece32b5a14c\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Hook\",\n                    \"type\": \"Button\",\n                    \"id\": \"10724cb7-a181-40fc-9b86-c4d0ea53a8bb\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"67198acc-fa9a-481d-9d9a-d76dc60d8715\",\n                    \"path\": \"<Keyboard>/f\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Punch\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"60b0442a-1009-4d7e-a114-dbd44433d3a4\",\n                    \"path\": \"<Gamepad>/buttonWest\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Punch\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"23f28a42-e471-4602-9417-1f4658a13806\",\n                    \"path\": \"<Keyboard>/r\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Hook\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"Gamepad\",\n                    \"id\": \"9cd09ed9-ad4b-460a-b14c-4119905d26bc\",\n                    \"path\": \"OneModifier\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Hook\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"modifier\",\n                    \"id\": \"829dbbb7-04f0-450b-a532-364e192a9940\",\n                    \"path\": \"<Gamepad>/leftShoulder\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Hook\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"binding\",\n                    \"id\": \"0ff7fe63-f392-4798-8a1b-482e56b30dd3\",\n                    \"path\": \"<Gamepad>/rightShoulder\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Hook\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"fdfc4715-57ab-49d2-bdd5-ec5ac779724c\",\n                    \"path\": \"<Keyboard>/g\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Change Fist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"655dd916-82a6-4eeb-afaa-9b7dcad0c182\",\n                    \"path\": \"<Gamepad>/dpad/down\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Change Fist\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"Weapon\",\n            \"id\": \"6b9886b7-c7e2-4025-93cd-cda0cdac230a\",\n            \"actions\": [\n                {\n                    \"name\": \"Primary Fire\",\n                    \"type\": \"Value\",\n                    \"id\": \"02a37447-3cc3-449b-b39d-fdc77f11f764\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Secondary Fire\",\n                    \"type\": \"Button\",\n                    \"id\": \"15bebcb7-335a-459f-87b9-13e61e491c11\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Next Variation\",\n                    \"type\": \"Button\",\n                    \"id\": \"18f559c7-89b9-4171-ad32-a91c22e3e5ff\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Previous Variation\",\n                    \"type\": \"Button\",\n                    \"id\": \"b3234529-5d0b-4e5f-b8eb-11ff37849585\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Revolver\",\n                    \"type\": \"Button\",\n                    \"id\": \"e2f53064-bda2-4654-b185-29dca350eaa0\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45,pressPoint=0.5)\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Shotgun\",\n                    \"type\": \"Button\",\n                    \"id\": \"0763f1a7-6c7e-49a1-9a3c-4b146c27e04c\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45)\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Nailgun\",\n                    \"type\": \"Button\",\n                    \"id\": \"4ed2d805-e1e4-4025-ac6f-3432e06b1ce5\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45)\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Railcannon\",\n                    \"type\": \"Button\",\n                    \"id\": \"c7f3d928-3d5b-45d5-9d90-6b319e8311fb\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45)\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Rocket Launcher\",\n                    \"type\": \"Button\",\n                    \"id\": \"7849759d-8615-4f07-8de0-a28f26126ea2\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45)\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Spawner Arm\",\n                    \"type\": \"Button\",\n                    \"id\": \"3089e314-3d30-45ce-a07f-7d1cf04bb37f\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap(duration=1.401298E-45)\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Next Weapon\",\n                    \"type\": \"Button\",\n                    \"id\": \"d7c48ca7-dbd6-4f18-80f3-9f18e5c8ab1f\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Previous Weapon\",\n                    \"type\": \"Button\",\n                    \"id\": \"76594c5b-371a-4c5b-a9be-8a023cbe4cff\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Last Used Weapon\",\n                    \"type\": \"Button\",\n                    \"id\": \"ba0a138f-bf7b-4f3e-8bc8-d404f83020c1\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"WheelLook\",\n                    \"type\": \"Value\",\n                    \"id\": \"dc2612ed-51f2-4421-b9a6-f2e82ca48fa3\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"Variation Slot 1\",\n                    \"type\": \"Button\",\n                    \"id\": \"03278bce-78f4-4124-99a3-5f08692f158f\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Variation Slot 2\",\n                    \"type\": \"Button\",\n                    \"id\": \"edecf429-1346-41df-80bd-f5fdc3865b3f\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Variation Slot 3\",\n                    \"type\": \"Button\",\n                    \"id\": \"77f2f8d4-0612-407f-8628-9f02978ea515\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"93335d5d-6f0a-4f2d-8637-b20440416ad9\",\n                    \"path\": \"<Mouse>/leftButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Primary Fire\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"6bc77874-60ce-4a73-aa47-17440efd7e34\",\n                    \"path\": \"<Gamepad>/rightTrigger\",\n                    \"interactions\": \"Hold\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Primary Fire\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"eb709d49-df96-435a-b74b-842378d8101f\",\n                    \"path\": \"<Mouse>/rightButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Secondary Fire\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"13d52b9e-bc2d-4c2c-ba4e-c800584b05ad\",\n                    \"path\": \"<Gamepad>/leftTrigger\",\n                    \"interactions\": \"Hold\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Secondary Fire\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"5a614cd8-3f18-44ca-85e3-46e8fa633d73\",\n                    \"path\": \"<Keyboard>/e\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Next Variation\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"832b43cb-5024-4933-9050-c19e5b4c26ae\",\n                    \"path\": \"<Gamepad>/buttonNorth\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Next Variation\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"7a005e4a-4688-4c48-91ad-aff216b70387\",\n                    \"path\": \"<Keyboard>/1\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Revolver\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"173d4f78-e12d-4366-97fb-98c9b4053ce3\",\n                    \"path\": \"<Keyboard>/2\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Shotgun\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"99b705e4-4419-4585-9682-5e66be07a062\",\n                    \"path\": \"<Keyboard>/3\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Nailgun\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"b160dc8e-9231-4830-b57d-11feca18f885\",\n                    \"path\": \"<Keyboard>/4\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Railcannon\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"23aa32cc-3c8e-444c-a6ef-6df11f9674da\",\n                    \"path\": \"<Keyboard>/5\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Rocket Launcher\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"e93c0bc5-5274-46a6-9c6c-d51176e13d98\",\n                    \"path\": \"<Keyboard>/6\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Spawner Arm\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"ab01fc7f-eb43-4fc4-b5d0-452819ca3158\",\n                    \"path\": \"<Gamepad>/dpad/up\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Last Used Weapon\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4308293d-7e6d-46df-ab18-3a434ad9c88d\",\n                    \"path\": \"<Gamepad>/rightStick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"WheelLook\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"ba90b80a-c77e-41f1-9c18-8defadce77c3\",\n                    \"path\": \"<Mouse>/delta\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"WheelLook\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4e7c2a98-432f-4ea5-9f19-a6d5e94ce4f1\",\n                    \"path\": \"<Gamepad>/rightShoulder\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Next Weapon\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"53776e46-c411-4ead-9029-28a726300449\",\n                    \"path\": \"<Gamepad>/leftShoulder\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Previous Weapon\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"284d0b5f-8f69-4ddc-944a-49fdc92b78a0\",\n                    \"path\": \"<Keyboard>/q\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Previous Variation\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"HUD\",\n            \"id\": \"f220c680-c3c2-4bae-a82a-81a1f1bb9d0c\",\n            \"actions\": [\n                {\n                    \"name\": \"Stats\",\n                    \"type\": \"Button\",\n                    \"id\": \"296faedb-712e-44d6-baf4-661c82946274\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"d4ab4fd3-dfe1-47d3-8390-bc85ee66f1e4\",\n                    \"path\": \"<Keyboard>/tab\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Keyboard & Mouse\",\n                    \"action\": \"Stats\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"915dede1-3f36-4970-ab7e-7c0a74bedb87\",\n                    \"path\": \"<Gamepad>/select\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"Gamepad\",\n                    \"action\": \"Stats\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        }\n    ],\n    \"controlSchemes\": [\n        {\n            \"name\": \"Keyboard & Mouse\",\n            \"bindingGroup\": \"Keyboard & Mouse\",\n            \"devices\": [\n                {\n                    \"devicePath\": \"<Keyboard>\",\n                    \"isOptional\": false,\n                    \"isOR\": false\n                },\n                {\n                    \"devicePath\": \"<Mouse>\",\n                    \"isOptional\": false,\n                    \"isOR\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"Gamepad\",\n            \"bindingGroup\": \"Gamepad\",\n            \"devices\": [\n                {\n                    \"devicePath\": \"<Gamepad>\",\n                    \"isOptional\": false,\n                    \"isOR\": false\n                }\n            ]\n        }\n    ]\n}");
		m_UI = asset.FindActionMap("UI", throwIfNotFound: true);
		m_UI_Navigate = m_UI.FindAction("Navigate", throwIfNotFound: true);
		m_UI_Submit = m_UI.FindAction("Submit", throwIfNotFound: true);
		m_UI_Cancel = m_UI.FindAction("Cancel", throwIfNotFound: true);
		m_UI_Point = m_UI.FindAction("Point", throwIfNotFound: true);
		m_UI_Click = m_UI.FindAction("Click", throwIfNotFound: true);
		m_UI_ScrollWheel = m_UI.FindAction("ScrollWheel", throwIfNotFound: true);
		m_UI_MiddleClick = m_UI.FindAction("MiddleClick", throwIfNotFound: true);
		m_UI_RightClick = m_UI.FindAction("RightClick", throwIfNotFound: true);
		m_UI_TrackedDevicePosition = m_UI.FindAction("TrackedDevicePosition", throwIfNotFound: true);
		m_UI_TrackedDeviceOrientation = m_UI.FindAction("TrackedDeviceOrientation", throwIfNotFound: true);
		m_UI_ScrollSublist = m_UI.FindAction("ScrollSublist", throwIfNotFound: true);
		m_UI_Pause = m_UI.FindAction("Pause", throwIfNotFound: true);
		m_Movement = asset.FindActionMap("Movement", throwIfNotFound: true);
		m_Movement_Move = m_Movement.FindAction("Move", throwIfNotFound: true);
		m_Movement_Look = m_Movement.FindAction("Look", throwIfNotFound: true);
		m_Movement_Dodge = m_Movement.FindAction("Dodge", throwIfNotFound: true);
		m_Movement_Slide = m_Movement.FindAction("Slide", throwIfNotFound: true);
		m_Movement_Jump = m_Movement.FindAction("Jump", throwIfNotFound: true);
		m_Fist = asset.FindActionMap("Fist", throwIfNotFound: true);
		m_Fist_Punch = m_Fist.FindAction("Punch", throwIfNotFound: true);
		m_Fist_ChangeFist = m_Fist.FindAction("Change Fist", throwIfNotFound: true);
		m_Fist_PunchFeedbacker = m_Fist.FindAction("Punch (Feedbacker)", throwIfNotFound: true);
		m_Fist_PunchKnuckleblaster = m_Fist.FindAction("Punch (Knuckleblaster)", throwIfNotFound: true);
		m_Fist_Hook = m_Fist.FindAction("Hook", throwIfNotFound: true);
		m_Weapon = asset.FindActionMap("Weapon", throwIfNotFound: true);
		m_Weapon_PrimaryFire = m_Weapon.FindAction("Primary Fire", throwIfNotFound: true);
		m_Weapon_SecondaryFire = m_Weapon.FindAction("Secondary Fire", throwIfNotFound: true);
		m_Weapon_NextVariation = m_Weapon.FindAction("Next Variation", throwIfNotFound: true);
		m_Weapon_PreviousVariation = m_Weapon.FindAction("Previous Variation", throwIfNotFound: true);
		m_Weapon_Revolver = m_Weapon.FindAction("Revolver", throwIfNotFound: true);
		m_Weapon_Shotgun = m_Weapon.FindAction("Shotgun", throwIfNotFound: true);
		m_Weapon_Nailgun = m_Weapon.FindAction("Nailgun", throwIfNotFound: true);
		m_Weapon_Railcannon = m_Weapon.FindAction("Railcannon", throwIfNotFound: true);
		m_Weapon_RocketLauncher = m_Weapon.FindAction("Rocket Launcher", throwIfNotFound: true);
		m_Weapon_SpawnerArm = m_Weapon.FindAction("Spawner Arm", throwIfNotFound: true);
		m_Weapon_NextWeapon = m_Weapon.FindAction("Next Weapon", throwIfNotFound: true);
		m_Weapon_PreviousWeapon = m_Weapon.FindAction("Previous Weapon", throwIfNotFound: true);
		m_Weapon_LastUsedWeapon = m_Weapon.FindAction("Last Used Weapon", throwIfNotFound: true);
		m_Weapon_WheelLook = m_Weapon.FindAction("WheelLook", throwIfNotFound: true);
		m_Weapon_VariationSlot1 = m_Weapon.FindAction("Variation Slot 1", throwIfNotFound: true);
		m_Weapon_VariationSlot2 = m_Weapon.FindAction("Variation Slot 2", throwIfNotFound: true);
		m_Weapon_VariationSlot3 = m_Weapon.FindAction("Variation Slot 3", throwIfNotFound: true);
		m_HUD = asset.FindActionMap("HUD", throwIfNotFound: true);
		m_HUD_Stats = m_HUD.FindAction("Stats", throwIfNotFound: true);
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(asset);
	}

	public bool Contains(InputAction action)
	{
		return asset.Contains(action);
	}

	public IEnumerator<InputAction> GetEnumerator()
	{
		return asset.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Enable()
	{
		asset.Enable();
	}

	public void Disable()
	{
		asset.Disable();
	}

	public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
	{
		return asset.FindAction(actionNameOrId, throwIfNotFound);
	}

	public int FindBinding(InputBinding bindingMask, out InputAction action)
	{
		return asset.FindBinding(bindingMask, out action);
	}
}



public class InputActionState
{
	public InputAction Action { get; }

	public float PerformedTime { get; private set; }

	public int PerformedFrame { get; private set; }

	public int CanceledFrame { get; private set; }

	public bool IsPressed { get; private set; }

	public string LastUsedBinding { get; private set; }

	public float HoldTime
	{
		get
		{
			if (!IsPressed && !WasCanceledThisFrame)
			{
				return 0f;
			}
			return Time.time - PerformedTime;
		}
	}

	public bool WasPerformedThisFrame => PerformedFrame == Time.frameCount;

	public bool WasCanceledThisFrame => CanceledFrame == Time.frameCount;

	public InputActionState(InputAction action)
	{
		Action = action;
		action.started += OnTriggered;
		action.canceled += OnTriggered;
	}

	private void OnTriggered(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			IsPressed = true;
			PerformedFrame = Time.frameCount;
			PerformedTime = Time.time;
			LastUsedBinding = context.control.path;
		}
		else if (context.canceled)
		{
			IsPressed = false;
			CanceledFrame = Time.frameCount;
		}
	}

	public TValue ReadValue<TValue>() where TValue : struct
	{
		return Action.ReadValue<TValue>();
	}
}



public static class InputExtensions
{
	private static readonly Logger Log = new Logger("Input");

	public static string GetBindingDisplayStringWithoutOverride(this InputAction action, InputBinding binding, InputBinding.DisplayStringOptions options = (InputBinding.DisplayStringOptions)0)
	{
		if (binding.isPartOfComposite)
		{
			return binding.ToDisplayString(InputBinding.DisplayStringOptions.DontIncludeInteractions | InputBinding.DisplayStringOptions.IgnoreBindingOverrides);
		}
		string overridePath = binding.overridePath;
		binding.overridePath = null;
		action.ApplyBindingOverride(binding);
		string result = action.GetBindingDisplayString(binding, InputBinding.DisplayStringOptions.DontIncludeInteractions | InputBinding.DisplayStringOptions.IgnoreBindingOverrides).ToUpper();
		binding.overridePath = overridePath;
		action.ApplyBindingOverride(binding);
		return result;
	}

	public static void WipeAction(this InputAction action, string controlScheme)
	{
		new List<InputBinding>();
		InputActionSetupExtensions.BindingSyntax bindingSyntax = action.ChangeBindingWithGroup(controlScheme);
		while (bindingSyntax.valid)
		{
			bindingSyntax.Erase();
			bindingSyntax = action.ChangeBindingWithGroup(controlScheme);
		}
	}

	public static bool IsActionEqual(this InputAction action, InputAction baseAction, string controlScheme = null)
	{
		Log.Fine("<b>(" + action.name + ")</b> Comparing action " + action.name + " to default action " + baseAction.name);
		List<InputBinding> list = action.bindings.ToList();
		List<InputBinding> list2 = baseAction.bindings.ToList();
		if (controlScheme != null)
		{
			list = list.Where((InputBinding bind) => action.BindingHasGroup(bind, controlScheme)).ToList();
			list2 = list2.Where((InputBinding bind) => baseAction.BindingHasGroup(bind, controlScheme)).ToList();
		}
		if (list.Count != list2.Count)
		{
			Log.Warning($"Binding count mismatch - Action: {list.Count}, Base: {list2.Count}");
			return false;
		}
		Log.Fine($"{action.name} to {baseAction.name} - Action: {list.Count}, Base: {list2.Count}");
		for (int i = 0; i < list.Count; i++)
		{
			InputBinding binding = list[i];
			InputBinding other = list2[i];
			if (!binding.IsBindingEqual(other))
			{
				Log.Fine("Difference found - '" + other.path + "' to '" + binding.path + "'");
				return false;
			}
		}
		return true;
	}

	public static bool IsBindingEqual(this InputBinding binding, InputBinding other)
	{
		if (AreStringsEqual(other.effectivePath, binding.effectivePath) && AreStringsEqual(other.effectiveInteractions, binding.effectiveInteractions))
		{
			return AreStringsEqual(other.effectiveProcessors, binding.effectiveProcessors);
		}
		return false;
	}

	public static bool BindingHasGroup(this InputAction action, InputBinding binding, string group)
	{
		return action.BindingHasGroup(action.GetBindingIndex(binding), group);
	}

	public static bool BindingHasGroup(this InputAction action, int i, string group)
	{
		InputBinding inputBinding = action.bindings[i];
		if (inputBinding.isComposite && action.bindings.Count > i + 1)
		{
			inputBinding = action.bindings[i + 1];
		}
		if (inputBinding.groups == null)
		{
			return false;
		}
		return inputBinding.groups.Contains(group);
	}

	public static int[] GetBindingsWithGroup(this InputAction action, string group)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < action.bindings.Count; i++)
		{
			if (!action.bindings[i].isPartOfComposite && action.BindingHasGroup(i, group))
			{
				list.Add(i);
			}
		}
		return list.ToArray();
	}

	private static bool AreStringsEqual(string str1, string str2)
	{
		if (string.IsNullOrEmpty(str1) && string.IsNullOrEmpty(str2))
		{
			return true;
		}
		return string.Equals(str1, str2);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class InputManager : MonoSingleton<InputManager>
{
	private sealed class ButtonPressListener : IObserver<InputControl>
	{
		public static ButtonPressListener Instance { get; } = new ButtonPressListener();


		public void OnCompleted()
		{
		}

		public void OnError(Exception error)
		{
		}

		public void OnNext(InputControl value)
		{
			if (!(value.device is LegacyInput))
			{
				MonoSingleton<InputManager>.Instance.LastButtonDevice = value.device;
			}
		}
	}

	private class BindingInfo
	{
		public InputAction Action;

		public string Name;

		public int Offset;

		public KeyCode DefaultKey;

		public string PrefName => "keyBinding." + Name;
	}

	public Dictionary<string, KeyCode> inputsDictionary = new Dictionary<string, KeyCode>();

	public InputActionAsset defaultActions;

	private IDisposable anyButtonListener;

	public bool ScrOn;

	public bool ScrWep;

	public bool ScrVar;

	public bool ScrRev;

	public Action<InputAction> actionModified;

	private BindingInfo[] legacyBindings;

	private InputActionRebindingExtensions.RebindingOperation rebinding;

	public PlayerInput InputSource { get; private set; }

	public InputDevice LastButtonDevice { get; private set; }

	private static IObservable<InputControl> onAnyInput => from e in InputSystem.onEvent
		select (e.type != 1398030676 && e.type != 1145852993) ? null : e.GetFirstButtonPressOrNull(-1f, buttonControlsOnly: false) into c
		where c != null && !c.noisy
		select c;

	public Dictionary<string, KeyCode> Inputs => inputsDictionary;

	private FileInfo savedBindingsFile => new FileInfo(Path.Combine(PrefsManager.PrefsPath, "Binds.json"));

	protected override void Awake()
	{
		base.Awake();
		InputSource = new PlayerInput();
		defaultActions = InputActionAsset.FromJson(InputSource.Actions.asset.ToJson());
		if (savedBindingsFile.Exists)
		{
			JsonConvert.DeserializeObject<JsonBindingMap>(File.ReadAllText(savedBindingsFile.FullName)).ApplyTo(InputSource.Actions.asset);
		}
		legacyBindings = new BindingInfo[20]
		{
			new BindingInfo
			{
				Action = InputSource.Move.Action,
				DefaultKey = KeyCode.W,
				Name = "W"
			},
			new BindingInfo
			{
				Action = InputSource.Move.Action,
				Offset = 1,
				DefaultKey = KeyCode.S,
				Name = "S"
			},
			new BindingInfo
			{
				Action = InputSource.Move.Action,
				Offset = 2,
				DefaultKey = KeyCode.A,
				Name = "A"
			},
			new BindingInfo
			{
				Action = InputSource.Move.Action,
				Offset = 3,
				DefaultKey = KeyCode.D,
				Name = "D"
			},
			new BindingInfo
			{
				Action = InputSource.Jump.Action,
				DefaultKey = KeyCode.Space,
				Name = "Jump"
			},
			new BindingInfo
			{
				Action = InputSource.Dodge.Action,
				DefaultKey = KeyCode.LeftShift,
				Name = "Dodge"
			},
			new BindingInfo
			{
				Action = InputSource.Slide.Action,
				DefaultKey = KeyCode.LeftControl,
				Name = "Slide"
			},
			new BindingInfo
			{
				Action = InputSource.Fire1.Action,
				DefaultKey = KeyCode.Mouse0,
				Name = "Fire1"
			},
			new BindingInfo
			{
				Action = InputSource.Fire2.Action,
				DefaultKey = KeyCode.Mouse1,
				Name = "Fire2"
			},
			new BindingInfo
			{
				Action = InputSource.Punch.Action,
				DefaultKey = KeyCode.F,
				Name = "Punch"
			},
			new BindingInfo
			{
				Action = InputSource.Hook.Action,
				DefaultKey = KeyCode.R,
				Name = "Hook"
			},
			new BindingInfo
			{
				Action = InputSource.LastWeapon.Action,
				DefaultKey = KeyCode.Q,
				Name = "LastUsedWeapon"
			},
			new BindingInfo
			{
				Action = InputSource.NextVariation.Action,
				DefaultKey = KeyCode.E,
				Name = "ChangeVariation"
			},
			new BindingInfo
			{
				Action = InputSource.ChangeFist.Action,
				DefaultKey = KeyCode.G,
				Name = "ChangeFist"
			},
			new BindingInfo
			{
				Action = InputSource.Slot1.Action,
				DefaultKey = KeyCode.Alpha1,
				Name = "Slot1"
			},
			new BindingInfo
			{
				Action = InputSource.Slot2.Action,
				DefaultKey = KeyCode.Alpha2,
				Name = "Slot2"
			},
			new BindingInfo
			{
				Action = InputSource.Slot3.Action,
				DefaultKey = KeyCode.Alpha3,
				Name = "Slot3"
			},
			new BindingInfo
			{
				Action = InputSource.Slot4.Action,
				DefaultKey = KeyCode.Alpha4,
				Name = "Slot4"
			},
			new BindingInfo
			{
				Action = InputSource.Slot5.Action,
				DefaultKey = KeyCode.Alpha5,
				Name = "Slot5"
			},
			new BindingInfo
			{
				Action = InputSource.Slot6.Action,
				DefaultKey = KeyCode.Alpha6,
				Name = "Slot6"
			}
		};
		UpgradeBindings();
		InputSource.Enable();
		ScrOn = MonoSingleton<PrefsManager>.Instance.GetBool("scrollEnabled");
		ScrWep = MonoSingleton<PrefsManager>.Instance.GetBool("scrollWeapons");
		ScrVar = MonoSingleton<PrefsManager>.Instance.GetBool("scrollVariations");
		ScrRev = MonoSingleton<PrefsManager>.Instance.GetBool("scrollReversed");
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		anyButtonListener = onAnyInput.Subscribe(ButtonPressListener.Instance);
	}

	private void OnDisable()
	{
		anyButtonListener?.Dispose();
		SaveBindings(InputSource.Actions.asset);
	}

	public void ResetToDefault()
	{
		JsonBindingMap.From(defaultActions, InputSource.Actions.KeyboardMouseScheme).ApplyTo(InputSource.Actions.asset);
		InputSource.ValidateBindings(InputSource.Actions.KeyboardMouseScheme);
	}

	public void ResetToDefault(InputAction action, InputControlScheme controlScheme)
	{
		InputAction inputAction = defaultActions.FindAction(action.name);
		InputSource.Disable();
		action.WipeAction(controlScheme.bindingGroup);
		for (int i = 0; i < inputAction.bindings.Count; i++)
		{
			if (!inputAction.BindingHasGroup(i, controlScheme.bindingGroup))
			{
				continue;
			}
			InputBinding binding = inputAction.bindings[i];
			if (binding.isPartOfComposite)
			{
				continue;
			}
			if (binding.isComposite)
			{
				InputActionSetupExtensions.CompositeSyntax compositeSyntax = action.AddCompositeBinding("2DVector");
				for (int j = i + 1; j < inputAction.bindings.Count && inputAction.bindings[j].isPartOfComposite; j++)
				{
					InputBinding inputBinding = inputAction.bindings[j];
					compositeSyntax.With(inputBinding.name, inputBinding.path, controlScheme.bindingGroup);
				}
			}
			else
			{
				action.AddBinding(binding).WithGroup(controlScheme.bindingGroup);
			}
		}
		actionModified?.Invoke(action);
		SaveBindings(InputSource.Actions.asset);
		InputSource.Enable();
	}

	public bool PerformingCheatMenuCombo()
	{
		if (!MonoSingleton<CheatsController>.Instance.cheatsEnabled)
		{
			return false;
		}
		if (!(LastButtonDevice is Gamepad))
		{
			return false;
		}
		if (Gamepad.current == null)
		{
			return false;
		}
		return Gamepad.current.selectButton.isPressed;
	}

	public void SaveBindings(InputActionAsset asset)
	{
		JsonBindingMap value = JsonBindingMap.From(asset, defaultActions, InputSource.Actions.KeyboardMouseScheme);
		File.WriteAllText(savedBindingsFile.FullName, JsonConvert.SerializeObject(value, Formatting.Indented));
	}

	public void UpgradeBindings()
	{
		Debug.Log(Keyboard.current.digit0Key.path);
		BindingInfo[] array = legacyBindings;
		foreach (BindingInfo bindingInfo in array)
		{
			InputBinding bindingMask = InputBinding.MaskByGroup("Keyboard & Mouse");
			int bindingIndex = bindingInfo.Action.GetBindingIndex(bindingMask);
			Inputs[bindingInfo.Name] = (KeyCode)MonoSingleton<PrefsManager>.Instance.GetInt(bindingInfo.PrefName, (int)bindingInfo.DefaultKey);
			if (bindingIndex != -1 && MonoSingleton<PrefsManager>.Instance.HasKey(bindingInfo.PrefName))
			{
				KeyCode @int = (KeyCode)MonoSingleton<PrefsManager>.Instance.GetInt(bindingInfo.PrefName);
				MonoSingleton<PrefsManager>.Instance.DeleteKey(bindingInfo.PrefName);
				ButtonControl button = LegacyInput.current.GetButton(@int);
				bindingInfo.Action.ChangeBinding(bindingIndex + bindingInfo.Offset).WithPath(button.path).WithGroup(InputSource.Actions.KeyboardMouseScheme.bindingGroup);
			}
		}
		foreach (InputAction action in InputSource.Actions)
		{
			foreach (InputBinding binding in action.bindings)
			{
				if (binding.path.Contains("LegacyInput"))
				{
					string path = binding.path.Replace("/LegacyInput/", "<Keyboard>/").Replace("alpha", "");
					if (InputSystem.FindControl(path) != null)
					{
						action.ChangeBinding(binding).WithPath(path);
					}
					else
					{
						action.ChangeBinding(binding).Erase();
					}
				}
			}
		}
	}

	public void WaitForButton(Action<string> onComplete, Action onCancel, List<string> allowedPaths = null)
	{
		InputSource.Disable();
		rebinding?.Cancel();
		rebinding?.Dispose();
		rebinding = new InputActionRebindingExtensions.RebindingOperation().OnApplyBinding(delegate(InputActionRebindingExtensions.RebindingOperation op, string path)
		{
			rebinding = null;
			op.Dispose();
			if (InputControlPath.TryFindControl(Keyboard.current, path) == Keyboard.current.escapeKey)
			{
				onCancel?.Invoke();
			}
			else
			{
				onComplete?.Invoke(path);
			}
			InputSource.Enable();
		}).WithControlsExcluding(LegacyInput.current.path).WithExpectedControlType<ButtonControl>()
			.WithMatchingEventsBeingSuppressed();
		if (allowedPaths != null)
		{
			foreach (string allowedPath in allowedPaths)
			{
				rebinding.WithControlsHavingToMatchPath(allowedPath);
			}
		}
		rebinding.Start();
	}

	public void WaitForButtonSequence(Queue<string> partNames, Action<string> onBeginPart, Action<string, string> onCompletePart, Action onComplete, Action onCancel, List<string> allowedPaths = null)
	{
		if (partNames.Count == 0)
		{
			onComplete?.Invoke();
			return;
		}
		string part = partNames.Dequeue();
		onBeginPart?.Invoke(part);
		WaitForButton(delegate(string path)
		{
			onCompletePart?.Invoke(part, path);
			WaitForButtonSequence(partNames, onBeginPart, onCompletePart, onComplete, onCancel);
		}, onCancel, allowedPaths);
	}

	public void ClearOtherActions(InputAction action, string path)
	{
		foreach (InputAction action2 in InputSource.Actions)
		{
			if (action2 == action)
			{
				continue;
			}
			int bindingIndex = action2.GetBindingIndex(null, path);
			if (bindingIndex != -1)
			{
				InputActionSetupExtensions.BindingSyntax bindingSyntax = action2.ChangeBinding(bindingIndex);
				if (bindingSyntax.binding.isPartOfComposite)
				{
					bindingSyntax = bindingSyntax.PreviousCompositeBinding();
				}
				bindingSyntax.Erase();
			}
		}
	}

	public void Rebind(InputAction action, int? existingIndex, Action onComplete, Action onCancel, InputControlScheme scheme)
	{
		List<string> allowedPaths = scheme.deviceRequirements.Select((InputControlScheme.DeviceRequirement requirement) => requirement.controlPath).ToList();
		WaitForButton(delegate(string path)
		{
			foreach (InputBinding binding in action.bindings)
			{
				if (InputSystem.FindControl(binding.path) == InputSystem.FindControl(path))
				{
					onComplete?.Invoke();
					return;
				}
			}
			int? num = existingIndex;
			int valueOrDefault = num.GetValueOrDefault();
			(num.HasValue ? action.ChangeBinding(valueOrDefault) : action.AddBinding()).WithPath(path).WithGroup(scheme.bindingGroup);
			actionModified?.Invoke(action);
			onComplete?.Invoke();
		}, delegate
		{
			onCancel?.Invoke();
		}, allowedPaths);
	}

	public void RebindComposite(InputAction action, int? existingIndex, Action<string> onBeginPart, Action onComplete, Action onCancel, InputControlScheme scheme)
	{
		List<string> allowedPaths = scheme.deviceRequirements.Select((InputControlScheme.DeviceRequirement requirement) => requirement.controlPath).ToList();
		if (action.expectedControlType == "Vector2")
		{
			string[] collection = new string[4] { "Up", "Down", "Left", "Right" };
			Dictionary<string, string> partPathDict = new Dictionary<string, string>();
			WaitForButtonSequence(new Queue<string>(collection), onBeginPart, delegate(string part, string path)
			{
				partPathDict.Add(part, path);
			}, delegate
			{
				int? num = existingIndex;
				int valueOrDefault = num.GetValueOrDefault();
				if (num.HasValue)
				{
					InputActionSetupExtensions.BindingSyntax bindingSyntax = action.ChangeBinding(valueOrDefault);
					foreach (KeyValuePair<string, string> item in partPathDict)
					{
						bindingSyntax.NextPartBinding(item.Key).WithPath(item.Value).WithGroup(scheme.bindingGroup);
					}
				}
				else
				{
					InputActionSetupExtensions.CompositeSyntax compositeSyntax = action.AddCompositeBinding("2DVector");
					foreach (KeyValuePair<string, string> item2 in partPathDict)
					{
						compositeSyntax.With(item2.Key, item2.Value, scheme.bindingGroup);
					}
					action.AddBinding().Erase();
				}
				actionModified?.Invoke(action);
				onComplete?.Invoke();
			}, onCancel, allowedPaths);
		}
		else
		{
			Debug.LogError("Attempted to call RebindComposite on action with unsupported control type: '" + action.expectedControlType + "'");
		}
	}

	public string GetBindingString(Guid actionId)
	{
		return GetBindingString(actionId.ToString());
	}

	public string GetBindingString(string nameOrId)
	{
		ReadOnlyArray<InputBinding> bindings = InputSource.Actions.FindAction(nameOrId).bindings;
		string text = string.Empty;
		int num = 0;
		Queue<string> queue = new Queue<string>();
		InputControlScheme inputControlScheme = InputSource.Actions.KeyboardMouseScheme;
		foreach (InputControlScheme controlScheme in InputSource.Actions.controlSchemes)
		{
			if (controlScheme.SupportsDevice(LastButtonDevice))
			{
				inputControlScheme = controlScheme;
				break;
			}
		}
		for (int i = 0; i < bindings.Count; i++)
		{
			if (bindings[i].isComposite)
			{
				num = i;
				continue;
			}
			InputControl inputControl = InputSystem.FindControl(bindings[i].path);
			if (inputControl == null)
			{
				continue;
			}
			if (bindings[i].isPartOfComposite)
			{
				for (int j = num + 1; j < bindings.Count && bindings[j].isPartOfComposite; j++)
				{
					if (j > num + 1)
					{
						text += " + ";
					}
					text += bindings[j].ToDisplayString() ?? "?";
				}
				return text;
			}
			if (inputControlScheme.SupportsDevice(inputControl.device))
			{
				return bindings[i].ToDisplayString();
			}
		}
		if (queue.Count == 0)
		{
			return "";
		}
		Debug.Log(queue.Count);
		string text2 = queue.Dequeue() ?? "";
		while (queue.Count > 0)
		{
			text2 = text2 + "/" + queue.Dequeue();
		}
		return text2;
	}
}



public class InstantiateObject : MonoBehaviour
{
	[SerializeField]
	private bool instantiateOnEnable = true;

	[SerializeField]
	private GameObject source;

	[SerializeField]
	private InstantiateObjectMode mode;

	[SerializeField]
	private bool removePreviousOnInstantiate = true;

	[SerializeField]
	private bool reParent = true;

	[SerializeField]
	private bool useOwnPosition = true;

	[SerializeField]
	private bool useOwnRotation = true;

	[SerializeField]
	private bool combineRotations;

	[SerializeField]
	private bool parentToGoreZone;

	private GoreZone gz;

	private List<GameObject> createdObjects = new List<GameObject>();

	private void OnEnable()
	{
		if (instantiateOnEnable)
		{
			Instantiate();
		}
	}

	public void Instantiate()
	{
		if (removePreviousOnInstantiate)
		{
			foreach (GameObject createdObject in createdObjects)
			{
				Object.Destroy(createdObject);
			}
			createdObjects.Clear();
		}
		GameObject gameObject = Object.Instantiate(source);
		if (useOwnPosition)
		{
			gameObject.transform.position = base.transform.position;
		}
		if (useOwnRotation)
		{
			if (combineRotations)
			{
				gameObject.transform.rotation *= base.transform.rotation;
			}
			else
			{
				gameObject.transform.rotation = base.transform.rotation;
			}
		}
		if (reParent)
		{
			gameObject.transform.SetParent(base.transform);
			if (useOwnPosition)
			{
				gameObject.transform.localPosition = Vector3.zero;
			}
			if (useOwnRotation)
			{
				gameObject.transform.localRotation = Quaternion.identity;
			}
		}
		createdObjects.Add(gameObject);
		switch (mode)
		{
		case InstantiateObjectMode.ForceDisable:
			gameObject.SetActive(value: false);
			break;
		case InstantiateObjectMode.ForceEnable:
			gameObject.SetActive(value: true);
			break;
		}
		if (parentToGoreZone)
		{
			if (gz == null)
			{
				gz = GoreZone.ResolveGoreZone(base.transform);
			}
			gameObject.transform.SetParent(gz.transform, worldPositionStays: true);
		}
	}
}


public enum InstantiateObjectMode
{
	Normal,
	ForceEnable,
	ForceDisable
}



public class IntermissionController : MonoBehaviour
{
	private Text txt;

	private string fullString;

	private string tempString;

	private StringBuilder sb;

	private AudioSource aud;

	private float origPitch;

	private bool waitingForInput;

	private bool skipToInput;

	public UnityEvent onTextEvent;

	public UnityEvent onComplete;

	public string preText;

	private bool restart;

	private void Start()
	{
		txt = GetComponent<Text>();
		fullString = txt.text;
		txt.text = "";
		aud = GetComponent<AudioSource>();
		origPitch = aud.pitch;
		StartCoroutine(TextAppear());
	}

	private void OnDisable()
	{
		restart = true;
	}

	private void OnEnable()
	{
		if (restart)
		{
			restart = false;
			StartCoroutine(TextAppear());
		}
	}

	private void Update()
	{
		if (MonoSingleton<OptionsManager>.Instance.paused)
		{
			return;
		}
		if (waitingForInput)
		{
			if (Input.GetKeyDown(KeyCode.Mouse0) || MonoSingleton<InputManager>.Instance == null || (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame) || Input.GetKey(KeyCode.Space) || MonoSingleton<InputManager>.Instance.InputSource.Dodge.IsPressed || (Gamepad.current != null && Gamepad.current.aButton.wasPressedThisFrame))
			{
				waitingForInput = false;
			}
		}
		else if (Input.GetKeyDown(KeyCode.Mouse0) || MonoSingleton<InputManager>.Instance == null || (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame) || Input.GetKey(KeyCode.Space) || MonoSingleton<InputManager>.Instance.InputSource.Dodge.IsPressed || (Gamepad.current != null && Gamepad.current.aButton.wasPressedThisFrame))
		{
			skipToInput = true;
		}
	}

	private IEnumerator TextAppear()
	{
		int j = fullString.Length;
		for (int i = 0; i < j; i++)
		{
			char c = fullString[i];
			float waitTime = 0.05f;
			bool playSound = true;
			if (MonoSingleton<OptionsManager>.Instance.paused)
			{
				yield return new WaitUntil(() => MonoSingleton<OptionsManager>.Instance == null || !MonoSingleton<OptionsManager>.Instance.paused);
			}
			switch (c)
			{
			case '':
				sb = new StringBuilder(fullString);
				sb[i] = ' ';
				fullString = sb.ToString();
				txt.text = preText + fullString.Substring(0, i);
				tempString = txt.text;
				skipToInput = false;
				waitingForInput = true;
				StartCoroutine(DotAppear());
				yield return new WaitUntil(() => !waitingForInput || !base.gameObject.scene.isLoaded);
				break;
			case '}':
				sb = new StringBuilder(fullString);
				sb[i] = ' ';
				fullString = sb.ToString();
				playSound = false;
				waitTime = 0f;
				txt.text = preText + fullString.Substring(0, i);
				onTextEvent?.Invoke();
				break;
			case ' ':
				waitTime = 0f;
				txt.text = preText + fullString.Substring(0, i);
				break;
			default:
				txt.text = preText + fullString.Substring(0, i);
				break;
			}
			j = fullString.Length;
			if (waitTime != 0f && playSound)
			{
				aud.pitch = Random.Range(origPitch - 0.05f, origPitch + 0.05f);
				aud.Play();
			}
			if (skipToInput)
			{
				waitTime = 0f;
			}
			yield return new WaitForSecondsRealtime(waitTime);
		}
		onComplete?.Invoke();
	}

	private IEnumerator DotAppear()
	{
		while (waitingForInput)
		{
			if (MonoSingleton<OptionsManager>.Instance.paused)
			{
				yield return new WaitUntil(() => !MonoSingleton<OptionsManager>.Instance.paused || !base.gameObject.scene.isLoaded);
			}
			txt.text = tempString + "<color=black></color>";
			yield return new WaitForSecondsRealtime(0.25f);
			if (waitingForInput)
			{
				txt.text = tempString + "";
				yield return new WaitForSecondsRealtime(0.25f);
			}
		}
	}
}



[Serializable]
public struct IntermissionRelation
{
	public string intermissionScene;

	public int nextLevelIndex;
}



public static class InternalDebug
{
	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void Assert(bool condition)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void Assert(bool condition, UnityEngine.Object context)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void Assert(bool condition, object message)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void Assert(bool condition, object message, UnityEngine.Object context)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void AssertFormat(bool condition, string format, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void AssertFormat(bool condition, UnityEngine.Object context, string format, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void Break()
	{
		UnityEngine.Debug.Break();
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void ClearDeveloperConsole()
	{
		UnityEngine.Debug.ClearDeveloperConsole();
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void DrawLine(Vector3 start, Vector3 end, Color color = default(Color), float duration = 0f, bool depthTest = true)
	{
		UnityEngine.Debug.DrawLine(start, end, color, duration, depthTest);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void DrawRay(Vector3 start, Vector3 dir, Color color = default(Color), float duration = 0f, bool depthTest = true)
	{
		UnityEngine.Debug.DrawRay(start, dir, color, duration, depthTest);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void Log(object message, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.Log(message);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void Log(object message, UnityEngine.Object context, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.Log(message, context);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertion(object message, bool condition = true)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertion(object message, UnityEngine.Object context, bool condition = true)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertionFormat(string format, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertionFormat(string format, bool condition = true, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertionFormat(UnityEngine.Object context, string format, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	[Conditional("UNITY_ASSERTIONS")]
	public static void LogAssertionFormat(UnityEngine.Object context, string format, bool condition = true, params object[] args)
	{
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogError(object message, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogError(message);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogError(object message, UnityEngine.Object context, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogError(message, context);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogErrorFormat(string format, params object[] args)
	{
		UnityEngine.Debug.LogErrorFormat(format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogErrorFormat(string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogErrorFormat(format, args);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
	{
		UnityEngine.Debug.LogErrorFormat(context, format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogErrorFormat(UnityEngine.Object context, string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogErrorFormat(context, format, args);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogException(Exception exception, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogException(Exception exception, UnityEngine.Object context, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogException(exception, context);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogFormat(string format, params object[] args)
	{
		UnityEngine.Debug.LogFormat(format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogFormat(string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogFormat(format, args);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
	{
		UnityEngine.Debug.LogFormat(context, format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogFormat(UnityEngine.Object context, string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogFormat(context, format, args);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarning(object message, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogWarning(message);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarning(object message, UnityEngine.Object context, bool condition = true)
	{
		if (condition)
		{
			UnityEngine.Debug.LogWarning(message, context);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarningFormat(string format, params object[] args)
	{
		UnityEngine.Debug.LogWarningFormat(format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarningFormat(string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogWarningFormat(format, args);
		}
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarningFormat(UnityEngine.Object context, string format, params object[] args)
	{
		UnityEngine.Debug.LogWarningFormat(context, format, args);
	}

	[Conditional("DEVELOPMENT_BUILD")]
	[Conditional("UNITY_EDITOR")]
	public static void LogWarningFormat(UnityEngine.Object context, string format, bool condition = true, params object[] args)
	{
		if (condition)
		{
			UnityEngine.Debug.LogWarningFormat(context, format, args);
		}
	}
}



public class IntroText : MonoBehaviour
{
	private TMP_Text txt;

	private string fullString;

	private string tempString;

	private StringBuilder sb;

	private bool doneWithDots;

	private bool readyToContinue;

	private bool waitingForInput;

	private AudioSource aud;

	private int dotsAmount = 3;

	private int calibrated;

	public GameObject[] calibrationWindows;

	public GameObject[] activateOnEnd;

	public GameObject[] deactivateOnEnd;

	public GameObject[] activateOnTextTrigger;

	private string colorString;

	private List<int> colorsPositions = new List<int>();

	private List<int> colorsClosePositions = new List<int>();

	private void Start()
	{
		txt = GetComponent<TMP_Text>();
		fullString = txt.text;
		aud = GetComponent<AudioSource>();
		StartCoroutine(TextAppear());
	}

	private void Update()
	{
		if (!waitingForInput)
		{
			return;
		}
		if (!Input.GetKeyDown(KeyCode.Y))
		{
			Gamepad current = Gamepad.current;
			if (current == null || !current.buttonSouth.wasPressedThisFrame)
			{
				if (!Input.GetKeyDown(KeyCode.N))
				{
					Gamepad current2 = Gamepad.current;
					if (current2 == null || !current2.buttonEast.wasPressedThisFrame)
					{
						return;
					}
				}
				Over();
				return;
			}
		}
		waitingForInput = false;
	}

	public void DoneWithSetting()
	{
		calibrationWindows[calibrated].SetActive(value: false);
		calibrated++;
		readyToContinue = true;
	}

	private IEnumerator TextAppear()
	{
		int j = fullString.Length;
		for (int i = 0; i < j; i++)
		{
			char c = fullString[i];
			float waitTime = 0.035f;
			bool playSound = true;
			char c2 = c;
			if (c == IntroTextOperators.PauseWithEllipsis)
			{
				sb = new StringBuilder(fullString);
				sb[i] = ' ';
				fullString = sb.ToString();
				txt.text = fullString.Substring(0, i);
				tempString = txt.text;
				doneWithDots = false;
				dotsAmount = 2;
				StartCoroutine(DotsAppear());
				yield return new WaitUntil(() => doneWithDots);
			}
			else if (c == IntroTextOperators.ShortPauseWithEllipsis)
			{
				sb = new StringBuilder(fullString);
				sb[i] = ' ';
				fullString = sb.ToString();
				txt.text = fullString.Substring(0, i);
				tempString = txt.text;
				doneWithDots = false;
				dotsAmount = 1;
				StartCoroutine(DotsAppear());
				yield return new WaitUntil(() => doneWithDots);
			}
			else if (c != IntroTextOperators.Pause)
			{
				if (c2 == ' ')
				{
					waitTime = 0f;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.DrawYes)
				{
					sb = new StringBuilder(fullString);
					if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
					{
						if (Gamepad.current.buttonSouth.displayName == "Cross")
						{
							sb[i] = 'X';
						}
						else
						{
							sb[i] = 'A';
						}
					}
					else
					{
						sb[i] = 'Y';
					}
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.DrawNo)
				{
					sb = new StringBuilder(fullString);
					if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
					{
						if (Gamepad.current.buttonEast.displayName == "Circle")
						{
							sb[i] = 'O';
						}
						else
						{
							sb[i] = 'B';
						}
					}
					else
					{
						sb[i] = 'N';
					}
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.WaitForYesNo)
				{
					waitTime = 0f;
					sb = new StringBuilder(fullString);
					sb[i] = ' ';
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i);
					waitingForInput = true;
					yield return new WaitUntil(() => !waitingForInput);
				}
				else if (c == IntroTextOperators.ActivateOnTextTrigger)
				{
					waitTime = 0f;
					sb = new StringBuilder(fullString);
					sb[i] = ' ';
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i);
					GameObject[] array = activateOnTextTrigger;
					for (int k = 0; k < array.Length; k++)
					{
						array[k].SetActive(value: true);
					}
				}
				else if (c == IntroTextOperators.EndIntro)
				{
					GetComponentInParent<IntroTextController>().introOver = true;
					GameProgressSaver.SetIntro(seen: true);
					waitTime = 0f;
					sb = new StringBuilder(fullString);
					sb[i] = ' ';
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.ShowCalibrationMenu)
				{
					sb = new StringBuilder(fullString);
					sb[i] = ' ';
					fullString = sb.ToString();
					txt.text = fullString.Substring(0, i) + "<color=red>ERROR</color>";
					yield return new WaitForSecondsRealtime(1f);
					calibrationWindows[calibrated].SetActive(value: true);
					readyToContinue = false;
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
					yield return new WaitUntil(() => readyToContinue);
					Cursor.lockState = CursorLockMode.Locked;
					Cursor.visible = false;
					tempString = "<color=green>OK</color>";
					fullString = fullString.Insert(i, tempString);
					i += tempString.Length;
					_ = j + tempString.Length;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.BeginColorRed)
				{
					colorString = "<color=red>";
					PlaceColor(i);
					i += colorString.Length;
					_ = j + colorString.Length;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.BeginColorGreen)
				{
					colorString = "<color=green>";
					PlaceColor(i);
					i += colorString.Length;
					_ = j + colorString.Length;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.BeginColorGrey)
				{
					colorString = "<color=grey>";
					PlaceColor(i);
					i += colorString.Length;
					_ = j + colorString.Length;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.BeginColorBlue)
				{
					colorString = "<color=#4C99E6>";
					PlaceColor(i);
					i += colorString.Length;
					_ = j + colorString.Length;
					txt.text = fullString.Substring(0, i);
				}
				else if (c == IntroTextOperators.EndColor)
				{
					colorsClosePositions.Add(i);
					sb = new StringBuilder(fullString);
					sb[i] = ' ';
					fullString = sb.ToString();
					string text = "</color>";
					fullString = fullString.Insert(i, text);
					i += text.Length;
					_ = j + text.Length;
					txt.text = fullString.Substring(0, i);
				}
				else
				{
					txt.text = fullString.Substring(0, i);
				}
			}
			else
			{
				sb = new StringBuilder(fullString);
				sb[i] = ' ';
				fullString = sb.ToString();
				playSound = false;
				waitTime = 0.75f;
				txt.text = fullString.Substring(0, i);
			}
			j = fullString.Length;
			if (waitTime != 0f && playSound)
			{
				aud.Play();
			}
			if (colorsPositions.Count > colorsClosePositions.Count)
			{
				txt.text += "</color>";
			}
			yield return new WaitForSecondsRealtime(waitTime);
		}
		Over();
	}

	private void PlaceColor(int i)
	{
		colorsPositions.Add(i);
		sb = new StringBuilder(fullString);
		sb[i] = ' ';
		fullString = sb.ToString();
		fullString = fullString.Insert(i, colorString);
	}

	private void Over()
	{
		GameObject[] array = activateOnEnd;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		array = deactivateOnEnd;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	private IEnumerator DotsAppear()
	{
		for (int i = 0; i < dotsAmount; i++)
		{
			txt.text = tempString;
			aud.Play();
			yield return new WaitForSecondsRealtime(0.25f);
			txt.text = tempString + ".";
			aud.Play();
			yield return new WaitForSecondsRealtime(0.25f);
			txt.text = tempString + "..";
			aud.Play();
			yield return new WaitForSecondsRealtime(0.25f);
			txt.text = tempString + "...";
			aud.Play();
			yield return new WaitForSecondsRealtime(0.25f);
		}
		doneWithDots = true;
	}
}



public class IntroTextChecker : MonoBehaviour
{
	public GameObject firstTime;

	public GameObject secondTime;

	private void Awake()
	{
		if (GameProgressSaver.GetIntro())
		{
			secondTime.SetActive(value: true);
		}
		else
		{
			firstTime.SetActive(value: true);
		}
		base.gameObject.SetActive(value: false);
	}
}



public class IntroTextController : MonoBehaviour
{
	public bool firstTime;

	public GameObject page1Screen;

	public GameObject page1SecondTimeScreen;

	public GameObject page2Screen;

	public GameObject page2NoFade;

	public GameObject[] deactivateOnIntroEnd;

	public Slider soundSlider;

	public Slider sfxSlider;

	public Slider musicSlider;

	private AudioMixer[] audmix;

	private Image img;

	private TMP_Text page2Text;

	private float fadeValue;

	private bool inMenu;

	public bool introOver;

	private float introOverWait = 1f;

	private Rigidbody rb;

	private void Awake()
	{
		audmix = new AudioMixer[2]
		{
			MonoSingleton<AudioMixerController>.Instance.allSound,
			MonoSingleton<AudioMixerController>.Instance.musicSound
		};
		firstTime = !GameProgressSaver.GetIntro();
		if (firstTime && !OptionsMenuToManager.introCheckComplete)
		{
			soundSlider.value = 100f;
			sfxSlider.value = 0f;
			musicSlider.value = 0f;
			MonoSingleton<PrefsManager>.Instance.SetFloat("allVolume", 1f);
			MonoSingleton<PrefsManager>.Instance.SetFloat("musicVolume", 0f);
			MonoSingleton<PrefsManager>.Instance.SetFloat("sfxVolume", 0f);
			page1Screen.SetActive(value: true);
		}
		else
		{
			soundSlider.value = MonoSingleton<PrefsManager>.Instance.GetFloat("allVolume") * 100f;
			sfxSlider.value = MonoSingleton<PrefsManager>.Instance.GetFloat("sfxVolume") * 100f;
			musicSlider.value = MonoSingleton<PrefsManager>.Instance.GetFloat("musicVolume") * 100f;
			page1SecondTimeScreen.SetActive(value: true);
		}
	}

	public void DoneWithSetting()
	{
		if (page1Screen.activeSelf)
		{
			page1Screen.GetComponent<IntroText>().DoneWithSetting();
		}
		if (page1SecondTimeScreen.activeSelf)
		{
			page1SecondTimeScreen.GetComponent<IntroText>().DoneWithSetting();
		}
	}

	private void Start()
	{
		float value = 0f;
		audmix[0].GetFloat("allVolume", out value);
		Debug.Log("Mixer Volume " + value);
		AudioMixer[] array = audmix;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetFloat("allVolume", -80f);
		}
		audmix[0].GetFloat("allVolume", out value);
		Debug.Log("Mixer Volume " + value);
		Invoke("SlowDown", 0.1f);
		MonoSingleton<OptionsManager>.Instance.inIntro = true;
		rb = MonoSingleton<NewMovement>.Instance.GetComponent<Rigidbody>();
		rb.velocity = Vector3.zero;
		rb.useGravity = false;
	}

	private void SlowDown()
	{
		inMenu = true;
	}

	private void Update()
	{
		if (inMenu)
		{
			rb.velocity = Vector3.zero;
			rb.useGravity = false;
			if (page2Screen.activeSelf)
			{
				MonoSingleton<NewMovement>.Instance.GetComponent<Rigidbody>().useGravity = true;
				inMenu = false;
			}
			if (!firstTime && MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame)
			{
				inMenu = false;
				introOver = true;
			}
		}
		else
		{
			if (!introOver)
			{
				return;
			}
			if (!img)
			{
				img = GetComponent<Image>();
				page2Text = page2Screen.GetComponent<TMP_Text>();
				fadeValue = 1f;
				page2NoFade.SetActive(value: true);
				MonoSingleton<AudioMixerController>.Instance.forceOff = false;
			}
			if (fadeValue > 0f)
			{
				fadeValue = Mathf.MoveTowards(fadeValue, 0f, Time.deltaTime * 0.375f);
				Color color = img.color;
				color.a = fadeValue;
				img.color = color;
				AudioMixer[] array = audmix;
				foreach (AudioMixer audioMixer in array)
				{
					float value = 0f;
					audioMixer.GetFloat("allVolume", out value);
					if (audioMixer == MonoSingleton<AudioMixerController>.Instance.musicSound && MonoSingleton<AudioMixerController>.Instance.musicVolume > 0f)
					{
						audioMixer.SetFloat("allVolume", Mathf.MoveTowards(value, Mathf.Log10(MonoSingleton<AudioMixerController>.Instance.musicVolume) * 20f, Time.deltaTime * Mathf.Abs(value)));
					}
					else if (audioMixer == MonoSingleton<AudioMixerController>.Instance.allSound)
					{
						audioMixer.SetFloat("allVolume", Mathf.MoveTowards(value, Mathf.Log10(MonoSingleton<AudioMixerController>.Instance.sfxVolume) * 20f, Time.deltaTime * Mathf.Abs(value)));
					}
				}
				color = page2Text.color;
				color.a = fadeValue;
				page2Text.color = color;
			}
			else if (introOverWait > 0f)
			{
				if (introOverWait == 1f)
				{
					AudioMixer[] array = audmix;
					foreach (AudioMixer audioMixer2 in array)
					{
						if (audioMixer2 == MonoSingleton<AudioMixerController>.Instance.musicSound && MonoSingleton<AudioMixerController>.Instance.musicVolume > 0f)
						{
							audioMixer2.SetFloat("allVolume", Mathf.Log10(MonoSingleton<AudioMixerController>.Instance.musicVolume) * 20f);
						}
						else if (audioMixer2 == MonoSingleton<AudioMixerController>.Instance.allSound && MonoSingleton<AudioMixerController>.Instance.sfxVolume > 0f)
						{
							audioMixer2.SetFloat("allVolume", Mathf.Log10(MonoSingleton<AudioMixerController>.Instance.sfxVolume) * 20f);
						}
					}
				}
				introOverWait = Mathf.MoveTowards(introOverWait, 0f, Time.deltaTime);
			}
			else
			{
				MonoSingleton<OptionsManager>.Instance.inIntro = false;
				GameObject[] array2 = deactivateOnIntroEnd;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].SetActive(value: false);
				}
			}
		}
	}
}


public static class IntroTextOperators
{
	public static class Defaults
	{
		public const char PauseWithEllipsis = '';

		public const char ShortPauseWithEllipsis = '#';

		public const char Pause = '';

		public const char DrawYes = '';

		public const char DrawNo = '';

		public const char WaitForYesNo = '~';

		public const char ActivateOnTextTrigger = '@';

		public const char EndIntro = '&';

		public const char ShowCalibrationMenu = '';

		public const char BeginColorRed = '*';

		public const char BeginColorGreen = '+';

		public const char BeginColorGrey = '^';

		public const char BeginColorBlue = '';

		public const char EndColor = '_';
	}

	public static char PauseWithEllipsis = '';

	public static char ShortPauseWithEllipsis = '#';

	public static char Pause = '';

	public static char DrawYes = '';

	public static char DrawNo = '';

	public static char WaitForYesNo = '~';

	public static char ActivateOnTextTrigger = '@';

	public static char EndIntro = '&';

	public static char ShowCalibrationMenu = '';

	public static char BeginColorRed = '*';

	public static char BeginColorGreen = '+';

	public static char BeginColorGrey = '^';

	public static char BeginColorBlue = '';

	public static char EndColor = '_';
}



public class IntroViolenceScreen : MonoBehaviour
{
	private Image img;

	private float fadeAmount;

	private bool fade;

	private float targetAlpha = 1f;

	private VideoPlayer vp;

	private bool videoOver;

	[SerializeField]
	private GameObject loadingScreen;

	private bool shouldLoadTutorial;

	private bool bundlesLoaded;

	private void Start()
	{
		img = GetComponent<Image>();
		vp = GetComponent<VideoPlayer>();
		vp.SetDirectAudioVolume(0, MonoSingleton<PrefsManager>.Instance.GetFloat("allVolume") / 2f);
		if ((bool)loadingScreen && loadingScreen.TryGetComponent<AudioSource>(out var component))
		{
			component.volume = MonoSingleton<PrefsManager>.Instance.GetFloat("allVolume") / 2f;
		}
		Application.targetFrameRate = Screen.currentResolution.refreshRate;
		QualitySettings.vSyncCount = (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("vSync") ? 1 : 0);
		Cursor.lockState = CursorLockMode.None;
		Cursor.visible = false;
	}

	private string GetTargetScene()
	{
		shouldLoadTutorial = !GameProgressSaver.GetIntro() || !GameProgressSaver.GetTutorial();
		if (!shouldLoadTutorial)
		{
			return "Main Menu";
		}
		return "Tutorial";
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))
		{
			Skip();
		}
		if (Gamepad.current != null && (Gamepad.current.startButton.wasPressedThisFrame || Gamepad.current.buttonSouth.wasPressedThisFrame))
		{
			Skip();
		}
		if (!videoOver && vp.isPaused)
		{
			videoOver = true;
			vp.Stop();
			Invoke("FadeOut", 1f);
		}
		if (!fade)
		{
			return;
		}
		fadeAmount = Mathf.MoveTowards(fadeAmount, targetAlpha, Time.deltaTime);
		Color color = img.color;
		color.a = fadeAmount;
		img.color = color;
		if (fadeAmount == targetAlpha)
		{
			if (fadeAmount == 1f)
			{
				fade = false;
				targetAlpha = 0f;
				Invoke("FadeOut", 3f);
			}
			else
			{
				SceneHelper.LoadScene(GetTargetScene());
				base.enabled = false;
			}
		}
	}

	private void Skip()
	{
		if (vp.isPlaying)
		{
			vp.Stop();
			Invoke("FadeOut", 1f);
		}
		else if (fade)
		{
			targetAlpha = 0f;
		}
		else
		{
			CancelInvoke("FadeOut");
			targetAlpha = 0f;
			fade = true;
		}
	}

	private void FadeOut()
	{
		fade = true;
	}
}



public class InvertCorrection : MonoBehaviour
{
	public bool invert;

	public bool checkX = true;

	public bool checkY = true;

	public bool checkZ = true;

	private void Update()
	{
		Vector3 lossyScale = base.transform.lossyScale;
		Vector3 localScale = base.transform.localScale;
		if (invert)
		{
			if (checkX && lossyScale.x > 0f)
			{
				localScale.x *= -1f;
			}
			if (checkY && lossyScale.y > 0f)
			{
				localScale.y *= -1f;
			}
			if (checkZ && lossyScale.z > 0f)
			{
				localScale.z *= -1f;
			}
		}
		else
		{
			if (checkX && lossyScale.x < 0f)
			{
				localScale.x *= -1f;
			}
			if (checkY && lossyScale.y < 0f)
			{
				localScale.y *= -1f;
			}
			if (checkZ && lossyScale.z < 0f)
			{
				localScale.z *= -1f;
			}
		}
		base.transform.localScale = localScale;
	}
}



public class InvisibleBrush : MonoBehaviour
{
	[SerializeField]
	private Renderer renderer;

	private void Update()
	{
		bool anyArmActive = SummonSandboxArm.AnyArmActive;
		if (renderer.enabled != anyArmActive)
		{
			renderer.enabled = anyArmActive;
		}
	}
}



public interface IPlaceholdableComponent
{
	void WillReplace(GameObject oldObject, GameObject newObject, bool isSelfBeingReplaced);
}


public interface ISandboxArmDebugGUI
{
	bool OnGUI();
}



public class ItemIdentifier : MonoBehaviour
{
	public bool infiniteSource;

	public bool pickedUp;

	[HideInInspector]
	public bool beenPickedUp;

	public bool reverseTransformSettings;

	public Vector3 putDownPosition;

	public Vector3 putDownRotation;

	public Vector3 putDownScale = Vector3.one;

	public GameObject pickUpSound;

	public ItemType itemType;

	public bool noHoldingAnimation;

	[HideInInspector]
	public bool hooked;

	[HideInInspector]
	public ItemPlaceZone ipz;

	public UltrakillEvent onPickUp;

	public UltrakillEvent onPutDown;

	public ItemIdentifier CreateCopy()
	{
		if (this == null)
		{
			return null;
		}
		ItemIdentifier itemIdentifier = Object.Instantiate(this);
		itemIdentifier.infiniteSource = false;
		itemIdentifier.pickedUp = false;
		itemIdentifier.beenPickedUp = false;
		itemIdentifier.hooked = false;
		return itemIdentifier;
	}

	private void PickUp()
	{
		onPickUp?.Invoke();
	}

	private void PutDown()
	{
		onPutDown?.Invoke();
	}

	public void ForcePutDown(ItemPlaceZone target)
	{
		if (MonoSingleton<FistControl>.Instance.currentPunch.heldItem == this)
		{
			MonoSingleton<PlayerUtilities>.Instance.PlaceHeldObject(target);
		}
	}
}



public class ItemlessChecker : MonoBehaviour
{
	private ItemIdentifier itid;

	private bool failed;

	private void Start()
	{
		MonoSingleton<ChallengeDoneByDefault>.Instance.Prepare();
	}

	private void Update()
	{
		if (!failed)
		{
			if (itid == null)
			{
				itid = GetComponent<ItemIdentifier>();
			}
			if (itid != null && itid.pickedUp)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeFailed = true;
				MonoSingleton<ChallengeManager>.Instance.challengeFailedPermanently = true;
				failed = true;
			}
		}
	}
}



public class ItemPlaceZone : MonoBehaviour
{
	private bool acceptedItemPlaced;

	public ItemType acceptedItemType;

	public GameObject[] activateOnSuccess;

	public GameObject[] deactivateOnSuccess;

	public GameObject[] activateOnFailure;

	public Door[] doors;

	public Door[] reverseDoors;

	public ArenaStatus[] arenaStatuses;

	public ArenaStatus[] reverseArenaStatuses;

	private Collider col;

	private List<Bounds> doorsBounds = new List<Bounds>();

	private List<Bounds> reverseDoorsBounds = new List<Bounds>();

	public GameObject boundsError;

	private void Start()
	{
		col = GetComponent<Collider>();
		ColorDoors(doors);
		ColorDoors(reverseDoors);
		CheckItem(prelim: true);
	}

	private void Awake()
	{
		GetDoorBounds(doors, doorsBounds);
		GetDoorBounds(reverseDoors, reverseDoorsBounds);
	}

	private void GetDoorBounds(Door[] doors, List<Bounds> boundies)
	{
		if (doors.Length == 0)
		{
			return;
		}
		for (int i = 0; i < doors.Length; i++)
		{
			if (doors[i].ignoreHookCheck)
			{
				continue;
			}
			List<Collider> list = new List<Collider>();
			if (doors[i].doorType == DoorType.Normal)
			{
				Collider[] componentsInChildren = doors[i].GetComponentsInChildren<Collider>();
				foreach (Collider item in componentsInChildren)
				{
					list.Add(item);
				}
			}
			else if (doors[i].doorType == DoorType.BigDoorController)
			{
				BigDoor[] componentsInChildren2 = doors[i].GetComponentsInChildren<BigDoor>();
				for (int j = 0; j < componentsInChildren2.Length; j++)
				{
					Collider[] componentsInChildren = componentsInChildren2[j].GetComponentsInChildren<Collider>();
					foreach (Collider item2 in componentsInChildren)
					{
						list.Add(item2);
					}
				}
			}
			else if (doors[i].doorType == DoorType.SubDoorController)
			{
				SubDoor[] componentsInChildren3 = doors[i].GetComponentsInChildren<SubDoor>();
				for (int j = 0; j < componentsInChildren3.Length; j++)
				{
					Collider[] componentsInChildren = componentsInChildren3[j].GetComponentsInChildren<Collider>();
					foreach (Collider item3 in componentsInChildren)
					{
						list.Add(item3);
					}
				}
			}
			if (list.Count > 0)
			{
				Bounds bounds = list[0].bounds;
				if (list.Count > 1)
				{
					for (int l = 1; l < list.Count; l++)
					{
						bounds.Encapsulate(list[l].bounds);
					}
				}
				boundies.Add(bounds);
			}
			else
			{
				boundies.Add(new Bounds(Vector3.zero, Vector3.zero));
			}
		}
	}

	public bool CheckDoorBounds(Vector3 origin, Vector3 end, bool reverseBounds)
	{
		bool result = true;
		foreach (Bounds item in reverseBounds ? reverseDoorsBounds : doorsBounds)
		{
			if (item.IntersectRay(new Ray(origin, end - origin), out var distance) && distance < Vector3.Distance(origin, end) + 1f)
			{
				Object.Instantiate(boundsError, item.center, Quaternion.identity).transform.localScale = item.size * 1.1f;
				result = false;
			}
		}
		return result;
	}

	private void ColorDoors(Door[] drs)
	{
		foreach (Door door in drs)
		{
			switch (acceptedItemType)
			{
			case ItemType.SkullBlue:
				door.defaultLightsColor = new Color(0f, 0.75f, 1f);
				break;
			case ItemType.SkullRed:
				door.defaultLightsColor = new Color(1f, 0.2f, 0.2f);
				break;
			case ItemType.SkullGreen:
				door.defaultLightsColor = new Color(0.25f, 1f, 0.25f);
				break;
			}
			if (!door.noPass || !door.noPass.activeSelf)
			{
				door.ChangeColor(door.defaultLightsColor);
			}
			door.AltarControlled();
		}
	}

	public void CheckItem(bool prelim = false)
	{
		ItemIdentifier componentInChildren = GetComponentInChildren<ItemIdentifier>();
		GameObject[] array;
		Door[] array2;
		if (componentInChildren != null)
		{
			if (componentInChildren.itemType == acceptedItemType)
			{
				acceptedItemPlaced = true;
				componentInChildren.ipz = this;
				array = activateOnSuccess;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: true);
				}
				array = deactivateOnSuccess;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
				array2 = doors;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].Open(enemy: false, skull: true);
				}
				array2 = reverseDoors;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].Close();
				}
				if (!prelim)
				{
					ArenaStatus[] array3 = arenaStatuses;
					for (int i = 0; i < array3.Length; i++)
					{
						array3[i].currentStatus++;
					}
					array3 = reverseArenaStatuses;
					for (int i = 0; i < array3.Length; i++)
					{
						array3[i].currentStatus--;
					}
				}
			}
			else
			{
				array = activateOnFailure;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: true);
				}
			}
			if ((bool)col)
			{
				col.enabled = false;
			}
			return;
		}
		if ((bool)col)
		{
			col.enabled = true;
		}
		if (!prelim && !acceptedItemPlaced)
		{
			return;
		}
		array = activateOnSuccess;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = activateOnFailure;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = deactivateOnSuccess;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		array2 = doors;
		foreach (Door door in array2)
		{
			if (door.doorType != 0 || door.transform.localPosition != door.closedPos)
			{
				door.Close();
			}
		}
		array2 = reverseDoors;
		foreach (Door door2 in array2)
		{
			if (door2.doorType != 0 || door2.transform.localPosition != door2.closedPos + door2.openPos)
			{
				door2.Open(enemy: false, skull: true);
			}
		}
		if (!prelim)
		{
			acceptedItemPlaced = false;
			ArenaStatus[] array3 = arenaStatuses;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].currentStatus--;
			}
			array3 = reverseArenaStatuses;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].currentStatus++;
			}
		}
	}
}



public class ItemTrigger : MonoBehaviour
{
	public ItemType targetType;

	public bool oneTime;

	private bool activated;

	public bool destroyActivator;

	public bool dontRequireItemLayer;

	public UltrakillEvent onEvent;

	private void OnTriggerEnter(Collider other)
	{
		if ((!oneTime || !activated) && (dontRequireItemLayer || other.gameObject.layer == 22) && (other.attachedRigidbody ? other.attachedRigidbody.TryGetComponent<ItemIdentifier>(out var component) : other.TryGetComponent<ItemIdentifier>(out component)) && component.itemType == targetType)
		{
			activated = true;
			onEvent?.Invoke();
			if (destroyActivator)
			{
				Object.Destroy(component.gameObject);
			}
		}
	}
}


public enum ItemType
{
	None = 0,
	SkullBlue = 1,
	SkullRed = 2,
	SkullGreen = 3,
	Readable = 4,
	Torch = 5,
	Soap = 6,
	Breakable = 10,
	CustomKey1 = 7,
	CustomKey2 = 8,
	CustomKey3 = 9
}



public class JsonBinding
{
	public string path;

	[JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
	public bool isComposite;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public Dictionary<string, string> parts;

	private JsonBinding()
	{
	}

	public static List<JsonBinding> FromAction(InputAction action, string group)
	{
		List<JsonBinding> list = new List<JsonBinding>();
		for (int i = 0; i < action.bindings.Count; i++)
		{
			InputBinding inputBinding = action.bindings[i];
			JsonBinding jsonBinding = new JsonBinding();
			if (!action.BindingHasGroup(i, group))
			{
				continue;
			}
			if (inputBinding.isComposite)
			{
				jsonBinding.path = inputBinding.GetNameOfComposite();
				jsonBinding.isComposite = true;
				jsonBinding.parts = new Dictionary<string, string>();
				while (i + 1 < action.bindings.Count && action.bindings[i + 1].isPartOfComposite)
				{
					i++;
					InputBinding inputBinding2 = action.bindings[i];
					Debug.Log("BLEURHG " + inputBinding2.name);
					Debug.Log(inputBinding2.path);
					Debug.Log(inputBinding2.isPartOfComposite);
					jsonBinding.parts.Add(inputBinding2.name, inputBinding2.path);
				}
			}
			else
			{
				jsonBinding.path = inputBinding.path;
			}
			list.Add(jsonBinding);
		}
		return list;
	}
}



public class JsonBindingMap
{
	public static readonly Logger Log = new Logger("JsonBindingMap");

	public string controlScheme;

	public static Dictionary<string, string> bindAliases = new Dictionary<string, string>
	{
		{ "Slot 1", "Revolver" },
		{ "Slot 2", "Shotgun" },
		{ "Slot 3", "Nailgun" },
		{ "Slot 4", "Railcannon" },
		{ "Slot 5", "Rocket Launcher" },
		{ "Change Variation", "Next Variation" },
		{ "Last Weapon", "Last Used Weapon" }
	};

	public Dictionary<string, List<JsonBinding>> modifiedActions = new Dictionary<string, List<JsonBinding>>();

	public static JsonBindingMap From(InputActionAsset asset, InputControlScheme scheme)
	{
		JsonBindingMap jsonBindingMap = new JsonBindingMap
		{
			controlScheme = scheme.bindingGroup
		};
		foreach (InputAction item in asset)
		{
			jsonBindingMap.AddAction(item);
		}
		return jsonBindingMap;
	}

	public static JsonBindingMap From(InputActionAsset asset, InputActionAsset baseAsset, InputControlScheme scheme)
	{
		JsonBindingMap jsonBindingMap = new JsonBindingMap
		{
			controlScheme = scheme.bindingGroup
		};
		foreach (InputAction item in asset)
		{
			InputAction baseAction = baseAsset.FindAction(item.id);
			if (!item.IsActionEqual(baseAction, scheme.bindingGroup))
			{
				jsonBindingMap.AddAction(item);
			}
		}
		return jsonBindingMap;
	}

	public void ApplyTo(InputActionAsset asset)
	{
		foreach (KeyValuePair<string, List<JsonBinding>> modifiedAction in modifiedActions)
		{
			string text = modifiedAction.Key;
			List<JsonBinding> value = modifiedAction.Value;
			if (bindAliases.TryGetValue(text, out var value2))
			{
				text = value2;
			}
			InputAction inputAction = asset.FindAction(text);
			if (inputAction == null)
			{
				Log.Warning("Action " + text + " was found in saved bindings, but does not exist (action == null). Ignoring...");
				break;
			}
			inputAction.WipeAction(controlScheme);
			foreach (JsonBinding item in value)
			{
				if (item.isComposite)
				{
					if (item.parts.Count == 0)
					{
						continue;
					}
					InputActionSetupExtensions.CompositeSyntax compositeSyntax = inputAction.AddCompositeBinding(item.path);
					foreach (KeyValuePair<string, string> part in item.parts)
					{
						compositeSyntax.With(part.Key, part.Value, controlScheme);
					}
					inputAction.ChangeBinding(compositeSyntax.bindingIndex).WithGroup(controlScheme);
				}
				else
				{
					inputAction.AddBinding(item.path, null, null, controlScheme);
				}
			}
		}
	}

	public void AddAction(InputAction action)
	{
		modifiedActions.Add(action.name, JsonBinding.FromAction(action, controlScheme));
	}
}



public class JumpPad : MonoBehaviour, IAlter, IAlterOptions<float>
{
	public float force;

	private float origPitch;

	private AudioSource aud;

	public AudioClip launchSound;

	public AudioClip lightLaunchSound;

	public bool forceDirection;

	public bool ignoreSlam;

	public string alterKey => "jump-pad";

	public string alterCategoryName => "Jump Pad";

	public AlterOption<float>[] options => new AlterOption<float>[1]
	{
		new AlterOption<float>
		{
			name = "Force",
			key = "force",
			value = force,
			callback = delegate(float value)
			{
				force = value;
			}
		}
	};

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if ((bool)aud)
		{
			origPitch = aud.pitch;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.isStatic)
		{
			return;
		}
		float num = 1f;
		if (other.gameObject.CompareTag("Player"))
		{
			NewMovement instance = MonoSingleton<NewMovement>.Instance;
			if ((bool)instance && instance.gameObject.activeSelf)
			{
				if (instance.gc.heavyFall && !ignoreSlam)
				{
					num = 1.2f;
				}
				instance.LaunchFromPoint(other.transform.position, 0f);
				if (forceDirection)
				{
					if (instance.sliding)
					{
						instance.StopSlide();
					}
					if (instance.boost)
					{
						instance.boost = false;
					}
				}
			}
			else if ((bool)MonoSingleton<PlatformerMovement>.Instance)
			{
				if (forceDirection)
				{
					MonoSingleton<PlatformerMovement>.Instance.StopSlide();
					MonoSingleton<PlatformerMovement>.Instance.rb.velocity = Vector3.zero;
				}
				MonoSingleton<PlatformerMovement>.Instance.Jump(silent: true, 0f);
			}
		}
		else if (other.gameObject.CompareTag("Enemy"))
		{
			EnemyIdentifier component = other.gameObject.GetComponent<EnemyIdentifier>();
			if (component != null && !component.dead)
			{
				if (component.unbounceable)
				{
					return;
				}
				component.DeliverDamage(other.gameObject, Vector3.up * 10f, other.transform.position, 0f, tryForExplode: false);
			}
		}
		Rigidbody component2 = other.gameObject.GetComponent<Rigidbody>();
		if (!(component2 != null) || component2.isKinematic)
		{
			return;
		}
		Vector3 velocity = component2.velocity;
		if (base.transform.up.x != 0f || forceDirection)
		{
			velocity.x = base.transform.up.x * force * num;
		}
		if (base.transform.up.y != 0f || forceDirection)
		{
			velocity.y = base.transform.up.y * force * num;
		}
		if (base.transform.up.z != 0f || forceDirection)
		{
			velocity.z = base.transform.up.z * force * num;
		}
		component2.velocity = velocity;
		int layer = other.gameObject.layer;
		if (layer == 14)
		{
			other.transform.LookAt(other.transform.position + component2.velocity);
		}
		if ((bool)aud)
		{
			if (layer == 11 || layer == 12 || layer == 2 || layer == 15)
			{
				aud.clip = launchSound;
			}
			else
			{
				aud.clip = lightLaunchSound;
			}
			aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
			aud.Play();
		}
	}
}



public class KeepInBounds : MonoBehaviour
{
	[Serializable]
	private enum UpdateMode
	{
		None,
		Update,
		FixedUpdate,
		LateUpdate
	}

	[SerializeField]
	private bool useColliderCenter;

	[SerializeField]
	private float maxConsideredDistance;

	[SerializeField]
	private UpdateMode updateMode = UpdateMode.Update;

	private Vector3 previousTracedPosition;

	private Vector3 previousRealPosition;

	private Collider col;

	private Vector3 CurrentPosition
	{
		get
		{
			if (!useColliderCenter)
			{
				return base.transform.position;
			}
			return col.bounds.center;
		}
	}

	private void Awake()
	{
		if (useColliderCenter)
		{
			col = GetComponent<Collider>();
			if (col == null)
			{
				Debug.LogWarning("Unfortunately, the Collider component is missing while useColliderCenter is true. Switching to fallback transform.position tracking", base.gameObject);
				useColliderCenter = false;
			}
		}
		previousTracedPosition = CurrentPosition;
		previousRealPosition = base.transform.position;
	}

	private void Update()
	{
		if (updateMode == UpdateMode.Update)
		{
			ValidateMove();
		}
	}

	private void FixedUpdate()
	{
		if (updateMode == UpdateMode.FixedUpdate)
		{
			ValidateMove();
		}
	}

	private void LateUpdate()
	{
		if (updateMode == UpdateMode.LateUpdate)
		{
			ValidateMove();
		}
	}

	public void ForceApproveNewPosition()
	{
		previousTracedPosition = CurrentPosition;
		previousRealPosition = base.transform.position;
	}

	public void ValidateMove()
	{
		Vector3 position = base.transform.position;
		if (maxConsideredDistance != 0f && Vector3.Distance(previousTracedPosition, CurrentPosition) > maxConsideredDistance)
		{
			previousTracedPosition = CurrentPosition;
			previousRealPosition = position;
			return;
		}
		if (Physics.Linecast(previousTracedPosition, CurrentPosition, out var _, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			base.transform.position = previousRealPosition;
		}
		previousTracedPosition = CurrentPosition;
		previousRealPosition = base.transform.position;
	}
}



public class KillAmountChallenge : MonoBehaviour
{
	public int kills;

	private void Update()
	{
		if (MonoSingleton<StatsManager>.Instance.kills == kills)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
		else
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = false;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class KillHitterCache : MonoSingleton<KillHitterCache>
{
	public int neededScore;

	public int currentScore;

	private List<int> eids = new List<int>();

	public bool ignoreRestarts;

	public void OneDone(int enemyId)
	{
		if (eids.Count == 0 || !eids.Contains(enemyId))
		{
			currentScore++;
			eids.Add(enemyId);
			if (currentScore >= neededScore)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
			}
		}
	}

	public void RemoveId(int enemyId)
	{
		if (eids.Contains(enemyId))
		{
			currentScore--;
			eids.Remove(enemyId);
			if (currentScore < neededScore)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeDone = false;
			}
		}
	}
}



public class KillHitterTarget : MonoBehaviour
{
	public string[] acceptedHitters;

	private KillHitterCache khc;

	public int id;

	private EnemyIdentifier eid;

	private bool done;

	private void Start()
	{
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Update()
	{
		if (done || !eid.dead)
		{
			return;
		}
		done = true;
		string[] array = acceptedHitters;
		foreach (string text in array)
		{
			if (eid.hitter == text)
			{
				if (khc == null)
				{
					khc = MonoSingleton<KillHitterCache>.Instance;
				}
				khc.OneDone(id);
				GoreZone componentInParent = GetComponentInParent<GoreZone>();
				if ((bool)componentInParent)
				{
					componentInParent.AddKillHitterTarget(id);
				}
				break;
			}
		}
		Object.Destroy(this);
	}
}



public class LampFlicker : MonoBehaviour
{
	public float randomSpeedMin;

	public float randomSpeedMax;

	public float randomMin;

	public float randomMax;

	private float baseIntensity;

	private Light thisLight;

	private void Awake()
	{
		thisLight = GetComponent<Light>();
		baseIntensity = thisLight.intensity;
	}

	private void OnEnable()
	{
		StartCoroutine(FlickerLamp());
	}

	private IEnumerator FlickerLamp()
	{
		while (true)
		{
			thisLight.intensity = baseIntensity * Random.Range(randomMin, randomMax);
			yield return new WaitForSeconds(Random.Range(randomSpeedMin, randomSpeedMax));
		}
	}
}



public class Landmine : MonoBehaviour
{
	private bool valuesSet;

	private Rigidbody rb;

	private AudioSource aud;

	[SerializeField]
	private GameObject lightCylinder;

	private Light lit;

	private Renderer[] rends;

	private SpriteRenderer sr;

	private MaterialPropertyBlock block;

	[SerializeField]
	private AudioClip activatedBeep;

	[SerializeField]
	private GameObject explosion;

	[SerializeField]
	private GameObject superExplosion;

	[SerializeField]
	private GameObject parryZone;

	private bool activated;

	private bool parried;

	private bool exploded;

	private Vector3 movementDirection;

	public EnemyIdentifier originEnemy;

	private void Start()
	{
		SetValues();
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			rb = GetComponent<Rigidbody>();
			aud = GetComponent<AudioSource>();
			lit = lightCylinder.GetComponentInChildren<Light>();
			rends = GetComponentsInChildren<Renderer>();
			sr = lightCylinder.GetComponentInChildren<SpriteRenderer>();
			block = new MaterialPropertyBlock();
			MonoSingleton<ObjectTracker>.Instance.AddLandmine(this);
		}
	}

	private void OnDestroy()
	{
		if ((bool)MonoSingleton<ObjectTracker>.Instance)
		{
			MonoSingleton<ObjectTracker>.Instance.RemoveLandmine(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!activated && (other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject || ((bool)MonoSingleton<PlatformerMovement>.Instance && other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject) || (originEnemy != null && originEnemy.target != null && originEnemy.target.enemyIdentifier != null && other.gameObject == originEnemy.target.enemyIdentifier.gameObject) || ((other.gameObject.layer == 10 || other.gameObject.layer == 11) && other.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && !component.eid.dead && originEnemy != null && originEnemy.target != null && originEnemy.target.enemyIdentifier != null && originEnemy.target.enemyIdentifier == component.eid)))
		{
			Activate();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!parried || exploded || collision.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			return;
		}
		EnemyIdentifier component = null;
		EnemyIdentifierIdentifier component2 = null;
		if (collision.gameObject.layer == 26 && collision.gameObject.TryGetComponent<ParryHelper>(out var component3) && (bool)component3.target)
		{
			component3.target.TryGetComponent<EnemyIdentifier>(out component);
		}
		if ((bool)component || (collision.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out component2) && (bool)component2.eid) || collision.gameObject.TryGetComponent<EnemyIdentifier>(out component))
		{
			if ((bool)component2 && (bool)component2.eid)
			{
				component = component2.eid;
			}
			if (!component.dead)
			{
				if (component == originEnemy)
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(150, "ultrakill.landyours", null, component);
				}
				else
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(75, "ultrakill.serve", null, component);
				}
				if (component.enemyType == EnemyType.Gutterman && component.TryGetComponent<Gutterman>(out var component4) && component4.hasShield)
				{
					component4.ShieldBreak(player: true, flash: false);
				}
			}
		}
		Explode(super: true);
	}

	private void FixedUpdate()
	{
		if (parried)
		{
			rb.velocity = movementDirection * 250f;
		}
	}

	public void Activate(float forceMultiplier = 1f)
	{
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.AddForce(base.transform.up * 20f * forceMultiplier, ForceMode.VelocityChange);
		rb.AddRelativeTorque(Vector3.right * 360f * forceMultiplier, ForceMode.VelocityChange);
		if (!activated)
		{
			activated = true;
			aud.clip = activatedBeep;
			aud.pitch = 1.5f;
			aud.Play();
			parryZone.SetActive(value: true);
			SetColor(new Color(1f, 0.66f, 0f));
			Invoke("Explode", 1f);
		}
	}

	public void Parry()
	{
		CancelInvoke("Explode");
		parried = true;
		movementDirection = base.transform.forward;
		rb.useGravity = true;
		rb.AddRelativeTorque(Vector3.up * 36000f, ForceMode.VelocityChange);
		parryZone.SetActive(value: false);
		SetColor(new Color(0f, 1f, 1f));
		Invoke("Explode", 3f);
	}

	private void Explode()
	{
		Explode(super: false);
	}

	private void Explode(bool super = false)
	{
		if (!exploded)
		{
			exploded = true;
			Object.Instantiate(super ? superExplosion : explosion, base.transform.position, Quaternion.identity);
			Object.Destroy(base.gameObject);
		}
	}

	public void SetColor(Color newColor)
	{
		if (!valuesSet)
		{
			SetValues();
		}
		Renderer[] array = rends;
		foreach (Renderer renderer in array)
		{
			if (!(renderer == sr))
			{
				for (int j = 0; j < renderer.sharedMaterials.Length; j++)
				{
					renderer.GetPropertyBlock(block, j);
					block.SetColor(UKShaderProperties.EmissiveColor, newColor);
					renderer.SetPropertyBlock(block, j);
				}
			}
		}
		sr.color = new Color(newColor.r, newColor.g, newColor.b, sr.color.a);
		lit.color = newColor;
	}
}



public class Lantern : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}



[DefaultExecutionOrder(int.MaxValue)]
public sealed class LateCopyPositionAndRotation : MonoBehaviour
{
	[SerializeField]
	[FormerlySerializedAs("target")]
	private Transform m_Target;

	[SerializeField]
	[FormerlySerializedAs("copyRotation")]
	private bool m_CopyRotation = true;

	[SerializeField]
	[FormerlySerializedAs("copyPosition")]
	private bool m_CopyPosition = true;

	public Transform target
	{
		get
		{
			return m_Target;
		}
		set
		{
			m_Target = value;
		}
	}

	public bool copyRotation
	{
		get
		{
			return m_CopyRotation;
		}
		set
		{
			m_CopyRotation = value;
		}
	}

	public bool copyPosition
	{
		get
		{
			return m_CopyPosition;
		}
		set
		{
			m_CopyPosition = value;
		}
	}

	private void LateUpdate()
	{
		if (m_CopyRotation)
		{
			base.transform.rotation = m_Target.rotation;
		}
		if (m_CopyPosition)
		{
			base.transform.position = m_Target.position;
		}
	}
}



[DisallowMultipleComponent]
public sealed class LateUpdateMessage : MessageDispatcher
{
	private void LateUpdate()
	{
		base.Handler.Invoke();
	}
}



[DefaultExecutionOrder(11000)]
public class LateUpdateParticles : MonoBehaviour
{
	private ParticleSystem part;

	private bool beenStarted;

	private void Awake()
	{
		part = GetComponent<ParticleSystem>();
	}

	private void LateUpdate()
	{
		if (part.isPlaying)
		{
			beenStarted = true;
		}
		if (beenStarted)
		{
			part.Simulate(Time.deltaTime, withChildren: true, restart: false, fixedTimeStep: false);
		}
	}
}



public class LateUpdateTest : MonoBehaviour
{
	private void LateUpdate()
	{
		base.transform.position = MonoSingleton<NewMovement>.Instance.transform.position;
	}

	private void OnTriggerEnter(Collider other)
	{
		Debug.Log("Fuck");
	}
}



public class LaughingSkull : MonoBehaviour
{
	private AudioSource aud;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	public void PlayAudio()
	{
		aud.Play();
	}
}



public class LaunchPlayer : MonoBehaviour
{
	public Vector3 direction;

	public bool relative;

	public bool oneTime;

	private bool beenLaunched;

	public bool dontLaunchOnEnable;

	private bool colliderless;

	private void Awake()
	{
		colliderless = GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null;
	}

	private void OnEnable()
	{
		if (colliderless && !dontLaunchOnEnable && (!oneTime || !beenLaunched))
		{
			Launch();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((!oneTime || !beenLaunched) && other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			Launch();
		}
	}

	public void Launch()
	{
		if (!beenLaunched)
		{
			beenLaunched = true;
		}
		else if (oneTime)
		{
			return;
		}
		if (relative)
		{
			MonoSingleton<NewMovement>.Instance.Launch(base.transform.rotation * direction);
		}
		else
		{
			MonoSingleton<NewMovement>.Instance.Launch(direction);
		}
	}
}



public static class LayerMaskDefaults
{
	public static LayerMask Get(LMD lmd)
	{
		LayerMask layerMask = default(LayerMask);
		switch (lmd)
		{
		case LMD.Enemies:
			layerMask = (int)layerMask | 0x400;
			return (int)layerMask | 0x800;
		case LMD.Environment:
			layerMask = (int)layerMask | 0x100;
			return (int)layerMask | 0x1000000;
		case LMD.Player:
			return (int)layerMask | 4;
		case LMD.EnvironmentAndBigEnemies:
			layerMask = (int)layerMask | 0x100;
			layerMask = (int)layerMask | 0x1000000;
			return (int)layerMask | 0x800;
		case LMD.EnemiesAndEnvironment:
			layerMask = (int)layerMask | 0x100;
			layerMask = (int)layerMask | 0x1000000;
			layerMask = (int)layerMask | 0x400;
			return (int)layerMask | 0x800;
		case LMD.EnemiesAndPlayer:
			layerMask = (int)layerMask | 4;
			layerMask = (int)layerMask | 0x400;
			return (int)layerMask | 0x800;
		case LMD.EnvironmentAndPlayer:
			layerMask = (int)layerMask | 4;
			layerMask = (int)layerMask | 0x100;
			return (int)layerMask | 0x1000000;
		case LMD.EnemiesEnvironmentAndPlayer:
			layerMask = (int)layerMask | 4;
			layerMask = (int)layerMask | 0x100;
			layerMask = (int)layerMask | 0x1000000;
			layerMask = (int)layerMask | 0x400;
			return (int)layerMask | 0x800;
		case LMD.BigEnemiesEnvironmentAndPlayer:
			layerMask = (int)layerMask | 4;
			layerMask = (int)layerMask | 0x100;
			layerMask = (int)layerMask | 0x1000000;
			return (int)layerMask | 0x800;
		default:
			return layerMask;
		}
	}
}



public class LayerSelect : MonoBehaviour
{
	public SecretMissionPanel secretMissionPanel;

	public int layerNumber;

	public int levelAmount;

	private float totalScore;

	private float scoresChecked;

	private int perfects;

	public int golds;

	private bool secretMission;

	[HideInInspector]
	public TMP_Text rankText;

	public bool gold;

	public bool allPerfects;

	public int trueScore;

	public bool complete;

	public bool noSecretMission;

	[HideInInspector]
	public LevelSelectLeaderboard[] childLeaderboards;

	private void Awake()
	{
		childLeaderboards = GetComponentsInChildren<LevelSelectLeaderboard>(includeInactive: true);
	}

	private void OnDisable()
	{
		totalScore = 0f;
		scoresChecked = 0f;
		perfects = 0;
		golds = 0;
		if (rankText == null)
		{
			rankText = base.transform.Find("Header").Find("RankPanel").GetComponentInChildren<TMP_Text>();
		}
		rankText.text = "";
		Image component = rankText.transform.parent.GetComponent<Image>();
		component.color = Color.white;
		component.fillCenter = false;
		secretMission = false;
		GetComponent<Image>().color = new Color(0f, 0f, 0f, 0.75f);
	}

	public void CheckScore()
	{
		totalScore = 0f;
		trueScore = 0;
		scoresChecked = 0f;
		perfects = 0;
		golds = 0;
		complete = false;
		allPerfects = false;
		gold = false;
		if (rankText == null)
		{
			rankText = base.transform.Find("Header").Find("RankPanel").GetComponentInChildren<TMP_Text>();
		}
		rankText.text = "";
		Image component = rankText.transform.parent.GetComponent<Image>();
		component.color = Color.white;
		component.fillCenter = false;
		secretMission = false;
		GetComponent<Image>().color = new Color(0f, 0f, 0f, 0.75f);
		LevelSelectPanel[] componentsInChildren = GetComponentsInChildren<LevelSelectPanel>(includeInactive: true);
		secretMissionPanel.GotEnabled();
		LevelSelectPanel[] array = componentsInChildren;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckScore();
		}
	}

	public void AddScore(int score, bool perfect = false)
	{
		if (rankText == null)
		{
			rankText = base.transform.Find("Header").Find("RankPanel").GetComponentInChildren<TMP_Text>();
		}
		if (golds < levelAmount)
		{
			GetComponent<Image>().color = new Color(0f, 0f, 0f, 0.75f);
		}
		scoresChecked += 1f;
		totalScore += score;
		if (perfect)
		{
			perfects++;
		}
		if (scoresChecked != (float)levelAmount)
		{
			return;
		}
		complete = true;
		if (perfects == levelAmount)
		{
			rankText.text = "<color=#FFFFFF>P</color>";
			Image component = rankText.transform.parent.GetComponent<Image>();
			component.color = new Color(1f, 0.686f, 0f, 1f);
			component.fillCenter = true;
			allPerfects = true;
			trueScore = Mathf.RoundToInt(totalScore / (float)levelAmount);
			return;
		}
		trueScore = Mathf.RoundToInt(totalScore / (float)levelAmount);
		float num = totalScore / (float)levelAmount;
		Debug.Log("True Score: " + trueScore + ". Real score: " + num);
		switch (trueScore)
		{
		case 1:
			rankText.text = "<color=#4CFF00>C</color>";
			break;
		case 2:
			rankText.text = "<color=#FFD800>B</color>";
			break;
		case 3:
			rankText.text = "<color=#FF6A00>A</color>";
			break;
		case 4:
		case 5:
		case 6:
			rankText.text = "<color=#FF0000>S</color>";
			break;
		default:
			rankText.text = "<color=#0094FF>D</color>";
			break;
		}
		Image component2 = rankText.transform.parent.GetComponent<Image>();
		component2.color = Color.white;
		component2.fillCenter = false;
	}

	public void Gold()
	{
		golds++;
		if (golds == levelAmount && levelAmount != 0 && (noSecretMission || secretMission))
		{
			GetComponent<Image>().color = new Color(1f, 0.686f, 0f, 0.75f);
			gold = true;
		}
	}

	public void SecretMissionDone()
	{
		secretMission = true;
		if (golds == levelAmount && secretMission)
		{
			GetComponent<Image>().color = new Color(1f, 0.686f, 0f, 0.75f);
		}
	}
}



[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class LeaderboardController : MonoSingleton<LeaderboardController>
{
	private readonly Dictionary<string, Leaderboard> cachedLeaderboards = new Dictionary<string, Leaderboard>();

	public async void SubmitCyberGrindScore(int difficulty, float wave, int kills, int style, float seconds)
	{
		if (!SteamClient.IsValid)
		{
			return;
		}
		int majorVersion = -1;
		int minorVersion = -1;
		string[] array = Application.version.Split('.');
		if (int.TryParse(array[0], out var result))
		{
			majorVersion = result;
		}
		if (array.Length > 1 && int.TryParse(array[1], out var result2))
		{
			minorVersion = result2;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Cyber Grind Wave ");
		stringBuilder.Append(LeaderboardProperties.Difficulties[difficulty]);
		Leaderboard? leaderboard = await FetchLeaderboard(stringBuilder.ToString());
		if (leaderboard.HasValue)
		{
			await leaderboard.Value.SubmitScoreAsync(Mathf.FloorToInt(wave), new int[6]
			{
				kills,
				style,
				Mathf.FloorToInt(seconds * 1000f),
				majorVersion,
				minorVersion,
				DateTimeOffset.UtcNow.Millisecond
			});
			stringBuilder.Append(" Precise");
			Leaderboard? leaderboard2 = await FetchLeaderboard(stringBuilder.ToString());
			if (leaderboard2.HasValue)
			{
				await leaderboard2.Value.SubmitScoreAsync(Mathf.FloorToInt(wave * 1000f), new int[6]
				{
					kills,
					style,
					Mathf.FloorToInt(seconds * 1000f),
					majorVersion,
					minorVersion,
					DateTimeOffset.UtcNow.Millisecond
				});
				Debug.Log($"Score {wave} submitted to Steamworks");
			}
		}
	}

	public async void SubmitLevelScore(string levelName, int difficulty, float seconds, int kills, int style, int restartCount, bool pRank = false)
	{
		if (SteamClient.IsValid)
		{
			int majorVersion = -1;
			int minorVersion = -1;
			string[] array = Application.version.Split('.');
			if (int.TryParse(array[0], out var result))
			{
				majorVersion = result;
			}
			if (array.Length > 1 && int.TryParse(array[1], out var result2))
			{
				minorVersion = result2;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(levelName);
			if (pRank)
			{
				stringBuilder.Append(" PRank");
			}
			else
			{
				stringBuilder.Append(" Any%");
			}
			Leaderboard? leaderboard = await FetchLeaderboard(stringBuilder.ToString(), createIfNotFound: true, LeaderboardSort.Ascending);
			if (leaderboard.HasValue)
			{
				Leaderboard value = leaderboard.Value;
				int score = Mathf.FloorToInt(seconds * 1000f + 0.5f);
				await value.SubmitScoreAsync(score, new int[7]
				{
					difficulty,
					kills,
					style,
					restartCount,
					majorVersion,
					minorVersion,
					DateTimeOffset.UtcNow.Millisecond
				});
				Debug.Log($"Score {seconds}s submitted to {stringBuilder} Steamworks");
			}
		}
	}

	public async Task<LeaderboardEntry[]> GetLevelScores(string levelName, bool pRank)
	{
		if (!SteamClient.IsValid)
		{
			return null;
		}
		if (!levelName.StartsWith("Level "))
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(levelName);
		if (pRank)
		{
			stringBuilder.Append(" PRank");
		}
		else
		{
			stringBuilder.Append(" Any%");
		}
		return await FetchLeaderboardEntries(stringBuilder.ToString(), LeaderboardType.Friends, 15, createIfNotFound: true, LeaderboardSort.Ascending);
	}

	public async Task<LeaderboardEntry[]> GetCyberGrindScores(int difficulty, LeaderboardType type)
	{
		if (!SteamClient.IsValid)
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Cyber Grind Wave ");
		stringBuilder.Append(LeaderboardProperties.Difficulties[difficulty]);
		stringBuilder.Append(" Precise");
		return await FetchLeaderboardEntries(stringBuilder.ToString(), type);
	}

	public async Task<LeaderboardEntry[]> GetFishScores(LeaderboardType type)
	{
		if (!SteamClient.IsValid)
		{
			return null;
		}
		return (await FetchLeaderboardEntries("Fish Size", type, 20)).Where((LeaderboardEntry fs) => fs.Score == 1 || SteamController.BuiltInVerifiedSteamIds.Contains(fs.User.Id.Value)).Take(20).ToArray();
	}

	public async void SubmitFishSize(int fishSize)
	{
		if (!SteamClient.IsValid)
		{
			return;
		}
		int majorVersion = -1;
		int minorVersion = -1;
		string[] array = Application.version.Split('.');
		if (int.TryParse(array[0], out var result))
		{
			majorVersion = result;
		}
		if (array.Length > 1 && int.TryParse(array[1], out var result2))
		{
			minorVersion = result2;
		}
		Leaderboard? leaderboard = await FetchLeaderboard("Fish Size");
		if (leaderboard.HasValue)
		{
			Leaderboard value = leaderboard.Value;
			if (!SteamController.BuiltInVerifiedSteamIds.Contains<ulong>(SteamClient.SteamId))
			{
				await value.ReplaceScore(Mathf.FloorToInt(1f), new int[3]
				{
					majorVersion,
					minorVersion,
					DateTimeOffset.UtcNow.Millisecond
				});
			}
			else
			{
				await value.ReplaceScore(fishSize, new int[3]
				{
					majorVersion,
					minorVersion,
					DateTimeOffset.UtcNow.Millisecond
				});
			}
			Debug.Log("Fish submitted to Steamworks");
		}
	}

	private async Task<LeaderboardEntry[]> FetchLeaderboardEntries(string key, LeaderboardType type, int count = 10, bool createIfNotFound = false, LeaderboardSort defaultSortMode = LeaderboardSort.Descending)
	{
		if (!SteamClient.IsValid)
		{
			return null;
		}
		Leaderboard? leaderboard = await FetchLeaderboard(key, createIfNotFound, defaultSortMode);
		if (!leaderboard.HasValue)
		{
			return null;
		}
		Leaderboard value = leaderboard.Value;
		LeaderboardEntry[] array = type switch
		{
			LeaderboardType.Friends => await value.GetScoresFromFriendsAsync(), 
			LeaderboardType.Global => await value.GetScoresAsync(count), 
			LeaderboardType.GlobalAround => await value.GetScoresAroundUserAsync(-4, 3), 
			_ => throw new ArgumentOutOfRangeException("type", type, null), 
		};
		if (array == null)
		{
			return new LeaderboardEntry[0];
		}
		return array.Take(count).ToArray();
	}

	private async Task<Leaderboard?> FetchLeaderboard(string key, bool createIfNotFound = false, LeaderboardSort defaultSortMode = LeaderboardSort.Descending)
	{
		if (cachedLeaderboards.TryGetValue(key, out var value))
		{
			Debug.Log("Resolved leaderboard '" + key + "' from cache");
			return value;
		}
		Leaderboard? leaderboard = await SteamController.FetchSteamLeaderboard(key, createIfNotFound, defaultSortMode);
		if (!leaderboard.HasValue)
		{
			Debug.LogError("Failed to resolve leaderboard '" + key + "' from Steamworks");
			return null;
		}
		Leaderboard value2 = leaderboard.Value;
		cachedLeaderboards.Add(key, value2);
		Debug.Log("Resolved leaderboard '" + key + "' from Steamworks");
		return value2;
	}
}


public static class LeaderboardProperties
{
	public const string CyberGrindWavePrefix = "Cyber Grind Wave ";

	public const string PrecisePostfix = " Precise";

	public const string FishSize = "Fish Size";

	public static readonly string[] Difficulties = new string[6]
	{
		"Harmless",
		"Lenient",
		"Standard",
		"Violent",
		"Brutal",
		string.Empty
	};

	public const string AnyPercentPostfix = " Any%";

	public const string PRankPostfix = " PRank";
}


public enum LeaderboardType
{
	GlobalAround,
	Global,
	Friends
}



public class Lerp : MonoBehaviour
{
	[SerializeField]
	private Vector3 position;

	[SerializeField]
	private Vector3 rotation;

	[SerializeField]
	private float moveSpeed;

	[SerializeField]
	private float rotateSpeed;

	private Quaternion qRot;

	[SerializeField]
	private bool onEnable = true;

	[SerializeField]
	private bool inFixedUpdate;

	[SerializeField]
	private bool inLocalSpace;

	private bool moving;

	[SerializeField]
	private UltrakillEvent onComplete;

	private void Start()
	{
		if (onEnable)
		{
			Activate();
		}
	}

	private void OnEnable()
	{
		if (onEnable)
		{
			Activate();
		}
	}

	private void Update()
	{
		if (moving && !inFixedUpdate)
		{
			Move(Time.deltaTime);
		}
	}

	private void FixedUpdate()
	{
		if (moving && inFixedUpdate)
		{
			Move(Time.fixedDeltaTime);
		}
	}

	private void Move(float amount)
	{
		if (!inLocalSpace)
		{
			Vector3 vector = Vector3.MoveTowards(base.transform.position, position, moveSpeed * amount);
			Quaternion quaternion = Quaternion.RotateTowards(base.transform.rotation, qRot, rotateSpeed * amount);
			base.transform.SetPositionAndRotation(vector, quaternion);
		}
		else
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, position, moveSpeed * amount);
			base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, qRot, rotateSpeed * amount);
		}
		if (base.transform.position == position && base.transform.rotation == qRot)
		{
			moving = false;
			onComplete?.Invoke();
		}
	}

	public void Activate()
	{
		if (!moving)
		{
			qRot = Quaternion.Euler(rotation);
			moving = true;
		}
	}

	public void Skip()
	{
		Activate();
		Move(99999f);
	}
}



public class LevelEndLeaderboard : MonoBehaviour
{
	[SerializeField]
	private GameObject template;

	[SerializeField]
	private TMP_Text templateUsername;

	[SerializeField]
	private TMP_Text templateTime;

	[SerializeField]
	private TMP_Text templateDifficulty;

	[Space]
	[SerializeField]
	private Transform container;

	[SerializeField]
	private TMP_Text leaderboardType;

	[SerializeField]
	private TMP_Text switchTypeInput;

	[Space]
	[SerializeField]
	private GameObject loadingPanel;

	private bool displayPRank;

	private InputControlScheme keyboardControlScheme;

	private const string LeftBracket = "<color=white>[";

	private const string RightBracket = "]</color>";

	private void Start()
	{
		keyboardControlScheme = MonoSingleton<InputManager>.Instance.InputSource.Actions.KeyboardMouseScheme;
	}

	private void OnEnable()
	{
		if (SceneHelper.IsPlayingCustom || !SceneHelper.CurrentScene.StartsWith("Level ") || !GameStateManager.ShowLeaderboards || !MonoSingleton<PrefsManager>.Instance.GetBool("levelLeaderboards") || MonoSingleton<StatsManager>.Instance.firstPlayThrough)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		Debug.Log("Fetching level leaderboards for " + SceneHelper.CurrentScene);
		displayPRank = MonoSingleton<StatsManager>.Instance.rankScore == 12;
		StartCoroutine(Fetch(SceneHelper.CurrentScene));
	}

	private IEnumerator Fetch(string levelName)
	{
		if (string.IsNullOrEmpty(levelName))
		{
			yield break;
		}
		ResetEntries();
		loadingPanel.SetActive(value: true);
		leaderboardType.text = (displayPRank ? "P RANK" : "ANY RANK");
		Task<LeaderboardEntry[]> entryTask = MonoSingleton<LeaderboardController>.Instance.GetLevelScores(levelName, displayPRank);
		while (!entryTask.IsCompleted)
		{
			yield return null;
		}
		if (entryTask.Result == null)
		{
			yield break;
		}
		LeaderboardEntry[] result = entryTask.Result;
		for (int i = 0; i < result.Length; i++)
		{
			LeaderboardEntry leaderboardEntry = result[i];
			TMP_Text tMP_Text = templateUsername;
			Friend user = leaderboardEntry.User;
			tMP_Text.text = user.Name;
			int score = leaderboardEntry.Score;
			int num = score / 60000;
			float num2 = (float)(score - num * 60000) / 1000f;
			templateTime.text = $"{num}:{num2:00.000}";
			int? num3 = null;
			if (leaderboardEntry.Details.Length != 0)
			{
				num3 = leaderboardEntry.Details[0];
			}
			if (LeaderboardProperties.Difficulties.Length <= num3)
			{
				Debug.LogWarning($"Difficulty {num3} is out of range for {levelName}");
				continue;
			}
			templateDifficulty.text = ((!num3.HasValue) ? "UNKNOWN" : LeaderboardProperties.Difficulties[num3.Value].ToUpper());
			GameObject obj = Object.Instantiate(template, container);
			obj.SetActive(value: true);
			SteamController.FetchAvatar(obj.GetComponentInChildren<RawImage>(), leaderboardEntry.User);
		}
		loadingPanel.SetActive(value: false);
		container.gameObject.SetActive(value: true);
	}

	private void ResetEntries()
	{
		foreach (Transform item in container)
		{
			if (!(item == template.transform))
			{
				Object.Destroy(item.gameObject);
			}
		}
	}

	private void Update()
	{
		InputBinding? inputBinding = null;
		if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.NextWeapon.Action.bindings.Count > 0)
			{
				foreach (InputBinding binding in MonoSingleton<InputManager>.Instance.InputSource.NextWeapon.Action.bindings)
				{
					if (!binding.groups.Contains(keyboardControlScheme.bindingGroup))
					{
						inputBinding = binding;
					}
				}
			}
		}
		else
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.PreviousVariation.Action.bindings.Count > 0)
			{
				foreach (InputBinding binding2 in MonoSingleton<InputManager>.Instance.InputSource.PreviousVariation.Action.bindings)
				{
					if (binding2.groups.Contains(keyboardControlScheme.bindingGroup))
					{
						inputBinding = binding2;
					}
				}
			}
			if (!inputBinding.HasValue && MonoSingleton<InputManager>.Instance.InputSource.LastWeapon.Action.bindings.Count > 0)
			{
				foreach (InputBinding binding3 in MonoSingleton<InputManager>.Instance.InputSource.LastWeapon.Action.bindings)
				{
					if (binding3.groups.Contains(keyboardControlScheme.bindingGroup))
					{
						inputBinding = binding3;
					}
				}
			}
		}
		if (!inputBinding.HasValue)
		{
			switchTypeInput.text = "<color=white>[<color=orange>NO BINDING</color>]</color>";
			return;
		}
		switchTypeInput.text = "<color=white>[<color=orange>" + inputBinding?.ToDisplayString().ToUpper() + "</color>]</color>";
		if (MonoSingleton<InputManager>.Instance.InputSource.NextWeapon.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.LastWeapon.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.PreviousVariation.WasPerformedThisFrame)
		{
			displayPRank = !displayPRank;
			StopAllCoroutines();
			StartCoroutine(Fetch(SceneHelper.CurrentScene));
		}
	}
}



public class LevelNameActivator : MonoBehaviour
{
	private Collider col;

	private bool activateOnCollision;

	private void Start()
	{
		col = GetComponent<Collider>();
		if (col == null || !col.isTrigger)
		{
			GoTime();
		}
		else
		{
			activateOnCollision = true;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (activateOnCollision && other.gameObject.CompareTag("Player"))
		{
			GoTime();
		}
	}

	private void GoTime()
	{
		MonoSingleton<LevelNamePopup>.Instance.NameAppear();
		Object.Destroy(this);
	}
}



public class LevelNameFinder : MonoBehaviour
{
	public string textBeforeName;

	public bool breakLine;

	private int thisLevelNumber;

	public int otherLevelNumber;

	private Text txt;

	private TMP_Text txt2;

	public bool lookForPreviousMission;

	public bool lookForLatestMission;

	private void OnEnable()
	{
		if (lookForPreviousMission || lookForLatestMission)
		{
			bool flag = false;
			if (lookForPreviousMission)
			{
				PreviousMissionSaver instance = MonoSingleton<PreviousMissionSaver>.Instance;
				if (instance != null)
				{
					flag = true;
					otherLevelNumber = instance.previousMission;
				}
			}
			if (!flag && lookForLatestMission)
			{
				otherLevelNumber = GameProgressSaver.GetProgress(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"));
			}
		}
		string text = "";
		if (otherLevelNumber != 0)
		{
			text = textBeforeName + (breakLine ? "\n" : "") + GetMissionName.GetMission(otherLevelNumber);
		}
		else
		{
			if (thisLevelNumber == 0)
			{
				thisLevelNumber = (MonoSingleton<StatsManager>.Instance ? MonoSingleton<StatsManager>.Instance.levelNumber : (-1));
			}
			text = textBeforeName + (breakLine ? "\n" : "") + GetMissionName.GetMission(thisLevelNumber);
		}
		if (!txt2)
		{
			txt2 = GetComponent<TMP_Text>();
		}
		if ((bool)txt2)
		{
			txt2.text = text;
			return;
		}
		if (!txt)
		{
			txt = GetComponent<Text>();
		}
		if ((bool)txt)
		{
			txt.text = text;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class LevelNamePopup : MonoSingleton<LevelNamePopup>
{
	public TMP_Text layerText;

	private string layerString;

	public TMP_Text nameText;

	private string nameString;

	private bool activated;

	private bool fadingOut;

	private AudioSource aud;

	private float textTimer;

	private int currentLetter;

	private bool countTime;

	private void Start()
	{
		MapInfoBase instanceAnyType = MapInfoBase.InstanceAnyType;
		if ((bool)instanceAnyType)
		{
			layerString = instanceAnyType.layerName;
			nameString = instanceAnyType.levelName;
		}
		aud = GetComponent<AudioSource>();
		layerText.text = "";
		nameText.text = "";
	}

	private void Update()
	{
		if (countTime)
		{
			textTimer += Time.deltaTime;
		}
		if (fadingOut)
		{
			Color color = layerText.color;
			color.a = Mathf.MoveTowards(color.a, 0f, Time.deltaTime);
			layerText.color = color;
			nameText.color = color;
			if (color.a <= 0f)
			{
				fadingOut = false;
			}
		}
	}

	public void NameAppear()
	{
		if (!activated)
		{
			activated = true;
			StartCoroutine(ShowLayerText());
		}
	}

	private IEnumerator ShowLayerText()
	{
		countTime = true;
		currentLetter = 0;
		aud.Play();
		while (currentLetter <= layerString.Length)
		{
			while (textTimer >= 0.01f && currentLetter <= layerString.Length)
			{
				textTimer -= 0.01f;
				layerText.text = layerString.Substring(0, currentLetter);
				currentLetter++;
			}
			yield return new WaitForSeconds(0.01f);
		}
		countTime = false;
		aud.Stop();
		yield return new WaitForSeconds(0.5f);
		StartCoroutine(ShowNameText());
	}

	private IEnumerator ShowNameText()
	{
		countTime = true;
		currentLetter = 0;
		aud.Play();
		while (currentLetter <= nameString.Length)
		{
			while (textTimer >= 0.01f && currentLetter <= nameString.Length)
			{
				textTimer -= 0.01f;
				nameText.text = nameString.Substring(0, currentLetter);
				currentLetter++;
			}
			yield return new WaitForSeconds(0.01f);
		}
		countTime = false;
		aud.Stop();
		yield return new WaitForSeconds(3f);
		fadingOut = true;
	}
}



public class LevelSelectAct : MonoBehaviour
{
	private LayerSelect[] childLayers;

	private PlayerInput inputSource;

	private bool currentLeaderboardMode;

	private void Awake()
	{
		childLayers = GetComponentsInChildren<LayerSelect>(includeInactive: true);
		inputSource = MonoSingleton<InputManager>.Instance.InputSource;
	}

	private void Update()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetBool("levelLeaderboards") && (inputSource.NextWeapon.WasPerformedThisFrame || inputSource.LastWeapon.WasPerformedThisFrame || inputSource.PreviousVariation.WasPerformedThisFrame))
		{
			string text = "";
			if (inputSource.NextWeapon.WasPerformedThisFrame)
			{
				text = inputSource.NextWeapon.LastUsedBinding;
			}
			else if (inputSource.LastWeapon.WasPerformedThisFrame)
			{
				text = inputSource.LastWeapon.LastUsedBinding;
			}
			else if (inputSource.PreviousVariation.WasPerformedThisFrame)
			{
				text = inputSource.PreviousVariation.LastUsedBinding;
			}
			if (text != null && !string.IsNullOrEmpty(text) && !text.Contains("/dpad/"))
			{
				ChangeLeaderboardType(!currentLeaderboardMode);
			}
		}
	}

	public void ChangeLeaderboardType(bool pRank)
	{
		currentLeaderboardMode = pRank;
		StopAllCoroutines();
		LayerSelect[] array = childLayers;
		foreach (LayerSelect layer in array)
		{
			StartCoroutine(SwitchLeaderboardsSequence(layer, pRank));
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private IEnumerator SwitchLeaderboardsSequence(LayerSelect layer, bool pRank)
	{
		LevelSelectLeaderboard[] childLeaderboards = layer.childLeaderboards;
		for (int i = 0; i < childLeaderboards.Length; i++)
		{
			childLeaderboards[i].SwitchLeaderboardType(pRank);
			yield return new WaitForSeconds(0.1f);
		}
	}
}



public class LevelSelectLeaderboard : MonoBehaviour
{
	public string layerLevelNumber;

	[SerializeField]
	private GameObject scrollRectContainer;

	[SerializeField]
	private GameObject template;

	[SerializeField]
	private TMP_Text templateUsername;

	[SerializeField]
	private TMP_Text templateTime;

	[SerializeField]
	private TMP_Text templateDifficulty;

	[Space]
	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private Transform container;

	[Space]
	[SerializeField]
	private UnityEngine.UI.Image anyPercentButton;

	[SerializeField]
	private UnityEngine.UI.Image pRankButton;

	[SerializeField]
	private TMP_Text anyPercentLabel;

	[SerializeField]
	private TMP_Text pRankLabel;

	[Space]
	[SerializeField]
	private GameObject loadingPanel;

	[SerializeField]
	private GameObject noItemsPanel;

	[Space]
	[SerializeField]
	private InputActionAsset inputActionAsset;

	[SerializeField]
	private float controllerScrollSpeed = 250f;

	private bool pRankSelected;

	private LevelSelectPanel levelSelect;

	private InputAction scrollSublistAction;

	public void RefreshAnyPercent()
	{
		anyPercentButton.fillCenter = true;
		pRankButton.fillCenter = false;
		anyPercentLabel.color = UnityEngine.Color.black;
		pRankLabel.color = UnityEngine.Color.white;
		container.gameObject.SetActive(value: false);
		scrollRectContainer.SetActive(value: false);
		loadingPanel.SetActive(value: true);
		noItemsPanel.SetActive(value: false);
		ResetEntries();
		pRankSelected = false;
		StopAllCoroutines();
		StartCoroutine(Fetch("Level " + layerLevelNumber));
	}

	public void RefreshPRank()
	{
		anyPercentButton.fillCenter = false;
		pRankButton.fillCenter = true;
		anyPercentLabel.color = UnityEngine.Color.white;
		pRankLabel.color = UnityEngine.Color.black;
		container.gameObject.SetActive(value: false);
		scrollRectContainer.SetActive(value: false);
		loadingPanel.SetActive(value: true);
		noItemsPanel.SetActive(value: false);
		ResetEntries();
		pRankSelected = true;
		StopAllCoroutines();
		StartCoroutine(Fetch("Level " + layerLevelNumber));
	}

	private void OnEnable()
	{
		RefreshAnyPercent();
	}

	private void ResetEntries()
	{
		foreach (Transform item in container)
		{
			if (!(item.gameObject == template))
			{
				Object.Destroy(item.gameObject);
			}
		}
	}

	private bool IsLayerSelected()
	{
		GameObject currentSelectedGameObject = EventSystem.current.currentSelectedGameObject;
		if (currentSelectedGameObject == null)
		{
			return false;
		}
		LevelSelectPanel componentInParent = currentSelectedGameObject.GetComponentInParent<LevelSelectPanel>();
		if (componentInParent == null)
		{
			return false;
		}
		return levelSelect == componentInParent;
	}

	private IEnumerator Fetch(string levelName)
	{
		if (string.IsNullOrEmpty(levelName))
		{
			yield break;
		}
		Task<LeaderboardEntry[]> entryTask = MonoSingleton<LeaderboardController>.Instance.GetLevelScores(levelName, pRankSelected);
		while (!entryTask.IsCompleted)
		{
			yield return null;
		}
		if (entryTask.Result == null)
		{
			yield break;
		}
		LeaderboardEntry[] result = entryTask.Result;
		LeaderboardEntry[] array = result;
		for (int i = 0; i < array.Length; i++)
		{
			LeaderboardEntry leaderboardEntry = array[i];
			TMP_Text tMP_Text = templateUsername;
			Friend user = leaderboardEntry.User;
			tMP_Text.text = user.Name;
			int score = leaderboardEntry.Score;
			int num = score / 60000;
			float num2 = (float)(score - num * 60000) / 1000f;
			templateTime.text = $"{num}:{num2:00.000}";
			int? num3 = null;
			if (leaderboardEntry.Details.Length != 0)
			{
				num3 = leaderboardEntry.Details[0];
			}
			if (LeaderboardProperties.Difficulties.Length <= num3)
			{
				Debug.LogWarning($"Difficulty {num3} is out of range for {levelName}");
				continue;
			}
			templateDifficulty.text = ((!num3.HasValue) ? "UNKNOWN" : LeaderboardProperties.Difficulties[num3.Value].ToUpper());
			GameObject obj = Object.Instantiate(template, container);
			obj.SetActive(value: true);
			SteamController.FetchAvatar(obj.GetComponentInChildren<RawImage>(), leaderboardEntry.User);
		}
		if (result.Length == 0)
		{
			noItemsPanel.SetActive(value: true);
		}
		loadingPanel.SetActive(value: false);
		container.gameObject.SetActive(value: true);
		scrollRectContainer.SetActive(value: true);
	}

	private void Update()
	{
		if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
		{
			UpdateLeaderboardScroll();
		}
	}

	public void SwitchLeaderboardType(bool pRank)
	{
		if (pRank)
		{
			RefreshPRank();
		}
		else
		{
			RefreshAnyPercent();
		}
	}

	private void UpdateLeaderboardScroll()
	{
		Vector2 vector = scrollSublistAction.ReadValue<Vector2>();
		if (!(vector == Vector2.zero) && IsLayerSelected())
		{
			if (vector.y > 0f)
			{
				scrollRect.verticalNormalizedPosition += 0.01f * Time.deltaTime * controllerScrollSpeed;
			}
			else if (vector.y < 0f)
			{
				scrollRect.verticalNormalizedPosition -= 0.01f * Time.deltaTime * controllerScrollSpeed;
			}
		}
	}

	private void Start()
	{
		scrollSublistAction = inputActionAsset.FindAction("ScrollSublist");
		if (!scrollSublistAction.enabled)
		{
			Debug.Log("Enabling scroll sublist action");
			scrollSublistAction.Enable();
		}
	}

	private void Awake()
	{
		levelSelect = GetComponentInParent<LevelSelectPanel>();
	}
}



public class LevelSelectPanel : MonoBehaviour
{
	public float collapsedHeight = 260f;

	public float expandedHeight = 400f;

	public GameObject leaderboardPanel;

	private RectTransform rectTransform;

	public int levelNumber;

	public int levelNumberInLayer;

	private bool allSecrets;

	public Sprite lockedSprite;

	public Sprite unlockedSprite;

	private Sprite origSprite;

	public Image[] secretIcons;

	public Image challengeIcon;

	private int tempInt;

	private string origName;

	private LayerSelect ls;

	private GameObject challengeChecker;

	public bool forceOff;

	public void CheckScore()
	{
		rectTransform = GetComponent<RectTransform>();
		if (ls == null)
		{
			ls = base.transform.parent.GetComponent<LayerSelect>();
		}
		if (ls == null && base.transform.parent.parent != null)
		{
			ls = base.transform.parent.parent.GetComponent<LayerSelect>();
		}
		if (origSprite == null)
		{
			origSprite = base.transform.Find("Image").GetComponent<Image>().sprite;
		}
		if (levelNumber == 666)
		{
			tempInt = GameProgressSaver.GetPrime(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"), levelNumberInLayer);
		}
		else
		{
			tempInt = GameProgressSaver.GetProgress(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"));
		}
		int num = levelNumber;
		if (levelNumber == 666)
		{
			num += levelNumberInLayer - 1;
		}
		origName = GetMissionName.GetMission(num);
		if ((levelNumber == 666 && tempInt == 0) || (levelNumber != 666 && tempInt < levelNumber) || forceOff)
		{
			string text = ls.layerNumber.ToString();
			if (ls.layerNumber == 666)
			{
				text = "P";
			}
			base.transform.Find("Name").GetComponent<TMP_Text>().text = text + "-" + levelNumberInLayer + ": ???";
			base.transform.Find("Image").GetComponent<Image>().sprite = lockedSprite;
			GetComponent<Button>().enabled = false;
			rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, collapsedHeight);
			leaderboardPanel.SetActive(value: false);
		}
		else
		{
			bool flag = false;
			if (tempInt == levelNumber || (levelNumber == 666 && tempInt == 1))
			{
				flag = false;
				base.transform.Find("Image").GetComponent<Image>().sprite = unlockedSprite;
			}
			else
			{
				flag = true;
				base.transform.Find("Image").GetComponent<Image>().sprite = origSprite;
			}
			base.transform.Find("Name").GetComponent<TMP_Text>().text = origName;
			GetComponent<Button>().enabled = true;
			if (challengeIcon != null)
			{
				if (challengeChecker == null)
				{
					challengeChecker = challengeIcon.transform.Find("EventTrigger").gameObject;
				}
				if (tempInt > levelNumber)
				{
					challengeChecker.SetActive(value: true);
				}
			}
			if (MonoSingleton<PrefsManager>.Instance.GetBool("levelLeaderboards") && flag)
			{
				rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, expandedHeight);
				leaderboardPanel.SetActive(value: true);
			}
			else
			{
				rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, collapsedHeight);
				leaderboardPanel.SetActive(value: false);
			}
		}
		RankData rank = GameProgressSaver.GetRank(num);
		if (rank != null)
		{
			int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			if (rank.levelNumber == levelNumber || (levelNumber == 666 && rank.levelNumber == levelNumber + levelNumberInLayer - 1))
			{
				TMP_Text componentInChildren = base.transform.Find("Stats").Find("Rank").GetComponentInChildren<TMP_Text>();
				if (rank.ranks[@int] == 12 && (rank.majorAssists == null || !rank.majorAssists[@int]))
				{
					componentInChildren.text = "<color=#FFFFFF>P</color>";
					Image component = componentInChildren.transform.parent.GetComponent<Image>();
					component.color = new Color(1f, 0.686f, 0f, 1f);
					component.fillCenter = true;
					ls.AddScore(4, perfect: true);
				}
				else if (rank.majorAssists != null && rank.majorAssists[@int])
				{
					if (rank.ranks[@int] < 0)
					{
						componentInChildren.text = "";
					}
					else
					{
						switch (rank.ranks[@int])
						{
						case 1:
							componentInChildren.text = "C";
							ls.AddScore(1);
							break;
						case 2:
							componentInChildren.text = "B";
							ls.AddScore(2);
							break;
						case 3:
							componentInChildren.text = "A";
							ls.AddScore(3);
							break;
						case 4:
						case 5:
						case 6:
							ls.AddScore(4);
							componentInChildren.text = "S";
							break;
						default:
							ls.AddScore(0);
							componentInChildren.text = "D";
							break;
						}
						Image component2 = componentInChildren.transform.parent.GetComponent<Image>();
						component2.color = new Color(0.3f, 0.6f, 0.9f, 1f);
						component2.fillCenter = true;
					}
				}
				else if (rank.ranks[@int] < 0)
				{
					componentInChildren.text = "";
					Image component3 = componentInChildren.transform.parent.GetComponent<Image>();
					component3.color = Color.white;
					component3.fillCenter = false;
				}
				else
				{
					switch (rank.ranks[@int])
					{
					case 1:
						componentInChildren.text = "<color=#4CFF00>C</color>";
						ls.AddScore(1);
						break;
					case 2:
						componentInChildren.text = "<color=#FFD800>B</color>";
						ls.AddScore(2);
						break;
					case 3:
						componentInChildren.text = "<color=#FF6A00>A</color>";
						ls.AddScore(3);
						break;
					case 4:
					case 5:
					case 6:
						ls.AddScore(4);
						componentInChildren.text = "<color=#FF0000>S</color>";
						break;
					default:
						ls.AddScore(0);
						componentInChildren.text = "<color=#0094FF>D</color>";
						break;
					}
					Image component4 = componentInChildren.transform.parent.GetComponent<Image>();
					component4.color = Color.white;
					component4.fillCenter = false;
				}
				if (rank.secretsAmount > 0)
				{
					allSecrets = true;
					for (int i = 0; i < 5; i++)
					{
						if (i < rank.secretsAmount && rank.secretsFound[i])
						{
							secretIcons[i].fillCenter = true;
						}
						else if (i < rank.secretsAmount)
						{
							allSecrets = false;
							secretIcons[i].fillCenter = false;
						}
						else if (i >= rank.secretsAmount)
						{
							secretIcons[i].enabled = false;
						}
					}
				}
				else
				{
					Image[] array = secretIcons;
					for (int j = 0; j < array.Length; j++)
					{
						array[j].enabled = false;
					}
				}
				if ((bool)challengeIcon)
				{
					if (rank.challenge)
					{
						challengeIcon.fillCenter = true;
						TMP_Text componentInChildren2 = challengeIcon.GetComponentInChildren<TMP_Text>();
						componentInChildren2.text = "C O M P L E T E";
						if (rank.ranks[@int] == 12 && (allSecrets || rank.secretsAmount == 0))
						{
							componentInChildren2.color = new Color(0.6f, 0.4f, 0f, 1f);
						}
						else
						{
							componentInChildren2.color = Color.black;
						}
					}
					else
					{
						challengeIcon.fillCenter = false;
						TMP_Text componentInChildren3 = challengeIcon.GetComponentInChildren<TMP_Text>();
						componentInChildren3.text = "C H A L L E N G E";
						componentInChildren3.color = Color.white;
					}
				}
			}
			else
			{
				Debug.Log("Error in finding " + levelNumber + " Data");
				Image component5 = base.transform.Find("Stats").Find("Rank").GetComponent<Image>();
				component5.color = Color.white;
				component5.fillCenter = false;
				component5.GetComponentInChildren<TMP_Text>().text = "";
				allSecrets = false;
				Image[] array = secretIcons;
				foreach (Image obj in array)
				{
					obj.enabled = true;
					obj.fillCenter = false;
				}
			}
			if ((rank.challenge || !challengeIcon) && rank.ranks[@int] == 12 && (allSecrets || rank.secretsAmount == 0))
			{
				ls.Gold();
				GetComponent<Image>().color = new Color(1f, 0.686f, 0f, 0.75f);
			}
			else
			{
				GetComponent<Image>().color = new Color(0f, 0f, 0f, 0.75f);
			}
		}
		else
		{
			Debug.Log("Didn't Find Level " + levelNumber + " Data");
			Image component6 = base.transform.Find("Stats").Find("Rank").GetComponent<Image>();
			component6.color = Color.white;
			component6.fillCenter = false;
			component6.GetComponentInChildren<TMP_Text>().text = "";
			allSecrets = false;
			Image[] array = secretIcons;
			foreach (Image obj2 in array)
			{
				obj2.enabled = true;
				obj2.fillCenter = false;
			}
		}
	}
}



public class LevelStats : MonoBehaviour
{
	public bool cyberGrind;

	public bool secretLevel;

	public TMP_Text levelName;

	private bool ready;

	public TMP_Text time;

	public TMP_Text timeRank;

	private float seconds;

	private float minutes;

	public TMP_Text kills;

	public TMP_Text killsRank;

	public TMP_Text style;

	public TMP_Text styleRank;

	public Image[] secrets;

	private bool checkSecrets = true;

	public TMP_Text challenge;

	public TMP_Text majorAssists;

	[Header("Cyber Grind")]
	public TMP_Text wave;

	public TMP_Text enemiesLeft;

	private StatsManager sman => MonoSingleton<StatsManager>.Instance;

	private void Start()
	{
		if (secretLevel || cyberGrind)
		{
			levelName.text = (cyberGrind ? "THE CYBER GRIND" : "SECRET MISSION");
			ready = true;
			CheckStats();
			return;
		}
		if (SceneHelper.IsPlayingCustom)
		{
			MapInfo instance = MapInfo.Instance;
			levelName.text = ((instance != null) ? instance.levelName : "???");
			ready = true;
			CheckStats();
		}
		RankData rankData = null;
		if (sman.levelNumber != 0 && !Debug.isDebugBuild)
		{
			rankData = GameProgressSaver.GetRank(returnNull: true);
		}
		if (sman.levelNumber != 0 && (Debug.isDebugBuild || (rankData != null && rankData.levelNumber == sman.levelNumber)))
		{
			StockMapInfo instance2 = StockMapInfo.Instance;
			if (instance2 != null)
			{
				levelName.text = instance2.assets.LargeText;
			}
			else
			{
				levelName.text = "???";
			}
			ready = true;
			CheckStats();
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
		if (sman.secretObjects.Length < secrets.Length)
		{
			for (int num = secrets.Length - 1; num >= sman.secretObjects.Length; num--)
			{
				secrets[num].gameObject.SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		if (ready)
		{
			CheckStats();
		}
	}

	private void CheckStats()
	{
		if ((bool)time)
		{
			seconds = sman.seconds;
			minutes = 0f;
			while (seconds >= 60f)
			{
				seconds -= 60f;
				minutes += 1f;
			}
			time.text = minutes + ":" + seconds.ToString("00.000");
		}
		if ((bool)timeRank)
		{
			timeRank.text = sman.GetRanks(sman.timeRanks, sman.seconds, reverse: true);
		}
		if (cyberGrind)
		{
			if ((bool)wave)
			{
				wave.text = MonoSingleton<EndlessGrid>.Instance.waveNumberText.text;
			}
			if ((bool)enemiesLeft)
			{
				enemiesLeft.text = MonoSingleton<EndlessGrid>.Instance.enemiesLeftText.text;
			}
			return;
		}
		if ((bool)kills)
		{
			kills.text = sman.kills.ToString();
		}
		if ((bool)killsRank)
		{
			killsRank.text = sman.GetRanks(sman.killRanks, sman.kills, reverse: false);
		}
		if ((bool)style)
		{
			style.text = sman.stylePoints.ToString();
		}
		if ((bool)styleRank)
		{
			styleRank.text = sman.GetRanks(sman.styleRanks, sman.stylePoints, reverse: false);
		}
		if (checkSecrets && secrets != null && secrets.Length != 0)
		{
			bool flag = true;
			int num = 0;
			for (int num2 = sman.secretObjects.Length - 1; num2 >= 0; num2--)
			{
				if (sman.prevSecrets.Contains(num) || sman.newSecrets.Contains(num))
				{
					secrets[num2].fillCenter = true;
				}
				else
				{
					flag = false;
				}
				num++;
			}
			if (flag)
			{
				checkSecrets = false;
			}
		}
		if ((bool)challenge)
		{
			if (MonoSingleton<ChallengeManager>.Instance.challengeDone && !MonoSingleton<ChallengeManager>.Instance.challengeFailed)
			{
				challenge.text = "<color=#FFAF00>YES</color>";
			}
			else
			{
				challenge.text = "NO";
			}
		}
		if ((bool)majorAssists)
		{
			if (sman.majorUsed)
			{
				majorAssists.text = "<color=#4C99E6>YES</color>";
			}
			else
			{
				majorAssists.text = "NO";
			}
		}
	}
}



public class LevelStatsEnabler : MonoBehaviour
{
	private GameObject levelStats;

	private bool keepOpen;

	private float doubleTap;

	public int secretLevel = -1;

	public bool canAlwaysEnable;

	private void Start()
	{
		if (!canAlwaysEnable)
		{
			if (secretLevel < 0)
			{
				StatsManager instance = MonoSingleton<StatsManager>.Instance;
				RankData rankData = null;
				if (instance.levelNumber != 0 && !Debug.isDebugBuild)
				{
					rankData = GameProgressSaver.GetRank(returnNull: true);
				}
				if ((instance.levelNumber == 0 || ((rankData == null || rankData.levelNumber != instance.levelNumber) && !Debug.isDebugBuild)) && !SceneHelper.IsPlayingCustom)
				{
					PlayerPrefs.SetInt("LevStaOpe", 0);
					base.gameObject.SetActive(value: false);
				}
				else if (PlayerPrefs.GetInt("LevStaTut", 0) == 0)
				{
					Invoke("LevelStatsTutorial", 1.5f);
				}
			}
			else if (GameProgressSaver.GetSecretMission(secretLevel) < 2)
			{
				PlayerPrefs.SetInt("LevStaOpe", 0);
				base.gameObject.SetActive(value: false);
			}
		}
		levelStats = base.transform.GetChild(0).gameObject;
		if (PlayerPrefs.GetInt("LevStaOpe", 0) == 0)
		{
			levelStats.SetActive(value: false);
		}
		else
		{
			keepOpen = true;
		}
	}

	private void Update()
	{
		if (!keepOpen)
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.Stats.WasPerformedThisFrame)
			{
				if (!keepOpen)
				{
					if (doubleTap > 0f)
					{
						PlayerPrefs.SetInt("LevStaOpe", 1);
						keepOpen = true;
					}
					else
					{
						doubleTap = 0.5f;
					}
				}
				levelStats.SetActive(value: true);
			}
			else if (MonoSingleton<InputManager>.Instance.InputSource.Stats.WasCanceledThisFrame)
			{
				levelStats.SetActive(value: false);
			}
		}
		else if (MonoSingleton<InputManager>.Instance.InputSource.Stats.WasPerformedThisFrame)
		{
			keepOpen = false;
			PlayerPrefs.SetInt("LevStaOpe", 0);
			levelStats.SetActive(value: false);
		}
		if (doubleTap > 0f)
		{
			doubleTap = Mathf.MoveTowards(doubleTap, 0f, Time.deltaTime);
		}
	}

	private void LevelStatsTutorial()
	{
		PlayerPrefs.SetInt("LevStaTut", 1);
		MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Hold <color=orange>TAB</color> to see current stats when <color=orange>REPLAYING</color> a level.\n<color=orange>DOUBLE TAP</color> to keep open.");
	}
}



public class LeviathanController : MonoBehaviour
{
	[HideInInspector]
	public bool active = true;

	public LeviathanHead head;

	[SerializeField]
	private Transform headWeakPoint;

	public LeviathanTail tail;

	[SerializeField]
	private Transform tailWeakPoint;

	[HideInInspector]
	public EnemyIdentifier eid;

	[HideInInspector]
	public Statue stat;

	public float phaseChangeHealth;

	private bool inSubPhase;

	private bool secondPhase;

	private int currentAttacks;

	private int setDifficulty = -1;

	public UltrakillEvent onEnterSecondPhase;

	[SerializeField]
	private Transform tailPartsParent;

	[SerializeField]
	private Transform headPartsParent;

	private Transform[] tailParts;

	private Transform[] headParts;

	private int currentPart;

	private GoreZone gz;

	private bool shaking;

	private Vector3 defaultPosition;

	public UltrakillEvent onDeathEnd;

	public GameObject bigSplash;

	[HideInInspector]
	public int difficulty
	{
		get
		{
			return GetDifficulty();
		}
		set
		{
			setDifficulty = value;
		}
	}

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		stat = GetComponent<Statue>();
		tail.lcon = this;
		head.lcon = this;
	}

	private void UpdateBuff()
	{
		head.SetSpeed();
	}

	private int GetDifficulty()
	{
		if (setDifficulty < 0)
		{
			difficulty = ((eid.difficultyOverride >= 0) ? eid.difficultyOverride : MonoSingleton<PrefsManager>.Instance.GetInt("difficulty", 2));
		}
		return setDifficulty;
	}

	private void OnDestroy()
	{
		if (eid.dead)
		{
			DeathEnd();
		}
	}

	private void Update()
	{
		if (shaking)
		{
			base.transform.localPosition = defaultPosition + Random.onUnitSphere * 0.5f;
		}
		if (active && !secondPhase && stat.health <= phaseChangeHealth)
		{
			secondPhase = true;
			onEnterSecondPhase?.Invoke();
			if (!inSubPhase)
			{
				BeginSubPhase();
			}
			else
			{
				BeginMainPhase();
			}
		}
	}

	private void BeginMainPhase()
	{
		if (active)
		{
			if (!secondPhase)
			{
				inSubPhase = false;
			}
			head.ChangePosition();
			eid.weakPoint = headWeakPoint.gameObject;
		}
	}

	public void MainPhaseOver()
	{
		if (active)
		{
			if (!secondPhase)
			{
				BeginSubPhase();
			}
			else
			{
				BeginMainPhase();
			}
		}
	}

	public void BeginSubPhase()
	{
		if (!inSubPhase && active)
		{
			if (!secondPhase)
			{
				eid.weakPoint = tailWeakPoint.gameObject;
			}
			inSubPhase = true;
			currentAttacks = 2;
			SubAttack();
		}
	}

	private void SubAttack()
	{
		if (active)
		{
			if (!BlindEnemies.Blind || secondPhase)
			{
				tail.ChangePosition();
			}
			else
			{
				BeginMainPhase();
			}
		}
	}

	public void SubAttackOver()
	{
		if (!active)
		{
			return;
		}
		if (BlindEnemies.Blind)
		{
			currentAttacks = 0;
		}
		if (!secondPhase)
		{
			currentAttacks--;
			if (currentAttacks <= 0)
			{
				BeginMainPhase();
			}
			else
			{
				SubAttack();
			}
		}
		else if (difficulty <= 2)
		{
			Invoke("SubAttack", (10f - (float)difficulty * 2.5f) / eid.totalSpeedModifier);
		}
		else
		{
			SubAttack();
		}
	}

	private void SpecialDeath()
	{
		headParts = headPartsParent.GetComponentsInChildren<Transform>();
		tailParts = tailPartsParent.GetComponentsInChildren<Transform>();
		Animator[] componentsInChildren = GetComponentsInChildren<Animator>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Object.Destroy(componentsInChildren[i]);
		}
		tail.SwingEnd();
		head.BiteDamageStop();
		active = false;
		head.active = false;
		defaultPosition = base.transform.localPosition;
		shaking = true;
		currentPart = tailParts.Length - 1;
		if (tail.gameObject.activeSelf)
		{
			ExplodeTail();
			return;
		}
		currentPart = headParts.Length - 1;
		ExplodeHead();
	}

	private void ExplodeTail()
	{
		if (tailParts[currentPart] == null)
		{
			currentPart--;
			ExplodeTail();
			return;
		}
		bool flag = true;
		if (currentPart >= 0)
		{
			flag = tailParts[currentPart].position.y > base.transform.position.y - 5f;
			tailParts[currentPart].localScale = Vector3.zero;
			tailParts[currentPart].localPosition = Vector3.zero;
			if (flag)
			{
				GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, isUnderwater: false, eid.sandified, eid.blessed, eid);
				gore.transform.position = tailParts[currentPart].position;
				gore.transform.localScale *= 2f;
				if (!gz)
				{
					gz = GoreZone.ResolveGoreZone(base.transform);
				}
				gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				if (gore.TryGetComponent<AudioSource>(out var component))
				{
					component.maxDistance = 500f;
				}
				gore.SetActive(value: true);
			}
		}
		if (currentPart > 0)
		{
			currentPart = Mathf.Max(0, currentPart - 2);
			if (flag)
			{
				Invoke("ExplodeTail", 0.125f / eid.totalSpeedModifier);
			}
			else
			{
				Invoke("ExplodeTail", 0.025f / eid.totalSpeedModifier);
			}
		}
		else
		{
			tail.gameObject.SetActive(value: false);
			currentPart = headParts.Length - 1;
			Invoke("ExplodeHead", 0.125f / eid.totalSpeedModifier);
		}
	}

	private void ExplodeHead()
	{
		if (headParts[currentPart] == null)
		{
			if (currentPart > 0)
			{
				currentPart--;
				ExplodeHead();
			}
			else
			{
				Invoke("FinalExplosion", 0.5f / eid.totalSpeedModifier);
			}
			return;
		}
		bool flag = true;
		if (currentPart >= 0)
		{
			flag = headParts[currentPart].position.y > base.transform.position.y - 5f;
			headParts[currentPart].localScale = Vector3.zero;
			headParts[currentPart].localPosition = Vector3.zero;
			if (flag)
			{
				GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, isUnderwater: false, eid.sandified, eid.blessed, eid);
				gore.transform.position = headParts[currentPart].position;
				gore.transform.localScale *= 2f;
				if (!gz)
				{
					gz = GoreZone.ResolveGoreZone(base.transform);
				}
				gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				if (gore.TryGetComponent<AudioSource>(out var component))
				{
					component.maxDistance = 500f;
				}
				gore.SetActive(value: true);
			}
		}
		if (currentPart > 0)
		{
			currentPart = Mathf.Max(0, currentPart - 2);
			if (flag)
			{
				Invoke("ExplodeHead", 0.125f / eid.totalSpeedModifier);
			}
			else
			{
				Invoke("ExplodeHead", 0.025f / eid.totalSpeedModifier);
			}
		}
		else
		{
			Invoke("FinalExplosion", 0.5f / eid.totalSpeedModifier);
		}
	}

	private void FinalExplosion()
	{
		Transform[] componentsInChildren = head.tracker.GetComponentsInChildren<Transform>();
		GameObject gameObject = null;
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i] == null)
			{
				continue;
			}
			for (int j = 0; j < 3; j++)
			{
				switch (j)
				{
				case 0:
					gameObject = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, isUnderwater: false, eid.sandified, eid.blessed, eid);
					break;
				case 1:
					gameObject = MonoSingleton<BloodsplatterManager>.Instance.GetGib(BSType.gib);
					break;
				case 2:
					gameObject = MonoSingleton<BloodsplatterManager>.Instance.GetGib((BSType)Random.Range(0, 5));
					break;
				}
				if (!(gameObject == null))
				{
					gameObject.transform.position = componentsInChildren[i].position;
					gameObject.transform.localScale *= (float)((j == 0) ? 3 : 15);
					if (!gz)
					{
						gz = GoreZone.ResolveGoreZone(base.transform);
					}
					gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
					gameObject.SetActive(value: true);
				}
			}
		}
		MonoSingleton<TimeController>.Instance.SlowDown(0.0001f);
		DeathEnd();
	}

	public void DeathEnd()
	{
		onDeathEnd?.Invoke();
		base.gameObject.SetActive(value: false);
	}
}



public class LeviathanHead : MonoBehaviour
{
	[HideInInspector]
	public bool active = true;

	private Animator anim;

	[SerializeField]
	private Transform shootPoint;

	private bool projectileBursting;

	private int projectilesLeftInBurst;

	private float projectileBurstCooldown;

	public float projectileSpreadAmount;

	public Transform tracker;

	private List<Transform> trackerBones = new List<Transform>();

	[SerializeField]
	private Transform tailBone;

	private Transform[] tailBones;

	private bool inAction = true;

	private float attackCooldown;

	public bool lookAtPlayer;

	private Quaternion defaultHeadRotation = new Quaternion(-0.645012f, 0.2603323f, 0.6614516f, 0.2804788f);

	private Quaternion previousHeadRotation;

	private bool notAtDefaultHeadRotation;

	private bool trackerOverrideAnimation;

	private bool trackerIgnoreLimits;

	private float cantTurnToPlayer;

	private float headRotationSpeedMultiplier = 1f;

	private bool freezeTail;

	private Vector3[] defaultTailPositions;

	private Quaternion[] defaultTailRotations;

	private bool rotateBody;

	private Quaternion defaultBodyRotation;

	private Vector3 defaultPosition;

	private bool bodyRotationOverride;

	private Vector3 bodyRotationOverrideTarget;

	[SerializeField]
	private SwingCheck2 biteSwingCheck;

	public Vector3[] spawnPositions;

	private int previousSpawnPosition;

	private int previousAttack = -1;

	private int recentAttacks;

	[HideInInspector]
	public LeviathanController lcon;

	[SerializeField]
	private UltrakillEvent onRoar;

	[SerializeField]
	private AudioSource projectileWindupSound;

	[SerializeField]
	private AudioSource biteWindupSound;

	[SerializeField]
	private AudioSource swingSound;

	[SerializeField]
	private GameObject warningFlash;

	private EnemyTarget Target => lcon.eid.target;

	private void Start()
	{
		SetSpeed();
		previousHeadRotation = tracker.rotation;
		defaultBodyRotation = base.transform.rotation;
		defaultPosition = base.transform.position;
		tailBones = tailBone.GetComponentsInChildren<Transform>();
		defaultTailPositions = new Vector3[tailBones.Length];
		for (int i = 0; i < tailBones.Length; i++)
		{
			defaultTailPositions[i] = tailBones[i].position;
		}
		defaultTailRotations = new Quaternion[tailBones.Length];
		for (int j = 0; j < tailBones.Length; j++)
		{
			defaultTailRotations[j] = tailBones[j].rotation;
		}
		if (!BlindEnemies.Blind)
		{
			anim.Play("AscendLong");
		}
		lookAtPlayer = false;
	}

	public void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (lcon.difficulty == 2)
		{
			anim.speed = 0.9f;
		}
		else if (lcon.difficulty == 1)
		{
			anim.speed = 0.8f;
		}
		else if (lcon.difficulty == 0)
		{
			anim.speed = 0.65f;
		}
		else if (lcon.difficulty == 3)
		{
			anim.speed = 1f;
		}
		else
		{
			anim.speed = 1.25f;
		}
		anim.speed *= lcon.eid.totalSpeedModifier;
	}

	private void OnEnable()
	{
		ResetDefaults();
	}

	private void ResetDefaults()
	{
		defaultBodyRotation = base.transform.rotation;
		headRotationSpeedMultiplier = 1f;
		defaultPosition = base.transform.position;
	}

	private void OnDisable()
	{
		trackerOverrideAnimation = false;
		trackerIgnoreLimits = false;
		projectileBursting = false;
		if ((bool)anim)
		{
			anim.SetBool("ProjectileBurst", value: false);
		}
		bodyRotationOverride = false;
	}

	private void LateUpdate()
	{
		if (!active)
		{
			return;
		}
		if (rotateBody && Target != null)
		{
			Vector3 vector = (bodyRotationOverride ? bodyRotationOverrideTarget : Target.position);
			Quaternion quaternion = Quaternion.LookRotation(base.transform.position - ((vector.y < base.transform.position.y) ? new Vector3(vector.x, base.transform.position.y, vector.z) : vector));
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * Mathf.Max(Mathf.Min(270f, Quaternion.Angle(base.transform.rotation, quaternion) * 13.5f), 10f) * lcon.eid.totalSpeedModifier);
			Quaternion rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * Mathf.Max(Mathf.Min(270f, Quaternion.Angle(base.transform.rotation, quaternion) * 13.5f), 10f) * lcon.eid.totalSpeedModifier);
			Vector3 position = defaultPosition + Vector3.up * (Mathf.Max(0f, base.transform.localRotation.eulerAngles.x) * 0.85f);
			base.transform.SetPositionAndRotation(position, rotation);
		}
		else
		{
			Quaternion rotation2 = Quaternion.RotateTowards(base.transform.rotation, defaultBodyRotation, Time.deltaTime * Mathf.Max(Mathf.Min(270f, Quaternion.Angle(base.transform.rotation, defaultBodyRotation) * 13.5f), 10f) * lcon.eid.totalSpeedModifier);
			Vector3 position2 = Vector3.MoveTowards(base.transform.position, defaultPosition, Time.deltaTime * Mathf.Max(10f, Vector3.Distance(base.transform.position, defaultPosition) * 5f) * lcon.eid.totalSpeedModifier);
			base.transform.SetPositionAndRotation(position2, rotation2);
		}
		if (lookAtPlayer && Target != null)
		{
			Quaternion quaternion2 = Quaternion.LookRotation(Target.position - tracker.position);
			quaternion2 *= Quaternion.Euler(Vector3.right * 90f);
			if (!trackerOverrideAnimation)
			{
				Quaternion quaternion3 = Quaternion.Inverse(tracker.parent.rotation * defaultHeadRotation) * tracker.rotation;
				quaternion2 *= quaternion3;
				if (!trackerIgnoreLimits)
				{
					float num = Quaternion.Angle(quaternion2, tracker.rotation);
					if (num > 50f)
					{
						quaternion2 = Quaternion.Lerp(tracker.rotation, quaternion2, 50f / num);
						cantTurnToPlayer = Mathf.MoveTowards(cantTurnToPlayer, 5f, Time.deltaTime);
					}
					else
					{
						cantTurnToPlayer = Mathf.MoveTowards(cantTurnToPlayer, 0f, Time.deltaTime);
					}
				}
				quaternion2 = Quaternion.RotateTowards(previousHeadRotation, quaternion2, Time.deltaTime * Mathf.Max(Mathf.Min(270f, Quaternion.Angle(previousHeadRotation, quaternion2) * 13.5f), 10f) * headRotationSpeedMultiplier * lcon.eid.totalSpeedModifier);
			}
			tracker.rotation = quaternion2;
			previousHeadRotation = tracker.rotation;
			notAtDefaultHeadRotation = true;
		}
		else if (notAtDefaultHeadRotation)
		{
			if (Quaternion.Angle(previousHeadRotation, tracker.rotation) > 1f)
			{
				tracker.rotation = Quaternion.RotateTowards(previousHeadRotation, tracker.rotation, Time.deltaTime * Mathf.Max(Mathf.Min(270f, Quaternion.Angle(previousHeadRotation, tracker.rotation) * 13.5f), 10f) * headRotationSpeedMultiplier * lcon.eid.totalSpeedModifier);
				previousHeadRotation = tracker.rotation;
			}
			else
			{
				previousHeadRotation = tracker.rotation;
				notAtDefaultHeadRotation = false;
			}
		}
		else
		{
			previousHeadRotation = tracker.rotation;
		}
		if (freezeTail)
		{
			for (int i = 0; i < tailBones.Length; i++)
			{
				tailBones[i].SetPositionAndRotation(defaultTailPositions[i], defaultTailRotations[i]);
			}
		}
	}

	private void Update()
	{
		if (!active || inAction || Target == null)
		{
			return;
		}
		attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * lcon.eid.totalSpeedModifier);
		if (!(attackCooldown <= 0f))
		{
			return;
		}
		if (recentAttacks >= 3)
		{
			Descend();
			return;
		}
		if (Vector3.Distance(Target.position, tracker.position) < 50f)
		{
			Bite();
			previousAttack = 1;
			recentAttacks++;
			return;
		}
		int num = Random.Range(0, 2);
		if (num == previousAttack)
		{
			num++;
		}
		if (num >= 2)
		{
			num = 0;
		}
		switch (num)
		{
		case 0:
			ProjectileBurst();
			break;
		case 1:
			Bite();
			break;
		}
		previousAttack = num;
		recentAttacks++;
	}

	private void FixedUpdate()
	{
		if (!active)
		{
			return;
		}
		if (projectileBursting)
		{
			if (projectileBurstCooldown > 0f)
			{
				projectileBurstCooldown = Mathf.MoveTowards(projectileBurstCooldown, 0f, Time.deltaTime * lcon.eid.totalSpeedModifier);
			}
			else
			{
				if (lcon.difficulty >= 2)
				{
					projectileBurstCooldown = 0.025f;
				}
				else
				{
					projectileBurstCooldown = ((lcon.difficulty == 1) ? 0.0375f : 0.05f);
				}
				projectilesLeftInBurst--;
				GameObject gameObject = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.projectile, shootPoint.position, shootPoint.rotation);
				if (gameObject.TryGetComponent<Projectile>(out var component))
				{
					component.safeEnemyType = EnemyType.Leviathan;
					if (lcon.difficulty >= 2)
					{
						component.speed *= 2f;
					}
					else if (lcon.difficulty == 1)
					{
						component.speed *= 1.5f;
					}
					component.enemyDamageMultiplier = 0.5f;
					component.damage *= lcon.eid.totalDamageModifier;
				}
				if (projectilesLeftInBurst % 10 != 0)
				{
					gameObject.transform.Rotate(new Vector3(Random.Range(0f - projectileSpreadAmount, projectileSpreadAmount), Random.Range(0f - projectileSpreadAmount, projectileSpreadAmount), Random.Range(0f - projectileSpreadAmount, projectileSpreadAmount)));
				}
				else if (Target != null)
				{
					gameObject.transform.rotation = Quaternion.RotateTowards(gameObject.transform.rotation, Quaternion.LookRotation(Target.position - gameObject.transform.position), 5f);
				}
				gameObject.transform.localScale *= 2f;
			}
		}
		if (projectileBursting && (projectilesLeftInBurst <= 0 || Target == null))
		{
			projectileBursting = false;
			trackerIgnoreLimits = false;
			anim.SetBool("ProjectileBurst", value: false);
		}
	}

	private void Descend()
	{
		if (active)
		{
			inAction = true;
			headRotationSpeedMultiplier = 0.5f;
			lookAtPlayer = false;
			rotateBody = false;
			anim.SetBool("Sunken", value: true);
			Object.Instantiate(biteWindupSound, tracker.position, Quaternion.identity, tracker).pitch = 0.5f;
			recentAttacks = 0;
			previousAttack = -1;
		}
	}

	private void DescendEnd()
	{
		if (active)
		{
			base.gameObject.SetActive(value: false);
			lcon.MainPhaseOver();
		}
	}

	public void ChangePosition()
	{
		if (active)
		{
			int num = Random.Range(0, spawnPositions.Length);
			if (spawnPositions.Length > 1 && num == previousSpawnPosition)
			{
				num++;
			}
			if (num >= spawnPositions.Length)
			{
				num = 0;
			}
			if ((bool)lcon.tail && lcon.tail.gameObject.activeInHierarchy && Vector3.Distance(spawnPositions[num], new Vector3(lcon.tail.transform.localPosition.x, spawnPositions[num].y, lcon.tail.transform.localPosition.z)) < 10f)
			{
				num++;
			}
			if (num >= spawnPositions.Length)
			{
				num = 0;
			}
			base.transform.localPosition = spawnPositions[num];
			previousSpawnPosition = num;
			base.transform.rotation = Quaternion.LookRotation(base.transform.position - new Vector3(base.transform.parent.position.x, base.transform.position.y, base.transform.parent.position.z));
			base.gameObject.SetActive(value: true);
			ResetDefaults();
			Ascend();
		}
	}

	private void Ascend()
	{
		if (active)
		{
			inAction = true;
			headRotationSpeedMultiplier = 0.5f;
			lookAtPlayer = false;
			rotateBody = false;
			anim.SetBool("Sunken", value: false);
			BigSplash();
			if (lcon.difficulty <= 2)
			{
				attackCooldown = 1 + (2 - lcon.difficulty);
			}
		}
	}

	private void StartHeadTracking()
	{
		lookAtPlayer = true;
	}

	private void StartBodyTracking()
	{
		rotateBody = true;
	}

	private void Bite()
	{
		if (active)
		{
			rotateBody = true;
			anim.SetTrigger("Bite");
			trackerOverrideAnimation = true;
			inAction = true;
			Object.Instantiate(biteWindupSound, tracker.position, Quaternion.identity, tracker);
			if (lcon.difficulty <= 2)
			{
				attackCooldown = 0.2f + (float)(2 - lcon.difficulty);
			}
		}
	}

	private void BiteStopTracking()
	{
		if (!active)
		{
			return;
		}
		lookAtPlayer = false;
		trackerOverrideAnimation = false;
		bodyRotationOverride = true;
		if (Target != null)
		{
			if (lcon.difficulty == 0)
			{
				bodyRotationOverrideTarget = Target.position;
			}
			else
			{
				bodyRotationOverrideTarget = Target.position + Target.GetVelocity() * ((lcon.difficulty >= 2) ? 0.85f : 0.4f);
			}
			GameObject gameObject = Object.Instantiate(warningFlash, lcon.eid.weakPoint.transform.position + lcon.eid.weakPoint.transform.up, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - tracker.position), tracker);
			gameObject.transform.localScale *= 0.05f;
			gameObject.transform.position += gameObject.transform.forward * 10f;
		}
	}

	private void BiteDamageStart()
	{
		if (active)
		{
			biteSwingCheck.DamageStart();
			Object.Instantiate(swingSound, base.transform.position, Quaternion.identity);
			if (trackerBones == null || trackerBones.Count == 0)
			{
				trackerBones.AddRange(tracker.GetComponentsInChildren<Transform>());
			}
			lcon.stat.parryables = trackerBones;
			lcon.stat.ParryableCheck(partial: true);
		}
	}

	public void BiteDamageStop()
	{
		biteSwingCheck.DamageStop();
		lcon.stat.partiallyParryable = false;
	}

	private void BiteResetRotation()
	{
		rotateBody = false;
		bodyRotationOverride = false;
	}

	private void BiteEnd()
	{
		headRotationSpeedMultiplier = 1f;
		lookAtPlayer = true;
		StopAction();
	}

	private void ProjectileBurst()
	{
		if (active)
		{
			anim.SetBool("ProjectileBurst", value: true);
			if (lcon.difficulty >= 2)
			{
				projectilesLeftInBurst = 80;
			}
			else
			{
				projectilesLeftInBurst = ((lcon.difficulty == 1) ? 60 : 40);
			}
			inAction = true;
			lookAtPlayer = true;
			if (lcon.difficulty <= 2)
			{
				attackCooldown = 0.5f + (float)(2 - lcon.difficulty);
			}
			Object.Instantiate(projectileWindupSound, tracker.position, Quaternion.identity, tracker);
		}
	}

	private void ProjectileBurstStart()
	{
		projectileBursting = true;
	}

	private void StopAction()
	{
		inAction = false;
	}

	private void Roar()
	{
		onRoar?.Invoke();
	}

	private void BigSplash()
	{
		Object.Instantiate(lcon.bigSplash, new Vector3(tracker.position.x, base.transform.position.y, tracker.position.z), Quaternion.LookRotation(Vector3.up));
	}
}



public class LeviathanTail : MonoBehaviour, IHitTargetCallback
{
	private SwingCheck2[] tails;

	public Vector3[] spawnPositions;

	private int previousSpawnPosition;

	private Animator anim;

	[HideInInspector]
	public LeviathanController lcon;

	[SerializeField]
	private AudioSource swingSound;

	[SerializeField]
	private AudioSource[] spawnAuds;

	[SerializeField]
	private AudioClip swingHighSound;

	[SerializeField]
	private AudioClip swingLowSound;

	private bool idling;

	private void Awake()
	{
		tails = GetComponentsInChildren<SwingCheck2>();
		anim = GetComponent<Animator>();
		EnemyIdentifier component = (lcon ? lcon.eid : (component = lcon.GetComponent<EnemyIdentifier>()));
		SwingCheck2[] array = tails;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].eid = component;
		}
	}

	private void Update()
	{
		if (idling && !BlindEnemies.Blind)
		{
			idling = false;
			anim.speed = GetAnimSpeed() * lcon.eid.totalSpeedModifier;
			AudioSource[] array = spawnAuds;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
		}
	}

	public void TargetBeenHit()
	{
		SwingCheck2[] array = tails;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStop();
		}
	}

	private void SwingStart()
	{
		SwingCheck2[] array = tails;
		foreach (SwingCheck2 obj in array)
		{
			obj.DamageStart();
			obj.col.isTrigger = true;
		}
		Object.Instantiate(swingSound, base.transform.position, Quaternion.identity).pitch = 0.5f;
	}

	public void SwingEnd()
	{
		if (tails != null && tails.Length != 0)
		{
			SwingCheck2[] array = tails;
			foreach (SwingCheck2 obj in array)
			{
				obj.DamageStop();
				obj.col.isTrigger = false;
			}
		}
	}

	private void ActionOver()
	{
		base.gameObject.SetActive(value: false);
		lcon.SubAttackOver();
	}

	public void ChangePosition()
	{
		int num = Random.Range(0, spawnPositions.Length);
		if (spawnPositions.Length > 1 && num == previousSpawnPosition)
		{
			num++;
		}
		if (num >= spawnPositions.Length)
		{
			num = 0;
		}
		if ((bool)lcon.head && lcon.head.gameObject.activeInHierarchy && Vector3.Distance(spawnPositions[num], new Vector3(lcon.head.transform.localPosition.x, spawnPositions[num].y, lcon.head.transform.localPosition.z)) < 10f)
		{
			num++;
		}
		if (num >= spawnPositions.Length)
		{
			num = 0;
		}
		base.transform.localPosition = spawnPositions[num];
		previousSpawnPosition = num;
		bool flag = Random.Range(0f, 1f) > 0.5f;
		base.transform.localPosition += (flag ? (Vector3.up * -30.5f) : (Vector3.up * -4.5f));
		base.transform.localScale = new Vector3((!flag) ? 1 : (-1), 1f, 1f);
		if (lcon.difficulty <= 2)
		{
			spawnAuds[0].clip = (flag ? swingLowSound : swingHighSound);
		}
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - new Vector3(base.transform.parent.position.x, base.transform.position.y, base.transform.parent.position.z));
		base.gameObject.SetActive(value: true);
		anim.Rebind();
		anim.Update(0f);
		if (BlindEnemies.Blind)
		{
			idling = true;
			anim.speed = 0f;
			return;
		}
		anim.speed = GetAnimSpeed() * lcon.eid.totalSpeedModifier;
		AudioSource[] array = spawnAuds;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play();
		}
	}

	private void BigSplash()
	{
		Object.Instantiate(lcon.bigSplash, new Vector3(base.transform.position.x, base.transform.position.y, base.transform.position.z), Quaternion.LookRotation(Vector3.up));
	}

	private float GetAnimSpeed()
	{
		return lcon.difficulty switch
		{
			5 => 2f, 
			4 => 1.5f, 
			3 => 1f, 
			2 => 0.85f, 
			1 => 0.65f, 
			0 => 0.45f, 
			_ => 1f, 
		};
	}
}



public class LibraryLadder : MonoBehaviour
{
	public Rigidbody rb;

	public Transform leftClamp;

	public Transform rightClamp;

	private Vector3 startPos;

	private Transform rbTrans;

	private void Start()
	{
		rbTrans = rb.transform;
		startPos = rbTrans.localPosition;
	}

	private void FixedUpdate()
	{
		Vector3 vector = Vector3.Scale(rbTrans.InverseTransformVector(rb.velocity), new Vector3(1f, 0f, 0f));
		rb.velocity = rbTrans.TransformVector(vector);
		Vector3 localPosition = rbTrans.localPosition;
		float x = leftClamp.localPosition.x;
		float x2 = rightClamp.localPosition.x;
		localPosition.x = Mathf.Clamp(localPosition.x, x, x2);
		localPosition.y = startPos.y;
		localPosition.z = startPos.z;
		rbTrans.localPosition = localPosition;
	}
}



public class LightDistanceFade : MonoBehaviour
{
	private Transform player;

	private Light lit;

	private float maxIntensity;

	public float minDistance;

	public float maxDistance;

	private void Start()
	{
		player = MonoSingleton<CameraController>.Instance.transform;
		lit = GetComponent<Light>();
		maxIntensity = lit.intensity;
	}

	private void Update()
	{
		if (!lit || !player)
		{
			return;
		}
		float num = Vector3.Distance(base.transform.position, player.position);
		if (num >= maxDistance)
		{
			lit.enabled = false;
			return;
		}
		lit.enabled = true;
		if (num <= minDistance)
		{
			lit.intensity = maxIntensity;
			return;
		}
		float f = maxDistance - minDistance;
		float f2 = num - minDistance;
		lit.intensity = Mathf.Pow((Mathf.Sqrt(f) - Mathf.Sqrt(f2)) / Mathf.Sqrt(f), 2f) * maxIntensity;
	}
}



public class LightGetEmissiveColor : MonoBehaviour
{
	private Light lit;

	[SerializeField]
	private MeshRenderer targetRenderer;

	private MaterialPropertyBlock block;

	private void Start()
	{
		lit = GetComponent<Light>();
		block = new MaterialPropertyBlock();
		targetRenderer.GetPropertyBlock(block);
		lit.color = block.GetColor(UKShaderProperties.EmissiveColor);
	}

	private void Update()
	{
		targetRenderer.GetPropertyBlock(block);
		lit.color = block.GetColor(UKShaderProperties.EmissiveColor);
	}
}



public class LightningStormMetalChecker : MonoBehaviour
{
	public GameObject lightningBolt;

	public GameObject boltWarning;

	private List<GameObject> boltWarnings = new List<GameObject>();

	public float frequencyMinimum = 10f;

	public float frequencyMaximum = 20f;

	public float damageMultiplier = 1f;

	public float enemyDamageMultiplier = 1f;

	private void Start()
	{
		Invoke("Check", Random.Range(frequencyMinimum / 3f, frequencyMaximum / 3f));
	}

	private void Check()
	{
		List<EnemyIdentifier> currentEnemies = MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies();
		if (currentEnemies.Count > 0)
		{
			for (int i = 0; i < currentEnemies.Count; i++)
			{
				if (currentEnemies[i].enemyType != EnemyType.Ferryman && (currentEnemies[i].nailsAmount >= 40 || currentEnemies[i].stuckMagnets.Count > 0) && OutdoorsChecker.CheckIfPositionOutdoors(currentEnemies[i].transform.position + Vector3.up * 0.25f))
				{
					Transform positionFromEnemy = GetPositionFromEnemy(currentEnemies[i]);
					GameObject gameObject = Object.Instantiate(boltWarning, positionFromEnemy.position, Quaternion.identity);
					Follow follow = gameObject.AddComponent<Follow>();
					follow.target = positionFromEnemy;
					follow.destroyIfNoTarget = true;
					boltWarnings.Add(gameObject);
				}
			}
		}
		Harpoon[] array = Object.FindObjectsOfType<Harpoon>();
		if (array != null && array.Length != 0)
		{
			for (int j = 0; j < array.Length; j++)
			{
				if (array[j].drill)
				{
					GameObject gameObject2 = Object.Instantiate(boltWarning, array[j].transform.position, Quaternion.identity);
					Follow follow2 = gameObject2.AddComponent<Follow>();
					follow2.target = array[j].transform;
					follow2.destroyIfNoTarget = true;
					boltWarnings.Add(gameObject2);
				}
			}
		}
		if (boltWarnings.Count > 0)
		{
			Invoke("Check", Random.Range(frequencyMinimum, frequencyMaximum));
			Invoke("SummonLightning", 3f);
		}
		else
		{
			Invoke("Check", Random.Range(frequencyMinimum / 3f, frequencyMaximum / 3f));
		}
	}

	private void SummonLightning()
	{
		if (boltWarnings != null && boltWarnings.Count > 0)
		{
			for (int num = boltWarnings.Count - 1; num >= 0; num--)
			{
				if (boltWarnings[num] != null)
				{
					if (OutdoorsChecker.CheckIfPositionOutdoors(boltWarnings[num].transform.position))
					{
						GameObject gameObject = Object.Instantiate(lightningBolt, boltWarnings[num].transform.position, Quaternion.identity);
						if ((damageMultiplier != 1f || enemyDamageMultiplier != 1f) && gameObject.TryGetComponent<LightningStrikeExplosive>(out var component))
						{
							component.damageMultiplier = damageMultiplier;
							component.enemyDamageMultiplier = enemyDamageMultiplier;
						}
					}
					Object.Destroy(boltWarnings[num]);
				}
			}
		}
		boltWarnings.Clear();
	}

	private Transform GetPositionFromEnemy(EnemyIdentifier eid)
	{
		if (eid.stuckMagnets.Count > 0)
		{
			for (int i = 0; i < eid.stuckMagnets.Count; i++)
			{
				if (eid.stuckMagnets[i] != null)
				{
					return eid.stuckMagnets[i].transform;
				}
			}
		}
		if (eid.nails.Count > 0)
		{
			for (int j = 0; j < eid.nails.Count; j++)
			{
				if (eid.nails[j] != null)
				{
					return eid.nails[j].transform;
				}
			}
		}
		return eid.transform;
	}
}



public class LightningStrikeDecorative : MonoBehaviour
{
	[SerializeField]
	private SpriteRenderer lightning;

	[SerializeField]
	private Light flash;

	[SerializeField]
	private AudioSource thunder;

	private float originalFlashIntensity;

	private Color originalColor;

	private float cooldown = 15f;

	private bool flashing;

	public bool flashOnStart;

	private void Awake()
	{
		originalFlashIntensity = flash.intensity;
		flash.intensity = 0f;
		originalColor = lightning.color;
		lightning.color = new Color(originalColor.r, originalColor.g, originalColor.b, 0f);
		cooldown = Random.Range(5f, 60f);
		if (flashOnStart)
		{
			FlashStart();
		}
	}

	private void Update()
	{
		cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		if (cooldown == 0f)
		{
			FlashStart();
		}
		if (flashing)
		{
			flash.intensity = Mathf.MoveTowards(flash.intensity, 0f, originalFlashIntensity / 1.5f * Time.deltaTime);
			lightning.color = new Color(originalColor.r, originalColor.g, originalColor.b, Mathf.MoveTowards(lightning.color.a, 0f, Time.deltaTime / 1.5f));
			if (flash.intensity == 0f && lightning.color.a == 0f)
			{
				flashing = false;
			}
		}
	}

	private void FlashStart()
	{
		flashing = true;
		cooldown = Random.Range(25f, 60f);
		thunder.pitch = Random.Range(0.8f, 1.2f);
		thunder.Play();
		flash.intensity = originalFlashIntensity;
		lightning.color = originalColor;
	}
}



public class LightningStrikeExplosive : MonoBehaviour
{
	public GameObject normal;

	public GameObject reflected;

	public bool safeForPlayer;

	public float damageMultiplier = 1f;

	public float enemyDamageMultiplier = 1f;

	private void Start()
	{
		GameObject gameObject = null;
		bool flag = false;
		if ((bool)MonoSingleton<CoinList>.Instance && MonoSingleton<CoinList>.Instance.revolverCoinsList.Count > 0)
		{
			for (int i = 0; i < MonoSingleton<CoinList>.Instance.revolverCoinsList.Count; i++)
			{
				if (MonoSingleton<CoinList>.Instance.revolverCoinsList[i].transform.position.y > MonoSingleton<PlayerTracker>.Instance.GetPlayer().position.y && Vector2.Distance(new Vector2(MonoSingleton<CoinList>.Instance.revolverCoinsList[i].transform.position.x, MonoSingleton<CoinList>.Instance.revolverCoinsList[i].transform.position.z), new Vector2(base.transform.position.x, base.transform.position.z)) < 2f)
				{
					flag = true;
					gameObject = Object.Instantiate(reflected, base.transform.position + Vector3.up * 100f, Quaternion.LookRotation(Vector3.down));
					if (damageMultiplier != 1f && gameObject.TryGetComponent<RevolverBeam>(out var component))
					{
						component.damage *= damageMultiplier;
					}
					break;
				}
			}
		}
		if (!flag)
		{
			gameObject = Object.Instantiate(normal, base.transform.position, Quaternion.identity);
			Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
			foreach (Explosion explosion in componentsInChildren)
			{
				if (damageMultiplier != 1f || enemyDamageMultiplier != 1f)
				{
					explosion.damage = Mathf.RoundToInt((float)explosion.damage * damageMultiplier);
					explosion.enemyDamageMultiplier *= enemyDamageMultiplier;
					explosion.maxSize *= damageMultiplier;
					explosion.speed *= damageMultiplier;
				}
				if (safeForPlayer)
				{
					explosion.canHit = AffectedSubjects.EnemiesOnly;
				}
			}
		}
		if ((bool)base.transform.parent)
		{
			gameObject.transform.SetParent(base.transform.parent, worldPositionStays: true);
		}
		Object.Destroy(base.gameObject);
	}
}



public class LightOff : MonoBehaviour
{
	private Light light;

	private AudioSource[] aud;

	public GameObject otherLamp;

	private Light otherLight;

	public float oLIntensity;

	private void Awake()
	{
		aud = GetComponentsInChildren<AudioSource>();
		light = GetComponentInChildren<Light>();
		otherLight = otherLamp.GetComponent<Light>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			AudioSource[] array = aud;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
			if (light != null)
			{
				light.enabled = false;
			}
			if (otherLight != null)
			{
				otherLight.intensity = oLIntensity;
			}
		}
	}
}



public class LightPillar : MonoBehaviour
{
	public bool gotValues;

	public bool activated;

	public bool completed;

	private Light[] lights;

	private AudioSource aud;

	[HideInInspector]
	public Vector3 origScale;

	[HideInInspector]
	public float lightRange;

	[HideInInspector]
	public float origPitch;

	public float speed;

	private void Start()
	{
		if (activated || completed)
		{
			return;
		}
		lights = GetComponentsInChildren<Light>();
		aud = GetComponentInChildren<AudioSource>();
		if (!gotValues)
		{
			gotValues = true;
			origScale = base.transform.localScale;
			origPitch = aud.pitch + Random.Range(-0.1f, 0.1f);
			if (lights.Length != 0)
			{
				lightRange = lights[0].range;
				Light[] array = lights;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].range = 0f;
				}
			}
		}
		aud.pitch = 0f;
		base.transform.localScale = new Vector3(0f, origScale.y, 0f);
	}

	private void Update()
	{
		if (!activated)
		{
			return;
		}
		if (base.transform.localScale != origScale)
		{
			base.transform.localScale = Vector3.MoveTowards(base.transform.localScale, origScale, speed * Time.deltaTime);
		}
		if (lights != null && lights.Length != 0 && lights[0].range != lightRange)
		{
			Light[] array = lights;
			foreach (Light obj in array)
			{
				obj.range = Mathf.MoveTowards(obj.range, lightRange, speed * 4f * Time.deltaTime);
			}
		}
		if (aud.pitch != origPitch)
		{
			aud.pitch = Mathf.MoveTowards(aud.pitch, origPitch, speed / 3f * origPitch * Time.deltaTime);
		}
		else if (base.transform.localScale == origScale && lights[0].range == lightRange)
		{
			activated = false;
			completed = true;
		}
	}

	public void ActivatePillar()
	{
		activated = true;
	}
}


public enum LimbDestroyType
{
	Destroy,
	Detach,
	LimbGibs
}



public class LimboSwitch : MonoBehaviour
{
	public SwitchLockType type = SwitchLockType.Limbo;

	public bool beenPressed;

	public int switchNumber;

	private float fadeAmount;

	public bool dontSave;

	public UnityEvent onAlreadyPressed;

	public UnityEvent onDelayedEffect;

	private MaterialPropertyBlock block;

	private MeshRenderer mr;

	private void Start()
	{
		mr = GetComponent<MeshRenderer>();
		block = new MaterialPropertyBlock();
		if (!dontSave && ((type == SwitchLockType.Limbo && GameProgressSaver.GetLimboSwitch(switchNumber - 1)) || (type == SwitchLockType.Shotgun && GameProgressSaver.GetShotgunSwitch(switchNumber - 1))))
		{
			beenPressed = true;
			onAlreadyPressed?.Invoke();
			fadeAmount = 2f;
			mr.GetPropertyBlock(block);
			block.SetFloat(UKShaderProperties.EmissiveIntensity, fadeAmount);
			mr.SetPropertyBlock(block);
		}
	}

	private void Update()
	{
		if (beenPressed && fadeAmount < 2f)
		{
			fadeAmount = Mathf.MoveTowards(fadeAmount, 2f, Time.deltaTime);
			mr.GetPropertyBlock(block);
			block.SetFloat(UKShaderProperties.EmissiveIntensity, fadeAmount);
			mr.SetPropertyBlock(block);
		}
	}

	public void Pressed()
	{
		if (beenPressed)
		{
			return;
		}
		beenPressed = true;
		GetComponent<AudioSource>().Play();
		Invoke("DelayedEffect", 1f);
		if (!dontSave)
		{
			if (type == SwitchLockType.Limbo)
			{
				GameProgressSaver.SetLimboSwitch(switchNumber - 1);
			}
			else if (type == SwitchLockType.Shotgun)
			{
				GameProgressSaver.SetShotgunSwitch(switchNumber - 1);
			}
		}
	}

	private void DelayedEffect()
	{
		onDelayedEffect?.Invoke();
	}
}



public class LimboSwitchLock : MonoBehaviour
{
	public SwitchLockType type;

	public MeshRenderer[] locks;

	public MeshRenderer[] primeBossLocks;

	private MaterialPropertyBlock block;

	private float[] lockIntensities;

	private bool[] lockStates;

	private int openedLocks;

	public UnityEvent onAllLocksOpen;

	public int minimumOrderNumber;

	public int primeBossLockNumber = 1;

	private void Start()
	{
		block = new MaterialPropertyBlock();
		lockIntensities = new float[locks.Length + ((primeBossLocks != null && primeBossLocks.Length != 0) ? 1 : 0)];
		lockStates = new bool[locks.Length + ((primeBossLocks != null && primeBossLocks.Length != 0) ? 1 : 0)];
		CheckSaves();
		CheckLocks();
	}

	public void CheckSaves()
	{
		if (type == SwitchLockType.None)
		{
			return;
		}
		if (type == SwitchLockType.Limbo || type == SwitchLockType.Shotgun)
		{
			for (int i = 0; i < locks.Length; i++)
			{
				if ((type == SwitchLockType.Limbo && GameProgressSaver.GetLimboSwitch(i + minimumOrderNumber)) || (type == SwitchLockType.Shotgun && GameProgressSaver.GetShotgunSwitch(i + minimumOrderNumber)))
				{
					lockIntensities[i] = 2f;
					lockStates[i] = true;
					locks[i].GetPropertyBlock(block);
					block.SetFloat(UKShaderProperties.EmissiveIntensity, 2f);
					locks[i].SetPropertyBlock(block);
					openedLocks++;
				}
			}
		}
		else
		{
			if (type != SwitchLockType.PRank)
			{
				return;
			}
			int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			for (int j = 0; j < locks.Length; j++)
			{
				RankData rank = GameProgressSaver.GetRank(j + minimumOrderNumber + 1, returnNull: true);
				if (rank != null && rank.ranks[@int] == 12 && (rank.majorAssists == null || !rank.majorAssists[@int]))
				{
					lockIntensities[j] = 2f;
					lockStates[j] = true;
					locks[j].GetPropertyBlock(block);
					block.SetFloat(UKShaderProperties.EmissiveIntensity, 2f);
					locks[j].SetPropertyBlock(block);
					openedLocks++;
				}
			}
			if (primeBossLocks.Length == 0)
			{
				return;
			}
			RankData rank2 = GameProgressSaver.GetRank(primeBossLockNumber + 665, returnNull: true);
			if (rank2 != null && rank2.ranks[@int] >= 0 && (rank2.majorAssists == null || !rank2.majorAssists[@int]))
			{
				lockIntensities[locks.Length] = 2f;
				lockStates[locks.Length] = true;
				MeshRenderer[] array = primeBossLocks;
				foreach (MeshRenderer obj in array)
				{
					obj.GetPropertyBlock(block);
					block.SetFloat(UKShaderProperties.EmissiveIntensity, 2f);
					obj.SetPropertyBlock(block);
				}
				openedLocks++;
			}
		}
	}

	private void Update()
	{
		for (int i = 0; i < locks.Length; i++)
		{
			if (lockStates[i] && lockIntensities[i] != 2f)
			{
				lockIntensities[i] = Mathf.MoveTowards(lockIntensities[i], 2f, Time.deltaTime);
				locks[i].GetPropertyBlock(block);
				block.SetFloat(UKShaderProperties.EmissiveIntensity, lockIntensities[i]);
				locks[i].SetPropertyBlock(block);
				if (lockIntensities[i] == 2f)
				{
					openedLocks++;
					CheckLocks();
				}
			}
		}
	}

	private void CheckLocks()
	{
		if (openedLocks == locks.Length + ((primeBossLocks != null && primeBossLocks.Length != 0) ? 1 : 0))
		{
			onAllLocksOpen?.Invoke();
		}
	}

	public void OpenLock(int num)
	{
		lockStates[num - 1] = true;
		if (locks[num - 1] != null && locks[num - 1].TryGetComponent<AudioSource>(out var component))
		{
			component.Play();
		}
	}
}



public class LineToPoint : MonoBehaviour
{
	private LineRenderer lr;

	public Transform[] targets;

	private void Update()
	{
		if (lr == null)
		{
			lr = GetComponent<LineRenderer>();
			lr.useWorldSpace = true;
		}
		for (int i = 0; i < targets.Length; i++)
		{
			lr.SetPosition(i, targets[i].position);
		}
	}
}


public enum LinkPlatform
{
	YouTube,
	Twitter,
	Twitch,
	Steam,
	SoundCloud,
	Bandcamp,
	KoFi,
	Patreon,
	PayPalMe
}



public abstract class ListComponent<T> : MonoBehaviour where T : MonoBehaviour
{
	public static List<T> InstanceList = new List<T>();

	protected virtual void Awake()
	{
		InstanceList.Add(this as T);
	}

	protected virtual void OnDestroy()
	{
		InstanceList.Remove(this as T);
	}
}


public enum LMD
{
	Enemies,
	Environment,
	EnvironmentAndBigEnemies,
	EnemiesAndEnvironment,
	EnemiesAndPlayer,
	EnvironmentAndPlayer,
	EnemiesEnvironmentAndPlayer,
	BigEnemiesEnvironmentAndPlayer,
	Player
}


public enum LocalSortMode
{
	Name,
	Date
}


public enum LockerType
{
	State,
	Value,
	Unlocker
}


public enum LockMode
{
	None,
	Lock,
	Unlock
}



public class Machine : MonoBehaviour
{
	public float health;

	private BloodsplatterManager bsm;

	public bool limp;

	private EnemyIdentifier eid;

	public GameObject chest;

	private float chestHP = 3f;

	private AudioSource aud;

	public AudioClip[] hurtSounds;

	[HideInInspector]
	public StyleCalculator scalc;

	private GoreZone gz;

	public Material deadMaterial;

	private Material originalMaterial;

	public SkinnedMeshRenderer smr;

	private NavMeshAgent nma;

	private Rigidbody rb;

	private Rigidbody[] rbs;

	private Animator anim;

	public AudioClip deathSound;

	public AudioClip scream;

	private bool noheal;

	public bool bigKill;

	public bool thickLimbs;

	public bool parryable;

	public bool partiallyParryable;

	[HideInInspector]
	public List<Transform> parryables = new List<Transform>();

	private SwordsMachine sm;

	private Streetcleaner sc;

	private V2 v2;

	private Mindflayer mf;

	private Sisyphus sisy;

	private Turret tur;

	private Ferryman fm;

	private Mannequin man;

	private Minotaur min;

	private Gutterman gm;

	public GameObject[] destroyOnDeath;

	public Machine symbiote;

	private bool symbiotic;

	private bool healing;

	public bool grounded;

	[HideInInspector]
	public GroundCheckEnemy gc;

	public bool knockedBack;

	public bool overrideFalling;

	private float knockBackCharge;

	public float brakes;

	public float juggleWeight;

	public bool falling;

	private LayerMask lmask;

	private LayerMask lmaskWater;

	private float fallSpeed;

	private float fallTime;

	private float reduceFallTime;

	public bool noFallDamage;

	public bool dontDie;

	public bool dismemberment;

	public bool specialDeath;

	public bool simpleDeath;

	[HideInInspector]
	public bool musicRequested;

	public UnityEvent onDeath;

	private int parryFramesLeft;

	private bool parryFramesOnPartial;

	public Transform hitJiggleRoot;

	private Vector3 jiggleRootPosition;

	private void Awake()
	{
		nma = GetComponent<NavMeshAgent>();
		bsm = MonoSingleton<BloodsplatterManager>.Instance;
		rbs = GetComponentsInChildren<Rigidbody>();
		anim = GetComponentInChildren<Animator>();
		eid = GetComponent<EnemyIdentifier>();
		gc = GetComponentInChildren<GroundCheckEnemy>();
		rb = GetComponent<Rigidbody>();
	}

	private void Start()
	{
		if (smr != null)
		{
			originalMaterial = smr.material;
		}
		switch (eid.enemyType)
		{
		case EnemyType.Swordsmachine:
			sm = GetComponent<SwordsMachine>();
			break;
		case EnemyType.Streetcleaner:
			sc = GetComponent<Streetcleaner>();
			break;
		case EnemyType.V2:
			v2 = GetComponent<V2>();
			break;
		case EnemyType.Mindflayer:
			mf = GetComponent<Mindflayer>();
			break;
		case EnemyType.Sisyphus:
			sisy = GetComponent<Sisyphus>();
			break;
		case EnemyType.Turret:
			tur = GetComponent<Turret>();
			break;
		case EnemyType.Ferryman:
			fm = GetComponent<Ferryman>();
			break;
		case EnemyType.Mannequin:
			man = GetComponent<Mannequin>();
			break;
		case EnemyType.Minotaur:
			min = GetComponent<Minotaur>();
			break;
		case EnemyType.Gutterman:
			gm = GetComponent<Gutterman>();
			break;
		}
		if (symbiote != null)
		{
			symbiotic = true;
		}
		if (!gz)
		{
			gz = GoreZone.ResolveGoreZone(base.transform);
		}
		if ((bool)hitJiggleRoot)
		{
			jiggleRootPosition = hitJiggleRoot.localPosition;
		}
		if (!musicRequested && !eid.dead && (sm == null || !eid.IgnorePlayer))
		{
			musicRequested = true;
			MonoSingleton<MusicManager>.Instance.PlayBattleMusic();
		}
		if (limp && !mf)
		{
			noheal = true;
		}
		lmask = (int)lmask | 0x100;
		lmask = (int)lmask | 0x1000000;
		lmaskWater = lmask;
		lmaskWater = (int)lmaskWater | 0x10;
	}

	private void OnEnable()
	{
		parryable = false;
		partiallyParryable = false;
	}

	private void Update()
	{
		if (knockBackCharge > 0f)
		{
			knockBackCharge = Mathf.MoveTowards(knockBackCharge, 0f, Time.deltaTime);
		}
		if (healing && !limp && (bool)symbiote)
		{
			health = Mathf.MoveTowards(health, symbiote.health, Time.deltaTime * 10f);
			eid.health = health;
			if (health >= symbiote.health)
			{
				healing = false;
				if ((bool)sm)
				{
					sm.downed = false;
				}
				if ((bool)sisy)
				{
					sisy.downed = false;
				}
			}
		}
		if (falling && rb != null && !overrideFalling && (!nma || !nma.isOnOffMeshLink))
		{
			fallTime += Time.deltaTime;
			if ((bool)man)
			{
				noFallDamage = man.inControl;
				if (fallTime > 0.2f && !man.inControl)
				{
					parryable = true;
				}
			}
			if (gc.onGround && falling && nma != null)
			{
				if (fallSpeed <= -60f && !noFallDamage && !InvincibleEnemies.Enabled && !eid.blessed && (!gc.fallSuppressed || eid.unbounceable))
				{
					if (eid == null)
					{
						eid = GetComponent<EnemyIdentifier>();
					}
					eid.Splatter();
					return;
				}
				fallSpeed = 0f;
				nma.updatePosition = true;
				nma.updateRotation = true;
				if (!sm || !sm.moveAtTarget)
				{
					rb.isKinematic = true;
				}
				if (aud == null)
				{
					aud = GetComponent<AudioSource>();
				}
				if ((bool)aud && aud.clip == scream && aud.isPlaying)
				{
					aud.Stop();
				}
				rb.useGravity = false;
				nma.enabled = true;
				nma.Warp(base.transform.position);
				falling = false;
				anim.SetBool("Falling", value: false);
				if ((bool)man)
				{
					if (fallTime > 0.2f)
					{
						man.Landing();
					}
					else
					{
						man.inControl = true;
					}
					man.ResetMovementTarget();
				}
			}
			else if (eid.underwater && (bool)aud && aud.clip == scream && aud.isPlaying)
			{
				aud.Stop();
			}
			else if (fallTime > 0.05f && rb.velocity.y < fallSpeed)
			{
				fallSpeed = rb.velocity.y;
				reduceFallTime = 0.5f;
				if (aud == null)
				{
					aud = GetComponent<AudioSource>();
				}
				if ((bool)aud && !aud.isPlaying && !limp && !noFallDamage && !eid.underwater && (!Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, float.PositiveInfinity, lmaskWater, QueryTriggerInteraction.Collide) || ((hitInfo.distance > 42f || rb.velocity.y < -60f) && hitInfo.transform.gameObject.layer != 4)))
				{
					aud.clip = scream;
					aud.volume = 1f;
					aud.priority = 78;
					aud.pitch = Random.Range(0.8f, 1.2f);
					aud.Play();
				}
			}
			else if (fallTime > 0.05f && rb.velocity.y > fallSpeed)
			{
				reduceFallTime = Mathf.MoveTowards(reduceFallTime, 0f, Time.deltaTime);
				if (reduceFallTime <= 0f)
				{
					fallSpeed = rb.velocity.y;
				}
			}
			else if (rb.velocity.y > 0f)
			{
				fallSpeed = 0f;
			}
		}
		else if (fallTime > 0f)
		{
			fallTime = 0f;
		}
	}

	private void FixedUpdate()
	{
		if (parryFramesLeft > 0)
		{
			parryFramesLeft--;
		}
		if (!limp && gc != null && !overrideFalling)
		{
			if (knockedBack && knockBackCharge <= 0f && (rb.velocity.magnitude < 1f || v2 != null) && gc.onGround)
			{
				StopKnockBack();
			}
			else if (knockedBack)
			{
				if (eid.useBrakes || gc.onGround)
				{
					if (knockBackCharge <= 0f && gc.onGround)
					{
						brakes = Mathf.MoveTowards(brakes, 0f, 0.0005f * brakes);
					}
					rb.velocity = new Vector3(rb.velocity.x * 0.95f * brakes, rb.velocity.y - juggleWeight, rb.velocity.z * 0.95f * brakes);
				}
				else if (!eid.useBrakes)
				{
					brakes = 1f;
				}
				if (nma != null)
				{
					nma.updatePosition = false;
					nma.updateRotation = false;
					nma.enabled = false;
					rb.isKinematic = false;
					rb.useGravity = true;
				}
			}
			if (!grounded && gc.onGround)
			{
				grounded = true;
			}
			else if (grounded && !gc.onGround)
			{
				grounded = false;
			}
			if (!gc.onGround && !falling && nma != null && (!nma.enabled || !nma.isOnOffMeshLink))
			{
				rb.isKinematic = false;
				rb.useGravity = true;
				nma.enabled = false;
				falling = true;
				anim.SetBool("Falling", value: true);
				if (sc != null)
				{
					sc.StopFire();
				}
				if (tur != null)
				{
					tur.CancelAim(instant: true);
				}
				if ((bool)man && man.inAction && !man.jumping && !man.inControl)
				{
					man.CancelActions();
				}
			}
		}
		if (hitJiggleRoot != null && hitJiggleRoot.localPosition != jiggleRootPosition)
		{
			hitJiggleRoot.localPosition = Vector3.MoveTowards(hitJiggleRoot.localPosition, jiggleRootPosition, (Vector3.Distance(hitJiggleRoot.localPosition, jiggleRootPosition) + 1f) * 100f * Time.fixedDeltaTime);
		}
	}

	public void KnockBack(Vector3 force)
	{
		if ((!(sc == null) && sc.dodging) || (!(sm == null) && sm.inAction) || (!(tur == null) && tur.lodged) || eid.poise)
		{
			return;
		}
		if (nma != null)
		{
			nma.enabled = false;
			rb.isKinematic = false;
			rb.useGravity = true;
		}
		if ((bool)man)
		{
			man.inControl = false;
			if (man.clinging)
			{
				man.Uncling();
			}
		}
		if ((bool)gc && !overrideFalling)
		{
			if (!knockedBack || (!gc.onGround && rb.velocity.y < 0f))
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			}
			if (!gc.onGround)
			{
				rb.AddForce(Vector3.up, ForceMode.VelocityChange);
			}
		}
		if (hitJiggleRoot != null)
		{
			Vector3 vector = new Vector3(force.x, 0f, force.z);
			hitJiggleRoot.localPosition = jiggleRootPosition + vector.normalized * -0.01f;
			if (Vector3.Distance(hitJiggleRoot.localPosition, jiggleRootPosition) > 0.1f)
			{
				hitJiggleRoot.localPosition = jiggleRootPosition + (hitJiggleRoot.localPosition - jiggleRootPosition).normalized * 0.1f;
			}
		}
		rb.AddForce(force / 10f, ForceMode.VelocityChange);
		knockedBack = true;
		knockBackCharge = Mathf.Min(knockBackCharge + force.magnitude / 1500f, 0.35f);
		brakes = 1f;
	}

	public void StopKnockBack()
	{
		knockBackCharge = 0f;
		if (nma != null)
		{
			if (gc.onGround && Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, lmask))
			{
				_ = Vector3.zero;
				if (NavMesh.SamplePosition(hitInfo.point, out var hit, 4f, nma.areaMask))
				{
					knockedBack = false;
					nma.updatePosition = true;
					nma.updateRotation = true;
					nma.enabled = true;
					if ((!sm || !sm.moveAtTarget) && (!man || !man.jumping))
					{
						rb.isKinematic = true;
					}
					if ((bool)man)
					{
						man.inControl = true;
					}
					juggleWeight = 0f;
					nma.Warp(hit.position);
				}
				else
				{
					knockBackCharge = 0.5f;
				}
			}
			else
			{
				knockBackCharge = 0.5f;
			}
		}
		else if (v2 != null)
		{
			knockedBack = false;
			juggleWeight = 0f;
		}
	}

	public void GetHurt(GameObject target, Vector3 force, float multiplier, float critMultiplier, GameObject sourceWeapon = null, bool fromExplosion = false)
	{
		string hitLimb = "";
		bool dead = false;
		bool flag = false;
		float num = multiplier;
		GameObject gameObject = null;
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (force != Vector3.zero && !limp && sm == null && (v2 == null || !v2.inIntro) && (tur == null || !tur.lodged || eid.hitter == "heavypunch" || eid.hitter == "railcannon" || eid.hitter == "cannonball" || eid.hitter == "hammer"))
		{
			if ((bool)tur && tur.lodged)
			{
				tur.CancelAim(instant: true);
				tur.Unlodge();
			}
			KnockBack(force / 100f);
			if (eid.hitter == "heavypunch" || ((bool)gc && !gc.onGround && eid.hitter == "cannonball"))
			{
				eid.useBrakes = false;
			}
			else
			{
				eid.useBrakes = true;
			}
		}
		if (v2 != null && v2.secondEncounter && eid.hitter == "heavypunch")
		{
			v2.InstaEnrage();
		}
		if (sc != null && target.gameObject == sc.canister && !sc.canisterHit && eid.hitter == "revolver")
		{
			if (!InvincibleEnemies.Enabled && !eid.blessed)
			{
				sc.canisterHit = true;
			}
			if (!eid.dead && !InvincibleEnemies.Enabled && !eid.blessed)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(200, "ultrakill.instakill", sourceWeapon, eid);
			}
			MonoSingleton<TimeController>.Instance.ParryFlash();
			Invoke("CanisterExplosion", 0.1f);
			return;
		}
		if (tur != null && tur.aiming && (eid.hitter == "revolver" || eid.hitter == "coin") && tur.interruptables.Contains(target.transform))
		{
			tur.Interrupt();
		}
		if ((bool)gm)
		{
			if (gm.hasShield && !eid.dead && (eid.hitter == "heavypunch" || eid.hitter == "hammer"))
			{
				gm.ShieldBreak();
			}
			if (gm.hasShield)
			{
				multiplier /= 1.5f;
			}
			if (gm.fallen && !gm.exploded && eid.hitter == "ground slam")
			{
				gm.Explode();
				MonoSingleton<NewMovement>.Instance.Launch(Vector3.up * 750f);
			}
		}
		if ((bool)mf && mf.dying && eid.hitter == "heavypunch")
		{
			mf.DeadLaunch(force);
		}
		if (eid.hitter == "punch")
		{
			bool flag2 = parryables != null && parryables.Count > 0 && parryables.Contains(target.transform);
			if (parryable || (partiallyParryable && (flag2 || (parryFramesLeft > 0 && parryFramesOnPartial))))
			{
				parryable = false;
				partiallyParryable = false;
				parryables.Clear();
				if (!InvincibleEnemies.Enabled && !eid.blessed)
				{
					health -= ((parryFramesLeft > 0) ? 4 : 5);
				}
				MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: false, eid);
				if (sm != null && health > 0f)
				{
					if (!sm.enraged)
					{
						sm.Knockdown(light: true, fromExplosion);
					}
					else
					{
						sm.Enrage();
					}
				}
				else
				{
					SendMessage("GotParried", SendMessageOptions.DontRequireReceiver);
				}
			}
			else
			{
				parryFramesOnPartial = flag2;
				parryFramesLeft = MonoSingleton<FistControl>.Instance.currentPunch.activeFrames;
			}
		}
		else if ((bool)min && min.ramTimer > 0f && eid.hitter == "ground slam")
		{
			min.GotSlammed();
		}
		if ((bool)sisy && num > 0f)
		{
			if (eid.burners.Count > 0)
			{
				if (eid.hitter != "fire")
				{
					if (num <= 0.5f)
					{
						gameObject = bsm.GetGore(GoreType.Limb, eid, fromExplosion);
						sisy.PlayHurtSound(1);
					}
					else
					{
						gameObject = bsm.GetGore(GoreType.Head, eid, fromExplosion);
						sisy.PlayHurtSound(2);
					}
				}
				else
				{
					sisy.PlayHurtSound();
				}
			}
			else if (eid.hitter != "fire")
			{
				gameObject = bsm.GetGore(GoreType.Smallest, eid, fromExplosion);
			}
		}
		float num2 = 0f;
		if (target.gameObject.CompareTag("Head"))
		{
			num2 = 1f;
		}
		else if (target.gameObject.CompareTag("Limb") || target.gameObject.CompareTag("EndLimb"))
		{
			num2 = 0.5f;
		}
		num = multiplier + num2 * multiplier * critMultiplier;
		if (num2 == 0f && (eid.hitter == "shotgunzone" || eid.hitter == "hammerzone"))
		{
			if (!parryable && (target.gameObject != chest || health - num > 0f))
			{
				num = 0f;
			}
			else if ((parryable && (target.gameObject == chest || MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude > 18f)) || (partiallyParryable && parryables != null && parryables.Contains(target.transform)))
			{
				num *= 1.5f;
				parryable = false;
				partiallyParryable = false;
				parryables.Clear();
				MonoSingleton<NewMovement>.Instance.Parry(eid);
				if (sm != null && health - num > 0f)
				{
					if (!sm.enraged)
					{
						sm.Knockdown(light: true, fromExplosion);
					}
					else
					{
						sm.Enrage();
					}
				}
				else
				{
					SendMessage("GotParried", SendMessageOptions.DontRequireReceiver);
				}
			}
		}
		if ((bool)sisy && !limp && eid.hitter == "fire" && health > 0f && health - num < 0.01f && !eid.isGasolined)
		{
			num = health - 0.01f;
		}
		if (!eid.blessed && !InvincibleEnemies.Enabled)
		{
			health -= num;
		}
		if (!gameObject && eid.hitter != "fire" && num > 0f)
		{
			if ((num2 == 1f && (num >= 1f || health <= 0f)) || eid.hitter == "hammer")
			{
				gameObject = bsm.GetGore(GoreType.Head, eid, fromExplosion);
			}
			else if (((num >= 1f || health <= 0f) && eid.hitter != "explosion") || (eid.hitter == "explosion" && target.gameObject.CompareTag("EndLimb")))
			{
				gameObject = ((!target.gameObject.CompareTag("Body")) ? bsm.GetGore(GoreType.Limb, eid, fromExplosion) : bsm.GetGore(GoreType.Body, eid, fromExplosion));
			}
			else if (eid.hitter != "explosion")
			{
				gameObject = bsm.GetGore(GoreType.Small, eid, fromExplosion);
			}
		}
		if (!limp)
		{
			flag = true;
			string text = target.gameObject.tag.ToLower();
			if (text == "endlimb")
			{
				text = "limb";
			}
			hitLimb = text;
		}
		if (health <= 0f)
		{
			if (symbiotic)
			{
				if (sm != null && !sm.downed && symbiote.health > 0f)
				{
					sm.downed = true;
					sm.Down(fromExplosion);
					Invoke("StartHealing", 3f);
				}
				else if (sisy != null && !sisy.downed && symbiote.health > 0f)
				{
					sisy.downed = true;
					sisy.Knockdown(base.transform.position + base.transform.forward);
					Invoke("StartHealing", 3f);
				}
				else if (symbiote.health <= 0f)
				{
					symbiotic = false;
					if (!limp)
					{
						GoLimp(fromExplosion);
					}
				}
			}
			else
			{
				if (!limp)
				{
					GoLimp(fromExplosion);
				}
				if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && !target.gameObject.CompareTag("EndLimb"))
				{
					float num3 = 1f;
					if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone" || eid.hitter == "explosion")
					{
						num3 = 0.5f;
					}
					string text2 = target.gameObject.tag;
					if (!(text2 == "Head"))
					{
						if (text2 == "Limb")
						{
							for (int i = 0; (float)i < 4f * num3; i++)
							{
								GameObject gib = bsm.GetGib(BSType.gib);
								if ((bool)gib && (bool)gz && (bool)gz.gibZone)
								{
									ReadyGib(gib, target);
								}
							}
							if (target.transform.childCount > 0 && dismemberment)
							{
								Transform child = target.transform.GetChild(0);
								CharacterJoint[] componentsInChildren = target.GetComponentsInChildren<CharacterJoint>();
								if (componentsInChildren.Length != 0)
								{
									CharacterJoint[] array = componentsInChildren;
									foreach (CharacterJoint characterJoint in array)
									{
										if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
										{
											component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
										}
										Object.Destroy(characterJoint);
									}
								}
								CharacterJoint component2 = target.GetComponent<CharacterJoint>();
								if (component2 != null)
								{
									component2.connectedBody = null;
									Object.Destroy(component2);
								}
								target.transform.position = child.position;
								target.transform.SetParent(child);
								child.SetParent(gz.gibZone);
								Object.Destroy(target.GetComponent<Rigidbody>());
							}
						}
					}
					else
					{
						for (int k = 0; (float)k < 6f * num3; k++)
						{
							GameObject gib = bsm.GetGib(BSType.skullChunk);
							if ((bool)gib && (bool)gz && (bool)gz.gibZone)
							{
								ReadyGib(gib, target);
							}
						}
						for (int l = 0; (float)l < 4f * num3; l++)
						{
							GameObject gib = bsm.GetGib(BSType.brainChunk);
							if ((bool)gib && (bool)gz && (bool)gz.gibZone)
							{
								ReadyGib(gib, target);
							}
						}
						for (int m = 0; (float)m < 2f * num3; m++)
						{
							GameObject gib = bsm.GetGib(BSType.eyeball);
							if ((bool)gib && (bool)gz && (bool)gz.gibZone)
							{
								ReadyGib(gib, target);
							}
							gib = bsm.GetGib(BSType.jawChunk);
							if ((bool)gib && (bool)gz && (bool)gz.gibZone)
							{
								ReadyGib(gib, target);
							}
						}
					}
				}
				if (dismemberment)
				{
					if (!target.gameObject.CompareTag("Body"))
					{
						if (target.TryGetComponent<Collider>(out var component3))
						{
							Object.Destroy(component3);
						}
						target.transform.localScale = Vector3.zero;
					}
					else if (target.gameObject == chest && v2 == null && sc == null)
					{
						chestHP -= num;
						if (chestHP <= 0f || eid.hitter == "shotgunzone" || eid.hitter == "hammerzone")
						{
							CharacterJoint[] componentsInChildren2 = target.GetComponentsInChildren<CharacterJoint>();
							if (componentsInChildren2.Length != 0)
							{
								CharacterJoint[] array = componentsInChildren2;
								foreach (CharacterJoint characterJoint2 in array)
								{
									if (characterJoint2.transform.parent.parent == chest.transform)
									{
										if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint2.TryGetComponent<EnemyIdentifierIdentifier>(out var component4))
										{
											component4.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
										}
										Object.Destroy(characterJoint2);
										characterJoint2.transform.parent = null;
									}
								}
							}
							if (MonoSingleton<BloodsplatterManager>.Instance.goreOn)
							{
								for (int n = 0; n < 2; n++)
								{
									GameObject gib2 = bsm.GetGib(BSType.gib);
									if ((bool)gib2 && (bool)gz && (bool)gz.gibZone)
									{
										ReadyGib(gib2, target);
									}
								}
							}
							GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion);
							gore.transform.position = target.transform.position;
							gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
							target.transform.localScale = Vector3.zero;
						}
					}
				}
			}
			if (limp)
			{
				Rigidbody componentInParent = target.GetComponentInParent<Rigidbody>();
				if (componentInParent != null)
				{
					componentInParent.AddForce(force);
				}
			}
		}
		if (gameObject != null)
		{
			if (!gz)
			{
				gz = GoreZone.ResolveGoreZone(base.transform);
			}
			if (thickLimbs && target.TryGetComponent<Collider>(out var component5))
			{
				gameObject.transform.position = component5.ClosestPoint(MonoSingleton<NewMovement>.Instance.transform.position);
			}
			else
			{
				gameObject.transform.position = target.transform.position;
			}
			if (eid.hitter == "drill")
			{
				gameObject.transform.localScale *= 2f;
			}
			if (gz != null && gz.goreZone != null)
			{
				gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
			}
			Bloodsplatter component6 = gameObject.GetComponent<Bloodsplatter>();
			if ((bool)component6)
			{
				ParticleSystem.CollisionModule collision = component6.GetComponent<ParticleSystem>().collision;
				if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone" || eid.hitter == "explosion")
				{
					if (Random.Range(0f, 1f) > 0.5f)
					{
						collision.enabled = false;
					}
					component6.hpAmount = 3;
				}
				else if (eid.hitter == "nail")
				{
					component6.hpAmount = 1;
					component6.GetComponent<AudioSource>().volume *= 0.8f;
				}
				if (!noheal)
				{
					component6.GetReady();
				}
			}
		}
		if ((health > 0f || symbiotic) && hurtSounds.Length != 0 && !eid.blessed)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = hurtSounds[Random.Range(0, hurtSounds.Length)];
			if ((bool)tur)
			{
				aud.volume = 0.85f;
			}
			else if ((bool)min)
			{
				aud.volume = 1f;
			}
			else
			{
				aud.volume = 0.5f;
			}
			if (sm != null)
			{
				aud.pitch = Random.Range(0.85f, 1.35f);
			}
			else
			{
				aud.pitch = Random.Range(0.9f, 1.1f);
			}
			aud.priority = 12;
			aud.Play();
		}
		if (num == 0f || eid.puppet)
		{
			flag = false;
		}
		if (!flag || !(eid.hitter != "enemy"))
		{
			return;
		}
		if (scalc == null)
		{
			scalc = MonoSingleton<StyleCalculator>.Instance;
		}
		if (health <= 0f && !symbiotic && (v2 == null || !v2.dontDie) && (!eid.flying || (bool)mf))
		{
			dead = true;
			if ((bool)gc && !gc.onGround)
			{
				if (eid.hitter == "explosion" || eid.hitter == "ffexplosion" || eid.hitter == "railcannon")
				{
					scalc.shud.AddPoints(120, "ultrakill.fireworks", sourceWeapon, eid);
				}
				else if (eid.hitter == "ground slam")
				{
					scalc.shud.AddPoints(160, "ultrakill.airslam", sourceWeapon, eid);
				}
				else if (eid.hitter != "deathzone")
				{
					scalc.shud.AddPoints(50, "ultrakill.airshot", sourceWeapon, eid);
				}
			}
		}
		else if (health > 0f && (bool)gc && !gc.onGround && (eid.hitter == "explosion" || eid.hitter == "ffexplosion" || eid.hitter == "railcannon"))
		{
			scalc.shud.AddPoints(20, "ultrakill.fireworksweak", sourceWeapon, eid);
		}
		if (eid.hitter != "secret")
		{
			if (bigKill)
			{
				scalc.HitCalculator(eid.hitter, "spider", hitLimb, dead, eid, sourceWeapon);
			}
			else
			{
				scalc.HitCalculator(eid.hitter, "machine", hitLimb, dead, eid, sourceWeapon);
			}
		}
	}

	public void GoLimp()
	{
		GoLimp(fromExplosion: false);
	}

	public void GoLimp(bool fromExplosion = false)
	{
		if (limp)
		{
			return;
		}
		if (!gz)
		{
			gz = GoreZone.ResolveGoreZone(base.transform);
		}
		onDeath?.Invoke();
		if (smr != null)
		{
			smr.updateWhenOffscreen = true;
		}
		if (health > 0f)
		{
			health = 0f;
		}
		if (!mf)
		{
			Invoke("StopHealing", 1f);
		}
		if ((bool)v2)
		{
			v2.active = false;
			v2.Die();
		}
		if ((bool)mf)
		{
			mf.active = false;
		}
		if ((bool)tur)
		{
			tur.OnDeath();
		}
		if ((bool)fm)
		{
			fm.OnDeath();
		}
		if ((bool)man)
		{
			man.OnDeath();
		}
		SwingCheck2[] componentsInChildren = GetComponentsInChildren<SwingCheck2>();
		if (sm != null)
		{
			anim.StopPlayback();
			SwingCheck2[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				Object.Destroy(array[i]);
			}
			sm.CoolSword();
			if (sm.currentEnrageEffect != null)
			{
				Object.Destroy(sm.currentEnrageEffect);
			}
			Object.Destroy(sm);
		}
		if (sc != null)
		{
			if (anim != null)
			{
				anim.StopPlayback();
			}
			BulletCheck componentInChildren = GetComponentInChildren<BulletCheck>();
			if (componentInChildren != null)
			{
				Object.Destroy(componentInChildren.gameObject);
			}
			sc.hose.SetParent(sc.hoseTarget, worldPositionStays: true);
			sc.hose.transform.localPosition = Vector3.zero;
			sc.hose.transform.localScale = Vector3.zero;
			sc.StopFire();
			sc.dead = true;
			sc.damaging = false;
			FireZone componentInChildren2 = GetComponentInChildren<FireZone>();
			if ((bool)componentInChildren2)
			{
				Object.Destroy(componentInChildren2.gameObject);
			}
			if (sc.canister != null)
			{
				sc.canister.GetComponentInChildren<ParticleSystem>().Stop();
				AudioSource componentInChildren3 = sc.canister.GetComponentInChildren<AudioSource>();
				if (componentInChildren3 != null)
				{
					if (componentInChildren3.TryGetComponent<AudioLowPassFilter>(out var component))
					{
						Object.Destroy(component);
					}
					Object.Destroy(componentInChildren3);
				}
			}
		}
		if (destroyOnDeath.Length != 0)
		{
			GameObject[] array2 = destroyOnDeath;
			foreach (GameObject gameObject in array2)
			{
				if (gameObject.activeInHierarchy)
				{
					Transform transform = gameObject.GetComponentInParent<Rigidbody>().transform;
					if ((bool)transform)
					{
						gameObject.transform.SetParent(transform);
						gameObject.transform.position = transform.position;
						gameObject.transform.localScale = Vector3.zero;
					}
				}
			}
		}
		if (!dontDie && !eid.dontCountAsKills && !limp)
		{
			if (gz != null && gz.checkpoint != null)
			{
				gz.AddDeath();
				gz.checkpoint.sm.kills++;
			}
			else
			{
				MonoSingleton<StatsManager>.Instance.kills++;
			}
			ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
			if (componentInParent != null)
			{
				componentInParent.AddDeadEnemy();
			}
		}
		EnemySimplifier[] componentsInChildren2 = GetComponentsInChildren<EnemySimplifier>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].Begone();
		}
		if (deadMaterial != null)
		{
			smr.sharedMaterial = deadMaterial;
		}
		else if (smr != null && !mf)
		{
			smr.sharedMaterial = originalMaterial;
		}
		if (nma != null)
		{
			Object.Destroy(nma);
			nma = null;
		}
		if (!v2 && !specialDeath)
		{
			Object.Destroy(anim);
			Object.Destroy(base.gameObject.GetComponent<Collider>());
			if (rb == null)
			{
				rb = GetComponent<Rigidbody>();
			}
			Object.Destroy(rb);
		}
		if (aud == null)
		{
			aud = GetComponent<AudioSource>();
		}
		if (deathSound != null)
		{
			aud.clip = deathSound;
			aud.pitch = Random.Range(0.85f, 1.35f);
			aud.priority = 11;
			aud.Play();
			if ((bool)tur)
			{
				aud.volume = 1f;
			}
		}
		if (!limp)
		{
			SendMessage("Death", SendMessageOptions.DontRequireReceiver);
			if (eid.hitter != "spin")
			{
				if (simpleDeath)
				{
					Explosion[] componentsInChildren3 = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.explosion, base.transform.position, base.transform.rotation).GetComponentsInChildren<Explosion>();
					for (int i = 0; i < componentsInChildren3.Length; i++)
					{
						componentsInChildren3[i].canHit = AffectedSubjects.EnemiesOnly;
					}
					Object.Destroy(base.gameObject);
				}
				else if (!specialDeath && !v2 && !mf)
				{
					rbs = GetComponentsInChildren<Rigidbody>();
					Rigidbody[] array3 = rbs;
					foreach (Rigidbody rigidbody in array3)
					{
						if (rigidbody != null)
						{
							rigidbody.isKinematic = false;
							rigidbody.useGravity = true;
							if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
							{
								component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
							}
							if ((bool)man)
							{
								rigidbody.AddForce((rigidbody.position - eid.overrideCenter.transform.position).normalized * Random.Range(20f, 30f), ForceMode.VelocityChange);
								rigidbody.AddTorque(Random.onUnitSphere * 360f, ForceMode.VelocityChange);
								Object.Instantiate(man.bloodSpray, rigidbody.transform.position, Quaternion.LookRotation(rigidbody.transform.parent.position - rigidbody.transform.position)).transform.SetParent(rigidbody.transform, worldPositionStays: true);
								rigidbody.transform.SetParent(gz.goreZone, worldPositionStays: true);
							}
						}
					}
				}
			}
			if ((bool)man)
			{
				GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, eid, fromExplosion);
				gore.transform.position = chest.transform.position;
				gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				gore.SetActive(value: true);
			}
			if (musicRequested)
			{
				MonoSingleton<MusicManager>.Instance.PlayCleanMusic();
			}
		}
		parryable = false;
		partiallyParryable = false;
		limp = true;
	}

	private void StartHealing()
	{
		if (symbiotic && symbiote != null)
		{
			healing = true;
		}
	}

	private void StopHealing()
	{
		noheal = true;
	}

	public void CanisterExplosion()
	{
		if (InvincibleEnemies.Enabled || eid.blessed)
		{
			if ((bool)sc && sc.canisterHit)
			{
				sc.canisterHit = false;
			}
			return;
		}
		eid.Explode(fromExplosion: true);
		Explosion[] componentsInChildren = Object.Instantiate(sc.explosion.ToAsset(), sc.canister.transform.position, Quaternion.identity).GetComponentsInChildren<Explosion>();
		foreach (Explosion obj in componentsInChildren)
		{
			obj.maxSize *= 1.75f;
			obj.damage = 50;
			obj.friendlyFire = true;
		}
		CharacterJoint[] componentsInChildren2 = chest.GetComponentsInChildren<CharacterJoint>();
		if (componentsInChildren2.Length != 0)
		{
			CharacterJoint[] array = componentsInChildren2;
			foreach (CharacterJoint characterJoint in array)
			{
				if (characterJoint.transform.parent.parent == chest.transform)
				{
					if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
					{
						component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
					}
					Object.Destroy(characterJoint);
					characterJoint.transform.parent = null;
				}
			}
		}
		if (MonoSingleton<BloodsplatterManager>.Instance.goreOn)
		{
			for (int j = 0; j < 2; j++)
			{
				GameObject gib = bsm.GetGib(BSType.gib);
				if ((bool)gib && (bool)gz && (bool)gz.gibZone)
				{
					ReadyGib(gib, sc.canister);
				}
			}
		}
		GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion: true);
		gore.transform.position = sc.canister.transform.position;
		gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
		chest.transform.localScale = Vector3.zero;
		if (sc.canister.TryGetComponent<Collider>(out var component2))
		{
			Object.Destroy(component2);
		}
		sc.canister.transform.localScale = Vector3.zero;
		sc.canister.transform.parent = gz.transform;
		sc.canister.transform.position = Vector3.zero;
	}

	public void ReadyGib(GameObject tempGib, GameObject target)
	{
		tempGib.transform.SetPositionAndRotation(target.transform.position, Random.rotation);
		gz.SetGoreZone(tempGib);
		if (!OptionsMenuToManager.bloodEnabled)
		{
			tempGib.SetActive(value: false);
		}
	}

	public void ParryableCheck(bool partial = false)
	{
		if (partial)
		{
			partiallyParryable = true;
		}
		else
		{
			parryable = true;
		}
		if (parryFramesLeft > 0 && (!partial || parryFramesOnPartial))
		{
			eid.hitter = "punch";
			eid.DeliverDamage(base.gameObject, MonoSingleton<CameraController>.Instance.transform.forward * 25000f, base.transform.position, 1f, tryForExplode: false);
			parryFramesLeft = 0;
		}
	}
}



public class MadnessGas : MonoBehaviour
{
	private void OnTriggerEnter(Collider col)
	{
		if (col.gameObject.layer == 12 && col.TryGetComponent<EnemyIdentifier>(out var component) && (!component.IgnorePlayer || !component.AttackEnemies))
		{
			component.madness = true;
			Transform transform = (component.weakPoint ? component.weakPoint.transform : ((component.overrideCenter != null) ? component.overrideCenter : component.transform));
			GameObject gameObject = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.madnessEffect, transform.position, Quaternion.identity);
			gameObject.transform.SetParent(transform, worldPositionStays: true);
			component.destroyOnDeath.Add(gameObject);
		}
	}
}



public class Magenta
{
	public string path;

	public string version;

	public readonly Dictionary<string, List<string>> bundles;

	public readonly Dictionary<string, string> assetsToBundles;

	public readonly Dictionary<string, List<string>> sceneDependencies;

	public readonly List<string> agonyDependencies;

	public Magenta(string path, bool loadUnhardened = true)
	{
		this.path = path;
		if (!Directory.Exists(path))
		{
			throw new DirectoryNotFoundException();
		}
		if (!File.Exists(Path.Combine(path, "magenta.json")))
		{
			throw new Exception("magenta.json not found");
		}
		Dictionary<string, string> dictionary = JsonConvert.DeserializeObject<Dictionary<string, string>>(File.ReadAllText(Path.Combine(path, "magenta.json")));
		version = dictionary["version"];
		string value = File.ReadAllText(Path.Combine(path, "bundles.json"));
		bundles = JsonConvert.DeserializeObject<Dictionary<string, List<string>>>(value);
		assetsToBundles = new Dictionary<string, string>();
		foreach (KeyValuePair<string, List<string>> bundle in bundles)
		{
			foreach (string item in bundle.Value)
			{
				if (!assetsToBundles.ContainsKey(item))
				{
					assetsToBundles.Add(item, bundle.Key);
				}
			}
		}
		if (loadUnhardened)
		{
			Dictionary<string, List<string>> unhardenedBundles = GetUnhardenedBundles();
			if (unhardenedBundles != null)
			{
				foreach (KeyValuePair<string, List<string>> item2 in unhardenedBundles)
				{
					if (bundles.ContainsKey(item2.Key))
					{
						continue;
					}
					bundles.Add(item2.Key, item2.Value);
					foreach (string item3 in item2.Value.Where((string asset) => !assetsToBundles.ContainsKey(asset)))
					{
						assetsToBundles.Add(item3, item2.Key);
					}
				}
			}
		}
		string text = Path.Combine(path, "sceneDependencies.json");
		if (File.Exists(text))
		{
			string value2 = File.ReadAllText(text);
			sceneDependencies = JsonConvert.DeserializeObject<Dictionary<string, List<string>>>(value2);
		}
		string text2 = Path.Combine(path, "agonyDependencies.json");
		if (File.Exists(text2))
		{
			string value3 = File.ReadAllText(text2);
			agonyDependencies = JsonConvert.DeserializeObject<List<string>>(value3);
		}
	}

	public Dictionary<string, List<string>> GetUnhardenedBundles()
	{
		string text = Path.Combine(path, "unhardenedBundles.json");
		if (!File.Exists(text))
		{
			return null;
		}
		return JsonConvert.DeserializeObject<Dictionary<string, List<string>>>(File.ReadAllText(text));
	}
}



public class Magnet : MonoBehaviour
{
	private List<Rigidbody> affectedRbs = new List<Rigidbody>();

	private List<Rigidbody> removeRbs = new List<Rigidbody>();

	private List<EnemyIdentifier> eids = new List<EnemyIdentifier>();

	private List<Rigidbody> eidRbs = new List<Rigidbody>();

	public List<EnemyIdentifier> ignoredEids = new List<EnemyIdentifier>();

	public EnemyIdentifier onEnemy;

	public List<Magnet> connectedMagnets = new List<Magnet>();

	public List<Rigidbody> sawblades = new List<Rigidbody>();

	public List<Rigidbody> rockets = new List<Rigidbody>();

	public List<Rigidbody> chainsaws = new List<Rigidbody>();

	private SphereCollider col;

	public float strength;

	private LayerMask lmask;

	private RaycastHit rhit;

	[SerializeField]
	private float maxWeight = 10f;

	private TimeBomb tb;

	[HideInInspector]
	public float health = 3f;

	private float maxWeightFinal => maxWeight;

	private void Start()
	{
		col = GetComponent<SphereCollider>();
		lmask = (int)lmask | 0x400;
		lmask = (int)lmask | 0x800;
		tb = GetComponentInParent<TimeBomb>();
		col.enabled = false;
		col.enabled = true;
	}

	private void OnEnable()
	{
		MonoSingleton<ObjectTracker>.Instance.AddMagnet(this);
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<ObjectTracker>.Instance)
		{
			MonoSingleton<ObjectTracker>.Instance.RemoveMagnet(this);
		}
	}

	private void OnDestroy()
	{
		Launch();
		if (connectedMagnets.Count > 0)
		{
			for (int num = connectedMagnets.Count - 1; num >= 0; num--)
			{
				if (connectedMagnets[num] != null)
				{
					DisconnectMagnets(connectedMagnets[num]);
				}
			}
		}
		if ((bool)tb && tb.gameObject.activeInHierarchy)
		{
			Object.Destroy(tb.gameObject);
		}
	}

	public void Launch()
	{
		if (eids.Count > 0)
		{
			for (int num = eids.Count - 1; num >= 0; num--)
			{
				if ((bool)eids[num])
				{
					ExitEnemy(eids[num]);
				}
			}
		}
		if (affectedRbs.Count == 0 && sawblades.Count == 0)
		{
			return;
		}
		List<Nail> list = new List<Nail>();
		foreach (Rigidbody sawblade in sawblades)
		{
			if (!(sawblade != null))
			{
				continue;
			}
			sawblade.velocity = (base.transform.position - sawblade.transform.position).normalized * sawblade.velocity.magnitude;
			if (sawblade.TryGetComponent<Nail>(out var component))
			{
				component.MagnetRelease(this);
				if (component.magnets.Count == 0)
				{
					list.Add(component);
				}
			}
		}
		foreach (Rigidbody affectedRb in affectedRbs)
		{
			if (!(affectedRb != null))
			{
				continue;
			}
			affectedRb.velocity = Vector3.zero;
			if (Physics.SphereCast(new Ray(affectedRb.transform.position, affectedRb.transform.position - base.transform.position), 5f, out rhit, 100f, lmask))
			{
				affectedRb.AddForce((rhit.point - affectedRb.transform.position).normalized * strength * 10f);
			}
			else
			{
				affectedRb.AddForce((base.transform.position - affectedRb.transform.position).normalized * strength * -10f);
			}
			if (affectedRb.TryGetComponent<Nail>(out var component2))
			{
				component2.MagnetRelease(this);
				if (component2.magnets.Count == 0)
				{
					affectedRb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
					list.Add(component2);
				}
			}
		}
		if (list.Count <= 0)
		{
			return;
		}
		GameObject obj = new GameObject("NailBurstController");
		NailBurstController nailBurstController = obj.AddComponent<NailBurstController>();
		nailBurstController.nails = new List<Nail>(list);
		obj.AddComponent<RemoveOnTime>().time = 5f;
		foreach (Nail item in list)
		{
			item.nbc = nailBurstController;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		Magnet component6;
		if (other.gameObject.layer == 14 && other.gameObject.CompareTag("Metal"))
		{
			Rigidbody attachedRigidbody = other.attachedRigidbody;
			if (!(attachedRigidbody != null) || affectedRbs.Contains(attachedRigidbody))
			{
				return;
			}
			Grenade component2;
			Chainsaw component3;
			if (attachedRigidbody.TryGetComponent<Nail>(out var component))
			{
				component.MagnetCaught(this);
				if (!component.sawblade)
				{
					affectedRbs.Add(attachedRigidbody);
					if (OptionsMenuToManager.simpleNailPhysics)
					{
						attachedRigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;
					}
				}
				else if (!sawblades.Contains(attachedRigidbody))
				{
					sawblades.Add(attachedRigidbody);
				}
				if (component.chainsaw && Vector3.Distance(base.transform.position, component.transform.position) > 20f)
				{
					component.transform.position = Vector3.MoveTowards(component.transform.position, base.transform.position, Vector3.Distance(base.transform.position, component.transform.position) - 20f);
				}
			}
			else if (attachedRigidbody.TryGetComponent<Grenade>(out component2))
			{
				if ((onEnemy != null && !onEnemy.dead) || component2.enemy)
				{
					if (!component2.magnets.Contains(this))
					{
						component2.latestEnemyMagnet = this;
						component2.magnets.Add(this);
					}
					if (!rockets.Contains(attachedRigidbody))
					{
						rockets.Add(attachedRigidbody);
					}
				}
			}
			else if (attachedRigidbody.TryGetComponent<Chainsaw>(out component3))
			{
				if (!chainsaws.Contains(attachedRigidbody))
				{
					chainsaws.Add(attachedRigidbody);
				}
			}
			else
			{
				affectedRbs.Add(attachedRigidbody);
			}
		}
		else if (other.gameObject.layer == 12 || other.gameObject.layer == 11)
		{
			EnemyIdentifier component4 = other.gameObject.GetComponent<EnemyIdentifier>();
			if (component4 != null && !component4.bigEnemy && !eids.Contains(component4) && !ignoredEids.Contains(component4))
			{
				Rigidbody component5 = component4.GetComponent<Rigidbody>();
				if (component5 != null)
				{
					component5.mass /= 2f;
					eids.Add(component4);
					eidRbs.Add(component5);
				}
			}
		}
		else if (other.TryGetComponent<Magnet>(out component6) && component6 != this && !connectedMagnets.Contains(component6))
		{
			ConnectMagnets(component6);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == 14 && other.gameObject.CompareTag("Metal"))
		{
			Rigidbody attachedRigidbody = other.attachedRigidbody;
			if (!(attachedRigidbody != null))
			{
				return;
			}
			if (affectedRbs.Contains(attachedRigidbody))
			{
				affectedRbs.Remove(attachedRigidbody);
				if (other.TryGetComponent<Nail>(out var component))
				{
					component.MagnetRelease(this);
					if (component.magnets.Count == 0)
					{
						attachedRigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
					}
				}
			}
			else if (sawblades.Contains(attachedRigidbody))
			{
				if (other.TryGetComponent<Nail>(out var component2))
				{
					component2.MagnetRelease(this);
				}
				sawblades.Remove(attachedRigidbody);
			}
			else if (rockets.Contains(attachedRigidbody))
			{
				if (other.TryGetComponent<Grenade>(out var component3) && component3.magnets.Contains(this))
				{
					component3.magnets.Remove(this);
				}
				rockets.Remove(attachedRigidbody);
			}
			else if (chainsaws.Contains(attachedRigidbody))
			{
				chainsaws.Remove(attachedRigidbody);
			}
		}
		else if (other.gameObject.layer == 12)
		{
			EnemyIdentifier component4 = other.gameObject.GetComponent<EnemyIdentifier>();
			ExitEnemy(component4);
		}
	}

	public void ConnectMagnets(Magnet target)
	{
		if (!target.connectedMagnets.Contains(this))
		{
			target.connectedMagnets.Add(this);
		}
		if (!connectedMagnets.Contains(target))
		{
			connectedMagnets.Add(target);
		}
	}

	public void DisconnectMagnets(Magnet target)
	{
		if (target.connectedMagnets.Contains(this))
		{
			target.connectedMagnets.Remove(this);
		}
		if (connectedMagnets.Contains(target))
		{
			connectedMagnets.Remove(target);
		}
	}

	public void ExitEnemy(EnemyIdentifier eid)
	{
		if (eid != null && eids.Contains(eid))
		{
			int index = eids.IndexOf(eid);
			eids.RemoveAt(index);
			if (eidRbs[index] != null)
			{
				eidRbs[index].mass *= 2f;
			}
			eidRbs.RemoveAt(index);
		}
	}

	private void Update()
	{
		float num = 0f;
		float num2 = strength * Time.deltaTime;
		Vector3 position = base.transform.position;
		foreach (Rigidbody affectedRb in affectedRbs)
		{
			if (affectedRb != null)
			{
				Vector3 position2 = affectedRb.transform.position;
				if (Mathf.Abs(Vector3.Dot(affectedRb.velocity, position - position2)) < 1000f)
				{
					affectedRb.AddForce((position - position2) * ((col.radius - Vector3.Distance(position2, position)) / col.radius * 50f * num2));
					num += affectedRb.mass;
				}
			}
			else
			{
				removeRbs.Add(affectedRb);
			}
		}
		if (chainsaws.Count > 0)
		{
			for (int num3 = chainsaws.Count - 1; num3 >= 0; num3--)
			{
				if (chainsaws[num3] == null)
				{
					chainsaws.RemoveAt(num3);
				}
				else if (Vector3.Distance(base.transform.position, chainsaws[num3].position) < 15f && Vector3.Dot(chainsaws[num3].position - base.transform.position, chainsaws[num3].velocity.normalized) < 0f)
				{
					Vector3 position3 = chainsaws[num3].transform.position;
					if (Mathf.Abs(Vector3.Dot(chainsaws[num3].velocity, position - position3)) < 1000f)
					{
						chainsaws[num3].AddForce((position - position3) * ((col.radius - Vector3.Distance(position3, position)) / col.radius * 50f * num2));
						num += chainsaws[num3].mass;
					}
				}
			}
		}
		foreach (Rigidbody sawblade in sawblades)
		{
			if (sawblade != null)
			{
				num += sawblade.mass;
			}
			else
			{
				removeRbs.Add(sawblade);
			}
		}
		if (removeRbs.Count > 0)
		{
			foreach (Rigidbody removeRb in removeRbs)
			{
				affectedRbs.Remove(removeRb);
			}
			removeRbs.Clear();
		}
		for (int num4 = eids.Count - 1; num4 >= 0; num4--)
		{
			EnemyIdentifier enemyIdentifier = eids[num4];
			Rigidbody rigidbody = eidRbs[num4];
			if (enemyIdentifier != null && rigidbody != null && !ignoredEids.Contains(enemyIdentifier))
			{
				Vector3 position4 = rigidbody.transform.position;
				if (enemyIdentifier.nailsAmount > 0 && !eidRbs[num4].isKinematic)
				{
					enemyIdentifier.useBrakes = false;
					enemyIdentifier.pulledByMagnet = true;
					rigidbody.AddForce((position - position4).normalized * ((col.radius - Vector3.Distance(position4, position)) / col.radius * (float)enemyIdentifier.nailsAmount * 5f * num2));
					num += rigidbody.mass;
				}
			}
			else
			{
				eids.RemoveAt(num4);
				eidRbs.RemoveAt(num4);
			}
		}
		float num5 = maxWeightFinal * (float)(connectedMagnets.Count + 1);
		if (num > num5 && !PauseTimedBombs.Paused)
		{
			Object.Destroy(tb.gameObject);
			return;
		}
		tb.beeperColor = Color.Lerp(Color.green, Color.red, num / num5);
		tb.beeperPitch = num / num5 / 2f + 0.25f;
		tb.beeperSizeMultiplier = num / num5 + 1f;
	}

	public IEnumerator Zap(List<GameObject> alreadyHitObjects, float damage = 1f, GameObject sourceWeapon = null)
	{
		alreadyHitObjects.Add(base.gameObject);
		yield return new WaitForSeconds(0.25f);
		EnemyIdentifier.Zap(base.transform.position, damage, alreadyHitObjects, sourceWeapon);
		DamageMagnet(1f);
	}

	public void DamageMagnet(float damage)
	{
		health -= damage;
		if (health <= 0f)
		{
			if ((bool)base.transform.parent && base.transform.parent.TryGetComponent<Harpoon>(out var component))
			{
				Object.Destroy(component.gameObject);
			}
			else
			{
				Object.Destroy(base.gameObject);
			}
		}
	}
}



public class MainMenuAgony : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("MainMenuAgony");

	public static bool isAgonyOpen = true;

	[SerializeField]
	private GameObject agonyButton;

	[Space]
	[SerializeField]
	private GameObject normalLights;

	[SerializeField]
	private GameObject agonyLights;

	[Space]
	[SerializeField]
	private GameObject[] agonyMenus;

	[SerializeField]
	private GameObject mainMenu;

	private void Awake()
	{
		isAgonyOpen = false;
		GameObject[] array = agonyMenus;
		for (int i = 0; i < array.Length; i++)
		{
			Object.DestroyImmediate(array[i]);
		}
	}

	private void Start()
	{
	}

	private IEnumerator CloseMainMenuDelayed()
	{
		yield return null;
		mainMenu.SetActive(value: false);
	}

	private void Update()
	{
		bool flag = isAgonyOpen;
		normalLights.SetActive(!flag);
		agonyLights.SetActive(flag);
	}

	public void OpenAgony(bool restore = false)
	{
		isAgonyOpen = true;
		if (restore)
		{
			agonyMenus.Last().SetActive(value: true);
		}
		else
		{
			agonyMenus.First().SetActive(value: true);
		}
		mainMenu.SetActive(value: false);
	}

	public void CloseAgony()
	{
		isAgonyOpen = false;
		GameObject[] array = agonyMenus;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		mainMenu.SetActive(value: true);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class MainMenuPit : MonoSingleton<MainMenuPit>
{
	protected override void Awake()
	{
		if (MonoSingleton<MainMenuPit>.Instance != null && MonoSingleton<MainMenuPit>.Instance != this)
		{
			Object.Destroy(MonoSingleton<MainMenuPit>.Instance.gameObject);
		}
		base.Awake();
	}
}



public class Mandalore : MonoBehaviour
{
	private AudioSource aud;

	private EnemyIdentifier eid;

	public AudioClip voiceFull;

	public AudioClip voiceFuller;

	private float cooldown = 2f;

	private float fullerChance;

	private int shotsLeft;

	private float maxHp;

	private int phase = 1;

	public GameObject fullAutoProjectile;

	public GameObject fullerAutoProjectile;

	public MandaloreVoice[] voices;

	private bool taunt = true;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
		eid = GetComponent<EnemyIdentifier>();
		maxHp = GetComponent<Drone>().health;
		voices = GetComponentsInChildren<MandaloreVoice>();
	}

	private void Start()
	{
		if (taunt)
		{
			int num = Random.Range(0, voices[0].taunts.Length);
			MandaloreVoice[] array = voices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Taunt(num);
			}
			switch (num)
			{
			case 0:
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>You cannot imagine what you'll face here</color>");
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>I'm gonna shoot em with a gun</color>", 2.5f, base.gameObject);
				break;
			case 1:
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>Why are we in the past</color>");
				break;
			case 2:
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>I'm going to fucking poison you</color>");
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>What</color>", 2f, base.gameObject);
				break;
			case 3:
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>Hold still</color>", 0.6f, base.gameObject);
				break;
			}
		}
	}

	private void Update()
	{
		if (eid.target == null)
		{
			return;
		}
		if (eid.dead)
		{
			if (!voices[0].dying)
			{
				MandaloreVoice[] array = voices;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Death();
				}
				GetComponent<Rigidbody>().mass = 5f;
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>Oh great, now we lost the fight, fantastic</color>");
			}
			return;
		}
		if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		else if (!voices[0].talking && !voices[1].talking && eid.target != null)
		{
			if (Random.Range(0f, 1f) > fullerChance)
			{
				if (fullerChance < 0.5f)
				{
					fullerChance = 0.5f;
				}
				fullerChance += 0.2f;
				if (phase == 1)
				{
					cooldown = 4f;
				}
				else if (phase == 2)
				{
					cooldown = 3.25f;
				}
				else
				{
					cooldown = 2.5f;
				}
				aud.PlayOneShot(voiceFull);
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Full auto");
				Invoke("FullBurst", 1f);
				shotsLeft = 4;
			}
			else
			{
				if (fullerChance > 0.5f)
				{
					fullerChance = 0.5f;
				}
				fullerChance -= 0.2f;
				if (eid.health > maxHp / 3f * 2f)
				{
					cooldown = 4f;
				}
				else if (eid.health > maxHp / 3f)
				{
					cooldown = 3f;
				}
				else
				{
					cooldown = 2f;
				}
				aud.PlayOneShot(voiceFuller);
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Fuller auto");
				Invoke("FullerBurst", 1f);
				shotsLeft = 40;
			}
		}
		if (aud.isPlaying || voices[0].talking || voices[1].talking)
		{
			return;
		}
		if (phase < 4 && eid.health < maxHp / 4f)
		{
			phase = 4;
			MandaloreVoice[] array = voices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].FinalPhase();
			}
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>Use the salt!</color>");
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>I'm reaching!</color>", 1.5f, base.gameObject);
			Invoke("Sandify", 2.5f / eid.totalSpeedModifier);
		}
		else if (phase < 3 && eid.health < maxHp / 2f)
		{
			phase = 3;
			MandaloreVoice[] array = voices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ThirdPhase();
			}
			Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.enrageEffect, base.transform);
			EnemySimplifier[] componentsInChildren = GetComponentsInChildren<EnemySimplifier>();
			if (componentsInChildren.Length != 0)
			{
				EnemySimplifier[] array2 = componentsInChildren;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].enraged = true;
				}
			}
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>Feel my maximum speed!</color>");
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>Slow down</color>", 3.25f, base.gameObject);
		}
		else if (phase < 2 && eid.health < maxHp / 4f * 3f)
		{
			phase = 2;
			MandaloreVoice[] array = voices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SecondPhase();
			}
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#FFC49E>Through the magic of the Druids, I increase my speed!</color>");
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("<color=#9EE6FF>Just fucking hit em</color>", 2.5f, base.gameObject);
		}
	}

	public void FullBurst()
	{
		if (!eid.dead)
		{
			GameObject obj = Object.Instantiate(fullAutoProjectile, base.transform.position, base.transform.rotation);
			Projectile componentInChildren = obj.GetComponentInChildren<Projectile>();
			componentInChildren.speed = 250f;
			componentInChildren.safeEnemyType = EnemyType.Drone;
			componentInChildren.precheckForCollisions = true;
			componentInChildren.damage *= eid.totalDamageModifier;
			obj.GetComponent<ProjectileSpread>().projectileAmount = 6;
			shotsLeft--;
			if (shotsLeft > 0)
			{
				Invoke("FullBurst", 0.2f / eid.totalSpeedModifier);
			}
		}
	}

	public void FullerBurst()
	{
		if (!eid.dead)
		{
			Projectile componentInChildren = Object.Instantiate(fullerAutoProjectile, base.transform.position, Random.rotation).GetComponentInChildren<Projectile>();
			componentInChildren.speed = 2.5f;
			componentInChildren.turnSpeed = 150f;
			componentInChildren.target = eid.target;
			componentInChildren.safeEnemyType = EnemyType.Drone;
			componentInChildren.damage *= eid.totalDamageModifier;
			shotsLeft--;
			if (shotsLeft > 0)
			{
				Invoke("FullerBurst", 0.02f / eid.totalSpeedModifier);
			}
		}
	}

	public void Sandify()
	{
		eid.Sandify();
	}

	public void DontTaunt()
	{
		taunt = false;
	}
}



public class MandaloreVoice : MonoBehaviour
{
	private AudioSource aud;

	public bool talking;

	public bool dying;

	public AudioClip secondPhase;

	public AudioClip thirdPhase;

	public AudioClip finalPhase;

	public AudioClip death;

	public AudioClip[] taunts;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (!aud.isPlaying)
		{
			talking = false;
		}
	}

	public void SecondPhase()
	{
		aud.Stop();
		aud.PlayOneShot(secondPhase);
		talking = true;
	}

	public void ThirdPhase()
	{
		aud.Stop();
		aud.PlayOneShot(thirdPhase);
		talking = true;
	}

	public void FinalPhase()
	{
		aud.Stop();
		aud.PlayOneShot(finalPhase);
		talking = true;
	}

	public void Death()
	{
		aud.Stop();
		aud.PlayOneShot(death);
		talking = true;
		dying = true;
	}

	public void Taunt(int num)
	{
		aud.Stop();
		if (taunts[num] != null)
		{
			aud.PlayOneShot(taunts[num]);
		}
		talking = true;
	}
}



public class Mannequin : MonoBehaviour
{
	private bool gotValues;

	private Animator anim;

	private NavMeshAgent nma;

	private NavMeshPath nmp;

	private Machine mach;

	private EnemyIdentifier eid;

	private Rigidbody rb;

	private SwingCheck2 sc;

	public GameObject bloodSpray;

	private bool skitterMode;

	private float walkSpeed = 22f;

	private float skitterSpeed = 64f;

	private int difficulty;

	public bool inAction;

	public MannequinBehavior behavior;

	public bool dontChangeBehavior;

	public bool dontAutoDrop;

	public bool stationary;

	private Vector3 randomMovementTarget;

	private bool trackTarget;

	private bool moveForward;

	[SerializeField]
	private TrailRenderer[] trails;

	[SerializeField]
	private Transform shootPoint;

	private bool aiming;

	[SerializeField]
	private Transform aimBone;

	private Vector3 aimPoint;

	public Projectile projectile;

	public GameObject chargeProjectile;

	[HideInInspector]
	public GameObject currentChargeProjectile;

	private bool chargingProjectile;

	private float meleeCooldown = 0.5f;

	private float projectileCooldown = 1f;

	private float jumpCooldown = 2f;

	private float meleeBehaviorCancel = 3.5f;

	public bool inControl;

	private bool canCling = true;

	[HideInInspector]
	public bool clinging;

	private Collider clungSurfaceCollider;

	private int attacksWhileClinging;

	private Vector3 clingNormal;

	private Vector3? clungMovementTarget;

	[SerializeField]
	private float clungMovementTolerance = 1.25f;

	private bool firstClingCheck = true;

	public AudioSource clingSound;

	private Collider col;

	[SerializeField]
	private AudioSource skitterSound;

	public string mostRecentAction;

	[HideInInspector]
	public bool jumping;

	private static bool debug => MannequinDebugGizmos.Enabled;

	private void Awake()
	{
		anim = GetComponent<Animator>();
		nma = GetComponent<NavMeshAgent>();
		mach = GetComponent<Machine>();
		eid = GetComponent<EnemyIdentifier>();
		rb = GetComponent<Rigidbody>();
		sc = GetComponentInChildren<SwingCheck2>();
		col = GetComponent<Collider>();
		nmp = new NavMeshPath();
	}

	private void Start()
	{
		GetValues();
		SlowUpdate();
	}

	private void OnEnable()
	{
		CancelActions(changeBehavior: false);
	}

	private void GetValues()
	{
		if (!gotValues)
		{
			gotValues = true;
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			skitterSound.priority = Random.Range(100, 200);
			SetSpeed();
			if (behavior == MannequinBehavior.Random)
			{
				ChangeBehavior();
			}
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		GetValues();
		if (difficulty == 0)
		{
			anim.speed = 0.75f;
			walkSpeed = 10f;
			skitterSpeed = 32f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.85f;
			walkSpeed = 12f;
			skitterSpeed = 48f;
		}
		else if (difficulty >= 4)
		{
			anim.speed = 1.25f;
			walkSpeed = 20f;
			skitterSpeed = 64f;
		}
		else
		{
			anim.speed = 1f;
			walkSpeed = 16f;
			skitterSpeed = 64f;
		}
		walkSpeed *= eid.totalSpeedModifier;
		skitterSpeed *= eid.totalSpeedModifier;
		anim.speed *= eid.totalSpeedModifier;
		if (difficulty <= 2)
		{
			anim.SetFloat("DifficultyDependentSpeed", 0.66f);
		}
		else
		{
			anim.SetFloat("DifficultyDependentSpeed", 1f);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.1f);
		if (!inAction && eid.target != null)
		{
			if (mach.gc.onGround)
			{
				nma.enabled = true;
			}
			if (nma.enabled && mach.gc.onGround && nma.isOnNavMesh)
			{
				canCling = true;
				if (meleeCooldown <= 0f && Vector3.Distance(eid.target.position, base.transform.position) < 5f)
				{
					MeleeAttack();
				}
				else if (behavior == MannequinBehavior.Melee || Physics.Raycast(eid.overrideCenter.position, eid.target.position - eid.overrideCenter.position, Vector3.Distance(eid.target.position, eid.overrideCenter.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore))
				{
					if (!stationary)
					{
						randomMovementTarget = base.transform.position;
						MoveToTarget(GetTargetPosition(), forceSkitter: true);
					}
				}
				else if (projectileCooldown <= 0f)
				{
					ProjectileAttack();
				}
				else if (!stationary && Vector3.Distance(eid.target.position, base.transform.position) > 50f)
				{
					SetMovementTarget(eid.target.position - base.transform.position, Vector3.Distance(eid.target.position, base.transform.position) - 40f);
				}
				else if (!stationary)
				{
					RaycastHit hitInfo;
					if (behavior == MannequinBehavior.RunAway && Vector3.Distance(eid.target.position, base.transform.position) < 15f)
					{
						SetMovementTarget(base.transform.position - eid.target.position, 20f - Vector3.Distance(eid.target.position, base.transform.position));
					}
					else if (canCling && behavior == MannequinBehavior.Jump && jumpCooldown <= 0f && Physics.Raycast(base.transform.position + Vector3.up, Vector3.up, out hitInfo, 40f, LayerMaskDefaults.Get(LMD.Environment)) && !Physics.Raycast(hitInfo.point - Vector3.up * 3f, eid.target.position - (hitInfo.point - Vector3.up * 3f), Vector3.Distance(eid.target.position, hitInfo.point - Vector3.up * 3f), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore))
					{
						Jump();
					}
					else if (Vector3.Distance(base.transform.position, randomMovementTarget) < 5f)
					{
						SetMovementTarget(Random.onUnitSphere);
					}
					else
					{
						nma.SetDestination(randomMovementTarget);
					}
				}
			}
			else if (clinging)
			{
				if (!stationary && Physics.Raycast(eid.overrideCenter.position, eid.target.position - eid.overrideCenter.position, Vector3.Distance(eid.target.position, eid.overrideCenter.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Ignore))
				{
					inControl = true;
					anim.SetBool("InControl", value: true);
					Uncling();
				}
				else if (projectileCooldown <= 0f && !clungMovementTarget.HasValue)
				{
					ProjectileAttack();
				}
			}
		}
		else
		{
			nma.enabled = false;
		}
	}

	private void Update()
	{
		if (mach.gc.onGround && nma.velocity.magnitude > 3f)
		{
			anim.SetBool("Walking", value: true);
		}
		else
		{
			anim.SetBool("Walking", value: false);
		}
		anim.SetBool("Skittering", skitterMode);
		anim.SetBool("InControl", inControl);
		nma.speed = (skitterMode ? skitterSpeed : walkSpeed);
		if (skitterMode && nma.velocity.magnitude > 3f && !skitterSound.isPlaying)
		{
			skitterSound.pitch = Random.Range(0.9f, 1.1f);
			skitterSound.Play();
			skitterSound.time = Random.Range(0f, skitterSound.clip.length);
		}
		else
		{
			skitterSound.Stop();
		}
		if ((inAction || clinging) && trackTarget && eid.target != null)
		{
			float num = Vector3.Dot(base.transform.up, eid.target.position - base.transform.position);
			Quaternion quaternion = Quaternion.LookRotation(eid.target.position - base.transform.up * num - base.transform.position, base.transform.up);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Mathf.Max(Quaternion.Angle(base.transform.rotation, quaternion), 10f) * 10f * Time.deltaTime);
		}
		if (meleeCooldown > 0f)
		{
			meleeCooldown = Mathf.MoveTowards(meleeCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (projectileCooldown > 0f)
		{
			projectileCooldown = Mathf.MoveTowards(projectileCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (jumpCooldown > 0f)
		{
			jumpCooldown = Mathf.MoveTowards(jumpCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (behavior == MannequinBehavior.Melee && !inAction && meleeBehaviorCancel > 0f)
		{
			meleeBehaviorCancel = Mathf.MoveTowards(meleeBehaviorCancel, 0f, Time.deltaTime * eid.totalSpeedModifier);
			if (meleeBehaviorCancel <= 0f)
			{
				ChangeBehavior();
			}
		}
		if (((nma.enabled && !inAction && behavior == MannequinBehavior.RunAway) || behavior == MannequinBehavior.Wander) && nma.velocity.magnitude > 2f)
		{
			Vector3 origin = eid.overrideCenter.position + Vector3.up * 0.5f;
			Vector3 normalized = nma.velocity.normalized;
			normalized.y = 0f;
			if (Physics.Raycast(new Ray(origin, normalized), out var hitInfo, 6f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				Ray ray = new Ray(origin, Quaternion.Euler(0f, -90f, 0f) * normalized);
				Ray ray2 = new Ray(origin, Quaternion.Euler(0f, 90f, 0f) * normalized);
				float maxDistance = 2f;
				if (Physics.Raycast(ray, out var hitInfo2, maxDistance, LayerMaskDefaults.Get(LMD.Environment)) || Physics.Raycast(ray2, out hitInfo2, maxDistance, LayerMaskDefaults.Get(LMD.Environment)))
				{
					if (debug)
					{
						Debug.Log("Space too tight, ignoring cling attempt", base.gameObject);
					}
					return;
				}
				clungMovementTarget = null;
				ClingToSurface(hitInfo);
				RelocateWhileClinging(ClungMannequinMovementDirection.Vertical);
				_ = debug;
			}
			_ = debug;
		}
		if (clungMovementTarget.HasValue && clinging && !inAction)
		{
			_ = debug;
			base.transform.position = Vector3.MoveTowards(base.transform.position, clungMovementTarget.Value, 30f * Time.deltaTime * eid.totalSpeedModifier);
			if (Vector3.Distance(base.transform.position, clungMovementTarget.Value) < 0.1f)
			{
				if (debug)
				{
					Debug.Log("Reached clung movement target", base.gameObject);
				}
				clungMovementTarget = null;
				skitterMode = false;
				RaycastHit hitInfo3;
				bool num2 = Physics.Raycast(new Ray(base.transform.position, Vector3.down), out hitInfo3, 3f, LayerMaskDefaults.Get(LMD.Environment));
				_ = debug;
				if (num2)
				{
					if (debug)
					{
						Debug.Log("We've hit the floor while cling walking. Let's jump off", base.gameObject);
					}
					Uncling();
				}
			}
		}
		if (clinging && (clungSurfaceCollider == null || !clungSurfaceCollider.enabled || !clungSurfaceCollider.gameObject.activeInHierarchy))
		{
			Uncling();
		}
	}

	private void FixedUpdate()
	{
		if (inAction && moveForward && !Physics.Raycast(base.transform.position + Vector3.up * 3f, base.transform.forward, 55f * Time.fixedDeltaTime * eid.totalSpeedModifier, LayerMaskDefaults.Get(LMD.Player), QueryTriggerInteraction.Ignore))
		{
			if (Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward, Vector3.down, out var _, (eid.target == null) ? 22f : Mathf.Max(22f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				rb.velocity = base.transform.forward * 55f * anim.speed * eid.totalSpeedModifier;
			}
			else
			{
				rb.velocity = Vector3.zero;
			}
		}
		if (canCling && !mach.gc.onGround)
		{
			CheckClings();
		}
		anim.SetFloat("ySpeed", rb.isKinematic ? 0f : rb.velocity.y);
	}

	private void LateUpdate()
	{
		if (aiming)
		{
			if (trackTarget && eid.target != null)
			{
				aimPoint = aimBone.position - eid.target.position;
			}
			aimBone.LookAt(aimBone.position + aimPoint, base.transform.up);
		}
	}

	private float EvaluateMaxClingWalkDistance(Vector3 origin, Vector3 movementDirection, Vector3 backToWallDirection, float maxDistance = 20f, float incrementLength = 1.5f)
	{
		float num = 0f;
		Vector3 vector = origin;
		Vector3 vector2 = clingNormal * clungMovementTolerance;
		while (num < maxDistance)
		{
			RaycastHit hitInfo;
			bool flag = Physics.Raycast(new Ray(vector + vector2, backToWallDirection), out hitInfo, clungMovementTolerance * 2f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore);
			_ = debug;
			if (!(Vector3.Angle(hitInfo.normal, clingNormal) < 5f))
			{
				flag = false;
			}
			if (flag)
			{
				bool num2 = Physics.Raycast(new Ray(vector + vector2 - movementDirection.normalized * 0.1f, movementDirection), out hitInfo, incrementLength * 1.25f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore);
				_ = debug;
				if (num2)
				{
					return num - incrementLength * 1.5f;
				}
				num += incrementLength;
				vector += movementDirection * incrementLength;
				continue;
			}
			return num - incrementLength * 1.5f;
		}
		if (num == 0f)
		{
			return 0f;
		}
		return num - incrementLength * 1.5f;
	}

	private void RelocateWhileClinging(ClungMannequinMovementDirection direction)
	{
		Vector3 position = base.transform.position;
		_ = debug;
		Vector3 vector = ((!(Mathf.Abs(Vector3.Dot(clingNormal, Vector3.up)) < 0.99f)) ? Vector3.Cross(clingNormal, Vector3.right).normalized : Vector3.Cross(clingNormal, Vector3.up).normalized);
		Vector3 normalized = Vector3.Cross(clingNormal, vector).normalized;
		Vector3 vector2;
		if (direction == ClungMannequinMovementDirection.Horizontal)
		{
			vector2 = vector;
			_ = debug;
			if (!debug)
			{
			}
		}
		else
		{
			vector2 = normalized;
			_ = debug;
			_ = debug;
		}
		float max = EvaluateMaxClingWalkDistance(position, vector2, -clingNormal);
		_ = debug;
		float num = EvaluateMaxClingWalkDistance(position, -vector2, -clingNormal);
		_ = debug;
		float num2 = Random.Range(0f - num, max);
		if (Mathf.Abs(num2) <= 2f)
		{
			return;
		}
		Vector3 vector3 = position + vector2 * num2;
		if (Physics.Raycast(new Ray(vector3 + clingNormal * clungMovementTolerance, -clingNormal), out var hitInfo, clungMovementTolerance * 2f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			if (debug)
			{
				Debug.Log($"Accounting for bump at target. Distance: {Vector3.Distance(vector3, hitInfo.point)}", base.gameObject);
			}
			vector3 = hitInfo.point;
		}
		_ = debug;
		MoveToTarget(vector3, forceSkitter: true, clungMode: true);
	}

	private void CheckClings()
	{
		RaycastHit hitInfo;
		bool num = Physics.Raycast(base.transform.position, Vector3.up, out hitInfo, firstClingCheck ? 9.5f : 7f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore);
		_ = debug;
		if (num && hitInfo.normal.y <= 0f)
		{
			ClingToSurface(hitInfo);
		}
		else if (firstClingCheck || new Vector3(rb.velocity.x, 0f, rb.velocity.z).magnitude > 3f)
		{
			Collider[] array = Physics.OverlapSphere(col.bounds.center, 2f, LayerMaskDefaults.Get(LMD.Environment));
			_ = debug;
			if (array == null || array.Length == 0)
			{
				return;
			}
			if (Physics.Raycast(col.bounds.center, array[0].ClosestPoint(col.bounds.center) - col.bounds.center, out hitInfo, firstClingCheck ? 3.5f : 2f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				ClingToSurface(hitInfo);
			}
			_ = debug;
		}
		firstClingCheck = false;
	}

	private void ClingToSurface(RaycastHit hit)
	{
		CancelActions();
		Vector3 point = hit.point;
		Vector3 normal = hit.normal;
		canCling = false;
		clinging = true;
		clungSurfaceCollider = hit.collider;
		skitterMode = false;
		mach.gc.ForceOff();
		base.transform.position = point;
		base.transform.up = normal;
		trackTarget = true;
		clingNormal = normal.normalized;
		nma.enabled = false;
		mach.overrideFalling = true;
		rb.isKinematic = true;
		rb.useGravity = false;
		anim.SetBool("Clinging", value: true);
		anim.Play("WallCling");
		if (!firstClingCheck)
		{
			Object.Instantiate(clingSound, base.transform.position, Quaternion.identity);
		}
		projectileCooldown = Random.Range(0f, 0.5f);
	}

	public void Uncling()
	{
		clinging = false;
		clungSurfaceCollider = null;
		CancelActions();
		Vector3 vector = new Vector3(clingNormal.x * 2f, clingNormal.y * 6f, clingNormal.z * 2f);
		if (Mathf.Abs(vector.y) < 6f && Physics.Raycast(new Ray(col.bounds.center, Vector3.up), out var _, 4f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			vector.y = -6f;
		}
		if ((bool)eid && eid.target != null)
		{
			base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		}
		else
		{
			base.transform.LookAt(base.transform.position + clingNormal);
		}
		base.transform.position += vector;
		trackTarget = false;
		Invoke("DelayedGroundCheckReenable", 0.1f);
		jumpCooldown = 2f;
		skitterMode = false;
		attacksWhileClinging = 0;
		mach.overrideFalling = false;
		rb.isKinematic = false;
		rb.useGravity = true;
		if (inControl)
		{
			rb.AddForce(Vector3.down * 50f, ForceMode.VelocityChange);
		}
		anim.SetBool("Clinging", value: false);
	}

	private void MeleeAttack()
	{
		if (!inAction)
		{
			inAction = true;
			mostRecentAction = "Melee Attack";
			meleeCooldown = 2f / eid.totalSpeedModifier;
			nma.enabled = false;
			anim.Play("MeleeAttack");
			trackTarget = true;
		}
	}

	private void ProjectileAttack()
	{
		if (!inAction)
		{
			inAction = true;
			mostRecentAction = "Projectile Attack";
			projectileCooldown = Random.Range(6f - (float)difficulty, 8f - (float)difficulty) / eid.totalSpeedModifier;
			nma.enabled = false;
			anim.Play(clinging ? "WallClingProjectile" : "ProjectileAttack");
			trackTarget = true;
			aiming = true;
			chargingProjectile = true;
			if (clinging)
			{
				attacksWhileClinging++;
			}
		}
	}

	private void Jump()
	{
		if (!inAction)
		{
			inAction = true;
			jumping = true;
			mach.overrideFalling = true;
			skitterMode = false;
			mostRecentAction = "Jump";
			nma.enabled = false;
			jumpCooldown = 2f;
			anim.SetBool("Jump", value: true);
		}
	}

	private void JumpNow()
	{
		mach.gc.ForceOff();
		Invoke("DelayedGroundCheckReenable", 0.1f);
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.AddForce(Vector3.up * 100f, ForceMode.VelocityChange);
		inControl = true;
		skitterMode = false;
		anim.SetBool("Jump", value: false);
		anim.SetBool("InControl", inControl);
	}

	private void MoveToTarget(Vector3 target, bool forceSkitter = false, bool clungMode = false)
	{
		if (clungMode)
		{
			if (debug)
			{
				Debug.Log("Starting clung movement");
			}
			clungMovementTarget = target;
			skitterMode = true;
		}
		else if (!inAction)
		{
			if (NavMesh.SamplePosition(target, out var hit, 15f, nma.areaMask))
			{
				target = hit.position;
			}
			nma.CalculatePath(target, nmp);
			skitterMode = forceSkitter || ((difficulty >= 3 || Random.Range(0f, 1f) > 0.5f) && Vector3.Distance(base.transform.position, target) > 15f);
			nma.path = nmp;
		}
	}

	public void OnDeath()
	{
		if ((bool)currentChargeProjectile)
		{
			Object.Destroy(currentChargeProjectile);
		}
		if (TryGetComponent<KeepInBounds>(out var component))
		{
			Object.Destroy(component);
		}
		skitterSound.Stop();
		sc.DamageStop();
		TrailRenderer[] array = trails;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].emitting = false;
		}
		mach.parryable = false;
		Object.Destroy(this);
	}

	private void StopTracking(int parryable = 0)
	{
		if (eid.target != null)
		{
			base.transform.LookAt(base.transform.position + (new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z) - base.transform.position));
		}
		trackTarget = false;
		if (parryable > 0)
		{
			mach.parryable = true;
			GameObject obj = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, eid.weakPoint.transform.position + eid.weakPoint.transform.forward * -0.35f, Quaternion.identity);
			obj.transform.LookAt(MonoSingleton<CameraController>.Instance.GetDefaultPos());
			obj.transform.localScale *= 3f;
			obj.transform.SetParent(eid.weakPoint.transform, worldPositionStays: true);
		}
	}

	private void SwingStart(int limb = 0)
	{
		moveForward = true;
		rb.isKinematic = false;
		sc.DamageStart();
		if (limb < trails.Length)
		{
			trails[limb].emitting = true;
		}
	}

	private void SwingEnd(int parryEnd = 0)
	{
		moveForward = false;
		if (eid.gce.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
		}
		sc.DamageStop();
		TrailRenderer[] array = trails;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].emitting = false;
		}
		if (parryEnd > 0)
		{
			mach.parryable = false;
		}
	}

	private void ChargeProjectile()
	{
		if ((bool)currentChargeProjectile)
		{
			Object.Destroy(currentChargeProjectile);
		}
		if (chargingProjectile)
		{
			currentChargeProjectile = Object.Instantiate(chargeProjectile, shootPoint.position, shootPoint.rotation);
			currentChargeProjectile.transform.SetParent(shootPoint, worldPositionStays: true);
		}
	}

	private void ShootProjectile()
	{
		if ((bool)currentChargeProjectile)
		{
			Object.Destroy(currentChargeProjectile);
		}
		if (this.projectile == null || this.projectile.Equals(null))
		{
			trackTarget = false;
			chargingProjectile = false;
			return;
		}
		Projectile projectile = Object.Instantiate(this.projectile, shootPoint.position, (eid.target != null) ? Quaternion.LookRotation(eid.target.position - shootPoint.position) : shootPoint.rotation);
		projectile.target = eid.target;
		projectile.safeEnemyType = EnemyType.Mannequin;
		if (difficulty <= 2)
		{
			projectile.turningSpeedMultiplier = 0.75f;
		}
		trackTarget = false;
		chargingProjectile = false;
	}

	public void ChangeBehavior()
	{
		if (!dontChangeBehavior)
		{
			if (Random.Range(0f, 1f) < 0.35f)
			{
				meleeBehaviorCancel = 3.5f;
				behavior = MannequinBehavior.Melee;
			}
			else
			{
				behavior = (MannequinBehavior)Random.Range(2, 5);
			}
		}
		randomMovementTarget = base.transform.position;
	}

	public void ResetMovementTarget()
	{
		randomMovementTarget = base.transform.position;
	}

	private void StopAiming()
	{
		aiming = false;
	}

	public void Landing()
	{
		mach.parryable = false;
		if (difficulty >= 4)
		{
			inControl = true;
		}
		if (!inControl)
		{
			anim.Play("Landing");
			inAction = true;
			mostRecentAction = "Landing";
			inControl = true;
			nma.enabled = false;
			randomMovementTarget = base.transform.position;
		}
	}

	public void StopAction()
	{
		StopAction(changeBehavior: true);
	}

	public void StopAction(bool changeBehavior = true)
	{
		if (clinging && !stationary && !dontAutoDrop && attacksWhileClinging >= ((Random.Range(0f, 1f) > 0.5f) ? 2 : 4))
		{
			attacksWhileClinging = 0;
			inControl = true;
			anim.SetBool("InControl", value: true);
			Uncling();
		}
		if (clinging)
		{
			if (inAction && !jumping)
			{
				bool flag = Random.Range(0f, 1f) > 0.5f;
				RelocateWhileClinging((!flag) ? ClungMannequinMovementDirection.Vertical : ClungMannequinMovementDirection.Horizontal);
			}
		}
		else
		{
			clungMovementTarget = null;
			jumping = false;
			mach.overrideFalling = false;
		}
		trackTarget = clinging;
		aiming = false;
		inAction = false;
		mach.parryable = false;
		moveForward = false;
		chargingProjectile = false;
		if (changeBehavior)
		{
			ChangeBehavior();
		}
	}

	public void CancelActions(bool changeBehavior = true)
	{
		if (moveForward)
		{
			SwingEnd();
		}
		StopAction(changeBehavior);
		if ((bool)currentChargeProjectile)
		{
			Object.Destroy(currentChargeProjectile);
		}
	}

	public void SetMovementTarget(Vector3 direction, float distance = -1f)
	{
		direction.y = 0f;
		if (distance == -1f)
		{
			distance = Random.Range(5f, 25f);
		}
		RaycastHit hitInfo2;
		if (Physics.Raycast(eid.overrideCenter.position, direction, out var hitInfo, distance, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			if (NavMesh.SamplePosition(hitInfo.point, out var hit, 5f, nma.areaMask))
			{
				randomMovementTarget = hit.position;
			}
			else if (Physics.SphereCast(hitInfo.point, 1f, Vector3.down, out hitInfo, distance, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				randomMovementTarget = hitInfo.point;
			}
		}
		else if (Physics.Raycast(eid.overrideCenter.position + direction.normalized * distance, Vector3.down, out hitInfo2, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			randomMovementTarget = hitInfo2.point;
		}
		if ((bool)nma && nma.enabled && nma.isOnNavMesh && mach.gc.onGround)
		{
			MoveToTarget(randomMovementTarget);
		}
	}

	private void DelayedGroundCheckReenable()
	{
		mach.gc.StopForceOff();
		if (jumping)
		{
			jumping = false;
			mach.overrideFalling = false;
			inAction = false;
		}
	}

	private float GetRealDistance(NavMeshPath path)
	{
		if (path.status == NavMeshPathStatus.PathInvalid || path.corners.Length <= 1)
		{
			return Vector3.Distance(base.transform.position, GetTargetPosition());
		}
		float num = 0f;
		if (path.corners.Length > 1)
		{
			for (int i = 1; i < path.corners.Length; i++)
			{
				num += Vector3.Distance(path.corners[i - 1], path.corners[i]);
			}
		}
		return num;
	}

	private Vector3 GetTargetPosition()
	{
		if (((eid.target.isPlayer && !MonoSingleton<NewMovement>.Instance.gc.onGround) || (eid.target.isEnemy && (bool)eid.target.enemyIdentifier && (!eid.target.enemyIdentifier.gce || !eid.target.enemyIdentifier.gce.onGround))) && Physics.Raycast(eid.target.position, Vector3.down, out var hitInfo, 200f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			return hitInfo.point;
		}
		return eid.target.position;
	}
}


public enum MannequinBehavior
{
	Random,
	Melee,
	RunAway,
	Wander,
	Jump
}



public class MannequinPoses : MonoBehaviour
{
	private Animator anim;

	private int poseNum;

	[SerializeField]
	private bool altar;

	private void Start()
	{
		anim = GetComponent<Animator>();
		if (altar)
		{
			anim.Play("Altar");
			base.enabled = false;
		}
		else
		{
			RandomPose();
			SlowUpdate();
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", Random.Range(1f, 3f));
		if (Vector3.Dot(MonoSingleton<CameraController>.Instance.transform.forward, base.transform.position - MonoSingleton<CameraController>.Instance.transform.position) < -0.33f)
		{
			RandomPose();
		}
	}

	private void RandomPose()
	{
		ChangePose(Random.Range(1, 10));
	}

	private void ChangePose(int num)
	{
		poseNum = num;
		anim.SetInteger("TargetPose", poseNum);
	}
}


public class MapDataRebuild : CustomGameContent
{
	public int version;

	public string[] placeholderPrefabs;

	public string bundleName;

	public string catalog;

	public byte[] bundle;
}


public class MapHeader
{
	public string name;

	public string description;

	public int bundleSize;

	public int thumbSize;

	public string uniqueIdentifier;

	public string author;

	public int version;

	public string[] placeholderPrefabs;

	public string catalog;

	public string bundleName;
}



[DefaultExecutionOrder(-300)]
public class MapInfo : MapInfoBase
{
	public static MapInfo Instance;

	public string uniqueId;

	public string mapName;

	public string description;

	public string author;

	[Header("Has to be 640x480")]
	public Texture2D thumbnail;

	[Header("Map Configuration")]
	public bool renderSkybox;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		MapInfoBase.InstanceAnyType = this;
	}
}



public class MapInfoBase : MonoBehaviour
{
	public static MapInfoBase InstanceAnyType;

	public string layerName = "LAYER /// NUMBER";

	public string levelName = "LEVEL NAME";

	public bool sandboxTools;

	public bool hideStockHUD;

	public bool forceUpdateEnemyRenderers;

	public bool continuousGibCollisions;

	public bool removeGibsWithoutAbsorbers;

	public float gibRemoveTime = 5f;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class MarkedForDeath : MonoSingleton<MarkedForDeath>
{
	private new void OnEnable()
	{
		EnemyIdentifier[] array = Object.FindObjectsOfType<EnemyIdentifier>();
		for (int num = array.Length - 1; num >= 0; num--)
		{
			if (!array[num].dead)
			{
				array[num].PlayerMarkedForDeath();
			}
		}
	}
}



public class Mass : MonoBehaviour
{
	private Animator anim;

	private bool battleMode;

	private Vector3 targetPos;

	private Quaternion targetRot;

	private float transformCooldown;

	private bool walking;

	private float walkWeight;

	public bool inAction;

	private bool inSemiAction;

	public Transform[] shootPoints;

	public GameObject homingProjectile;

	private float homingAttackChance = 50f;

	public float attackCooldown = 2f;

	public GameObject explosiveProjectile;

	public GameObject slamExplosion;

	private SwingCheck2[] swingChecks;

	private float swingCooldown = 2f;

	private bool attackedOnce;

	private float playerDistanceCooldown = 1.5f;

	public Transform tailEnd;

	private GameObject tailSpear;

	private float spearCooldown = 5f;

	public GameObject spear;

	public bool spearShot;

	public GameObject spearFlash;

	public GameObject tempSpear;

	public List<GameObject> tailHitboxes = new List<GameObject>();

	public GameObject regurgitateSound;

	public GameObject bigPainSound;

	public GameObject windupSound;

	public bool dead;

	public bool crazyMode;

	public float crazyModeHealth;

	private Statue stat;

	private EnemyIdentifier eid;

	private int crazyPoint;

	public GameObject enrageEffect;

	public GameObject currentEnrageEffect;

	public Material enrageMaterial;

	public Material highVisShockwave;

	public GameObject[] activateOnEnrage;

	private int difficulty = -1;

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		swingChecks = GetComponentsInChildren<SwingCheck2>();
		stat = GetComponent<Statue>();
	}

	private void Start()
	{
		transformCooldown = 10f;
		SetSpeed();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponentInChildren<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 1)
		{
			anim.speed = 0.85f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.65f;
		}
		else if (difficulty >= 4)
		{
			anim.speed = 1.25f;
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
	}

	private void OnDisable()
	{
		StopAction();
		inSemiAction = false;
		if (spearShot)
		{
			SpearReturned();
		}
		if (swingChecks != null)
		{
			SwingCheck2[] array = swingChecks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
		}
	}

	private void OnEnable()
	{
		if (battleMode)
		{
			anim.Play("BattlePose");
		}
	}

	private void Update()
	{
		if (dead || eid.target == null)
		{
			return;
		}
		targetPos = new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z);
		targetRot = Quaternion.LookRotation(targetPos - base.transform.position, Vector3.up);
		if (!inAction && base.transform.rotation != targetRot)
		{
			if (battleMode || crazyMode)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRot, Time.deltaTime * Quaternion.Angle(base.transform.rotation, targetRot) + Time.deltaTime * 50f * eid.totalSpeedModifier);
			}
			else
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRot, Time.deltaTime * Quaternion.Angle(base.transform.rotation, targetRot) + Time.deltaTime * 120f * eid.totalSpeedModifier);
			}
			if (stat.health >= 35f)
			{
				walking = true;
			}
			else
			{
				walking = false;
			}
		}
		else
		{
			walking = false;
		}
		if (walking && walkWeight != 1f)
		{
			walkWeight = Mathf.MoveTowards(walkWeight, 1f, Time.deltaTime * 4f);
			anim.SetLayerWeight(1, walkWeight);
		}
		else if (!walking && walkWeight != 0f)
		{
			walkWeight = Mathf.MoveTowards(walkWeight, 0f, Time.deltaTime * 2f);
			anim.SetLayerWeight(1, walkWeight);
		}
		if (spearCooldown != 0f && !spearShot)
		{
			spearCooldown = Mathf.MoveTowards(spearCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (swingCooldown != 0f)
		{
			float num = 1f;
			if (difficulty >= 4)
			{
				num = 1.5f;
			}
			swingCooldown = Mathf.MoveTowards(swingCooldown, 0f, Time.deltaTime * num * eid.totalSpeedModifier);
		}
		else if (!inAction && !inSemiAction && battleMode && transformCooldown > 0f)
		{
			base.transform.LookAt(targetPos);
			if (eid.target.position.y - base.transform.position.y < 15f && eid.target.position.y - base.transform.position.y > -5f && attackedOnce && ((Vector3.Distance(targetPos, base.transform.position) > 7f && Random.Range(0f, 1f) < 0.5f) || Vector3.Distance(targetPos, base.transform.position) > 15f))
			{
				BattleSlam();
			}
			else
			{
				SwingAttack();
			}
		}
		if (Vector3.Distance(targetPos, base.transform.position) < 7f)
		{
			playerDistanceCooldown = Mathf.MoveTowards(playerDistanceCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		else
		{
			playerDistanceCooldown = Mathf.MoveTowards(playerDistanceCooldown, 3f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (!battleMode && !crazyMode && playerDistanceCooldown == 0f && !inAction && !inSemiAction && !spearShot)
		{
			base.transform.LookAt(targetPos);
			ToBattle();
		}
		if (stat.health < crazyModeHealth)
		{
			if (battleMode)
			{
				ToScout();
			}
			else
			{
				anim.SetBool("Crazy", value: true);
			}
		}
		else if (transformCooldown != 0f)
		{
			if (battleMode)
			{
				transformCooldown = Mathf.MoveTowards(transformCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			else
			{
				transformCooldown = Mathf.MoveTowards(transformCooldown, 0f, Time.deltaTime * 1.5f * eid.totalSpeedModifier);
			}
		}
		else if (!inAction && !inSemiAction && !spearShot)
		{
			if (battleMode)
			{
				ToScout();
			}
			else
			{
				base.transform.LookAt(targetPos);
				ToBattle();
			}
		}
		if (attackCooldown != 0f)
		{
			float num2 = 1f;
			if (difficulty >= 4)
			{
				num2 = 1.5f;
			}
			attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * num2 * eid.totalSpeedModifier);
		}
		else if (!inAction && transformCooldown > 0f && stat.health >= crazyModeHealth && !battleMode)
		{
			ExplosiveAttack();
		}
	}

	private void LateUpdate()
	{
		if (eid.target == null || (!battleMode && (!crazyMode || difficulty < 4)) || inAction || inSemiAction || dead)
		{
			return;
		}
		tailEnd.LookAt(eid.target.position);
		if (spearCooldown == 0f)
		{
			if (!Physics.Raycast(tailEnd.position, eid.target.position - tailEnd.position, Vector3.Distance(eid.target.position, tailEnd.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				spearCooldown = Random.Range(2, 4);
				ReadySpear();
			}
			else
			{
				spearCooldown = 0.1f;
			}
		}
	}

	public void HomingAttack()
	{
		inAction = true;
		anim.SetTrigger("HomingAttack");
		attackCooldown = Random.Range(3, 5);
	}

	public void ExplosiveAttack()
	{
		inAction = true;
		anim.SetTrigger("ExplosiveAttack");
		attackCooldown = Random.Range(3, 5);
	}

	public void SwingAttack()
	{
		inAction = true;
		anim.SetTrigger("Swing");
		swingCooldown = Random.Range(3, 5);
		Object.Instantiate(windupSound, shootPoints[2].position, Quaternion.identity);
		attackedOnce = true;
	}

	public void ToScout()
	{
		if (battleMode)
		{
			transformCooldown = Random.Range(8, 12);
			inAction = true;
			anim.SetBool("Transform", value: true);
			battleMode = false;
			eid.weakPoint = stat.extraDamageZones[0];
		}
	}

	public void ToBattle()
	{
		if (!battleMode)
		{
			anim.SetBool("Transform", value: false);
			transformCooldown = Random.Range(8, 12);
			inAction = true;
			anim.SetTrigger("Slam");
			battleMode = true;
			spearCooldown = 3f;
			AudioSource component = Object.Instantiate(windupSound, shootPoints[2].position, Quaternion.identity).GetComponent<AudioSource>();
			component.pitch = 1f;
			component.volume = 0.75f;
			eid.weakPoint = stat.extraDamageZones[1];
			attackedOnce = false;
		}
	}

	public void SlamImpact()
	{
		if (!dead)
		{
			GameObject gameObject = Object.Instantiate(slamExplosion, new Vector3(shootPoints[2].position.x, base.transform.position.y, shootPoints[2].position.z), Quaternion.identity);
			if (difficulty >= 2)
			{
				gameObject.transform.localScale = new Vector3(gameObject.transform.localScale.x, gameObject.transform.localScale.y * 2.5f, gameObject.transform.localScale.z);
			}
			else if (difficulty == 1)
			{
				gameObject.transform.localScale = new Vector3(gameObject.transform.localScale.x, gameObject.transform.localScale.y * 2f, gameObject.transform.localScale.z);
			}
			else if (difficulty == 0)
			{
				gameObject.transform.localScale = new Vector3(gameObject.transform.localScale.x, gameObject.transform.localScale.y * 1.5f, gameObject.transform.localScale.z);
			}
			PhysicalShockwave component = gameObject.GetComponent<PhysicalShockwave>();
			component.damage = Mathf.RoundToInt(30f * eid.totalDamageModifier);
			if (difficulty == 1)
			{
				component.speed = 20f;
			}
			else if (difficulty == 0)
			{
				component.speed = 15f;
			}
			else if (difficulty >= 4)
			{
				component.speed = 35f;
			}
			else
			{
				component.speed = 25f;
			}
			component.maxSize = 100f;
			component.enemy = true;
			component.enemyType = EnemyType.HideousMass;
			MeshRenderer[] componentsInChildren = gameObject.GetComponentsInChildren<MeshRenderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].material = highVisShockwave;
			}
			gameObject.transform.SetParent(GetComponentInParent<GoreZone>().transform, worldPositionStays: true);
		}
	}

	public void ShootHoming(int arm)
	{
		if (eid.target != null && !dead)
		{
			Transform transform = shootPoints[arm];
			Projectile component = Object.Instantiate(homingProjectile, transform.position, transform.rotation).GetComponent<Projectile>();
			component.target = eid.target;
			component.GetComponent<Rigidbody>().velocity = transform.up * 5f;
			component.damage *= eid.totalDamageModifier;
		}
	}

	public void ShootExplosive(int arm)
	{
		if (eid.target != null && !dead)
		{
			Transform transform = shootPoints[arm];
			Projectile component = Object.Instantiate(explosiveProjectile, transform.position, transform.rotation).GetComponent<Projectile>();
			component.target = eid.target;
			component.GetComponent<Rigidbody>().AddForce(transform.up * 50f, ForceMode.VelocityChange);
			component.safeEnemyType = EnemyType.HideousMass;
			component.transform.SetParent(GetComponentInParent<GoreZone>().transform, worldPositionStays: true);
			component.damage *= eid.totalDamageModifier;
		}
	}

	private void ReadySpear()
	{
		if (eid.target != null && (difficulty > 3 || !crazyMode) && !dead && difficulty != 0)
		{
			if (tailSpear == null)
			{
				tailSpear = tailEnd.GetChild(1).gameObject;
			}
			inSemiAction = true;
			GameObject obj = Object.Instantiate(spearFlash, tailSpear.transform.position, Quaternion.identity);
			Object.Instantiate(regurgitateSound, tailSpear.transform.position, Quaternion.identity);
			obj.transform.SetParent(tailSpear.transform, worldPositionStays: true);
			if (crazyMode && difficulty >= 4)
			{
				Invoke("ShootSpear", 1f);
			}
			else
			{
				anim.SetTrigger("ShootSpear");
			}
		}
	}

	public void ShootSpear()
	{
		if (eid.target == null || dead || difficulty == 0)
		{
			return;
		}
		inSemiAction = false;
		tailEnd.LookAt(eid.target.position);
		tempSpear = Object.Instantiate(spear, tailSpear.transform.position, tailEnd.rotation);
		tempSpear.transform.LookAt(eid.target.position);
		if (tempSpear.TryGetComponent<MassSpear>(out var component))
		{
			component.target = eid.target;
			component.originPoint = tailSpear.transform;
			component.damageMultiplier = eid.totalDamageModifier;
			if (difficulty >= 4)
			{
				component.spearHealth *= 2f;
			}
		}
		tailSpear.SetActive(value: false);
		spearShot = true;
	}

	public void SpearParried()
	{
		if (!dead)
		{
			inAction = true;
			anim.SetTrigger("SpearParried");
			Object.Instantiate(bigPainSound, tailSpear.transform);
		}
	}

	public void SpearReturned()
	{
		tailSpear.SetActive(value: true);
		spearShot = false;
	}

	public void StopAction()
	{
		inAction = false;
	}

	public void BattleSlam()
	{
		inAction = true;
		anim.SetTrigger("BattleSlam");
		swingCooldown = Random.Range(3, 5);
		AudioSource component = Object.Instantiate(windupSound, shootPoints[2].position, Quaternion.identity).GetComponent<AudioSource>();
		component.pitch = 1f;
		component.volume = 0.75f;
	}

	public void SwingStart()
	{
		if (!dead)
		{
			SwingCheck2[] array = swingChecks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStart();
			}
		}
	}

	public void SwingEnd()
	{
		if (!dead)
		{
			SwingCheck2[] array = swingChecks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			GameObject obj = Object.Instantiate(slamExplosion, (shootPoints[0].position + shootPoints[1].position) / 2f, Quaternion.identity);
			obj.transform.up = base.transform.right;
			PhysicalShockwave component = obj.GetComponent<PhysicalShockwave>();
			component.damage = Mathf.RoundToInt(20f * eid.totalDamageModifier);
			component.speed = 100f;
			if (difficulty < 2)
			{
				component.maxSize = 10f;
			}
			else
			{
				component.maxSize = 100f;
			}
			component.enemy = true;
			component.enemyType = EnemyType.HideousMass;
			obj.transform.SetParent(GetComponentInParent<GoreZone>().transform, worldPositionStays: true);
			AudioSource component2 = obj.GetComponent<AudioSource>();
			component2.pitch = 1.5f;
			component2.volume = 0.5f;
		}
	}

	public void Enrage()
	{
		currentEnrageEffect = Object.Instantiate(enrageEffect, stat.chest.transform);
		currentEnrageEffect.transform.localScale = Vector3.one * 2f;
		currentEnrageEffect.transform.localPosition = new Vector3(-0.25f, 0f, 0f);
		stat.smr.material = enrageMaterial;
		GetComponentInChildren<EnemySimplifier>().enraged = true;
		eid.UpdateBuffs(visualsOnly: true);
		if (eid.sandified)
		{
			stat.smr.material.SetFloat("_HasSandBuff", 1f);
		}
		GameObject[] array = activateOnEnrage;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		GetComponent<AudioSource>().Play();
	}

	public void CrazyReady()
	{
		inAction = false;
		inSemiAction = false;
		crazyMode = true;
		Invoke("CrazyShoot", 0.5f / eid.totalSpeedModifier);
		Invoke("CrazyShoot", 1.5f / eid.totalSpeedModifier);
	}

	public void CrazyShoot()
	{
		if (!dead)
		{
			ShootExplosive(crazyPoint);
			if (crazyPoint == 0)
			{
				crazyPoint = 1;
			}
			else
			{
				crazyPoint = 0;
			}
			float num = 1f;
			if (difficulty >= 4)
			{
				num = 2f;
			}
			Invoke("CrazyShoot", Random.Range(2f, 3f) / num / eid.totalSpeedModifier);
		}
	}
}



public class MassAnimationReceiver : MonoBehaviour
{
	public GameObject groundBreakEffect;

	public GameObject smallGroundBreakEffect;

	public bool fakeMass;

	public bool otherBossIntro;

	public GameObject realMass;

	private Mass mass;

	public GameObject footstep;

	private Animator anim;

	private StatueIntroChecker sic;

	private bool turnTowards;

	private Transform player;

	private int breaks;

	public bool skipEntirelyOnReplay;

	public UnityEvent animationEvent1;

	public UnityEvent onSkip;

	public void Start()
	{
		anim = GetComponent<Animator>();
		if (fakeMass)
		{
			sic = MonoSingleton<StatueIntroChecker>.Instance;
			if (!otherBossIntro)
			{
				anim.speed = 0f;
			}
		}
		else
		{
			mass = GetComponentInParent<Mass>();
		}
		if ((bool)sic && sic.beenSeen && skipEntirelyOnReplay)
		{
			onSkip?.Invoke();
			SpawnMass();
		}
	}

	private void Update()
	{
		if (turnTowards)
		{
			Quaternion b = Quaternion.LookRotation(new Vector3(player.position.x, base.transform.position.y, player.position.z) - base.transform.position, Vector3.up);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * (Quaternion.Angle(base.transform.rotation, b) / 2f + 1f));
		}
	}

	public void GroundBreak()
	{
		Object.Instantiate(groundBreakEffect, base.transform.position, Quaternion.identity);
		breaks++;
		if (breaks == 3)
		{
			player = MonoSingleton<CameraController>.Instance.transform;
			turnTowards = true;
		}
	}

	public void SmallGroundBreak()
	{
		Object.Instantiate(smallGroundBreakEffect, base.transform.position, Quaternion.identity);
	}

	public void SpawnMass()
	{
		if ((bool)sic && !sic.beenSeen)
		{
			sic.beenSeen = true;
		}
		realMass.SetActive(value: true);
		base.gameObject.SetActive(value: false);
	}

	public void Footstep()
	{
		if (anim.GetLayerWeight(1) > 0.5f)
		{
			Object.Instantiate(footstep, base.transform.position, Quaternion.identity);
		}
	}

	public void SkipOnReplay()
	{
		if ((bool)sic && sic.beenSeen)
		{
			SpawnMass();
		}
	}

	public void AnimationEvent(int i)
	{
		if (i == 1)
		{
			animationEvent1?.Invoke();
		}
	}

	public void ShootSpear()
	{
		mass.ShootSpear();
	}

	public void StopAction()
	{
		mass.StopAction();
	}

	public void ShootHomingR()
	{
		mass.ShootHoming(0);
	}

	public void ShootHomingL()
	{
		mass.ShootHoming(1);
	}

	public void ShootExplosiveR()
	{
		mass.ShootExplosive(0);
	}

	public void ShootExplosiveL()
	{
		mass.ShootExplosive(1);
	}

	public void Slam()
	{
		mass.SlamImpact();
	}

	public void SwingStart()
	{
		mass.SwingStart();
	}

	public void SwingEnd()
	{
		mass.SwingEnd();
	}

	public void CrazyReady()
	{
		mass.CrazyReady();
	}

	public void Enrage()
	{
		mass.Enrage();
	}
}



public class MassSpear : MonoBehaviour
{
	public EnemyTarget target;

	private LineRenderer lr;

	private Rigidbody rb;

	public bool hittingPlayer;

	public bool hitPlayer;

	public bool beenStopped;

	private bool returning;

	private bool deflected;

	public Transform originPoint;

	private NewMovement nmov;

	public float spearHealth;

	private int difficulty;

	public GameObject breakMetalSmall;

	private AudioSource aud;

	public AudioClip hit;

	public AudioClip stop;

	private Mass mass;

	public float speedMultiplier = 1f;

	public float damageMultiplier = 1f;

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		lr = GetComponentInChildren<LineRenderer>();
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		mass = originPoint.GetComponentInParent<Mass>();
		Invoke("CheckForDistance", 3f / speedMultiplier);
		if (difficulty == 1)
		{
			rb.AddForce(base.transform.forward * 75f * speedMultiplier, ForceMode.VelocityChange);
		}
		if (difficulty == 2)
		{
			rb.AddForce(base.transform.forward * 200f * speedMultiplier, ForceMode.VelocityChange);
		}
		else if (difficulty >= 3)
		{
			rb.AddForce(base.transform.forward * 250f * speedMultiplier, ForceMode.VelocityChange);
		}
	}

	private void OnDisable()
	{
		if (!returning)
		{
			Return();
		}
	}

	private void Update()
	{
		if (originPoint != null && !originPoint.gameObject.activeInHierarchy)
		{
			lr.SetPosition(0, originPoint.position);
			lr.SetPosition(1, lr.transform.position);
			if (returning)
			{
				if (!originPoint || !originPoint.parent || !originPoint.parent.gameObject.activeInHierarchy)
				{
					Object.Destroy(base.gameObject);
					return;
				}
				base.transform.rotation = Quaternion.LookRotation(base.transform.position - originPoint.position, Vector3.up);
				rb.velocity = base.transform.forward * -100f * speedMultiplier;
				if (Vector3.Distance(base.transform.position, originPoint.position) < 1f)
				{
					if (mass != null)
					{
						mass.SpearReturned();
					}
					Object.Destroy(base.gameObject);
				}
			}
			else if (deflected)
			{
				base.transform.LookAt(originPoint.position);
				rb.velocity = base.transform.forward * 100f * speedMultiplier;
				if (!(Vector3.Distance(base.transform.position, originPoint.position) < 1f) || !(mass != null))
				{
					return;
				}
				mass.SpearReturned();
				BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
				EnemyIdentifier component = mass.GetComponent<EnemyIdentifier>();
				Transform child = mass.tailEnd.GetChild(0);
				HurtEnemy(child.gameObject, component);
				for (int i = 0; i < 3; i++)
				{
					GameObject gore = instance.GetGore(GoreType.Head, component);
					gore.transform.position = child.position;
					GoreZone goreZone = GoreZone.ResolveGoreZone(base.transform);
					if ((bool)goreZone)
					{
						gore.transform.SetParent(goreZone.goreZone);
					}
				}
				mass.SpearParried();
				Object.Destroy(base.gameObject);
			}
			else if (hitPlayer && !returning)
			{
				if (nmov.hp <= 0)
				{
					Return();
					Object.Destroy(base.gameObject);
				}
				if (spearHealth > 0f)
				{
					spearHealth = Mathf.MoveTowards(spearHealth, 0f, Time.deltaTime);
				}
				else if (spearHealth <= 0f)
				{
					Return();
				}
			}
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void HurtEnemy(GameObject target, EnemyIdentifier eid = null)
	{
		if (eid == null)
		{
			eid = target.GetComponent<EnemyIdentifier>();
			if (!eid)
			{
				EnemyIdentifierIdentifier component = target.GetComponent<EnemyIdentifierIdentifier>();
				if ((bool)component)
				{
					eid = component.eid;
				}
			}
		}
		if (eid != null && target == null)
		{
			target = eid.gameObject;
		}
		if ((bool)eid)
		{
			eid.DeliverDamage(target, Vector3.zero, originPoint.position, 30f * damageMultiplier, tryForExplode: false);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (beenStopped)
		{
			return;
		}
		if (!hitPlayer && !hittingPlayer && other.gameObject.CompareTag("Player"))
		{
			hittingPlayer = true;
			beenStopped = true;
			rb.isKinematic = true;
			rb.useGravity = false;
			rb.velocity = Vector3.zero;
			base.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos();
			Invoke("DelayedPlayerCheck", 0.05f);
		}
		else if (other.gameObject.layer == 8 || other.gameObject.layer == 24)
		{
			beenStopped = true;
			rb.velocity = Vector3.zero;
			rb.useGravity = false;
			base.transform.position += base.transform.forward * 2f;
			Invoke("Return", 2f / speedMultiplier);
			aud.pitch = 1f;
			aud.clip = stop;
			aud.Play();
		}
		else if (target != null && target.isEnemy && (other.gameObject.CompareTag("Head") || other.gameObject.CompareTag("Body") || other.gameObject.CompareTag("Limb") || other.gameObject.CompareTag("EndLimb")) && !other.gameObject.CompareTag("Armor"))
		{
			EnemyIdentifierIdentifier componentInParent = other.gameObject.GetComponentInParent<EnemyIdentifierIdentifier>();
			EnemyIdentifier enemyIdentifier = null;
			if (componentInParent != null && componentInParent.eid != null)
			{
				enemyIdentifier = componentInParent.eid;
			}
			if (!(enemyIdentifier == null) && !(enemyIdentifier != target.enemyIdentifier) && enemyIdentifier != null)
			{
				HurtEnemy(other.gameObject, enemyIdentifier);
				Return();
			}
		}
	}

	private void DelayedPlayerCheck()
	{
		if (!deflected)
		{
			hittingPlayer = false;
			hitPlayer = true;
			nmov = MonoSingleton<NewMovement>.Instance;
			nmov.GetHurt(Mathf.RoundToInt(25f * damageMultiplier), invincible: true);
			nmov.slowMode = true;
			base.transform.position = nmov.transform.position;
			base.transform.SetParent(nmov.transform, worldPositionStays: true);
			rb.velocity = Vector3.zero;
			rb.useGravity = false;
			rb.isKinematic = true;
			beenStopped = true;
			GetComponent<CapsuleCollider>().radius *= 0.1f;
			aud.pitch = 1f;
			aud.clip = hit;
			aud.Play();
		}
	}

	public void GetHurt(float damage)
	{
		Object.Instantiate(breakMetalSmall, base.transform.position, Quaternion.identity);
		spearHealth -= ((difficulty >= 4) ? (damage / 1.5f) : damage);
	}

	public void Deflected()
	{
		deflected = true;
		rb.isKinematic = false;
		GetComponent<Collider>().enabled = false;
	}

	private void Return()
	{
		if (hitPlayer)
		{
			nmov.slowMode = false;
			base.transform.SetParent(null, worldPositionStays: true);
			rb.isKinematic = false;
		}
		if (base.gameObject.activeInHierarchy)
		{
			aud.clip = stop;
			aud.pitch = 1f;
			aud.Play();
		}
		returning = true;
		beenStopped = true;
	}

	private void CheckForDistance()
	{
		if (!returning && !beenStopped && !hitPlayer && !deflected)
		{
			returning = true;
			beenStopped = true;
			base.transform.position = originPoint.position;
		}
	}
}



public class MasterOptions : MonoBehaviour
{
	public float mouseSensitivity;

	public bool enemySimplifier;

	public float enemySimplifierDistance;

	public float maxGore;

	public float bloodstainChance;

	public float musicVolume;

	public float masterVolume;

	private void Start()
	{
		Object.DontDestroyOnLoad(base.gameObject);
	}
}



public class MenuActSelect : MonoBehaviour
{
	public int requiredLevels;

	public bool forceOff;

	public bool hideWhenOff;

	public bool primeLevels;

	private Transform[] children;

	private Image img;

	private TMP_Text text;

	private string originalName;

	public string nameWhenDisabled;

	private void OnEnable()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		if (text == null)
		{
			text = base.transform.GetChild(0).GetComponent<TMP_Text>();
			originalName = text.text;
		}
		bool flag = false;
		if (primeLevels)
		{
			for (int i = 1; i < 4; i++)
			{
				if (GameProgressSaver.GetPrime(@int, i) > 0)
				{
					Debug.Log("Found Primes");
					flag = true;
				}
			}
		}
		if (forceOff || (GameProgressSaver.GetProgress(@int) <= requiredLevels && !flag))
		{
			GetComponent<Button>().interactable = false;
			text.color = new Color(0.3f, 0.3f, 0.3f);
			if (nameWhenDisabled != "")
			{
				text.text = nameWhenDisabled;
			}
			base.transform.GetChild(1).gameObject.SetActive(value: false);
			if (!hideWhenOff)
			{
				return;
			}
			if (!img)
			{
				img = GetComponent<Image>();
				children = base.transform.GetComponentsInChildren<Transform>();
			}
			img.enabled = false;
			Transform[] array = children;
			foreach (Transform transform in array)
			{
				if (transform != base.transform)
				{
					transform.gameObject.SetActive(value: false);
				}
			}
		}
		else
		{
			GetComponent<Button>().interactable = true;
			text.color = new Color(1f, 1f, 1f);
			text.text = originalName;
			base.transform.GetChild(1).gameObject.SetActive(value: true);
		}
	}

	private void OnDisable()
	{
		if (!hideWhenOff)
		{
			return;
		}
		if (!img)
		{
			img = GetComponent<Image>();
			children = base.transform.GetComponentsInChildren<Transform>();
		}
		img.enabled = true;
		Transform[] array = children;
		foreach (Transform transform in array)
		{
			if (transform != base.transform)
			{
				transform.gameObject.SetActive(value: true);
			}
		}
	}
}



public class MenuAlphaPop : MonoBehaviour
{
	[SerializeField]
	private bool animateOnEnable = true;

	[SerializeField]
	private bool canvasGroupInsteadOfImage;

	[SerializeField]
	private float initialAlpha = 1f;

	[SerializeField]
	private float finalAlpha;

	[SerializeField]
	private float animationDuration = 1f;

	private Image targetImage;

	private CanvasGroup targetGroup;

	private bool isAnimating;

	private float progress;

	private void Awake()
	{
		targetImage = GetComponent<Image>();
		targetGroup = GetComponent<CanvasGroup>();
	}

	private void OnEnable()
	{
		if (animateOnEnable)
		{
			Animate();
		}
	}

	private void Update()
	{
		if (isAnimating)
		{
			progress += Time.deltaTime / animationDuration;
			if (progress >= 1f)
			{
				isAnimating = false;
			}
			if (canvasGroupInsteadOfImage)
			{
				targetGroup.alpha = Mathf.Lerp(initialAlpha, finalAlpha, progress);
				return;
			}
			Color color = targetImage.color;
			color.a = Mathf.Lerp(initialAlpha, finalAlpha, progress);
			targetImage.color = color;
		}
	}

	public void Animate()
	{
		isAnimating = true;
		progress = 0f;
	}
}



public class MenuChallengeHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	[SerializeField]
	private GameObject panelToActivate;

	public void OnPointerEnter(PointerEventData eventData)
	{
		panelToActivate.SetActive(value: true);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		panelToActivate.SetActive(value: false);
	}
}



public class MenuEsc : MonoBehaviour
{
	private static MenuEsc current;

	public GameObject previousPage;

	public bool HardClose;

	public bool DontClose;

	public UltrakillEvent OnClose;

	private void OnEnable()
	{
		current = this;
	}

	private void OnDisable()
	{
		if (current == this)
		{
			current = null;
		}
	}

	private void Update()
	{
		if (current != null && current != this)
		{
			return;
		}
		current = this;
		if ((MonoSingleton<HUDOptions>.Instance.TryGetComponent<OptionsMenuToManager>(out var component) && component.selectedSomethingThisFrame) || (!MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame && (Gamepad.current == null || !Gamepad.current.buttonEast.wasPressedThisFrame) && (Gamepad.current == null || !Gamepad.current.buttonSouth.wasPressedThisFrame || !(EventSystem.current.currentSelectedGameObject != null) || !EventSystem.current.currentSelectedGameObject.TryGetComponent<Slider>(out var _))))
		{
			return;
		}
		if (EventSystem.current.currentSelectedGameObject != null)
		{
			BackSelectEvent componentInParent = EventSystem.current.currentSelectedGameObject.GetComponentInParent<BackSelectEvent>();
			if (componentInParent != null)
			{
				componentInParent.InvokeOnBack();
			}
			if (EventSystem.current.currentSelectedGameObject.TryGetComponent<BackSelectOverride>(out var component3))
			{
				component3.Selectable.Select();
				return;
			}
		}
		if (DontClose)
		{
			return;
		}
		if (HardClose)
		{
			if (SandboxHud.SavesMenuOpen)
			{
				MonoSingleton<SandboxHud>.Instance.HideSavesMenu();
			}
			MonoSingleton<OptionsManager>.Instance.CloseOptions();
			MonoSingleton<OptionsManager>.Instance.UnPause();
			MonoSingleton<OptionsManager>.Instance.UnFreeze();
		}
		base.gameObject.SetActive(value: false);
		if (previousPage != null)
		{
			previousPage.SetActive(value: true);
			if (previousPage.TryGetComponent<Selectable>(out var component4))
			{
				component4.Select();
			}
		}
		OnClose?.Invoke();
	}
}



public abstract class MessageDispatcher : MessageDispatcherBase
{
	[SerializeField]
	private UnityEvent _handler = new UnityEvent();

	public new UnityEvent Handler => _handler;

	public void AddListener(UnityAction action)
	{
		Handler.AddListener(action);
	}

	public void RemoveListener(UnityAction action)
	{
		Handler.RemoveListener(action);
	}

	public new void RemoveAllListeners()
	{
		Handler.RemoveAllListeners();
	}

	protected sealed override UnityEventBase GetHandler()
	{
		return Handler;
	}
}

public abstract class MessageDispatcher<T> : MessageDispatcherBase
{
	public abstract class Callback<TEvent> : MessageDispatcher<T> where TEvent : UnityEvent<T>, new()
	{
		[SerializeField]
		private TEvent _handler;

		public sealed override UnityEvent<T> Handler => _handler;

		public Callback()
		{
			_handler = new TEvent();
		}
	}

	public new abstract UnityEvent<T> Handler { get; }

	private MessageDispatcher()
	{
	}

	public void AddListener(UnityAction<T> action)
	{
		Handler.AddListener(action);
	}

	public void RemoveListener(UnityAction<T> action)
	{
		Handler.RemoveListener(action);
	}

	public new void RemoveAllListeners()
	{
		Handler.RemoveAllListeners();
	}

	protected sealed override UnityEventBase GetHandler()
	{
		return Handler;
	}
}

public abstract class MessageDispatcher<T1, T2> : MessageDispatcherBase
{
	public abstract class Callback<TEvent> : MessageDispatcher<T1, T2> where TEvent : UnityEvent<T1, T2>, new()
	{
		[SerializeField]
		private TEvent _handler;

		public sealed override UnityEvent<T1, T2> Handler => _handler;

		public Callback()
		{
			_handler = new TEvent();
		}
	}

	public new abstract UnityEvent<T1, T2> Handler { get; }

	private MessageDispatcher()
	{
	}

	public void AddListener(UnityAction<T1, T2> action)
	{
		Handler.AddListener(action);
	}

	public void RemoveListener(UnityAction<T1, T2> action)
	{
		Handler.RemoveListener(action);
	}

	public new void RemoveAllListeners()
	{
		Handler.RemoveAllListeners();
	}

	protected sealed override UnityEventBase GetHandler()
	{
		return Handler;
	}
}



public abstract class MessageDispatcherBase : MonoBehaviour
{
	public UnityEventBase Handler => GetHandler();

	private protected MessageDispatcherBase()
	{
	}

	protected abstract UnityEventBase GetHandler();

	public void RemoveAllListeners()
	{
		GetHandler().RemoveAllListeners();
	}
}



public static class MessageDispatcherExtensions
{
	public static void RemoveAllListeners<TMessage>(this GameObject gameObject) where TMessage : MessageDispatcherBase
	{
		if (gameObject.TryGetComponent<TMessage>(out var component))
		{
			component.RemoveAllListeners();
		}
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction handler) where TMessage : MessageDispatcher
	{
		gameObject.GetOrAddComponent<TMessage>().AddListener(handler);
	}

	public static void AddListener<TMessage, T>(this GameObject gameObject, UnityAction<T> handler) where TMessage : MessageDispatcher<T>
	{
		gameObject.GetOrAddComponent<TMessage>().AddListener(handler);
	}

	public static void AddListener<TMessage, T1, T2>(this GameObject gameObject, UnityAction<T1, T2> handler) where TMessage : MessageDispatcher<T1, T2>
	{
		gameObject.GetOrAddComponent<TMessage>().AddListener(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<int> handler) where TMessage : MessageDispatcher<int>
	{
		gameObject.AddListener<TMessage, int>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<bool> handler) where TMessage : MessageDispatcher<bool>
	{
		gameObject.AddListener<TMessage, bool>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<AnimationEvent> handler) where TMessage : MessageDispatcher<AnimationEvent>
	{
		gameObject.AddListener<TMessage, AnimationEvent>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<float[], int> handler) where TMessage : MessageDispatcher<float[], int>
	{
		gameObject.AddListener<TMessage, float[], int>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<Collision> handler) where TMessage : MessageDispatcher<Collision>
	{
		gameObject.AddListener<TMessage, Collision>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<Collision2D> handler) where TMessage : MessageDispatcher<Collision2D>
	{
		gameObject.AddListener<TMessage, Collision2D>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<ControllerColliderHit> handler) where TMessage : MessageDispatcher<ControllerColliderHit>
	{
		gameObject.AddListener<TMessage, ControllerColliderHit>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<float> handler) where TMessage : MessageDispatcher<float>
	{
		gameObject.AddListener<TMessage, float>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<Joint2D> handler) where TMessage : MessageDispatcher<Joint2D>
	{
		gameObject.AddListener<TMessage, Joint2D>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<GameObject> handler) where TMessage : MessageDispatcher<GameObject>
	{
		gameObject.AddListener<TMessage, GameObject>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<RenderTexture, RenderTexture> handler) where TMessage : MessageDispatcher<RenderTexture, RenderTexture>
	{
		gameObject.AddListener<TMessage, RenderTexture, RenderTexture>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<Collider> handler) where TMessage : MessageDispatcher<Collider>
	{
		gameObject.AddListener<TMessage, Collider>(handler);
	}

	public static void AddListener<TMessage>(this GameObject gameObject, UnityAction<Collider2D> handler) where TMessage : MessageDispatcher<Collider2D>
	{
		gameObject.AddListener<TMessage, Collider2D>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction handler) where TMessage : MessageDispatcher
	{
		gameObject.GetOrAddComponent<TMessage>().RemoveListener(handler);
	}

	public static void RemoveListener<TMessage, T>(this GameObject gameObject, UnityAction<T> handler) where TMessage : MessageDispatcher<T>
	{
		gameObject.GetOrAddComponent<TMessage>().RemoveListener(handler);
	}

	public static void RemoveListener<TMessage, T1, T2>(this GameObject gameObject, UnityAction<T1, T2> handler) where TMessage : MessageDispatcher<T1, T2>
	{
		gameObject.GetOrAddComponent<TMessage>().RemoveListener(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<int> handler) where TMessage : MessageDispatcher<int>
	{
		gameObject.RemoveListener<TMessage, int>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<bool> handler) where TMessage : MessageDispatcher<bool>
	{
		gameObject.RemoveListener<TMessage, bool>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<AnimationEvent> handler) where TMessage : MessageDispatcher<AnimationEvent>
	{
		gameObject.RemoveListener<TMessage, AnimationEvent>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<float[], int> handler) where TMessage : MessageDispatcher<float[], int>
	{
		gameObject.RemoveListener<TMessage, float[], int>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<Collision> handler) where TMessage : MessageDispatcher<Collision>
	{
		gameObject.RemoveListener<TMessage, Collision>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<Collision2D> handler) where TMessage : MessageDispatcher<Collision2D>
	{
		gameObject.RemoveListener<TMessage, Collision2D>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<ControllerColliderHit> handler) where TMessage : MessageDispatcher<ControllerColliderHit>
	{
		gameObject.RemoveListener<TMessage, ControllerColliderHit>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<float> handler) where TMessage : MessageDispatcher<float>
	{
		gameObject.RemoveListener<TMessage, float>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<Joint2D> handler) where TMessage : MessageDispatcher<Joint2D>
	{
		gameObject.RemoveListener<TMessage, Joint2D>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<GameObject> handler) where TMessage : MessageDispatcher<GameObject>
	{
		gameObject.RemoveListener<TMessage, GameObject>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<RenderTexture, RenderTexture> handler) where TMessage : MessageDispatcher<RenderTexture, RenderTexture>
	{
		gameObject.RemoveListener<TMessage, RenderTexture, RenderTexture>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<Collider> handler) where TMessage : MessageDispatcher<Collider>
	{
		gameObject.RemoveListener<TMessage, Collider>(handler);
	}

	public static void RemoveListener<TMessage>(this GameObject gameObject, UnityAction<Collider2D> handler) where TMessage : MessageDispatcher<Collider2D>
	{
		gameObject.RemoveListener<TMessage, Collider2D>(handler);
	}

	public static void RemoveAllListeners<TMessage>(this Component component) where TMessage : MessageDispatcherBase
	{
		component.gameObject.RemoveAllListeners<TMessage>();
	}

	public static void AddListener<TMessage>(this Component component, UnityAction handler) where TMessage : MessageDispatcher
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage, T>(this Component component, UnityAction<T> handler) where TMessage : MessageDispatcher<T>
	{
		component.gameObject.AddListener<TMessage, T>(handler);
	}

	public static void AddListener<TMessage, T1, T2>(this Component component, UnityAction<T1, T2> handler) where TMessage : MessageDispatcher<T1, T2>
	{
		component.gameObject.AddListener<TMessage, T1, T2>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<int> handler) where TMessage : MessageDispatcher<int>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<bool> handler) where TMessage : MessageDispatcher<bool>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<AnimationEvent> handler) where TMessage : MessageDispatcher<AnimationEvent>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<float[], int> handler) where TMessage : MessageDispatcher<float[], int>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<Collision> handler) where TMessage : MessageDispatcher<Collision>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<Collision2D> handler) where TMessage : MessageDispatcher<Collision2D>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<ControllerColliderHit> handler) where TMessage : MessageDispatcher<ControllerColliderHit>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<float> handler) where TMessage : MessageDispatcher<float>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<Joint2D> handler) where TMessage : MessageDispatcher<Joint2D>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<GameObject> handler) where TMessage : MessageDispatcher<GameObject>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<RenderTexture, RenderTexture> handler) where TMessage : MessageDispatcher<RenderTexture, RenderTexture>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<Collider> handler) where TMessage : MessageDispatcher<Collider>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void AddListener<TMessage>(this Component component, UnityAction<Collider2D> handler) where TMessage : MessageDispatcher<Collider2D>
	{
		component.gameObject.AddListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction handler) where TMessage : MessageDispatcher
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<int> handler) where TMessage : MessageDispatcher<int>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<bool> handler) where TMessage : MessageDispatcher<bool>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<AnimationEvent> handler) where TMessage : MessageDispatcher<AnimationEvent>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<float[], int> handler) where TMessage : MessageDispatcher<float[], int>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<Collision> handler) where TMessage : MessageDispatcher<Collision>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<Collision2D> handler) where TMessage : MessageDispatcher<Collision2D>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<ControllerColliderHit> handler) where TMessage : MessageDispatcher<ControllerColliderHit>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<float> handler) where TMessage : MessageDispatcher<float>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<Joint2D> handler) where TMessage : MessageDispatcher<Joint2D>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<GameObject> handler) where TMessage : MessageDispatcher<GameObject>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<RenderTexture, RenderTexture> handler) where TMessage : MessageDispatcher<RenderTexture, RenderTexture>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<Collider> handler) where TMessage : MessageDispatcher<Collider>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}

	public static void RemoveListener<TMessage>(this Component component, UnityAction<Collider2D> handler) where TMessage : MessageDispatcher<Collider2D>
	{
		component.gameObject.RemoveListener<TMessage>(handler);
	}
}



public class Mindflayer : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	private Animator anim;

	private float defaultAnimSpeed = 1f;

	[HideInInspector]
	public bool active = true;

	public Transform model;

	public GameObject homingProjectile;

	public GameObject decorativeProjectile;

	public GameObject warningFlash;

	public GameObject warningFlashUnparriable;

	public GameObject decoy;

	public Transform[] tentacles;

	private SwingCheck2 sc;

	public float cooldown;

	private bool inAction;

	private bool overrideRotation;

	private Vector3 overrideTarget;

	private bool dontTeleport;

	private EnemyIdentifier eid;

	private Machine mach;

	private LayerMask environmentMask;

	private float decoyThreshold;

	private int teleportAttempts;

	private int teleportInterval = 6;

	public GameObject bigHurt;

	public GameObject windUp;

	public GameObject windUpSmall;

	public GameObject teleportSound;

	private bool goingLeft;

	private bool goForward;

	private Rigidbody rb;

	private bool beaming;

	private bool beamCooldown = true;

	private bool beamNext;

	public GameObject beam;

	[HideInInspector]
	public GameObject tempBeam;

	public Transform rightHand;

	private float beamDistance;

	private LineRenderer lr;

	private float outOfSightTime;

	public AssetReference deathExplosion;

	public ParticleSystem chargeParticle;

	private bool vibrate;

	private Vector3 origPos;

	private float timeSinceMelee;

	private float spawnAttackDelay = 1f;

	private int difficulty = -1;

	private float cooldownMultiplier;

	private bool enraged;

	public GameObject enrageEffect;

	private GameObject currentEnrageEffect;

	private EnemySimplifier[] ensims;

	public GameObject originalGlow;

	public GameObject enrageGlow;

	public Gradient originalTentacleGradient;

	[HideInInspector]
	public bool dying;

	private bool launched;

	private Collider[] ownColliders;

	private EnemyTarget target => eid.target;

	public bool isEnraged => enraged;

	public string alterKey => "mindflayer";

	public string alterCategoryName => "mindflayer";

	public AlterOption<bool>[] options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			value = isEnraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		}
	};

	private void Awake()
	{
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		anim = GetComponent<Animator>();
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Start()
	{
		cooldown = 2f;
		decoyThreshold = mach.health - (float)teleportInterval;
		environmentMask = (int)environmentMask | 0x100;
		environmentMask = (int)environmentMask | 0x1000000;
		sc = GetComponentInChildren<SwingCheck2>();
		lr = GetComponent<LineRenderer>();
		lr.enabled = false;
		if (tempBeam != null)
		{
			Object.Destroy(tempBeam);
		}
		RandomizeDirection();
		SetSpeed();
		if (dying)
		{
			Death();
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		eid.immuneToFriendlyFire = difficulty >= 4;
		if (difficulty >= 4)
		{
			cooldownMultiplier = 2.5f;
			anim.speed = 1.5f;
		}
		else if (difficulty == 3)
		{
			cooldownMultiplier = 1.5f;
			anim.speed = 1.35f;
		}
		else if (difficulty < 2)
		{
			cooldownMultiplier = 0.75f;
			if (difficulty == 1)
			{
				anim.speed = 0.75f;
			}
			else if (difficulty == 0)
			{
				anim.speed = 0.5f;
			}
		}
		else
		{
			cooldownMultiplier = 1f;
			anim.speed = 1f;
		}
		cooldownMultiplier *= eid.totalSpeedModifier;
		anim.speed *= eid.totalSpeedModifier;
		defaultAnimSpeed = anim.speed;
	}

	private void OnDisable()
	{
		StopAction();
		if ((bool)sc)
		{
			DamageEnd();
		}
		if (tempBeam != null)
		{
			Object.Destroy(tempBeam);
		}
		chargeParticle.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
		overrideRotation = false;
	}

	private void UpdateRigidbodySettings()
	{
		if (target == null)
		{
			rb.drag = 3f;
			rb.angularDrag = 3f;
		}
		else
		{
			rb.drag = 0f;
			rb.angularDrag = 0f;
		}
	}

	private void Update()
	{
		UpdateRigidbodySettings();
		if (vibrate)
		{
			model.localPosition = new Vector3(origPos.x + Random.Range(-0.2f, 0.2f), origPos.y + Random.Range(-0.2f, 0.2f), origPos.z + Random.Range(-0.2f, 0.2f));
		}
		if (launched)
		{
			model.Rotate(Vector3.right, -1200f * Time.deltaTime, Space.Self);
		}
		if (target == null)
		{
			if (beaming)
			{
				StopBeam();
			}
			if (inAction)
			{
				StopAction();
			}
		}
		else
		{
			if (!active)
			{
				return;
			}
			bool flag = Vector3.Distance(base.transform.position, target.position) > 25f || base.transform.position.y > target.position.y + 15f || Physics.Raycast(base.transform.position, target.position - base.transform.position, Vector3.Distance(base.transform.position, target.position), environmentMask);
			if (spawnAttackDelay > 0f)
			{
				spawnAttackDelay = Mathf.MoveTowards(spawnAttackDelay, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			else if (Vector3.Distance(target.position, base.transform.position) < 5f && !inAction)
			{
				MeleeAttack();
			}
			timeSinceMelee += Time.deltaTime * eid.totalSpeedModifier;
			if (((difficulty > 2 && timeSinceMelee > 10f) || (difficulty == 2 && timeSinceMelee > 15f)) && !inAction)
			{
				Teleport(closeRange: true);
				timeSinceMelee = 5f;
				if (Vector3.Distance(target.position, base.transform.position) < 8f)
				{
					MeleeAttack();
				}
			}
			if (cooldown > 0f)
			{
				cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * cooldownMultiplier);
			}
			else if (!inAction && !flag)
			{
				if (beamCooldown || (Random.Range(0f, 1f) < 0.25f && !beamNext))
				{
					if (!beamCooldown)
					{
						beamNext = true;
					}
					beamCooldown = false;
					HomingAttack();
				}
				else
				{
					BeamAttack();
				}
			}
			if (flag)
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 3f, Time.deltaTime * eid.totalSpeedModifier);
				if (outOfSightTime >= 3f && !inAction)
				{
					Teleport();
				}
			}
			else
			{
				outOfSightTime = Mathf.MoveTowards(outOfSightTime, 0f, Time.deltaTime * 2f * eid.totalSpeedModifier);
			}
			if (!overrideRotation)
			{
				Quaternion quaternion = Quaternion.LookRotation(target.position - base.transform.position, Vector3.up);
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * (10f * Quaternion.Angle(quaternion, base.transform.rotation) + 2f) * eid.totalSpeedModifier);
			}
			else
			{
				Quaternion quaternion2 = Quaternion.LookRotation(overrideTarget - base.transform.position, Vector3.up);
				if (!beaming)
				{
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion2, Time.deltaTime * (100f * Quaternion.Angle(quaternion2, base.transform.rotation) + 10f) * eid.totalSpeedModifier);
				}
				else
				{
					float num = 1f;
					if (difficulty == 1)
					{
						num = 0.85f;
					}
					else if (difficulty == 0)
					{
						num = 0.65f;
					}
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion2, Time.deltaTime * beamDistance * num * eid.totalSpeedModifier);
					if (Quaternion.Angle(base.transform.rotation, quaternion2) < 1f)
					{
						StopBeam();
					}
				}
			}
			if (decoyThreshold > mach.health && decoyThreshold > 0f && !dontTeleport)
			{
				Object.Instantiate(bigHurt, base.transform.position, Quaternion.identity);
				while (decoyThreshold > mach.health)
				{
					decoyThreshold -= teleportInterval;
				}
				Teleport();
			}
			if (difficulty > 2 && mach.health < 15f && !enraged)
			{
				Enrage();
			}
		}
	}

	private void FixedUpdate()
	{
		if (launched)
		{
			RaycastHit[] array = Physics.SphereCastAll(base.transform.position, 1f, base.transform.forward * -1f, 50f * Time.fixedDeltaTime, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment));
			bool flag = false;
			bool flag2 = false;
			RaycastHit[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit = array2[i];
				if (raycastHit.collider.gameObject.layer == 8 || raycastHit.collider.gameObject.layer == 24)
				{
					flag = true;
					break;
				}
				Collider[] array3 = ownColliders;
				foreach (Collider collider in array3)
				{
					if (raycastHit.collider == collider)
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2)
				{
					flag = true;
					if (raycastHit.collider.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && !component.eid.dead)
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.strike", null, eid);
						if (component.eid.enemyType == EnemyType.Gutterman && component.eid.TryGetComponent<Gutterman>(out var component2) && component2.hasShield)
						{
							component2.ShieldBreak(player: true, flash: false);
						}
					}
					break;
				}
				flag2 = false;
			}
			if (flag)
			{
				CancelInvoke("DeathExplosion");
				DeathExplosion();
			}
			else
			{
				rb.MovePosition(base.transform.position - base.transform.forward * 50f * Time.fixedDeltaTime);
			}
		}
		if (target == null)
		{
			return;
		}
		if (!inAction)
		{
			if (goingLeft)
			{
				if (!Physics.Raycast(base.transform.position, base.transform.right * -1f, 1f, environmentMask))
				{
					rb.MovePosition(base.transform.position + base.transform.right * -5f * Time.fixedDeltaTime * anim.speed);
				}
				else
				{
					goingLeft = false;
				}
			}
			else if (!Physics.Raycast(base.transform.position, base.transform.right, 1f, environmentMask))
			{
				rb.MovePosition(base.transform.position + base.transform.right * 5f * Time.fixedDeltaTime * anim.speed);
			}
			else
			{
				goingLeft = true;
			}
		}
		else if (goForward && !Physics.Raycast(base.transform.position, base.transform.forward, 1f, environmentMask))
		{
			rb.MovePosition(base.transform.position + base.transform.forward * 75f * Time.fixedDeltaTime * anim.speed);
		}
	}

	private void RandomizeDirection()
	{
		if (Random.Range(0f, 1f) > 0.5f)
		{
			goingLeft = true;
		}
		else
		{
			goingLeft = false;
		}
	}

	public void Teleport(bool closeRange = false)
	{
		outOfSightTime = 0f;
		if ((bool)eid && eid.drillers.Count > 0)
		{
			return;
		}
		if (teleportAttempts == 0)
		{
			GameObject gameObject = Object.Instantiate(decoy, base.transform.GetChild(0).position, base.transform.GetChild(0).rotation);
			Animator componentInChildren = gameObject.GetComponentInChildren<Animator>();
			AnimatorStateInfo currentAnimatorStateInfo = anim.GetCurrentAnimatorStateInfo(0);
			componentInChildren.Play(currentAnimatorStateInfo.shortNameHash, 0, currentAnimatorStateInfo.normalizedTime);
			componentInChildren.speed = 0f;
			if (enraged)
			{
				gameObject.GetComponent<MindflayerDecoy>().enraged = true;
			}
		}
		Vector3 normalized = Random.onUnitSphere.normalized;
		if (normalized.y < 0f)
		{
			normalized.y *= -1f;
		}
		float num = Random.Range(8, 15);
		if (closeRange)
		{
			num = Random.Range(5, 8);
		}
		Vector3 vector = target.position + Vector3.up;
		vector = ((!Physics.Raycast(target.position + Vector3.up, normalized, out var hitInfo, num, environmentMask, QueryTriggerInteraction.Ignore)) ? (target.position + Vector3.up + normalized * num) : (hitInfo.point - normalized * 3f));
		bool flag = false;
		bool flag2 = false;
		if (Physics.Raycast(vector, Vector3.up, out var hitInfo2, 5f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag = true;
		}
		if (Physics.Raycast(vector, Vector3.down, out var hitInfo3, 5f, environmentMask, QueryTriggerInteraction.Ignore))
		{
			flag2 = true;
		}
		bool flag3 = false;
		Vector3 position = base.transform.position;
		if (flag && flag2)
		{
			if (Vector3.Distance(hitInfo2.point, hitInfo3.point) > 7f)
			{
				position = new Vector3(vector.x, (hitInfo3.point.y + hitInfo2.point.y) / 2f, vector.z);
				flag3 = true;
			}
			else
			{
				teleportAttempts++;
				if (teleportAttempts <= 10)
				{
					Teleport();
				}
			}
		}
		else
		{
			flag3 = true;
			position = (flag ? (hitInfo2.point + Vector3.down * Random.Range(5, 10)) : ((!flag2) ? vector : (hitInfo3.point + Vector3.up * Random.Range(5, 10))));
		}
		if (flag3)
		{
			if (Physics.CheckSphere(position, 0.1f, environmentMask, QueryTriggerInteraction.Ignore))
			{
				Teleport();
				return;
			}
			if (eid.hooked)
			{
				MonoSingleton<HookArm>.Instance.StopThrow(1f, sparks: true);
			}
			base.transform.position = position;
			teleportAttempts = 0;
			Object.Instantiate(teleportSound, base.transform.position, Quaternion.identity);
		}
		if (goingLeft)
		{
			goingLeft = false;
		}
		else
		{
			goingLeft = true;
		}
	}

	public void Death()
	{
		active = false;
		inAction = true;
		chargeParticle.Play();
		anim.SetTrigger("Death");
		Invoke("DeathExplosion", 2f / eid.totalSpeedModifier);
		origPos = model.localPosition;
		vibrate = true;
		dying = true;
		if ((bool)currentEnrageEffect)
		{
			Object.Destroy(currentEnrageEffect);
		}
		for (int i = 0; i < tentacles.Length; i++)
		{
			TrailRenderer component = tentacles[i].GetComponent<TrailRenderer>();
			if ((bool)component)
			{
				component.enabled = false;
			}
		}
		if (tempBeam != null)
		{
			Object.Destroy(tempBeam);
		}
		if (lr.enabled)
		{
			lr.enabled = false;
		}
	}

	private void DeathExplosion()
	{
		Object.Instantiate(deathExplosion.ToAsset(), base.transform.position, Quaternion.identity);
		if (eid.drillers.Count > 0)
		{
			for (int num = eid.drillers.Count - 1; num >= 0; num--)
			{
				Object.Destroy(eid.drillers[num].gameObject);
			}
		}
		Object.Destroy(base.gameObject);
	}

	public void DeadLaunch(Vector3 direction)
	{
		launched = true;
		base.transform.LookAt(base.transform.position - direction);
		anim.Play("BeamHold", 0, 0f);
		ownColliders = GetComponentsInChildren<Collider>();
		CancelInvoke("DeathExplosion");
		Invoke("DeathExplosion", 2f / eid.totalSpeedModifier);
	}

	private void HomingAttack()
	{
		inAction = true;
		dontTeleport = true;
		chargeParticle.Play();
		anim.SetTrigger("HomingAttack");
		Object.Instantiate(windUp, base.transform);
	}

	private void BeamAttack()
	{
		inAction = true;
		chargeParticle.Play();
		dontTeleport = true;
		beamCooldown = true;
		beamNext = false;
		anim.SetTrigger("BeamAttack");
		Object.Instantiate(windUp, base.transform).GetComponent<AudioSource>().pitch = 1.5f;
	}

	private void MeleeAttack()
	{
		timeSinceMelee = 0f;
		inAction = true;
		anim.SetTrigger("MeleeAttack");
		Object.Instantiate(windUpSmall, base.transform);
	}

	public void SwingStart()
	{
		Object.Instantiate(warningFlash, eid.weakPoint.transform).transform.localScale *= 8f;
		mach.ParryableCheck();
	}

	public void DamageStart()
	{
		sc.DamageStart();
		goForward = true;
	}

	public void DamageEnd()
	{
		sc.DamageStop();
		mach.parryable = false;
		goForward = false;
	}

	public void LockTarget()
	{
		if (target == null)
		{
			return;
		}
		if (difficulty > 2 && enraged && Random.Range(0f, 1f) > 0.5f)
		{
			Teleport();
		}
		Rigidbody componentInParent = target.targetTransform.GetComponentInParent<Rigidbody>();
		if ((bool)componentInParent)
		{
			if (difficulty < 4)
			{
				float y = -1.5f;
				if (componentInParent.velocity.y < 0f)
				{
					y = componentInParent.velocity.y * 3f - 1.5f;
				}
				Vector3 vector = new Vector3(componentInParent.velocity.x * 2.5f, y, componentInParent.velocity.z * 2.5f);
				overrideTarget = target.position + vector;
				if (componentInParent.velocity.y < 0f && Physics.Raycast(maxDistance: Vector3.Distance(new Vector3(target.position.x + vector.x, target.position.y, target.position.z + vector.z), overrideTarget), origin: overrideTarget, direction: Vector3.down, hitInfo: out var hitInfo, layerMask: environmentMask))
				{
					overrideTarget = hitInfo.point + Vector3.up;
				}
			}
			else
			{
				overrideTarget = MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(0.5f);
			}
		}
		else
		{
			overrideTarget = target.position;
		}
		Object.Instantiate(warningFlashUnparriable, eid.weakPoint.transform).transform.localScale *= 8f;
		lr.SetPosition(0, base.transform.position);
		lr.SetPosition(1, overrideTarget);
		lr.enabled = true;
		overrideRotation = true;
	}

	public void StartBeam()
	{
		if (target == null || beaming)
		{
			return;
		}
		lr.enabled = false;
		beaming = true;
		tempBeam = Object.Instantiate(beam, rightHand.transform.position, base.transform.rotation);
		tempBeam.transform.SetParent(launched ? model : rightHand, worldPositionStays: true);
		if (tempBeam.TryGetComponent<ContinuousBeam>(out var component))
		{
			component.damage *= eid.totalDamageModifier;
			component.target = target;
			if (launched)
			{
				component.canHitPlayer = false;
			}
		}
		Vector3 vector = ((difficulty >= 4 && eid.target.isPlayer) ? MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(0.5f) : target.position);
		overrideTarget += (vector - overrideTarget) * 2f;
		Quaternion b = Quaternion.LookRotation(overrideTarget - base.transform.position, Vector3.up);
		beamDistance = Quaternion.Angle(base.transform.rotation, b);
	}

	private void StopBeam()
	{
		if (tempBeam != null)
		{
			Object.Destroy(tempBeam);
		}
		chargeParticle.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
		overrideRotation = false;
		anim.SetTrigger("StopBeam");
	}

	public void ShootProjectiles()
	{
		if (target == null)
		{
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.transform.position = base.transform.position;
		ProjectileSpread projectileSpread = gameObject.AddComponent<ProjectileSpread>();
		projectileSpread.dontSpawn = true;
		projectileSpread.timeUntilDestroy = 10f;
		for (int i = 0; i < tentacles.Length; i++)
		{
			GameObject gameObject2 = Object.Instantiate(homingProjectile, base.transform.position, Quaternion.LookRotation(target.position - base.transform.position));
			if (!Physics.Raycast(base.transform.position, tentacles[i].position - base.transform.position, Vector3.Distance(tentacles[i].position, base.transform.position), environmentMask))
			{
				gameObject2.transform.position = tentacles[i].position;
			}
			gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: true);
			Projectile component = gameObject2.GetComponent<Projectile>();
			component.target = target;
			component.speed = 10f;
			component.damage *= eid.totalDamageModifier;
		}
		chargeParticle.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmittingAndClear);
		cooldown = Random.Range(4, 5);
	}

	public void HighDifficultyTeleport()
	{
		if (enraged && !dontTeleport)
		{
			Teleport();
			anim.speed = 0f;
			Invoke("ResetAnimSpeed", 0.25f / eid.totalSpeedModifier);
			if (Random.Range(0f, 1f) < 0.1f || (difficulty > 3 && Random.Range(0f, 1f) < 0.33f))
			{
				Invoke("Teleport", 0.2f / eid.totalSpeedModifier);
			}
		}
	}

	public void MeleeTeleport()
	{
		if (enraged)
		{
			Teleport(closeRange: true);
			anim.speed = 0f;
			CancelInvoke("ResetAnimSpeed");
			Invoke("ResetAnimSpeed", 0.25f / eid.totalSpeedModifier);
		}
	}

	public void ResetAnimSpeed()
	{
		anim.speed = defaultAnimSpeed;
	}

	public void StopAction()
	{
		beaming = false;
		inAction = false;
		dontTeleport = false;
		RandomizeDirection();
	}

	public void Enrage()
	{
		if (enraged)
		{
			return;
		}
		enraged = true;
		if (ensims == null || ensims.Length == 0)
		{
			ensims = GetComponentsInChildren<EnemySimplifier>();
		}
		EnemySimplifier[] array = ensims;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enraged = true;
		}
		Gradient gradient = new Gradient();
		GradientColorKey[] array2 = new GradientColorKey[2];
		array2[0].color = Color.red;
		array2[0].time = 0f;
		array2[1].color = Color.red;
		array2[1].time = 1f;
		GradientAlphaKey[] array3 = new GradientAlphaKey[2];
		array3[0].alpha = 1f;
		array3[0].time = 0f;
		array3[1].alpha = 0f;
		array3[1].time = 1f;
		gradient.SetKeys(array2, array3);
		for (int j = 0; j < tentacles.Length; j++)
		{
			TrailRenderer component = tentacles[j].GetComponent<TrailRenderer>();
			if ((bool)component)
			{
				component.colorGradient = gradient;
			}
		}
		currentEnrageEffect = Object.Instantiate(enrageEffect, base.transform.position, base.transform.rotation);
		currentEnrageEffect.transform.SetParent(base.transform, worldPositionStays: true);
		originalGlow.SetActive(value: false);
		enrageGlow.SetActive(value: true);
	}

	public void UnEnrage()
	{
		if (!enraged)
		{
			return;
		}
		enraged = false;
		if (ensims == null || ensims.Length == 0)
		{
			ensims = GetComponentsInChildren<EnemySimplifier>();
		}
		EnemySimplifier[] array = ensims;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enraged = false;
		}
		for (int j = 0; j < tentacles.Length; j++)
		{
			TrailRenderer component = tentacles[j].GetComponent<TrailRenderer>();
			if ((bool)component)
			{
				component.colorGradient = originalTentacleGradient;
			}
		}
		Object.Destroy(currentEnrageEffect);
		originalGlow.SetActive(value: true);
		enrageGlow.SetActive(value: false);
	}
}



public class MindflayerDecoy : MonoBehaviour
{
	private Renderer[] rends;

	private List<Material> mats = new List<Material>();

	private Color clr;

	public bool enraged;

	public Material enrageMaterial;

	public float fadeOverride;

	public float fadeSpeed = 1f;

	private void Start()
	{
		rends = GetComponentsInChildren<Renderer>();
		Renderer[] array = rends;
		foreach (Renderer renderer in array)
		{
			if (enraged)
			{
				renderer.material = enrageMaterial;
			}
			mats.AddRange(renderer.materials);
		}
		clr = mats[0].color;
		if (fadeOverride == 0f)
		{
			return;
		}
		clr.a = fadeOverride;
		foreach (Material mat in mats)
		{
			mat.color = clr;
		}
	}

	private void Update()
	{
		if (!(clr.a > 0f))
		{
			return;
		}
		clr.a = Mathf.MoveTowards(clr.a, 0f, Time.deltaTime * fadeSpeed);
		if (clr.a <= 0f)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		foreach (Material mat in mats)
		{
			mat.color = clr;
		}
	}
}



public class MinosArm : MonoBehaviour
{
	private bool introOver;

	private float attackCooldown = 1.5f;

	private bool inAction;

	private Animator anim;

	private int previousSlam;

	private int maxSlams = 2;

	private int currentSlams;

	public Transform hand;

	public GameObject slamWave;

	public ObjectSpawner rubbleSpawner;

	private bool shaking;

	public GameObject shakeEffect;

	public GameObject impactSound;

	public GameObject hurtSound;

	public GameObject bigHurtSound;

	private Statue stat;

	private float originalHealth;

	private float speedState;

	public UnityEvent encounterStart;

	public UnityEvent encounterEnd;

	private int difficulty = -1;

	private float originalAnimSpeed = 1f;

	private EnemyIdentifier eid;

	private void Start()
	{
		stat = GetComponent<Statue>();
		originalHealth = stat.health;
		SetSpeed();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 4)
		{
			maxSlams = 99;
		}
		else if (difficulty == 3)
		{
			maxSlams = 3;
		}
		if (difficulty == 1)
		{
			originalAnimSpeed = 0.85f;
		}
		else if (difficulty == 0)
		{
			originalAnimSpeed = 0.65f;
		}
		else
		{
			originalAnimSpeed = 1f;
		}
		originalAnimSpeed *= eid.totalSpeedModifier;
		anim.speed = originalAnimSpeed * (1f + speedState / 4f);
	}

	private void Update()
	{
		if (introOver)
		{
			if (BlindEnemies.Blind || (EnemyIgnorePlayer.Active && eid.target == null))
			{
				return;
			}
			if (attackCooldown > 0f)
			{
				attackCooldown = Mathf.MoveTowards(attackCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			else if (!inAction)
			{
				bool flag = false;
				while (!flag)
				{
					int num = Random.Range(0, 3);
					if (num != previousSlam)
					{
						previousSlam = num;
						flag = true;
						switch (num)
						{
						case 0:
							SlamDown();
							break;
						case 1:
							SlamLeft();
							break;
						case 2:
							SlamRight();
							break;
						}
						currentSlams++;
						if (currentSlams >= maxSlams)
						{
							currentSlams = 0;
							attackCooldown = 5f - speedState;
						}
					}
				}
			}
		}
		if (shaking)
		{
			MonoSingleton<CameraController>.Instance.CameraShake(0.25f);
		}
		if (speedState == 1f && stat.health < originalHealth * 0.4f)
		{
			speedState = 2f;
			anim.speed = originalAnimSpeed * 1.5f;
			Flinch();
		}
		else if (speedState == 0f && stat.health < originalHealth * 0.75f)
		{
			speedState = 1f;
			anim.speed = originalAnimSpeed * 1.25f;
			Flinch();
		}
	}

	private void SlamLeft()
	{
		anim.SetTrigger("SlamLeft");
		inAction = true;
	}

	private void SlamRight()
	{
		anim.SetTrigger("SlamRight");
		inAction = true;
	}

	private void SlamDown()
	{
		anim.SetTrigger("SlamDown");
		inAction = true;
	}

	public void Slam(int type)
	{
		Vector3 vector = Vector3.down;
		switch (type)
		{
		case 1:
			vector = base.transform.right;
			break;
		case 2:
			vector = base.transform.right * -1f;
			break;
		}
		Vector3 position = hand.position;
		if (Physics.Raycast(hand.position, vector, out var hitInfo, 100f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			position = hitInfo.point - vector * 0.1f;
		}
		GameObject gameObject = Object.Instantiate(slamWave, position, Quaternion.identity);
		GoreZone componentInParent = GetComponentInParent<GoreZone>();
		if ((bool)componentInParent)
		{
			gameObject.transform.SetParent(componentInParent.transform, worldPositionStays: true);
		}
		else
		{
			gameObject.transform.SetParent(base.transform, worldPositionStays: true);
		}
		float num = 3f;
		if (type > 0)
		{
			num = 7f;
		}
		gameObject.transform.localScale = new Vector3(gameObject.transform.localScale.x, gameObject.transform.localScale.y * num, gameObject.transform.localScale.z);
		PhysicalShockwave component = gameObject.GetComponent<PhysicalShockwave>();
		if ((bool)component)
		{
			if (difficulty == 1)
			{
				component.speed = 60f;
			}
			else if (difficulty == 0)
			{
				component.speed = 30f;
			}
			else
			{
				component.speed = 90f;
			}
			component.damage = Mathf.RoundToInt(35f * eid.totalDamageModifier);
			component.maxSize = 350f;
		}
		if (type > 0)
		{
			gameObject.transform.Rotate(base.transform.forward * 90f);
		}
		BigImpact();
	}

	public void BigImpact(float shakeAmount = 2f)
	{
		MonoSingleton<CameraController>.Instance.CameraShake(2f);
		rubbleSpawner.SpawnObject(0);
		if (shakeAmount != 2f)
		{
			Object.Instantiate(impactSound, base.transform.position, base.transform.rotation);
		}
	}

	private void Flinch()
	{
		anim.SetTrigger("Flinch");
		inAction = true;
		currentSlams = 0;
		maxSlams++;
		attackCooldown = 0f;
		if (!introOver)
		{
			if (shaking)
			{
				StopShaking();
			}
			StartEncounter();
			IntroEnd();
		}
		Object.Instantiate(hurtSound, base.transform.position, Quaternion.identity);
	}

	public void Retreat()
	{
		anim.SetBool("Retreat", value: true);
		inAction = true;
		StartShaking();
		Object.Instantiate(bigHurtSound, base.transform.position, Quaternion.identity);
	}

	public void EndEncounter()
	{
		StopShaking();
		encounterEnd.Invoke();
		GetComponentInChildren<DoubleRender>()?.RemoveEffect();
	}

	public void IntroEnd()
	{
		introOver = true;
	}

	public void StopAction()
	{
		inAction = false;
	}

	public void StartShaking()
	{
		shaking = true;
		rubbleSpawner.SpawnObject(0);
		shakeEffect.SetActive(value: true);
	}

	public void StopShaking()
	{
		shaking = false;
		shakeEffect.SetActive(value: false);
		BigImpact(1f);
	}

	public void StartEncounter()
	{
		encounterStart.Invoke();
	}
}



public class MinosBoss : MonoBehaviour
{
	private Animator anim;

	private EnemyIdentifier eid;

	private Statue stat;

	public Transform head;

	private bool inAction;

	private bool inPhaseChange;

	private float cooldown = 3f;

	public int phase = 1;

	public Transform rightArm;

	public Transform rightHand;

	private Transform[] rightHandBones;

	private SwingCheck2[] scRight;

	private bool attackingRight;

	public Transform leftArm;

	public Transform leftHand;

	private Transform[] leftHandBones;

	private SwingCheck2[] scLeft;

	private bool attackingLeft;

	public GameObject windupSound;

	public GameObject bigHurtSound;

	public GameObject punchExplosion;

	public bool onRight;

	public bool onMiddle;

	public bool onLeft;

	private float blackHoleCooldown = 10f;

	public GameObject blackHole;

	private BlackHoleProjectile currentBlackHole;

	public Transform blackHoleSpawnPos;

	private float lowMiddleChance = 0.5f;

	public GameObject[] eyes;

	public Material eyeless;

	public Parasite[] parasites;

	private float originalHealth;

	public UnityEvent onDeathImpact;

	public UnityEvent onDeathOver;

	private bool dead;

	private int difficulty = -1;

	private bool beenParried;

	public bool parryChallenge;

	private int punchesSinceBreak;

	private void Start()
	{
		stat = GetComponent<Statue>();
		originalHealth = stat.health;
		scRight = rightArm.GetComponentsInChildren<SwingCheck2>();
		rightHandBones = rightArm.GetComponentsInChildren<Transform>();
		scLeft = leftArm.GetComponentsInChildren<SwingCheck2>();
		leftHandBones = leftArm.GetComponentsInChildren<Transform>();
		SetSpeed();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 1)
		{
			anim.speed = 0.85f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.65f;
		}
		else if (difficulty == 4)
		{
			anim.speed = 1.25f;
		}
		else if (difficulty == 5)
		{
			anim.speed = 1.5f;
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
		Parasite[] array = parasites;
		foreach (Parasite obj in array)
		{
			obj.speedMultiplier = eid.totalSpeedModifier;
			obj.damageMultiplier = eid.totalDamageModifier;
		}
	}

	private void Update()
	{
		if (dead && !anim.GetCurrentAnimatorStateInfo(0).IsName("Death"))
		{
			anim.Play("Death");
		}
		if (currentBlackHole == null && blackHoleCooldown > 0f && (phase < 2 || difficulty > 2))
		{
			blackHoleCooldown = Mathf.MoveTowards(blackHoleCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if ((bool)stat && stat.health < originalHealth / 2f && phase < 2 && !anim.IsInTransition(0))
		{
			inPhaseChange = true;
			PhaseChange(2);
		}
		if (eid.target == null || inAction || inPhaseChange)
		{
			return;
		}
		if (currentBlackHole == null && blackHoleCooldown == 0f && difficulty >= 2 && (phase < 2 || difficulty > 2))
		{
			BlackHole();
		}
		else if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * anim.speed);
		}
		else
		{
			if (anim.IsInTransition(0))
			{
				return;
			}
			if (phase == 1 && difficulty < 4)
			{
				cooldown = ((difficulty >= 4) ? 1 : 2);
			}
			else if (phase == 2 || difficulty >= 4)
			{
				if ((difficulty == 4 && punchesSinceBreak < 2) || difficulty == 5)
				{
					punchesSinceBreak++;
					cooldown = 0f;
				}
				else
				{
					punchesSinceBreak = 0;
					cooldown = 3f;
				}
			}
			else
			{
				cooldown = 0f;
			}
			if (onRight)
			{
				if (onMiddle && Random.Range(0f, 1f) > 0.5f)
				{
					SlamMiddle();
				}
				else
				{
					SlamRight();
				}
			}
			else if (onLeft)
			{
				if (onMiddle && Random.Range(0f, 1f) > 0.5f)
				{
					SlamMiddle();
				}
				else
				{
					SlamLeft();
				}
			}
			else
			{
				SlamMiddle();
			}
		}
	}

	private void SlamRight()
	{
		inAction = true;
		anim.SetTrigger("SlamRight");
		Object.Instantiate(windupSound, head);
		attackingRight = true;
	}

	private void SlamLeft()
	{
		inAction = true;
		anim.SetTrigger("SlamLeft");
		Object.Instantiate(windupSound, head);
		attackingLeft = true;
	}

	private void SlamMiddle()
	{
		inAction = true;
		Object.Instantiate(windupSound, head);
		if (Random.Range(0f, 1f) > lowMiddleChance)
		{
			if (lowMiddleChance < 0.5f)
			{
				lowMiddleChance = 0.5f;
			}
			lowMiddleChance += 0.25f;
			anim.SetTrigger("SlamMiddle");
			attackingLeft = true;
		}
		else
		{
			if (lowMiddleChance > 0.5f)
			{
				lowMiddleChance = 0.5f;
			}
			lowMiddleChance -= 0.25f;
			anim.SetTrigger("SlamMiddleLow");
			attackingRight = true;
		}
	}

	public void SwingStart()
	{
		if (attackingRight)
		{
			SwingCheck2[] array = scRight;
			foreach (SwingCheck2 obj in array)
			{
				obj.damage = 45;
				obj.DamageStart();
			}
			stat.ParryableCheck(partial: true);
			Transform[] array2 = rightHandBones;
			foreach (Transform item in array2)
			{
				stat.parryables.Add(item);
			}
		}
		if (attackingLeft)
		{
			SwingCheck2[] array = scLeft;
			foreach (SwingCheck2 obj2 in array)
			{
				obj2.damage = 45;
				obj2.DamageStart();
			}
			stat.ParryableCheck(partial: true);
			Transform[] array2 = leftHandBones;
			foreach (Transform item2 in array2)
			{
				stat.parryables.Add(item2);
			}
		}
	}

	public void SpecialDeath()
	{
		inAction = true;
		dead = true;
		anim.Play("Death");
		if (currentBlackHole != null)
		{
			currentBlackHole.Explode();
		}
		Parasite[] array = parasites;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
		Object.Instantiate(bigHurtSound, head).GetComponent<AudioSource>().pitch = 0.75f;
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
	}

	public void Impact()
	{
		Object.Instantiate(punchExplosion, head);
		MonoSingleton<CameraController>.Instance.CameraShake(3f);
		onDeathImpact?.Invoke();
	}

	public void DeathOver()
	{
		onDeathOver?.Invoke();
	}

	public void SwingEnd()
	{
		MonoSingleton<CameraController>.Instance.CameraShake(2f);
		List<Transform> list = new List<Transform>();
		if (attackingRight)
		{
			SwingCheck2[] array = scRight;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			list.Add(rightHand.transform);
		}
		if (attackingLeft)
		{
			SwingCheck2[] array = scLeft;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			list.Add(leftHand.transform);
		}
		stat.partiallyParryable = false;
		stat.parryables.Clear();
		foreach (Transform item in list)
		{
			if (Physics.Raycast(item.position, item.up, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
			{
				Object.Instantiate(punchExplosion, hitInfo.point, Quaternion.identity);
			}
			else
			{
				Object.Instantiate(punchExplosion, item.position, Quaternion.identity);
			}
		}
		list.Clear();
	}

	private void BlackHole()
	{
		blackHoleCooldown = 5f;
		inAction = true;
		anim.SetTrigger("SpawnBlackHole");
	}

	public void SpawnBlackHole()
	{
		if (!inPhaseChange)
		{
			GameObject gameObject = Object.Instantiate(blackHole, blackHoleSpawnPos);
			currentBlackHole = gameObject.GetComponent<BlackHoleProjectile>();
			currentBlackHole.target = eid.target;
			currentBlackHole.FadeIn();
			if (difficulty == 4)
			{
				currentBlackHole.speed *= 1.5f;
			}
			else if (difficulty == 5)
			{
				currentBlackHole.speed *= 2f;
			}
		}
	}

	public void LaunchBlackHole()
	{
		currentBlackHole.Activate();
	}

	public void GotParried()
	{
		if (dead)
		{
			return;
		}
		Object.Instantiate(bigHurtSound, head);
		punchesSinceBreak = 0;
		if (!beenParried)
		{
			beenParried = true;
			if (parryChallenge)
			{
				MonoSingleton<ChallengeManager>.Instance.ChallengeDone();
			}
		}
		MonoSingleton<StyleHUD>.Instance.AddPoints(500, "ultrakill.downtosize", null, eid);
		if (attackingRight)
		{
			SwingCheck2[] array = scRight;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			anim.SetTrigger("ParryRight");
			eid.hitter = "";
			Transform[] array2 = rightHandBones;
			foreach (Transform transform in array2)
			{
				stat.GetHurt(transform.gameObject, Vector3.zero, 35 / rightHandBones.Length, 0f, transform.position);
				transform.gameObject.layer = 10;
			}
		}
		if (attackingLeft)
		{
			SwingCheck2[] array = scLeft;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			anim.SetTrigger("ParryLeft");
			eid.hitter = "";
			Transform[] array2 = leftHandBones;
			foreach (Transform transform2 in array2)
			{
				stat.GetHurt(transform2.gameObject, Vector3.zero, 35 / leftHandBones.Length, 0f, transform2.position);
				transform2.gameObject.layer = 10;
			}
		}
		stat.partiallyParryable = false;
		stat.parryables.Clear();
		eid.hitter = "";
	}

	public void ResetColliders()
	{
		if (attackingRight)
		{
			Transform[] array = rightHandBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.layer = 11;
			}
		}
		if (attackingLeft)
		{
			Transform[] array = leftHandBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.layer = 11;
			}
		}
	}

	public void StopAction()
	{
		attackingLeft = false;
		attackingRight = false;
		inAction = false;
	}

	public void PlayerInZone(int zone)
	{
		switch (zone)
		{
		case 0:
			onRight = true;
			break;
		case 1:
			onMiddle = true;
			break;
		case 2:
			onLeft = true;
			break;
		}
	}

	public void PlayerExitZone(int zone)
	{
		switch (zone)
		{
		case 0:
			onRight = false;
			break;
		case 1:
			onMiddle = false;
			break;
		case 2:
			onLeft = false;
			break;
		}
	}

	private void PhaseChange(int targetPhase)
	{
		phase = targetPhase;
		inAction = true;
		cooldown = ((difficulty >= 4) ? 1 : 4);
		Object.Instantiate(bigHurtSound, head);
		if (phase == 2)
		{
			anim.SetTrigger("PhaseParasite");
			if (attackingRight)
			{
				SwingCheck2[] array = scRight;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].DamageStop();
				}
			}
			if (attackingLeft)
			{
				SwingCheck2[] array = scLeft;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].DamageStop();
				}
			}
			stat.partiallyParryable = false;
			stat.parryables.Clear();
			if ((bool)currentBlackHole && (difficulty <= 2 || currentBlackHole.fadingIn))
			{
				currentBlackHole.Explode();
			}
		}
		else
		{
			inPhaseChange = false;
		}
	}

	public void ShutEye(int eye)
	{
		eyes[eye].SetActive(value: false);
		if (eye == 1)
		{
			SkinnedMeshRenderer componentInChildren = GetComponentInChildren<SkinnedMeshRenderer>();
			MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
			componentInChildren.GetPropertyBlock(materialPropertyBlock);
			materialPropertyBlock.SetTexture("_MainTex", eyeless.GetTexture("_MainTex"));
			componentInChildren.SetPropertyBlock(materialPropertyBlock, 0);
			eid.UpdateBuffs(visualsOnly: true);
		}
	}

	public void SpawnParasites()
	{
		MonoSingleton<CameraController>.Instance.CameraShake(2f);
		GoreZone componentInParent = GetComponentInParent<GoreZone>();
		GameObject[] array = eyes;
		foreach (GameObject gameObject in array)
		{
			for (int j = 0; j < 3; j++)
			{
				GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, eid);
				if ((bool)gore)
				{
					gore.transform.position = gameObject.transform.position;
					gore.transform.localScale = gore.transform.localScale * 3f;
					if ((bool)componentInParent)
					{
						gore.transform.SetParent(componentInParent.goreZone, worldPositionStays: true);
					}
					else
					{
						gore.transform.parent = null;
					}
				}
			}
		}
		Parasite[] array2 = parasites;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].gameObject.SetActive(value: true);
		}
		inPhaseChange = false;
		eid.weakPoint = parasites[0].GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject;
	}

	public void TargetBeenHit(SwingCheck2 swing)
	{
		if (attackingRight)
		{
			SwingCheck2[] array = scRight;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			Transform[] array2 = rightHandBones;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].gameObject.layer = 10;
			}
		}
		if (attackingLeft)
		{
			SwingCheck2[] array = scLeft;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStop();
			}
			Transform[] array2 = leftHandBones;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].gameObject.layer = 10;
			}
		}
	}
}



public class MinosPrime : MonoBehaviour, IHitTargetCallback
{
	private NavMeshAgent nma;

	private Animator anim;

	private Machine mach;

	private EnemyIdentifier eid;

	private GroundCheckEnemy gce;

	private Rigidbody rb;

	private Collider col;

	private AudioSource aud;

	private float originalHp;

	private bool inAction;

	private float cooldown = 2f;

	private MPAttack lastAttack;

	private Vector3 playerPos;

	private bool tracking;

	private bool fullTracking;

	private bool aiming;

	private bool jumping;

	public GameObject explosion;

	public GameObject rubble;

	public GameObject bigRubble;

	public GameObject groundWave;

	public GameObject swoosh;

	public Transform aimingBone;

	private Transform head;

	public GameObject projectileCharge;

	public GameObject snakeProjectile;

	private bool hasProjectiled;

	public GameObject warningFlash;

	public GameObject parryableFlash;

	private bool gravityInAction;

	private bool hasRiderKicked;

	private bool previouslyRiderKicked;

	private int downSwingAmount;

	private bool ignoreRiderkickAngle;

	public GameObject attackTrail;

	public GameObject swingSnake;

	private List<GameObject> currentSwingSnakes = new List<GameObject>();

	private bool uppercutting;

	private bool hitSuccessful;

	private bool gotParried;

	public Transform[] swingLimbs;

	private bool swinging;

	private bool boxing;

	private int attacksSinceBoxing;

	private SwingCheck2 sc;

	private GoreZone gz;

	private int attackAmount;

	private bool enraged;

	public GameObject passiveEffect;

	private GameObject currentPassiveEffect;

	public GameObject flameEffect;

	public GameObject phaseChangeEffect;

	private int difficulty = -1;

	private MPAttack previousCombo = MPAttack.Jump;

	private bool activated = true;

	private bool ascending;

	private bool vibrating;

	private Vector3 origPos;

	public GameObject lightShaft;

	public GameObject outroExplosion;

	public UltrakillEvent onOutroEnd;

	private Vector3 spawnPoint;

	[Header("Voice clips")]
	public AudioClip[] riderKickVoice;

	public AudioClip[] dropkickVoice;

	public AudioClip[] dropAttackVoice;

	public AudioClip[] boxingVoice;

	public AudioClip[] comboVoice;

	public AudioClip[] overheadVoice;

	public AudioClip[] projectileVoice;

	public AudioClip[] uppercutVoice;

	public AudioClip phaseChangeVoice;

	public AudioClip[] hurtVoice;

	private bool bossVersion;

	private EnemyTarget target => eid.target;

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		nma = GetComponent<NavMeshAgent>();
		mach = GetComponent<Machine>();
		gce = GetComponentInChildren<GroundCheckEnemy>();
		rb = GetComponent<Rigidbody>();
		sc = GetComponentInChildren<SwingCheck2>();
		col = GetComponent<Collider>();
		aud = GetComponent<AudioSource>();
	}

	private void Start()
	{
		SetSpeed();
		head = eid.weakPoint.transform;
		originalHp = mach.health;
		gz = GoreZone.ResolveGoreZone(base.transform);
		spawnPoint = base.transform.position;
		bossVersion = TryGetComponent<BossHealthBar>(out var _);
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 1)
		{
			anim.speed = 0.9f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.8f;
		}
		else if (difficulty == 5)
		{
			anim.speed = 1.25f;
		}
		else if (difficulty == 4)
		{
			anim.speed = 1.125f;
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
	}

	private void OnDisable()
	{
		if ((bool)mach)
		{
			CancelInvoke();
			StopAction();
			DamageStop();
			uppercutting = false;
			ascending = false;
			tracking = false;
			fullTracking = false;
			aiming = false;
			jumping = false;
		}
	}

	private void OnEnable()
	{
		if (!activated)
		{
			OutroEnd();
		}
	}

	private void Update()
	{
		if (target == null)
		{
			return;
		}
		if (activated)
		{
			playerPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
			if (!inAction)
			{
				cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (!enraged && mach.health < originalHp / 2f)
			{
				enraged = true;
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("WEAK");
				aud.clip = phaseChangeVoice;
				aud.pitch = 1f;
				aud.Play();
				currentPassiveEffect = Object.Instantiate(passiveEffect, base.transform.position + Vector3.up * 3.5f, Quaternion.identity);
				currentPassiveEffect.transform.SetParent(base.transform);
				EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
				foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
				{
					Object.Instantiate(flameEffect, enemyIdentifierIdentifier.transform);
				}
				Object.Instantiate(phaseChangeEffect, mach.chest.transform.position, Quaternion.identity);
			}
		}
		else if (ascending)
		{
			rb.velocity = Vector3.MoveTowards(rb.velocity, Vector3.up * 3f, Time.deltaTime);
			MonoSingleton<CameraController>.Instance.CameraShake(0.1f);
		}
		else if (vibrating)
		{
			base.transform.position = new Vector3(origPos.x + Random.Range(-0.1f, 0.1f), origPos.y + Random.Range(-0.1f, 0.1f), origPos.z + Random.Range(-0.1f, 0.1f));
		}
	}

	private void FixedUpdate()
	{
		if (!activated)
		{
			return;
		}
		CustomPhysics();
		if (target == null)
		{
			anim.SetBool("Walking", value: false);
			if (nma.enabled && nma.isOnNavMesh)
			{
				nma.isStopped = true;
			}
			return;
		}
		if (!inAction && gce.onGround && (bool)nma && nma.enabled && nma.isOnNavMesh && Vector3.Distance(base.transform.position, playerPos) > 2.5f)
		{
			nma.isStopped = false;
			if ((bool)MonoSingleton<NewMovement>.Instance.gc && !MonoSingleton<NewMovement>.Instance.gc.onGround)
			{
				if (Physics.Raycast(target.position, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
				{
					nma.SetDestination(hitInfo.point);
				}
				else
				{
					nma.SetDestination(target.position);
				}
			}
			else
			{
				nma.SetDestination(target.position);
			}
		}
		else if (inAction)
		{
			if ((bool)nma)
			{
				nma.enabled = false;
			}
			anim.SetBool("Walking", value: false);
		}
		if (tracking || fullTracking)
		{
			if (!fullTracking)
			{
				base.transform.LookAt(playerPos);
			}
			else
			{
				base.transform.rotation = Quaternion.LookRotation(target.position - new Vector3(base.transform.position.x, aimingBone.position.y, base.transform.position.z));
			}
		}
		if ((bool)nma && nma.enabled && nma.isOnNavMesh && !inAction)
		{
			if (nma.velocity.magnitude > 2f)
			{
				anim.SetBool("Walking", value: true);
			}
			else
			{
				anim.SetBool("Walking", value: false);
			}
		}
	}

	private void LateUpdate()
	{
		if (aiming && inAction && activated && target != null)
		{
			aimingBone.LookAt(target.position);
			aimingBone.Rotate(Vector3.up * -90f, Space.Self);
		}
	}

	private void CustomPhysics()
	{
		if ((difficulty == 3 && !enraged && attackAmount >= 10) || (difficulty <= 2 && (((difficulty <= 1 || !enraged) && attackAmount >= 6) || attackAmount >= 12)))
		{
			attackAmount = 0;
			if (difficulty == 1)
			{
				cooldown = 3f;
			}
			else if (difficulty == 0)
			{
				cooldown = 4f;
			}
			else
			{
				cooldown = 2f;
			}
		}
		if (!inAction)
		{
			gravityInAction = false;
			if (gce.onGround && !jumping)
			{
				nma.enabled = true;
				rb.isKinematic = true;
				hasRiderKicked = false;
				hasProjectiled = false;
				downSwingAmount = 0;
				if (cooldown <= 0f && !anim.IsInTransition(0) && target != null)
				{
					float num = Vector3.Distance(base.transform.position, playerPos);
					if (!Physics.Raycast(target.position, Vector3.down, 6f, LayerMaskDefaults.Get(LMD.Environment)) || MonoSingleton<NewMovement>.Instance.rb.velocity.y > 0f)
					{
						if (num < 25f && lastAttack != MPAttack.Jump)
						{
							if (activated)
							{
								Jump();
							}
							lastAttack = MPAttack.Jump;
						}
						else if (num > 25f && lastAttack != MPAttack.ProjectilePunch)
						{
							if (activated)
							{
								ProjectilePunch();
							}
							lastAttack = MPAttack.ProjectilePunch;
						}
						else if (activated)
						{
							int type = Random.Range(0, 4);
							PickAttack(type);
						}
					}
					else if (activated)
					{
						int type2 = Random.Range(0, 4);
						PickAttack(type2);
					}
				}
			}
			else
			{
				nma.enabled = false;
				rb.isKinematic = false;
				if (rb.velocity.y < 0f && !anim.IsInTransition(0) && activated && target != null)
				{
					if (!hasProjectiled && Random.Range(0f, 1f) < 0.25f && enraged && Vector3.Distance(playerPos, base.transform.position) > 6f && !Physics.Raycast(base.transform.position, Vector3.down, 4f, LayerMaskDefaults.Get(LMD.Environment)))
					{
						hasProjectiled = true;
						ProjectilePunch();
					}
					else if (Vector3.Distance(playerPos, base.transform.position) < 5f)
					{
						if (target.position.y < base.transform.position.y)
						{
							DropAttack();
						}
						else if (target.position.y < base.transform.position.y + 10f && downSwingAmount < 2)
						{
							DownSwing();
						}
					}
					else if (Vector3.Angle(Vector3.up, target.position - base.transform.position) > 90f || Vector3.Distance(base.transform.position, target.position) < 10f || ignoreRiderkickAngle)
					{
						if (previouslyRiderKicked && downSwingAmount < 2)
						{
							TeleportAnywhere();
							DownSwing();
							hasRiderKicked = true;
						}
						else if (!hasRiderKicked)
						{
							RiderKick();
						}
					}
					ignoreRiderkickAngle = false;
				}
			}
		}
		else
		{
			nma.enabled = false;
			if (gravityInAction)
			{
				rb.isKinematic = false;
			}
			else
			{
				rb.isKinematic = true;
			}
			if (swinging && !Physics.Raycast(base.transform.position, base.transform.forward, 1f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				if (MonoSingleton<NewMovement>.Instance.sliding)
				{
					rb.MovePosition(base.transform.position + base.transform.forward * 125f * Time.fixedDeltaTime * eid.totalSpeedModifier);
				}
				else
				{
					rb.MovePosition(base.transform.position + base.transform.forward * 75f * Time.fixedDeltaTime * eid.totalSpeedModifier);
				}
			}
		}
		if (!rb.isKinematic && rb.useGravity)
		{
			rb.velocity -= Vector3.up * 100f * Time.fixedDeltaTime;
		}
		if (!jumping)
		{
			if (!rb.isKinematic)
			{
				anim.SetBool("Falling", value: true);
			}
			else
			{
				anim.SetBool("Falling", value: false);
			}
		}
		else
		{
			if (inAction || !(rb.velocity.y < 0f))
			{
				return;
			}
			jumping = false;
			if (uppercutting)
			{
				uppercutting = false;
				DamageStop();
				if (hitSuccessful && target != null && target.position.y > base.transform.position.y && activated)
				{
					Jump();
					hitSuccessful = false;
				}
			}
		}
	}

	private void PickAttack(int type)
	{
		if (attacksSinceBoxing >= 5)
		{
			type = 0;
		}
		switch (type)
		{
		case 0:
			if (lastAttack != 0)
			{
				Boxing();
				lastAttack = MPAttack.Boxing;
				attacksSinceBoxing = 0;
			}
			else
			{
				PickAttack(type + 1);
			}
			break;
		case 1:
			if (lastAttack != MPAttack.Combo)
			{
				Combo();
				lastAttack = MPAttack.Combo;
				attacksSinceBoxing++;
			}
			else
			{
				PickAttack(type + 1);
			}
			break;
		case 2:
			if (lastAttack != MPAttack.Dropkick)
			{
				Dropkick();
				lastAttack = MPAttack.Dropkick;
				attacksSinceBoxing++;
			}
			else
			{
				PickAttack(type + 1);
			}
			break;
		case 3:
			Uppercut();
			attacksSinceBoxing++;
			break;
		}
	}

	private void Dropkick()
	{
		inAction = true;
		if ((bool)nma && nma.isOnNavMesh)
		{
			nma.isStopped = true;
		}
		anim.Play("Dropkick", 0, 0f);
		tracking = true;
		fullTracking = false;
		sc.knockBackForce = 100f;
		aiming = false;
		attackAmount += 2;
		if (!enraged)
		{
			cooldown += 1.25f;
		}
		else
		{
			cooldown += 0.25f;
		}
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Judgement!");
		PlayVoice(dropkickVoice);
	}

	private void ProjectilePunch()
	{
		inAction = true;
		if ((bool)nma && nma.isOnNavMesh)
		{
			nma.isStopped = true;
		}
		tracking = true;
		fullTracking = false;
		aiming = true;
		anim.Play("ProjectilePunch", 0, 0f);
		ProjectileCharge();
		aiming = false;
		attackAmount++;
		PlayVoice(projectileVoice);
	}

	private void Jump()
	{
		inAction = true;
		base.transform.LookAt(playerPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = true;
		rb.isKinematic = false;
		rb.useGravity = true;
		jumping = true;
		anim.SetBool("Falling", value: false);
		anim.Play("Jump", 0, 0f);
		Invoke("StopAction", 0.1f);
		rb.AddForce(Vector3.up * 100f, ForceMode.VelocityChange);
		Object.Instantiate(swoosh, base.transform.position, Quaternion.identity);
		aiming = false;
	}

	private void Uppercut()
	{
		hitSuccessful = false;
		inAction = true;
		base.transform.LookAt(playerPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("Uppercut", 0, 0f);
		anim.SetBool("Falling", value: false);
		Object.Instantiate(warningFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 5f;
		sc.knockBackForce = 100f;
		aiming = false;
		attackAmount++;
		PlayVoice(uppercutVoice);
	}

	private void RiderKick()
	{
		if (target != null)
		{
			downSwingAmount = 0;
			previouslyRiderKicked = true;
			inAction = true;
			base.transform.LookAt(target.position);
			tracking = true;
			fullTracking = true;
			gravityInAction = false;
			anim.SetTrigger("RiderKick");
			if (difficulty >= 2)
			{
				Invoke("StopTracking", 0.5f / anim.speed);
			}
			else
			{
				Invoke("StopTracking", 0.25f / anim.speed);
			}
			Invoke("RiderKickActivate", 0.75f / anim.speed);
			Object.Instantiate(warningFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 5f;
			sc.knockBackForce = 50f;
			aiming = false;
			attackAmount++;
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Die!");
			PlayVoice(riderKickVoice);
		}
	}

	private void DropAttack()
	{
		downSwingAmount = 0;
		tracking = true;
		fullTracking = false;
		ResetRotation();
		inAction = true;
		base.transform.LookAt(playerPos);
		gravityInAction = false;
		anim.SetTrigger("DropAttack");
		Invoke("DropAttackActivate", 0.75f / anim.speed);
		Object.Instantiate(warningFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 5f;
		sc.knockBackForce = 50f;
		aiming = false;
		attackAmount++;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Crush!");
		PlayVoice(dropAttackVoice);
	}

	private void DownSwing()
	{
		if (target != null)
		{
			downSwingAmount++;
			previouslyRiderKicked = false;
			tracking = true;
			fullTracking = true;
			inAction = true;
			base.transform.LookAt(target.position);
			gravityInAction = false;
			anim.SetTrigger("DownSwing");
			Object.Instantiate(warningFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 5f;
			sc.knockBackForce = 100f;
			sc.knockBackDirectionOverride = true;
			sc.knockBackDirection = Vector3.down;
			aiming = false;
			attackAmount++;
			PlayVoice(overheadVoice);
		}
	}

	public void UppercutActivate()
	{
		base.transform.LookAt(playerPos);
		uppercutting = true;
		tracking = true;
		fullTracking = false;
		gravityInAction = true;
		rb.isKinematic = false;
		rb.useGravity = true;
		jumping = true;
		anim.SetBool("Falling", value: false);
		Invoke("StopAction", 0.1f);
		rb.AddForce(Vector3.up * 100f, ForceMode.VelocityChange);
		Object.Instantiate(swoosh, base.transform.position, Quaternion.identity);
		Transform child = Object.Instantiate(swingSnake, aimingBone.position + base.transform.forward * 4f, Quaternion.identity).transform.GetChild(0);
		child.SetParent(base.transform, worldPositionStays: true);
		child.rotation = Quaternion.LookRotation(Vector3.up);
		currentSwingSnakes.Add(child.gameObject);
		SwingCheck2[] componentsInChildren = child.GetComponentsInChildren<SwingCheck2>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OverrideEnemyIdentifier(eid);
		}
		sc.knockBackDirectionOverride = true;
		sc.knockBackDirection = Vector3.up;
		DamageStart();
	}

	public void UppercutCancel(int parryable = 0)
	{
		if (target != null)
		{
			if (target.position.y > base.transform.position.y + 5f)
			{
				DamageStop();
				Uppercut();
			}
			else if (parryable == 1)
			{
				Parryable();
			}
		}
	}

	public void Combo()
	{
		if (previousCombo == MPAttack.Combo)
		{
			Boxing();
			return;
		}
		previousCombo = MPAttack.Combo;
		inAction = true;
		base.transform.LookAt(playerPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("Combo", 0, 0f);
		sc.knockBackForce = 50f;
		aiming = false;
		attackAmount += 3;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Prepare thyself!");
		PlayVoice(comboVoice);
	}

	public void Boxing()
	{
		if (previousCombo == MPAttack.Boxing)
		{
			Combo();
			return;
		}
		previousCombo = MPAttack.Boxing;
		inAction = true;
		base.transform.LookAt(playerPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("Boxing", 0, 0f);
		sc.knockBackForce = 30f;
		aiming = false;
		attackAmount += 2;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Thy end is now!");
		PlayVoice(boxingVoice);
	}

	private void RiderKickActivate()
	{
		Physics.Raycast(aimingBone.position, base.transform.forward, out var hitInfo, 250f, LayerMaskDefaults.Get(LMD.Environment));
		LineRenderer component = Object.Instantiate(attackTrail, aimingBone.position, base.transform.rotation).GetComponent<LineRenderer>();
		component.SetPosition(0, aimingBone.position);
		RaycastHit[] array = Physics.SphereCastAll(aimingBone.position, 5f, base.transform.forward, Vector3.Distance(aimingBone.position, hitInfo.point), LayerMaskDefaults.Get(LMD.EnemiesAndPlayer));
		bool flag = false;
		new List<EnemyIdentifier>();
		RaycastHit[] array2 = array;
		foreach (RaycastHit raycastHit in array2)
		{
			if (!flag && raycastHit.collider.gameObject.CompareTag("Player"))
			{
				flag = true;
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(30f * eid.totalDamageModifier), invincible: true);
				MonoSingleton<NewMovement>.Instance.LaunchFromPoint(MonoSingleton<NewMovement>.Instance.transform.position + base.transform.forward * -1f, 100f, 100f);
			}
		}
		if (Vector3.Angle(Vector3.up, hitInfo.normal) < 35f)
		{
			ResetRotation();
			base.transform.position = hitInfo.point;
			anim.Play("DropRecovery", 0, 0f);
		}
		else if (Vector3.Angle(Vector3.up, hitInfo.normal) < 145f)
		{
			base.transform.position = hitInfo.point - base.transform.forward;
			ResetRotation();
			inAction = false;
			hasRiderKicked = true;
			anim.Play("Falling", 0, 0f);
		}
		else
		{
			base.transform.position = hitInfo.point - Vector3.up * 6.5f;
			ResetRotation();
			inAction = false;
			hasRiderKicked = true;
			anim.Play("Falling", 0, 0f);
		}
		ResolveStuckness();
		component.SetPosition(1, aimingBone.position);
		GameObject gameObject = Object.Instantiate(bigRubble, hitInfo.point, Quaternion.identity);
		if (Vector3.Angle(hitInfo.normal, Vector3.up) < 5f)
		{
			gameObject.transform.LookAt(new Vector3(gameObject.transform.position.x + base.transform.forward.x, gameObject.transform.position.y, gameObject.transform.position.z + base.transform.forward.z));
		}
		else
		{
			gameObject.transform.up = hitInfo.normal;
		}
		if (difficulty >= 2)
		{
			gameObject = Object.Instantiate(groundWave, hitInfo.point, Quaternion.identity);
			gameObject.transform.up = hitInfo.normal;
			gameObject.transform.SetParent(gz.transform);
			if (gameObject.TryGetComponent<PhysicalShockwave>(out var component2))
			{
				component2.enemyType = EnemyType.MinosPrime;
				component2.damage = Mathf.RoundToInt((float)component2.damage * eid.totalDamageModifier);
			}
		}
	}

	private void DropAttackActivate()
	{
		Physics.Raycast(aimingBone.position, Vector3.down, out var hitInfo, 250f, LayerMaskDefaults.Get(LMD.Environment));
		LineRenderer component = Object.Instantiate(attackTrail, aimingBone.position, base.transform.rotation).GetComponent<LineRenderer>();
		component.SetPosition(0, aimingBone.position);
		RaycastHit[] array = Physics.SphereCastAll(aimingBone.position, 5f, Vector3.down, Vector3.Distance(aimingBone.position, hitInfo.point), LayerMaskDefaults.Get(LMD.EnemiesAndPlayer));
		bool flag = false;
		new List<EnemyIdentifier>();
		RaycastHit[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RaycastHit raycastHit = array2[i];
			if (!flag && raycastHit.collider.gameObject.CompareTag("Player"))
			{
				flag = true;
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(50f * eid.totalDamageModifier), invincible: true);
				MonoSingleton<NewMovement>.Instance.LaunchFromPoint(MonoSingleton<NewMovement>.Instance.transform.position + (MonoSingleton<NewMovement>.Instance.transform.position - new Vector3(raycastHit.point.x, MonoSingleton<NewMovement>.Instance.transform.position.y, raycastHit.point.z)).normalized, 100f, 100f);
			}
		}
		base.transform.position = hitInfo.point;
		anim.Play("DropRecovery", 0, 0f);
		component.SetPosition(1, aimingBone.position);
		GameObject gameObject = Object.Instantiate(bigRubble, hitInfo.point, Quaternion.identity);
		if (Vector3.Angle(hitInfo.normal, Vector3.up) < 5f)
		{
			gameObject.transform.LookAt(new Vector3(gameObject.transform.position.x + base.transform.forward.x, gameObject.transform.position.y, gameObject.transform.position.z + base.transform.forward.z));
		}
		else
		{
			gameObject.transform.up = hitInfo.normal;
		}
		if (difficulty >= 2)
		{
			gameObject = Object.Instantiate(groundWave, hitInfo.point, Quaternion.identity);
			gameObject.transform.up = hitInfo.normal;
			gameObject.transform.SetParent(gz.transform);
			if (gameObject.TryGetComponent<PhysicalShockwave>(out var component2))
			{
				component2.enemyType = EnemyType.MinosPrime;
				component2.damage = Mathf.RoundToInt((float)component2.damage * eid.totalDamageModifier);
			}
		}
		Explosion();
	}

	public void SnakeSwingStart(int limb)
	{
		Transform child = Object.Instantiate(swingSnake, aimingBone.position + base.transform.forward * 4f, Quaternion.identity).transform.GetChild(0);
		child.SetParent(base.transform, worldPositionStays: true);
		child.LookAt(playerPos);
		currentSwingSnakes.Add(child.gameObject);
		if (!boxing)
		{
			swinging = true;
		}
		if (child.TryGetComponent<SwingCheck2>(out var component))
		{
			component.OverrideEnemyIdentifier(eid);
			component.knockBackDirectionOverride = true;
			if (sc.knockBackDirectionOverride)
			{
				component.knockBackDirection = sc.knockBackDirection;
			}
			else
			{
				component.knockBackDirection = base.transform.forward;
			}
			component.knockBackForce = sc.knockBackForce;
		}
		if (child.TryGetComponent<AttackTrail>(out var component2))
		{
			component2.target = swingLimbs[limb];
			component2.pivot = aimingBone;
		}
		DamageStart();
	}

	public void DamageStart()
	{
		sc.DamageStart();
	}

	public void DamageStop()
	{
		swinging = false;
		sc.DamageStop();
		sc.knockBackDirectionOverride = false;
		mach.parryable = false;
		if (currentSwingSnakes.Count <= 0)
		{
			return;
		}
		for (int num = currentSwingSnakes.Count - 1; num >= 0; num--)
		{
			if (currentSwingSnakes[num].TryGetComponent<SwingCheck2>(out var component))
			{
				component.DamageStop();
			}
			if (base.gameObject.activeInHierarchy && currentSwingSnakes[num].TryGetComponent<AttackTrail>(out var component2))
			{
				component2.DelayedDestroy(0.5f);
				currentSwingSnakes[num].transform.parent = null;
				component2.target = null;
				component2.pivot = null;
			}
			else
			{
				Object.Destroy(currentSwingSnakes[num]);
			}
		}
		currentSwingSnakes.Clear();
	}

	public void Explosion()
	{
		if (gotParried && difficulty <= 2 && !enraged)
		{
			gotParried = false;
			return;
		}
		GameObject gameObject = Object.Instantiate(this.explosion, base.transform.position, Quaternion.identity);
		mach.parryable = false;
		if (difficulty > 1 && eid.totalDamageModifier == 1f)
		{
			return;
		}
		Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			if (difficulty == 1)
			{
				explosion.speed *= 0.6f;
				explosion.maxSize *= 0.75f;
			}
			else if (difficulty == 0)
			{
				explosion.speed *= 0.5f;
				explosion.maxSize *= 0.5f;
			}
			explosion.speed *= eid.totalDamageModifier;
			explosion.maxSize *= eid.totalDamageModifier;
			explosion.damage = Mathf.RoundToInt((float)explosion.damage * eid.totalDamageModifier);
		}
	}

	public void ProjectileCharge()
	{
		Object.Instantiate(projectileCharge, swingLimbs[0].position, swingLimbs[0].rotation).transform.SetParent(swingLimbs[0]);
	}

	public void ProjectileShoot()
	{
		if (target != null)
		{
			GameObject obj = Object.Instantiate(snakeProjectile, mach.chest.transform.position, Quaternion.LookRotation(target.position - (base.transform.position + Vector3.up)));
			obj.transform.SetParent(gz.transform);
			Projectile componentInChildren = obj.GetComponentInChildren<Projectile>();
			if ((bool)componentInChildren)
			{
				componentInChildren.target = (target.isPlayer ? new EnemyTarget(MonoSingleton<CameraController>.Instance.transform) : target);
				componentInChildren.damage *= eid.totalDamageModifier;
			}
			aiming = false;
			tracking = false;
			fullTracking = false;
		}
	}

	public void TeleportOnGround()
	{
		Teleport(playerPos, base.transform.position);
		base.transform.LookAt(playerPos);
	}

	public void TeleportAnywhere()
	{
		if (target != null)
		{
			Teleport(target.position, base.transform.position);
			base.transform.LookAt(target.position);
		}
	}

	public void TeleportSide(int side)
	{
		if (target == null)
		{
			return;
		}
		int num = 1;
		boxing = true;
		if (side == 0)
		{
			num = -1;
		}
		if (Physics.Raycast(playerPos + Vector3.up, target.right * num + target.forward, out var hitInfo, 4f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
		{
			if (hitInfo.distance >= 2f)
			{
				Teleport(playerPos, playerPos + Vector3.ClampMagnitude(target.right * num + target.forward, 1f) * (hitInfo.distance - 1f));
			}
			else
			{
				Teleport(playerPos, base.transform.position);
			}
			base.transform.LookAt(playerPos);
		}
		else
		{
			Teleport(playerPos, playerPos + (target.right * num + target.forward) * 10f);
			base.transform.LookAt(playerPos);
		}
	}

	public void Teleport(Vector3 teleportTarget, Vector3 startPos)
	{
		float num = Vector3.Distance(teleportTarget, startPos);
		if (boxing && num > 2.5f)
		{
			num = 2.5f;
		}
		else if (num > 3f)
		{
			num = 3f;
		}
		Vector3 vector = teleportTarget + (startPos - teleportTarget).normalized * num;
		Collider[] array = Physics.OverlapCapsule(vector + base.transform.up * 0.75f, vector + base.transform.up * 5.25f, 0.75f, LayerMaskDefaults.Get(LMD.Environment));
		if (array != null && array.Length != 0)
		{
			for (int i = 0; i < 6; i++)
			{
				Collider collider = array[0];
				if (!Physics.ComputePenetration(col, vector + base.transform.up * 3f, base.transform.rotation, collider, collider.transform.position, collider.transform.rotation, out var direction, out var distance))
				{
					break;
				}
				_ = 0.5f;
				vector += direction * distance;
				array = Physics.OverlapCapsule(vector + base.transform.up * 0.75f, vector + base.transform.up * 5.25f, 0.75f, LayerMaskDefaults.Get(LMD.Environment));
				if (array == null || array.Length == 0)
				{
					break;
				}
				if (i == 5)
				{
					ResolveStuckness();
					break;
				}
			}
		}
		float num2 = Vector3.Distance(base.transform.position, vector);
		for (int j = 0; (float)j < num2; j += 3)
		{
			if (Physics.Raycast(Vector3.Lerp(base.transform.position, vector, (num2 - (float)j) / num2) + Vector3.up, Vector3.down, out var hitInfo, 3f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				Object.Instantiate(rubble, hitInfo.point, Quaternion.Euler(0f, Random.Range(0, 360), 0f));
			}
		}
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
		base.transform.position = vector;
		tracking = false;
		fullTracking = false;
		Object.Instantiate(swoosh, base.transform.position, Quaternion.identity);
	}

	public void Death()
	{
		anim.Play("Outro");
		anim.SetBool("Dead", value: true);
		if (bossVersion)
		{
			anim.speed = 1f;
		}
		else
		{
			anim.speed = 5f;
		}
		activated = false;
		if ((bool)currentPassiveEffect)
		{
			Object.Destroy(currentPassiveEffect);
		}
		CancelInvoke();
		DamageStop();
		Object.Destroy(nma);
		DisableGravity();
		rb.useGravity = false;
		rb.isKinematic = true;
		MonoSingleton<TimeController>.Instance.SlowDown(0.0001f);
	}

	public void Ascend()
	{
		if (!bossVersion)
		{
			OutroEnd();
			return;
		}
		rb.isKinematic = false;
		rb.constraints = (RigidbodyConstraints)122;
		ascending = true;
		LightShaft();
		Invoke("LightShaft", 1.5f);
		Invoke("LightShaft", 3f);
		Invoke("LightShaft", 4f);
		Invoke("LightShaft", 5f);
		Invoke("LightShaft", 5.5f);
		Invoke("LightShaft", 6f);
		Invoke("LightShaft", 6.25f);
		Invoke("LightShaft", 6.5f);
		Invoke("LightShaft", 6.7f);
		Invoke("LightShaft", 6.8f);
		Invoke("LightShaft", 6.85f);
		Invoke("LightShaft", 6.9f);
		Invoke("LightShaft", 6.925f);
		Invoke("LightShaft", 6.95f);
		Invoke("LightShaft", 6.975f);
		Invoke("OutroEnd", 7f);
	}

	private void LightShaft()
	{
		if (base.gameObject.activeInHierarchy)
		{
			Object.Instantiate(lightShaft, mach.chest.transform.position, Random.rotation).transform.SetParent(base.transform, worldPositionStays: true);
			MonoSingleton<CameraController>.Instance.CameraShake(1f);
		}
	}

	public void OutroEnd()
	{
		if (base.gameObject.activeInHierarchy)
		{
			onOutroEnd.Invoke();
			Object.Instantiate(outroExplosion, mach.chest.transform.position, Quaternion.identity);
			base.gameObject.SetActive(value: false);
			MonoSingleton<TimeController>.Instance.SlowDown(0.01f);
		}
	}

	public void EnableGravity(int earlyCancel)
	{
		if (!gce.onGround)
		{
			anim.SetBool("Falling", value: true);
			gravityInAction = true;
			if (earlyCancel == 1)
			{
				inAction = false;
			}
		}
		ResetRotation();
	}

	public void Parryable()
	{
		if (difficulty <= 2 || !enraged)
		{
			gotParried = false;
			Object.Instantiate(parryableFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 10f;
			mach.ParryableCheck();
		}
	}

	public void GotParried()
	{
		PlayVoice(hurtVoice);
		attackAmount -= 5;
		gotParried = true;
	}

	public void Rubble()
	{
		Object.Instantiate(bigRubble, base.transform.position + base.transform.forward, base.transform.rotation);
	}

	public void ResetRotation()
	{
		base.transform.LookAt(new Vector3(base.transform.position.x + base.transform.forward.x, base.transform.position.y, base.transform.position.z + base.transform.forward.z));
		ResolveStuckness();
	}

	public void DisableGravity()
	{
		gravityInAction = false;
	}

	public void StopTracking()
	{
		tracking = false;
		fullTracking = false;
	}

	public void StopAction()
	{
		gotParried = false;
		inAction = false;
		boxing = false;
		if ((bool)mach)
		{
			mach.parryable = false;
		}
	}

	public void TargetBeenHit()
	{
		sc.DamageStop();
		hitSuccessful = true;
		mach.parryable = false;
		if (uppercutting)
		{
			ignoreRiderkickAngle = true;
		}
		foreach (GameObject currentSwingSnake in currentSwingSnakes)
		{
			if ((bool)currentSwingSnake && currentSwingSnake.TryGetComponent<SwingCheck2>(out var component))
			{
				component.DamageStop();
			}
		}
	}

	public void OutOfBounds()
	{
		base.transform.position = spawnPoint;
	}

	public void Vibrate()
	{
		origPos = base.transform.position;
		vibrating = true;
	}

	public void PlayVoice(AudioClip[] voice)
	{
		if (voice.Length != 0 && (!(aud.clip == phaseChangeVoice) || !aud.isPlaying))
		{
			aud.clip = voice[Random.Range(0, voice.Length)];
			aud.pitch = Random.Range(0.95f, 1f);
			aud.Play();
		}
	}

	public void ResolveStuckness()
	{
		Collider[] array = Physics.OverlapCapsule(base.transform.position + base.transform.up * 0.76f, base.transform.position + base.transform.up * 5.24f, 0.74f, LayerMaskDefaults.Get(LMD.Environment));
		if (array == null || array.Length == 0)
		{
			return;
		}
		if (gce.onGround)
		{
			gce.onGround = false;
			nma.enabled = false;
		}
		for (int i = 0; i < 6; i++)
		{
			RaycastHit[] array2 = Physics.CapsuleCastAll(spawnPoint + base.transform.up * 0.75f, spawnPoint + base.transform.up * 5.25f, 0.75f, base.transform.position - spawnPoint, Vector3.Distance(spawnPoint, base.transform.position), LayerMaskDefaults.Get(LMD.Environment));
			if (array2 == null || array2.Length == 0)
			{
				break;
			}
			RaycastHit[] array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				RaycastHit raycastHit = array3[j];
				bool flag = false;
				Collider[] array4 = array;
				for (int k = 0; k < array4.Length; k++)
				{
					if (array4[k] == raycastHit.collider)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					base.transform.position = spawnPoint + (base.transform.position - spawnPoint).normalized * raycastHit.distance + raycastHit.normal * 0.1f;
					break;
				}
			}
			_ = 5;
		}
	}
}



public class Minotaur : MonoBehaviour, IHitTargetCallback
{
	private Rigidbody rb;

	private EnemyIdentifier eid;

	private Animator anim;

	private Machine mach;

	private NavMeshAgent nma;

	private int difficulty;

	private bool gotValues;

	private bool dead;

	private float cooldown;

	private int previousAttack = -1;

	private int currentAttacks;

	private float ramCooldown = 15f;

	private bool inAction;

	private bool moveForward;

	private float moveSpeed = 1f;

	private float moveBreakSpeed;

	private bool trackTarget;

	private float trackSpeed = 1f;

	private Transform tempTarget;

	private bool chaseTarget;

	[SerializeField]
	private AudioSource roar;

	[SerializeField]
	private AudioClip roarClip;

	[SerializeField]
	private AudioClip roarShortClip;

	[SerializeField]
	private AudioClip squealClip;

	[SerializeField]
	private AudioClip longGruntClip;

	[SerializeField]
	private AudioClip exhaleClip;

	[SerializeField]
	private SwingCheck2[] hammerSwingChecks;

	[SerializeField]
	private TrailRenderer hammerTrail;

	[SerializeField]
	private Transform hammerPoint;

	[SerializeField]
	private GameObject hammerImpact;

	[SerializeField]
	private GameObject hammerExplosion;

	[SerializeField]
	private GameObject hammerBigExplosion;

	public bool tantrumOnSpawn;

	[SerializeField]
	private GameObject meatInHand;

	[SerializeField]
	private GameObject handBlood;

	[SerializeField]
	private GameObject toxicCloud;

	[SerializeField]
	private GameObject toxicCloudLong;

	[SerializeField]
	private GameObject goop;

	[SerializeField]
	private GameObject goopLong;

	[HideInInspector]
	public float ramTimer;

	[SerializeField]
	private GameObject ramStuff;

	[SerializeField]
	private GameObject fallEffect;

	private Vector3 deathPosition;

	private List<Transform> deathTransforms = new List<Transform>();

	private float deathTimer;

	private GoreZone gz;

	public UltrakillEvent onDeath;

	private float playerAirBias = 0.5f;

	private void Start()
	{
		GetValues();
	}

	private void GetValues()
	{
		if (!gotValues)
		{
			gotValues = true;
			rb = GetComponent<Rigidbody>();
			eid = GetComponent<EnemyIdentifier>();
			anim = GetComponent<Animator>();
			mach = GetComponent<Machine>();
			nma = GetComponent<NavMeshAgent>();
			gz = GoreZone.ResolveGoreZone(base.transform);
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			SetSpeed();
			if (tantrumOnSpawn)
			{
				currentAttacks++;
				previousAttack = 0;
				QuickTantrum();
			}
			Invoke("SlowUpdate", 0.1f);
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		GetValues();
		float num = 1f;
		if (difficulty >= 4)
		{
			num = 1.2f;
		}
		if (difficulty == 2)
		{
			num = 0.9f;
		}
		else if (difficulty == 1)
		{
			num = 0.85f;
		}
		else if (difficulty == 0)
		{
			num = 0.7f;
		}
		anim.speed = num * eid.totalSpeedModifier;
		nma.speed = 50f * anim.speed;
	}

	private void Update()
	{
		if (dead)
		{
			deathTimer = Mathf.MoveTowards(deathTimer, 5f, Time.deltaTime);
			base.transform.position = new Vector3(deathPosition.x + Random.Range((0f - deathTimer) / 10f, deathTimer / 10f), deathPosition.y + Random.Range((0f - deathTimer) / 10f, deathTimer / 10f), deathPosition.z + Random.Range((0f - deathTimer) / 10f, deathTimer / 10f));
			if (deathTimer < 4f && Random.Range(0f, 1f) < Time.deltaTime * 5f * deathTimer)
			{
				int index = Random.Range(0, deathTransforms.Count);
				if (deathTransforms[index] != null)
				{
					GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, eid);
					if ((bool)gore && (bool)gz && (bool)gz.goreZone)
					{
						gore.transform.position = deathTransforms[index].position;
						gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
					}
					if ((bool)gore && gore.TryGetComponent<Bloodsplatter>(out var component))
					{
						component.GetReady();
					}
				}
				else
				{
					deathTransforms.RemoveAt(index);
				}
			}
			if (deathTimer >= 1f)
			{
				if (!roar.isPlaying)
				{
					Roar(0.75f);
				}
				roar.pitch = 0.75f - (deathTimer - 1f) / 10f;
			}
			if (deathTimer == 5f)
			{
				BloodExplosion();
			}
			return;
		}
		if (trackTarget && (eid.target != null || tempTarget != null))
		{
			Transform transform = (tempTarget ? tempTarget : eid.target.targetTransform);
			Quaternion quaternion = Quaternion.LookRotation(new Vector3(transform.position.x, base.transform.position.y, transform.position.z) - base.transform.position);
			float num = 5f;
			if (difficulty == 1)
			{
				num = 3f;
			}
			if (difficulty == 0)
			{
				num = 1.5f;
			}
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, (45f + Quaternion.Angle(base.transform.rotation, quaternion)) * num * trackSpeed * anim.speed * Time.deltaTime);
		}
		if (mach.gc.onGround && nma.enabled && nma.velocity.magnitude > 2f)
		{
			anim.SetBool("Running", value: true);
			anim.SetFloat("RunningSpeed", nma.velocity.magnitude / 25f);
		}
		else
		{
			anim.SetBool("Running", value: false);
			anim.SetFloat("RunningSpeed", 0f);
		}
		if (cooldown > 0f && !inAction)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		}
		if (ramCooldown > 0f)
		{
			ramCooldown = Mathf.MoveTowards(ramCooldown, 0f, Time.deltaTime);
		}
		if (eid.target != null && eid.target.isPlayer)
		{
			playerAirBias = Mathf.MoveTowards(playerAirBias, (!MonoSingleton<NewMovement>.Instance.gc.onGround) ? 1 : 0, Time.deltaTime / 20f);
		}
	}

	private void FixedUpdate()
	{
		if (dead)
		{
			return;
		}
		rb.isKinematic = !moveForward && mach.gc.onGround;
		if (moveForward)
		{
			rb.velocity = base.transform.forward * 30f * moveSpeed * anim.speed;
			if (!mach.gc.onGround)
			{
				rb.velocity += Vector3.up * rb.velocity.y;
			}
		}
		else if (!mach.gc.onGround)
		{
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
		}
		if (moveBreakSpeed != 0f)
		{
			moveSpeed = Mathf.MoveTowards(moveSpeed, 0f, Time.fixedDeltaTime * moveBreakSpeed);
		}
		if (ramTimer > 0f)
		{
			if (Physics.SphereCast(base.transform.position + base.transform.up * 5f + base.transform.forward * 5f, 4f, base.transform.forward, out var hitInfo, rb.velocity.magnitude * Time.fixedDeltaTime, LayerMaskDefaults.Get(LMD.Environment)))
			{
				if (hitInfo.transform.gameObject.CompareTag("Breakable") && hitInfo.transform.TryGetComponent<Breakable>(out var component) && !component.playerOnly)
				{
					component.Break();
				}
				else
				{
					RamBonk(hitInfo.point);
				}
				return;
			}
			ramTimer = Mathf.MoveTowards(ramTimer, 0f, Time.fixedDeltaTime);
			if (ramTimer == 0f)
			{
				anim.Play("RamSwing");
				Roar(roarShortClip, 1.5f);
				moveBreakSpeed = 5f;
				StopRam();
			}
			else
			{
				anim.SetBool("Ramming", value: true);
			}
		}
		else
		{
			anim.SetBool("Ramming", value: false);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.1f);
		if (!inAction && mach.gc.onGround)
		{
			if (eid.target == null)
			{
				return;
			}
			float num = Vector3.Distance(base.transform.position, eid.target.position);
			RaycastHit hitInfo;
			bool flag = !Physics.Raycast(base.transform.position + Vector3.up, eid.target.position - (base.transform.position + Vector3.up), out hitInfo, Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment));
			if (flag && cooldown <= 0f)
			{
				if (currentAttacks >= 3 || ramCooldown <= 0f)
				{
					Ram();
					ramCooldown = 15f;
					currentAttacks = 0;
					previousAttack = -1;
				}
				else if (num <= 20f)
				{
					int num2 = Random.Range(0, 3);
					if (num2 == previousAttack)
					{
						num2++;
					}
					if (num2 >= 3)
					{
						num2 = 0;
					}
					switch (num2)
					{
					case 0:
						HammerTantrum();
						break;
					case 1:
						if (num < 15f || Vector3.Distance(base.transform.position, eid.target.position + eid.target.rigidbody.velocity.normalized) < num + 0.2f)
						{
							HammerSmash();
						}
						break;
					case 2:
						if (Random.Range(0f, 1f) > playerAirBias)
						{
							playerAirBias = 1f;
							MeatPool();
						}
						else
						{
							playerAirBias = 0f;
							MeatCloud();
						}
						break;
					}
					if (inAction)
					{
						previousAttack = num2;
						currentAttacks++;
					}
				}
				if (inAction)
				{
					return;
				}
			}
			if (!chaseTarget)
			{
				if (num > 20f)
				{
					chaseTarget = true;
				}
				else if (!flag && !hitInfo.transform.gameObject.CompareTag("Breakable"))
				{
					chaseTarget = true;
				}
			}
			if (!chaseTarget)
			{
				return;
			}
			if (flag && num <= 15f)
			{
				chaseTarget = false;
				if ((bool)nma && nma.enabled && nma.isOnNavMesh)
				{
					nma.SetDestination(base.transform.position);
				}
			}
			else if ((bool)nma && nma.enabled && nma.isOnNavMesh)
			{
				nma.SetDestination(eid.target.position);
			}
		}
		else
		{
			chaseTarget = false;
		}
	}

	private void Ram()
	{
		anim.Play("RamWindup", -1, 0f);
		inAction = true;
		trackTarget = true;
		Roar(exhaleClip);
		nma.enabled = false;
	}

	private void RamStart()
	{
		anim.Play("RamRun", -1, 0f);
		anim.SetBool("Ramming", value: true);
		moveSpeed = 2f;
		moveForward = true;
		trackSpeed = 0.25f;
		ramTimer = 3f;
		ramStuff.SetActive(value: true);
		GameObject obj = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, ramStuff.transform.position + ramStuff.transform.forward * 1.5f, base.transform.rotation);
		obj.transform.localScale *= 15f;
		obj.transform.SetParent(ramStuff.transform, worldPositionStays: true);
		mach.ParryableCheck();
		Roar(0.75f);
	}

	private void RamBonk(Vector3 point)
	{
		if (point != Vector3.zero)
		{
			Object.Instantiate(hammerImpact, point, Quaternion.identity);
			base.transform.LookAt(new Vector3(point.x, base.transform.position.y, point.z));
		}
		anim.Play("RamBonk", -1, 0f);
		anim.SetBool("Ramming", value: false);
		moveForward = false;
		ramTimer = 0f;
		trackTarget = false;
		ramStuff.SetActive(value: false);
		mach.parryable = false;
		eid.hitter = "enemy";
		mach.GetHurt(GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, Vector3.zero, 6f, 0f);
		MonoSingleton<CameraController>.Instance.CameraShake(2f);
		Roar(longGruntClip, 2f);
	}

	private void StopRam()
	{
		anim.SetBool("Ramming", value: false);
		ramStuff.SetActive(value: false);
		mach.parryable = false;
		ramTimer = 0f;
	}

	private void MeatCloud()
	{
		nma.enabled = false;
		anim.Play("MeatHigh", -1, 0f);
		inAction = true;
		trackTarget = true;
		Roar(longGruntClip);
	}

	private void MeatPool()
	{
		nma.enabled = false;
		anim.Play("MeatLow", -1, 0f);
		inAction = true;
		trackTarget = true;
		Roar(longGruntClip);
	}

	private void HandBlood()
	{
		Object.Instantiate(handBlood, meatInHand.transform.position, Quaternion.identity);
	}

	private void MeatSpawn()
	{
		meatInHand.SetActive(value: true);
		HandBlood();
	}

	private void MeatExplode()
	{
		meatInHand.SetActive(value: false);
		HandBlood();
		GameObject gameObject = Object.Instantiate((difficulty >= 4) ? toxicCloudLong : toxicCloud, meatInHand.transform.position, Quaternion.identity);
		gameObject.transform.SetParent(gz.transform, worldPositionStays: true);
		if (difficulty == 1)
		{
			gameObject.transform.localScale *= 0.85f;
		}
		else if (difficulty == 0)
		{
			gameObject.transform.localScale *= 0.75f;
		}
	}

	private void MeatSplash()
	{
		meatInHand.SetActive(value: false);
		HandBlood();
		GameObject gameObject = Object.Instantiate((difficulty >= 4) ? goopLong : goop, new Vector3(meatInHand.transform.position.x, base.transform.position.y, meatInHand.transform.position.z), Quaternion.identity);
		gameObject.transform.SetParent(gz.transform, worldPositionStays: true);
		if (difficulty == 1)
		{
			gameObject.transform.localScale *= 0.85f;
		}
		else if (difficulty == 0)
		{
			gameObject.transform.localScale *= 0.75f;
		}
	}

	private void MeatThrowThrow()
	{
		meatInHand.SetActive(value: false);
	}

	private void HammerSmash()
	{
		if (!dead)
		{
			nma.enabled = false;
			anim.Play("HammerSmash", -1, 0f);
			inAction = true;
			trackTarget = true;
			Roar(squealClip, 0.75f);
		}
	}

	private void HammerTantrum()
	{
		if (!dead)
		{
			nma.enabled = false;
			anim.Play("HammerTantrum", -1, 0f);
			inAction = true;
			trackTarget = true;
			Roar(1.25f);
		}
	}

	public void QuickTantrum()
	{
		if (!dead)
		{
			nma.enabled = false;
			anim.Play("HammerTantrum", -1, 0.275f);
			inAction = true;
		}
	}

	private void HammerSwingStart()
	{
		if (!dead)
		{
			nma.enabled = false;
			SwingCheck2[] array = hammerSwingChecks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DamageStart();
			}
			hammerTrail.emitting = true;
			moveForward = true;
			trackTarget = false;
		}
	}

	private void HammerImpact()
	{
		Object.Instantiate(hammerImpact, new Vector3(hammerPoint.position.x, base.transform.position.y + 0.25f, hammerPoint.position.z), Quaternion.identity);
		MonoSingleton<CameraController>.Instance.CameraShake(0.25f);
	}

	private void HammerExplosion(int size = 0)
	{
		Explosion[] componentsInChildren = Object.Instantiate((size == 0) ? hammerExplosion : hammerBigExplosion, new Vector3(hammerPoint.position.x, base.transform.position.y + 0.25f, hammerPoint.position.z), Quaternion.identity).GetComponentsInChildren<Explosion>();
		foreach (Explosion obj in componentsInChildren)
		{
			obj.toIgnore.Add(EnemyType.Minotaur);
			obj.maxSize *= ((size == 0) ? 2f : 1.75f);
			obj.speed *= ((size == 0) ? 2f : 1.75f);
		}
		MonoSingleton<CameraController>.Instance.CameraShake(1.5f);
	}

	private void HammerSwingStop(int startTrackingTarget = 0)
	{
		SwingCheck2[] array = hammerSwingChecks;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStop();
		}
		hammerTrail.emitting = false;
		moveForward = false;
		trackTarget = startTrackingTarget >= 1;
	}

	private void HammerSwingStopImpact(int startTrackingTarget = 0)
	{
		HammerImpact();
		HammerSwingStop(startTrackingTarget);
	}

	private void StartTracking()
	{
		trackTarget = true;
	}

	private void StopMoving()
	{
		moveForward = false;
		moveSpeed = 1f;
		moveBreakSpeed = 0f;
	}

	private void GotParried()
	{
		if (ramTimer > 0f)
		{
			RamBonk(MonoSingleton<NewMovement>.Instance.transform.position);
		}
		anim.Play("RamParried");
		nma.enabled = false;
		moveForward = true;
		moveSpeed = -2.5f;
		moveBreakSpeed = 5f;
		MonoSingleton<CameraController>.Instance.CameraShake(3f);
		eid.hitter = "";
		mach.GetHurt(GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, Vector3.zero, 20f, 0f);
		ramCooldown = 30f;
		Roar(2.5f);
	}

	public void GotSlammed()
	{
		if (ramTimer > 0f)
		{
			RamBonk(base.transform.position + base.transform.forward);
		}
		anim.Play("RamParried");
		nma.enabled = false;
		moveForward = true;
		moveSpeed = 2.5f;
		moveBreakSpeed = 1.5f;
		MonoSingleton<CameraController>.Instance.CameraShake(3f);
		eid.hitter = "";
		mach.GetHurt(GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, Vector3.zero, 20f, 0f);
		MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: false, eid);
		mach.parryable = false;
		ramCooldown = 30f;
		Roar(2.5f);
	}

	private void StopAction()
	{
		if ((bool)mach.gc && mach.gc.onGround)
		{
			nma.enabled = true;
		}
		inAction = false;
		moveForward = false;
		mach.parryable = false;
		trackTarget = true;
		moveSpeed = 1f;
		moveBreakSpeed = 0f;
		trackSpeed = 1f;
	}

	public void TargetBeenHit()
	{
		if (ramTimer > 0f)
		{
			anim.Play("RamSwing");
			moveBreakSpeed = 5f;
			StopRam();
			Roar(roarShortClip, 1.5f);
		}
		SwingCheck2[] array = hammerSwingChecks;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStop();
		}
	}

	public void Death()
	{
		if (!dead)
		{
			nma.enabled = false;
			dead = true;
			deathPosition = base.transform.position;
			deathTransforms.AddRange(GetComponentsInChildren<Transform>());
			HammerSwingStop();
			StopAction();
			meatInHand.SetActive(value: false);
			anim.Play("Death", -1, 0f);
			anim.SetBool("Dead", value: true);
			anim.speed = 1f;
			inAction = true;
			trackTarget = false;
			roar.Stop();
			Invoke("Roar", 0.9f);
			MonoSingleton<TimeController>.Instance.SlowDown(0.001f);
		}
	}

	private void BloodExplosion()
	{
		List<Transform> list = new List<Transform>();
		BloodsplatterManager instance = MonoSingleton<BloodsplatterManager>.Instance;
		foreach (Transform deathTransform in deathTransforms)
		{
			if (deathTransform != null && Random.Range(0f, 1f) < 0.33f)
			{
				GameObject gore = instance.GetGore(GoreType.Head, eid);
				if ((bool)gore)
				{
					gore.transform.position = deathTransform.position;
					if (gz != null && gz.goreZone != null)
					{
						gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
					}
					gore.GetComponent<Bloodsplatter>()?.GetReady();
				}
			}
			else if (deathTransform == null)
			{
				list.Add(deathTransform);
			}
		}
		if (list.Count > 0)
		{
			foreach (Transform item in list)
			{
				deathTransforms.Remove(item);
			}
			list.Clear();
		}
		if (OptionsMenuToManager.bloodEnabled && base.gameObject.activeInHierarchy)
		{
			for (int i = 0; i < 40; i++)
			{
				GameObject gib;
				if (i < 30)
				{
					gib = instance.GetGib(BSType.gib);
					if ((bool)gib && (bool)gz && (bool)gz.gibZone)
					{
						if ((bool)gz && (bool)gz.gibZone)
						{
							mach.ReadyGib(gib, deathTransforms[Random.Range(0, deathTransforms.Count)].gameObject);
						}
						gib.transform.localScale *= Random.Range(4f, 7f);
					}
					else
					{
						i = 30;
					}
					continue;
				}
				if (i < 35)
				{
					gib = instance.GetGib(BSType.eyeball);
					if ((bool)gib && (bool)gz && (bool)gz.gibZone)
					{
						if ((bool)gz && (bool)gz.gibZone)
						{
							mach.ReadyGib(gib, deathTransforms[Random.Range(0, deathTransforms.Count)].gameObject);
						}
						gib.transform.localScale *= Random.Range(3f, 6f);
					}
					else
					{
						i = 35;
					}
					continue;
				}
				gib = instance.GetGib(BSType.brainChunk);
				if (!gib || !gz || !gz.gibZone)
				{
					break;
				}
				if ((bool)gz && (bool)gz.gibZone)
				{
					mach.ReadyGib(gib, deathTransforms[Random.Range(0, deathTransforms.Count)].gameObject);
				}
				gib.transform.localScale *= Random.Range(3f, 4f);
			}
		}
		if (gz != null && gz.checkpoint != null)
		{
			gz.AddDeath();
			gz.checkpoint.sm.kills++;
		}
		else
		{
			MonoSingleton<StatsManager>.Instance.kills++;
		}
		ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
		if (componentInParent != null)
		{
			componentInParent.AddDeadEnemy();
		}
		onDeath?.Invoke();
		MonoSingleton<TimeController>.Instance.SlowDown(0.0001f);
		Object.Destroy(base.gameObject);
	}

	private void Roar()
	{
		Roar(roarClip);
	}

	private void Roar(float pitch = 1f)
	{
		Roar(roarClip, pitch);
	}

	private void Roar(AudioClip clip, float pitch = 1f)
	{
		roar.clip = clip;
		roar.pitch = Random.Range(pitch - 0.1f, pitch + 0.1f);
		roar.Play();
	}

	private void BodyImpact()
	{
		Object.Instantiate(fallEffect, base.transform.position, Quaternion.identity);
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
	}
}



public class MinotaurChase : MonoBehaviour
{
	private Rigidbody rb;

	private EnemyIdentifier eid;

	private Animator anim;

	private bool gotValues;

	private bool trackTarget;

	public float movementRange;

	public Vector3 leashPosition;

	private float leashRandomizer = 0.1f;

	private float movementSpeed;

	private float currentAnimatorWeight;

	private float cooldown = 1f;

	private int previousAttack = -1;

	private int currentAttacks;

	[SerializeField]
	private GameObject[] trams;

	private bool attacking;

	private bool backAttacking;

	[SerializeField]
	private SwingCheck2 hammerSwingCheck;

	[SerializeField]
	private TrailRenderer hammerTrail;

	[SerializeField]
	private Transform hammerPoint;

	[SerializeField]
	private GameObject hammerExplosion;

	[SerializeField]
	private GameObject meatInHand;

	[SerializeField]
	private GameObject handBlood;

	[SerializeField]
	private GameObject handSwingStuff;

	[SerializeField]
	private SwingCheck2 handSwingCheck;

	[SerializeField]
	private GameObject fallEffect;

	[SerializeField]
	private AudioSource roar;

	[SerializeField]
	private AudioClip roarClip;

	[SerializeField]
	private AudioClip longGruntClip;

	[SerializeField]
	private AudioClip shortRoarClip;

	[SerializeField]
	private AudioClip squealClip;

	[Header("Intro")]
	public bool intro;

	public UltrakillEvent onIntroEnd;

	private Transform tempTarget;

	private int difficulty;

	private bool dead;

	private bool dragging;

	public Material hurtMaterial;

	public Mesh hurtMesh;

	private void Start()
	{
		GetValues();
		trackTarget = !intro;
		if (intro)
		{
			eid.totalDamageTakenMultiplier = 0f;
			QuickHammer();
		}
		else
		{
			IntroEnd();
		}
	}

	private void GetValues()
	{
		if (!gotValues)
		{
			gotValues = true;
			rb = GetComponent<Rigidbody>();
			eid = GetComponent<EnemyIdentifier>();
			anim = GetComponent<Animator>();
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			SetSpeed();
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		GetValues();
		if (difficulty >= 4)
		{
			movementSpeed = 35f;
			anim.speed = 1.2f;
		}
		else if (difficulty == 3)
		{
			movementSpeed = 30f;
			anim.speed = 1f;
		}
		else if (difficulty == 2)
		{
			movementSpeed = 25f;
			anim.speed = 1f;
		}
		else if (difficulty == 1)
		{
			movementSpeed = 20f;
			anim.speed = 0.9f;
		}
		else
		{
			movementSpeed = 10f;
			anim.speed = 0.8f;
		}
		movementSpeed *= eid.totalSpeedModifier;
		anim.speed *= eid.totalSpeedModifier;
	}

	private void Update()
	{
		if (trackTarget && (eid.target != null || tempTarget != null))
		{
			Transform transform = (tempTarget ? tempTarget : eid.target.targetTransform);
			Quaternion quaternion = Quaternion.LookRotation(new Vector3(transform.position.x, base.transform.position.y, transform.position.z) - base.transform.position);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, (20f + Quaternion.Angle(base.transform.rotation, quaternion)) * ((attacking && difficulty <= 2) ? 0.5f : 1f) * Time.deltaTime);
			float num = ((base.transform.localRotation.eulerAngles.y > 180f) ? (base.transform.localRotation.eulerAngles.y - 360f) : base.transform.localRotation.eulerAngles.y);
			if (Mathf.Abs(num) > 66f)
			{
				base.transform.localRotation = Quaternion.Euler(0f, Mathf.Clamp(num, -66f, 66f), 0f);
			}
		}
		if (!attacking && Mathf.Abs(base.transform.position.z - leashPosition.z) < 10f)
		{
			if (eid.target != null && ((eid.target.position.y > base.transform.position.y + 3f && Vector3.Distance(base.transform.position, new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z)) < 8f) || eid.target.position.z > base.transform.position.z))
			{
				if (!backAttacking)
				{
					backAttacking = true;
					HandSwingStart();
					Invoke("HandSwinging", 0.5f);
					handSwingCheck.CanHitPlayerMultipleTimes(yes: true);
					anim.SetBool("BackAttack", value: true);
				}
			}
			else if (backAttacking)
			{
				backAttacking = false;
				HandSwingStop();
				handSwingCheck.CanHitPlayerMultipleTimes(yes: false);
				anim.SetBool("BackAttack", value: false);
			}
			if (cooldown <= 0f && !backAttacking)
			{
				if (currentAttacks >= 2)
				{
					HammerSwing();
					currentAttacks = 0;
					previousAttack = -1;
					cooldown = ((difficulty > 2) ? 1 : 2);
				}
				else
				{
					int num2 = Random.Range(0, 2);
					if (num2 == previousAttack)
					{
						num2++;
					}
					if (num2 >= 2)
					{
						num2 = 0;
					}
					switch (num2)
					{
					case 0:
						MeatThrow();
						break;
					case 1:
						HandSwing();
						break;
					}
					cooldown = ((difficulty > 2) ? 1 : 2);
					previousAttack = num2;
					currentAttacks++;
				}
			}
		}
		if (!attacking && cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		}
		if (!dead)
		{
			currentAnimatorWeight = Mathf.MoveTowards(currentAnimatorWeight, (attacking || backAttacking) ? 1 : 0, Time.deltaTime * 3f);
			anim.SetLayerWeight(1, currentAnimatorWeight);
		}
	}

	private void FixedUpdate()
	{
		if (trackTarget && eid.target != null)
		{
			float num = Mathf.MoveTowards(base.transform.position.z, leashPosition.z + leashRandomizer, Mathf.Min(Mathf.Abs(base.transform.position.z - (leashPosition.z + leashRandomizer)) * 2f + 0.5f, movementSpeed) * 1.5f * Time.fixedDeltaTime);
			Vector3 target = new Vector3(Mathf.Clamp((base.transform.position + base.transform.forward * movementSpeed * Time.fixedDeltaTime).x, leashPosition.x - movementRange, leashPosition.x + movementRange), base.transform.position.y, num);
			rb.MovePosition(Vector3.MoveTowards(base.transform.position, target, movementSpeed * Time.fixedDeltaTime));
			anim.SetFloat("RunSpeed", 1f + Mathf.Min(Mathf.Abs(num - leashPosition.z) * 2f, movementSpeed) / movementSpeed / 3f);
			if (Mathf.Abs(base.transform.position.z - (leashPosition.z + leashRandomizer)) < 0.01f)
			{
				leashRandomizer *= -1f;
			}
		}
		if (dragging)
		{
			rb.MovePosition(Vector3.MoveTowards(base.transform.position, base.transform.position + Vector3.forward * 100f, movementSpeed * 1.5f * Time.fixedDeltaTime));
		}
	}

	private void MeatThrow()
	{
		anim.Play("MeatThrow", 1, 0f);
		Roar(longGruntClip);
		attacking = true;
	}

	private void HandBlood()
	{
		Object.Instantiate(handBlood, meatInHand.transform.position, Quaternion.identity);
	}

	private void MeatSpawn()
	{
		meatInHand.SetActive(value: true);
		HandBlood();
	}

	private void MeatThrowPickTarget()
	{
		tempTarget = GetClosestTram(eid.target.position).transform;
	}

	private void MeatThrowThrow()
	{
		meatInHand.SetActive(value: false);
		GameObject closestTram = GetClosestTram(base.transform.position);
		if (closestTram != null)
		{
			ObjectSpawner componentInChildren = closestTram.GetComponentInChildren<ObjectSpawner>(includeInactive: true);
			if ((bool)componentInChildren)
			{
				componentInChildren.SpawnObject(1);
			}
		}
	}

	private void HandSwing()
	{
		anim.Play("HandSwing", 1, 0f);
		attacking = true;
		Roar(shortRoarClip, 0.75f);
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, meatInHand.transform.position, Quaternion.identity).transform.localScale *= 25f;
	}

	private void HandSwingStart()
	{
		handSwingStuff.SetActive(value: true);
		if (difficulty == 0)
		{
			trackTarget = false;
		}
		HandBlood();
	}

	private void HandSwinging()
	{
		handSwingCheck.DamageStart();
	}

	private void HandSwingStop()
	{
		handSwingStuff.SetActive(value: false);
		handSwingCheck.DamageStop();
		trackTarget = true;
		HandBlood();
	}

	private void HammerSwing()
	{
		anim.Play("HammerSwing", 1, 0f);
		attacking = true;
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, hammerTrail.transform.position, Quaternion.identity).transform.localScale *= 25f;
		Roar();
	}

	private void QuickHammer()
	{
		anim.Play("HammerSwing", 1, 0.4f);
		attacking = true;
	}

	private void HammerSwingStart()
	{
		hammerSwingCheck.DamageStart();
		hammerTrail.emitting = true;
	}

	private void HammerImpact()
	{
		trackTarget = false;
		Explosion[] componentsInChildren = Object.Instantiate(hammerExplosion, new Vector3(hammerPoint.position.x, base.transform.position.y, hammerPoint.position.z), Quaternion.identity).GetComponentsInChildren<Explosion>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].toIgnore.Add(EnemyType.Minotaur);
		}
		MonoSingleton<CameraController>.Instance.CameraShake(1.5f);
		if (intro)
		{
			IntroEnd();
			return;
		}
		GameObject closestTram = GetClosestTram(hammerPoint.position, 10f);
		if (!(closestTram != null))
		{
			return;
		}
		Harpoon[] componentsInChildren2 = closestTram.GetComponentsInChildren<Harpoon>();
		if (componentsInChildren2 != null && componentsInChildren2.Length != 0)
		{
			Harpoon[] array = componentsInChildren2;
			foreach (Harpoon harpoon in array)
			{
				if (harpoon.gameObject.activeInHierarchy)
				{
					TimeBomb componentInChildren = harpoon.GetComponentInChildren<TimeBomb>();
					if ((bool)componentInChildren)
					{
						componentInChildren.dontExplode = true;
					}
					Object.Destroy(harpoon.gameObject);
				}
			}
		}
		closestTram.SetActive(value: false);
		closestTram.transform.position += closestTram.transform.forward * 200f;
		if (difficulty >= 4)
		{
			MonoSingleton<DelayedActivationManager>.Instance.Add(closestTram, 7f);
		}
		else if (difficulty >= 2)
		{
			MonoSingleton<DelayedActivationManager>.Instance.Add(closestTram, 5f);
		}
		else if (difficulty == 1)
		{
			MonoSingleton<DelayedActivationManager>.Instance.Add(closestTram, 3f);
		}
		else
		{
			MonoSingleton<DelayedActivationManager>.Instance.Add(closestTram, 1f);
		}
		ObjectSpawner componentInChildren2 = closestTram.GetComponentInChildren<ObjectSpawner>(includeInactive: true);
		if ((bool)componentInChildren2)
		{
			componentInChildren2.SpawnObject(0);
		}
	}

	private void HammerSwingStop()
	{
		hammerSwingCheck.DamageStop();
		hammerTrail.emitting = false;
		if (difficulty <= 1)
		{
			trackTarget = false;
		}
	}

	public void Death()
	{
		dead = true;
		HammerSwingStop();
		handSwingStuff.SetActive(value: false);
		handSwingCheck.DamageStop();
		meatInHand.SetActive(value: false);
		anim.SetBool("BackAttack", value: false);
		anim.SetFloat("RunSpeed", 2.5f);
		anim.SetLayerWeight(1, 1f);
		anim.Play("Death", 1, 0f);
		attacking = true;
		trackTarget = false;
		Roar(squealClip);
		MonoSingleton<TimeController>.Instance.SlowDown(0.001f);
	}

	private void GetDragged()
	{
		if (dragging)
		{
			return;
		}
		dragging = true;
		anim.Play("Death", 0, anim.GetCurrentAnimatorStateInfo(1).normalizedTime);
		anim.SetLayerWeight(1, 0f);
		Object.Instantiate(fallEffect, base.transform.position, Quaternion.identity);
		MonoSingleton<CameraController>.Instance.CameraShake(3f);
		EnemySimplifier componentInChildren = GetComponentInChildren<EnemySimplifier>();
		if ((bool)componentInChildren)
		{
			componentInChildren.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, hurtMaterial);
		}
		else
		{
			ChangeMaterials componentInChildren2 = GetComponentInChildren<ChangeMaterials>();
			if ((bool)componentInChildren2)
			{
				componentInChildren2.Activate();
			}
		}
		GetComponentInChildren<SkinnedMeshRenderer>().sharedMesh = hurtMesh;
	}

	public void StopDragging()
	{
		dragging = false;
	}

	private void StartTracking()
	{
		trackTarget = true;
	}

	private void ResetTarget()
	{
		tempTarget = null;
	}

	private void StopAction()
	{
		attacking = false;
		trackTarget = true;
	}

	private void IntroEnd()
	{
		onIntroEnd?.Invoke();
		eid.totalDamageTakenMultiplier = 1f;
		intro = false;
	}

	public void DisableIntro()
	{
		intro = false;
	}

	private GameObject GetClosestTram(Vector3 position, float shortestDistance = float.PositiveInfinity)
	{
		GameObject result = null;
		for (int i = 0; i < trams.Length; i++)
		{
			float num = Vector3.Distance(trams[i].transform.position, position);
			if (num < shortestDistance)
			{
				shortestDistance = num;
				result = trams[i];
			}
		}
		return result;
	}

	private void Roar()
	{
		Roar(roarClip);
	}

	private void Roar(float pitch = 1f)
	{
		Roar(roarClip, pitch);
	}

	private void Roar(AudioClip clip, float pitch = 1f)
	{
		roar.clip = clip;
		roar.pitch = Random.Range(pitch - 0.1f, pitch + 0.1f);
		roar.Play();
	}
}



public class MixerVolumeDip : MonoBehaviour
{
	private bool dipped;

	public float targetAmount = -5f;

	private void OnEnable()
	{
		if (!dipped)
		{
			dipped = true;
			if ((bool)MonoSingleton<AudioMixerController>.Instance)
			{
				MonoSingleton<AudioMixerController>.Instance.TemporaryDip(targetAmount);
			}
		}
	}

	private void OnDisable()
	{
		if (dipped)
		{
			dipped = false;
			if ((bool)MonoSingleton<AudioMixerController>.Instance)
			{
				MonoSingleton<AudioMixerController>.Instance.TemporaryDip(0f);
			}
		}
	}
}



public class MixingTransformTest : MonoBehaviour
{
	private Animator anim;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F10))
		{
			anim.SetLayerWeight(1, 1f);
			anim.SetTrigger("Shoot");
		}
	}
}



public class ModifyMaterial : MonoBehaviour
{
	private Renderer rend;

	private MaterialPropertyBlock block;

	private bool valuesSet;

	public void ChangeEmissionIntensity(float value)
	{
		SetValues();
		for (int i = 0; i < rend.materials.Length; i++)
		{
			rend.GetPropertyBlock(block, i);
			block.SetFloat(UKShaderProperties.EmissiveIntensity, value);
			rend.SetPropertyBlock(block, i);
		}
	}

	public void ChangeEmissionColor(string hex)
	{
		if (ColorUtility.TryParseHtmlString(hex, out var color))
		{
			ChangeEmissionColor(color);
		}
		else
		{
			Debug.LogError("Failed to Change Emission Color: " + hex);
		}
	}

	public void ChangeEmissionColor(Color clr)
	{
		SetValues();
		for (int i = 0; i < rend.materials.Length; i++)
		{
			rend.GetPropertyBlock(block, i);
			block.SetColor(UKShaderProperties.EmissiveColor, clr);
			rend.SetPropertyBlock(block, i);
		}
	}

	public void ChangeColor(string hex)
	{
		if (ColorUtility.TryParseHtmlString(hex, out var color))
		{
			ChangeColor(color);
		}
		else
		{
			Debug.LogError("Failed to Change Color: " + hex);
		}
	}

	public void ChangeColor(Color clr)
	{
		SetValues();
		for (int i = 0; i < rend.materials.Length; i++)
		{
			rend.GetPropertyBlock(block, i);
			block.SetColor("Color", clr);
			rend.SetPropertyBlock(block, i);
		}
	}

	public void ChangeColorToWhite()
	{
		ChangeColor(Color.white);
	}

	public void ChangeColorToBlack()
	{
		ChangeColor(Color.black);
	}

	public void ChangeAlpha(float value)
	{
		SetValues();
		for (int i = 0; i < rend.materials.Length; i++)
		{
			rend.GetPropertyBlock(block, i);
			Color color = block.GetColor("Color");
			color.a = value;
			block.SetColor("Color", color);
			rend.SetPropertyBlock(block, i);
		}
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			block = new MaterialPropertyBlock();
			rend = GetComponent<Renderer>();
		}
	}
}



public class MoneyText : MonoBehaviour
{
	private TMP_Text text;

	private void OnEnable()
	{
		UpdateMoney();
	}

	public void UpdateMoney()
	{
		if (text == null)
		{
			text = GetComponent<TMP_Text>();
		}
		text.text = DivideMoney(GameProgressSaver.GetMoney()) + "<color=orange>P</color>";
	}

	public static string DivideMoney(int dosh)
	{
		int num = dosh;
		int num2 = 0;
		int num3 = 0;
		if (dosh > 1000000000)
		{
			return "LIKE, A LOT OF ";
		}
		while (num >= 1000)
		{
			num2++;
			num -= 1000;
		}
		while (num2 >= 1000)
		{
			num3++;
			num2 -= 1000;
		}
		if (num3 > 0)
		{
			string text = num3 + ",";
			text = ((num2 < 10) ? (text + "00" + num2 + ",") : ((num2 >= 100) ? (text + num2 + ",") : (text + "0" + num2 + ",")));
			if (num < 10)
			{
				return text + "00" + num;
			}
			if (num < 100)
			{
				return text + "0" + num;
			}
			return text + num;
		}
		if (num2 > 0)
		{
			string text = num2 + ",";
			if (num < 10)
			{
				return text + "00" + num;
			}
			if (num < 100)
			{
				return text + "0" + num;
			}
			return text + num;
		}
		return string.Concat(num);
	}
}



[DefaultExecutionOrder(-200)]
public abstract class MonoSingleton : MonoBehaviour
{
}

public abstract class MonoSingleton<T> : MonoSingleton where T : MonoSingleton<T>
{
	private static T instance;

	private static readonly SingletonFlags flags;

	public static T Instance
	{
		get
		{
			if (!instance)
			{
				return instance = Initialize();
			}
			return instance;
		}
		protected set
		{
			instance = value;
		}
	}

	static MonoSingleton()
	{
		flags = typeof(T).GetCustomAttribute<ConfigureSingletonAttribute>()?.Flags ?? SingletonFlags.None;
	}

	private static T Initialize()
	{
		if (flags.HasFlag(SingletonFlags.NoAutoInstance))
		{
			if (!SceneManager.GetActiveScene().isLoaded)
			{
				return Object.FindObjectOfType<T>();
			}
			return null;
		}
		GameObject gameObject = new GameObject(typeof(T).FullName);
		T result = gameObject.AddComponent<T>();
		if (flags.HasFlag(SingletonFlags.HideAutoInstance))
		{
			gameObject.hideFlags = HideFlags.HideAndDontSave;
		}
		if (flags.HasFlag(SingletonFlags.PersistAutoInstance))
		{
			Object.DontDestroyOnLoad(gameObject);
		}
		return result;
	}

	protected virtual void Awake()
	{
		if ((bool)instance && flags.HasFlag(SingletonFlags.DestroyDuplicates) && instance != this)
		{
			Object.Destroy(this);
		}
		else if (!flags.HasFlag(SingletonFlags.NoAwakeInstance) && (!instance || !instance.isActiveAndEnabled || base.isActiveAndEnabled))
		{
			Instance = (T)this;
		}
	}

	protected virtual void OnEnable()
	{
		Instance = (T)this;
	}

	protected virtual void OnDestroy()
	{
	}
}



public class MorphTarget : MonoBehaviour
{
	public float speed = 1f;

	private SkinnedMeshRenderer rend;

	private Mesh skinmesh;

	private float blend;

	private int blendshapecount;

	private void Awake()
	{
		rend = GetComponent<SkinnedMeshRenderer>();
		skinmesh = rend.sharedMesh;
	}

	private void Update()
	{
		rend.SetBlendShapeWeight(0, blend);
		blend = (blend + Time.deltaTime * speed * 60f) % 100f;
	}
}



public class MortarLauncher : MonoBehaviour
{
	private EnemyIdentifier eid;

	public Transform shootPoint;

	public Projectile mortar;

	private float cooldown = 1f;

	public float firingDelay;

	public float firstFireDelay = 1f;

	public float projectileForce;

	public UltrakillEvent onFire;

	private Animator anim;

	private int difficulty;

	private float difficultySpeedModifier = 1f;

	private void Start()
	{
		eid = GetComponentInParent<EnemyIdentifier>();
		anim = GetComponent<Animator>();
		cooldown = firstFireDelay;
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (difficulty == 1)
		{
			difficultySpeedModifier = 0.8f;
		}
		else if (difficulty == 0)
		{
			difficultySpeedModifier = 0.6f;
		}
	}

	private void Update()
	{
		cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier * difficultySpeedModifier);
		if (cooldown == 0f && eid.target != null)
		{
			cooldown = firingDelay;
			ShootHoming();
			onFire?.Invoke();
		}
	}

	public void ShootHoming()
	{
		if (eid.target != null)
		{
			Projectile projectile = Object.Instantiate(mortar, shootPoint.position, shootPoint.rotation);
			projectile.target = eid.target;
			projectile.GetComponent<Rigidbody>().velocity = shootPoint.forward * projectileForce;
			projectile.damage *= eid.totalDamageModifier;
			projectile.safeEnemyType = eid.enemyType;
			projectile.turningSpeedMultiplier *= difficultySpeedModifier;
			projectile.gameObject.SetActive(value: true);
			if ((bool)anim)
			{
				anim.Play("Shoot", 0, 0f);
			}
		}
	}

	public void ChangeFiringDelay(float target)
	{
		firingDelay = target;
		if (cooldown > firingDelay)
		{
			cooldown = firingDelay;
		}
	}
}



public class Movement : MonoBehaviour
{
	public float walkSpeed;

	public float jumpPower;

	private bool jumpCooldown;

	private bool falling;

	private Rigidbody rb;

	private Vector3 movementDirection;

	private Vector3 airDirection;

	public float timeBetweenSteps;

	private float stepTime;

	private int currentStep;

	public Animator anim;

	private GameObject body;

	private Quaternion tempRotation;

	private GameObject forwardPoint;

	private GroundCheck gc;

	private WallCheck wc;

	private PlayerAnimations pa;

	private Vector3 wallJumpPos;

	private int currentWallJumps;

	private AudioSource aud;

	private AudioSource aud2;

	private AudioSource aud3;

	private int currentSound;

	public AudioClip[] jumpSounds;

	public AudioClip landingSound;

	public AudioClip finalWallJump;

	private void Awake()
	{
		QualitySettings.vSyncCount = 0;
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
		body = GameObject.FindWithTag("Body");
		gc = GetComponentInChildren<GroundCheck>();
		wc = GetComponentInChildren<WallCheck>();
		aud2 = gc.GetComponent<AudioSource>();
		pa = GetComponentInChildren<PlayerAnimations>();
		aud3 = wc.GetComponent<AudioSource>();
		forwardPoint = GameObject.FindWithTag("Forward");
	}

	private void Update()
	{
		float axisRaw = Input.GetAxisRaw("Horizontal");
		float axisRaw2 = Input.GetAxisRaw("Vertical");
		if (gc.onGround != pa.onGround)
		{
			pa.onGround = gc.onGround;
		}
		if (!gc.onGround && rb.velocity.y < -10f)
		{
			falling = true;
		}
		if (!gc.onGround && rb.velocity.y < -20f)
		{
			if (rb.velocity.y > -120f)
			{
				aud3.pitch = rb.velocity.y * -1f / 80f;
			}
			else
			{
				aud3.pitch = 1.5f;
			}
			aud3.volume = rb.velocity.y * -1f / 80f;
		}
		else if (rb.velocity.y > -20f)
		{
			aud3.pitch = 0f;
			aud3.volume = 0f;
		}
		if (gc.onGround && falling)
		{
			falling = false;
			aud2.clip = landingSound;
			aud2.volume = 0.5f;
			aud2.Play();
		}
		movementDirection = (axisRaw * base.transform.right + axisRaw2 * base.transform.forward).normalized;
		if (gc.onGround)
		{
			aud.pitch = 1f;
			currentWallJumps = 0;
			movementDirection = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime, 0f, movementDirection.z * walkSpeed * Time.deltaTime);
			rb.velocity = movementDirection;
			anim.SetBool("Run", value: false);
		}
		else
		{
			movementDirection = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime, rb.velocity.y, movementDirection.z * walkSpeed * Time.deltaTime);
			airDirection.y = 0f;
			if ((movementDirection.x > 0f && rb.velocity.x < movementDirection.x) || (movementDirection.x < 0f && rb.velocity.x > movementDirection.x))
			{
				airDirection.x = movementDirection.x;
			}
			else
			{
				airDirection.x = 0f;
			}
			if ((movementDirection.z > 0f && rb.velocity.z < movementDirection.z) || (movementDirection.z < 0f && rb.velocity.z > movementDirection.z))
			{
				airDirection.z = movementDirection.z;
			}
			else
			{
				airDirection.z = 0f;
			}
			rb.AddForce(airDirection.normalized * 15000f * Time.deltaTime);
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame && gc.onGround && !jumpCooldown)
		{
			currentSound = Random.Range(0, jumpSounds.Length);
			aud.clip = jumpSounds[currentSound];
			aud.volume = 0.75f;
			aud.pitch = 1f;
			aud.Play();
			rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			rb.AddForce(Vector3.up * jumpPower * 1000f);
			jumpCooldown = true;
			Invoke("JumpReady", 0.1f);
		}
		else if (MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame && !gc.onGround && wc.onWall && !jumpCooldown && currentWallJumps < 3)
		{
			currentWallJumps++;
			currentSound = Random.Range(0, jumpSounds.Length);
			aud.clip = jumpSounds[currentSound];
			aud.pitch += 0.25f;
			aud.volume = 0.75f;
			aud.Play();
			if (currentWallJumps == 3)
			{
				aud2.clip = finalWallJump;
				aud2.volume = 0.75f;
				aud2.Play();
			}
			wallJumpPos = base.transform.position - wc.poc;
			rb.velocity = new Vector3(0f, 0f, 0f);
			rb.AddForceAtPosition(wallJumpPos.normalized * 10000f, base.transform.position);
			rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			jumpCooldown = true;
			Invoke("JumpReady", 0.1f);
		}
		if (axisRaw2 < 0f)
		{
			forwardPoint.transform.localPosition = new Vector3(axisRaw * -1f, body.transform.localPosition.y, axisRaw2 * -1f);
		}
		else if (axisRaw2 == 0f && axisRaw == 0f)
		{
			forwardPoint.transform.localPosition = new Vector3(0f, body.transform.localPosition.y, 1f);
		}
		else
		{
			forwardPoint.transform.localPosition = new Vector3(axisRaw, body.transform.localPosition.y, axisRaw2);
		}
		if (axisRaw2 > 0f)
		{
			anim.SetBool("WalkF", value: true);
			anim.SetBool("WalkB", value: false);
		}
		else if (axisRaw2 < 0f)
		{
			anim.SetBool("WalkB", value: true);
			anim.SetBool("WalkF", value: false);
		}
		else if (axisRaw != 0f)
		{
			anim.SetBool("WalkF", value: true);
			anim.SetBool("WalkB", value: false);
		}
		else if (axisRaw == 0f && axisRaw2 == 0f)
		{
			anim.SetBool("WalkF", value: false);
			anim.SetBool("WalkB", value: false);
		}
		body.transform.LookAt(forwardPoint.transform);
	}

	private void JumpReady()
	{
		jumpCooldown = false;
	}
}



public class MoveTowards : MonoBehaviour
{
	public Vector3 targetPosition;

	public float speed;

	public float easeAtEnd;

	public bool useRigidBody;

	private Rigidbody rb;

	public bool pitchAudioWithSpeed;

	private AudioSource aud;

	private float originalPitch;

	public UltrakillEvent onReachTarget;

	private void Start()
	{
		if (useRigidBody)
		{
			UseRigidbody(use: true);
		}
	}

	private void FixedUpdate()
	{
		if (base.transform.position != targetPosition)
		{
			float num = speed;
			if (easeAtEnd != 0f)
			{
				num = Mathf.Min(num, Vector3.Distance(base.transform.position, targetPosition) * 2f / easeAtEnd);
			}
			Vector3 vector = Vector3.MoveTowards(base.transform.position, targetPosition, num * Time.fixedDeltaTime);
			if (Vector3.Distance(vector, targetPosition) < 0.1f)
			{
				if (useRigidBody)
				{
					rb.MovePosition(targetPosition);
				}
				else
				{
					base.transform.position = targetPosition;
				}
				onReachTarget?.Invoke();
			}
			else if (useRigidBody)
			{
				rb.MovePosition(vector);
			}
			else
			{
				base.transform.position = vector;
			}
			if (pitchAudioWithSpeed && (bool)aud)
			{
				aud.pitch = num / speed * originalPitch;
			}
		}
		else if (pitchAudioWithSpeed && (bool)aud)
		{
			aud.pitch = 0f;
		}
	}

	public void SnapToTarget()
	{
		base.transform.position = targetPosition;
	}

	public void ChangeTarget(Vector3 target)
	{
		targetPosition = target;
	}

	public void ChangeX(float number)
	{
		ChangeTarget(new Vector3(number, targetPosition.y, targetPosition.z));
	}

	public void ChangeY(float number)
	{
		ChangeTarget(new Vector3(targetPosition.x, number, targetPosition.z));
	}

	public void ChangeZ(float number)
	{
		ChangeTarget(new Vector3(targetPosition.x, targetPosition.y, number));
	}

	public void UseRigidbody(bool use)
	{
		if (!rb && use)
		{
			rb = GetComponent<Rigidbody>();
		}
		useRigidBody = use;
	}

	public void PitchAudioWithSpeed(bool use)
	{
		if (!aud && use)
		{
			aud = GetComponent<AudioSource>();
			originalPitch = aud.pitch;
		}
		pitchAudioWithSpeed = use;
	}

	public void UpdateAudioOriginalPitch()
	{
		if ((bool)aud)
		{
			originalPitch = aud.pitch;
		}
	}

	public void EaseAtEnd(float newEase)
	{
		easeAtEnd = newEase;
	}
}



public class MovingPlatform : MonoBehaviour
{
	[HideInInspector]
	public bool infoSet;

	public Vector3[] relativePoints;

	[HideInInspector]
	public Vector3 originalPosition;

	[HideInInspector]
	public Vector3 currentPosition;

	[HideInInspector]
	public Vector3 targetPosition;

	[HideInInspector]
	public int currentPoint;

	public bool useRigidbody;

	private Rigidbody rb;

	public float speed;

	public bool ease;

	public bool reverseAtEnd;

	public bool stopAtEnd;

	[HideInInspector]
	public bool forward = true;

	[HideInInspector]
	public bool moving;

	public float startOffset;

	public float moveDelay;

	[HideInInspector]
	public AudioSource aud;

	[HideInInspector]
	public float origPitch;

	public AudioClip moveSound;

	public AudioClip stopSound;

	public UltrakillEvent[] onReachPoint;

	private void Start()
	{
		if (useRigidbody && !rb)
		{
			rb = GetComponent<Rigidbody>();
		}
		if (!rb)
		{
			useRigidbody = false;
		}
		if (relativePoints.Length >= 1)
		{
			bool flag = false;
			for (int i = 0; i < relativePoints.Length; i++)
			{
				if (relativePoints[i] == Vector3.zero)
				{
					flag = true;
					break;
				}
			}
			if (!flag && !stopAtEnd)
			{
				Vector3[] array = new Vector3[relativePoints.Length + 1];
				for (int j = 0; j < relativePoints.Length; j++)
				{
					array[j] = relativePoints[j];
				}
				array[^1] = Vector3.zero;
				relativePoints = array;
			}
		}
		if (!reverseAtEnd)
		{
			forward = true;
		}
		if (relativePoints.Length > 1 && !infoSet)
		{
			infoSet = true;
			aud = GetComponentInChildren<AudioSource>();
			if ((bool)aud)
			{
				origPitch = aud.pitch;
			}
			originalPosition = base.transform.position;
			currentPosition = originalPosition;
			Invoke("NextPoint", startOffset);
		}
		else if (infoSet && !moving)
		{
			Invoke("NextPoint", startOffset);
		}
	}

	private void FixedUpdate()
	{
		if (!moving)
		{
			return;
		}
		float num = speed;
		if (ease)
		{
			if (Vector3.Distance(base.transform.position, targetPosition) < speed / 2f)
			{
				num *= Vector3.Distance(base.transform.position, targetPosition) / (speed / 2f) + 0.1f;
			}
			if (Vector3.Distance(base.transform.position, currentPosition) < speed / 2f)
			{
				num *= Vector3.Distance(base.transform.position, currentPosition) / (speed / 2f) + 0.1f;
			}
		}
		Vector3 position = Vector3.MoveTowards(base.transform.position, targetPosition, Time.deltaTime * num);
		if (useRigidbody && (bool)rb)
		{
			rb.MovePosition(position);
		}
		else
		{
			base.transform.position = position;
		}
		if (Vector3.Distance(base.transform.position, targetPosition) < 0.01f)
		{
			base.transform.position = targetPosition;
			moving = false;
			if (onReachPoint.Length > currentPoint)
			{
				onReachPoint[currentPoint].Invoke();
			}
			Invoke("NextPoint", moveDelay);
			if ((bool)aud && (bool)stopSound)
			{
				aud.clip = stopSound;
				aud.loop = false;
				aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
				if (aud.clip != null)
				{
					aud.Play();
				}
			}
			else if ((bool)aud && (bool)moveSound)
			{
				aud.Stop();
			}
		}
		else if ((bool)aud && !aud.isPlaying && (bool)moveSound)
		{
			aud.clip = moveSound;
			aud.loop = true;
			aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
			if (aud.clip != null)
			{
				aud.Play();
			}
		}
	}

	private void NextPoint()
	{
		int num = 1;
		if (!forward)
		{
			num = -1;
		}
		if ((forward && currentPoint < relativePoints.Length - 1) || (!forward && currentPoint > 0))
		{
			currentPoint += num;
		}
		else
		{
			if (stopAtEnd)
			{
				return;
			}
			if (!reverseAtEnd)
			{
				currentPoint = 0;
			}
			else if (forward)
			{
				forward = false;
			}
			else
			{
				forward = true;
			}
		}
		currentPosition = targetPosition;
		targetPosition = originalPosition + relativePoints[currentPoint];
		moving = true;
		if ((bool)aud && (bool)moveSound)
		{
			aud.clip = moveSound;
			aud.loop = true;
			aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
			if (aud.clip != null)
			{
				aud.Play();
			}
		}
	}
}


public enum MPAttack
{
	Boxing,
	Combo,
	Dropkick,
	ProjectilePunch,
	Jump
}



public class MusicChanger : MonoBehaviour
{
	public bool match;

	public bool oneTime;

	public bool onEnable;

	public bool dontStart;

	public bool forceOn;

	public AudioClip clean;

	public AudioClip battle;

	public AudioClip boss;

	private MusicManager muman;

	private void OnEnable()
	{
		if (onEnable)
		{
			Change();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!onEnable && other.gameObject.CompareTag("Player"))
		{
			Change();
		}
	}

	public void ChangeTo(AudioClip clip)
	{
		clean = clip;
		battle = clip;
		boss = clip;
		Change();
	}

	public void Change()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		if (muman == null)
		{
			muman = MonoSingleton<MusicManager>.Instance;
		}
		if (oneTime || muman.cleanTheme.clip != clean || muman.battleTheme.clip != battle || (muman.off && (!muman.forcedOff || forceOn)))
		{
			float time = 0f;
			bool off = muman.off;
			if (match)
			{
				time = muman.cleanTheme.time;
			}
			else
			{
				muman.cleanTheme.time = 0f;
				muman.battleTheme.time = 0f;
				muman.bossTheme.time = 0f;
			}
			muman.StopMusic();
			muman.cleanTheme.clip = clean;
			muman.battleTheme.clip = battle;
			muman.bossTheme.clip = boss;
			if (forceOn)
			{
				muman.forcedOff = false;
			}
			if (!dontStart || !off)
			{
				muman.StartMusic();
			}
			if (match)
			{
				muman.cleanTheme.time = time;
				muman.battleTheme.time = time;
				muman.bossTheme.time = time;
			}
			if (oneTime)
			{
				Object.Destroy(this);
			}
		}
	}
}



public class MusicDeactivator : MonoBehaviour
{
	public bool oneTime;

	public bool forceOff;

	private void OnEnable()
	{
		MonoSingleton<MusicManager>.Instance.StopMusic();
		if (forceOff)
		{
			MonoSingleton<MusicManager>.Instance.forcedOff = true;
		}
		if (oneTime)
		{
			Object.Destroy(this);
		}
	}
}



public class MusicFadeOut : MonoBehaviour
{
	public bool forceOff;

	public bool oneTime = true;

	private bool colliderless = true;

	private void Start()
	{
		if (TryGetComponent<Collider>(out var _))
		{
			colliderless = false;
			return;
		}
		MonoSingleton<MusicManager>.Instance.off = true;
		if (forceOff)
		{
			MonoSingleton<MusicManager>.Instance.forcedOff = true;
		}
		if (oneTime)
		{
			Object.Destroy(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			MonoSingleton<MusicManager>.Instance.off = true;
			if (forceOff)
			{
				MonoSingleton<MusicManager>.Instance.forcedOff = true;
			}
			if (oneTime)
			{
				Object.Destroy(this);
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
[DefaultExecutionOrder(600)]
public class MusicManager : MonoSingleton<MusicManager>
{
	public bool off;

	public bool dontMatch;

	public bool useBossTheme;

	public AudioSource battleTheme;

	public AudioSource cleanTheme;

	public AudioSource bossTheme;

	public AudioSource targetTheme;

	private AudioSource[] allThemes;

	public float volume = 1f;

	public float requestedThemes;

	private bool arenaMode;

	private float defaultVolume;

	public float fadeSpeed;

	public bool forcedOff;

	private bool filtering;

	private new void OnEnable()
	{
		if (fadeSpeed == 0f)
		{
			fadeSpeed = 1f;
		}
		allThemes = GetComponentsInChildren<AudioSource>();
		defaultVolume = volume;
		if (!off)
		{
			AudioSource[] array = allThemes;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
			cleanTheme.volume = volume;
			targetTheme = cleanTheme;
		}
		else
		{
			targetTheme = GetComponent<AudioSource>();
		}
		if ((bool)MonoSingleton<AudioMixerController>.Instance.musicSound)
		{
			MonoSingleton<AudioMixerController>.Instance.musicSound.FindSnapshot("Unpaused").TransitionTo(0f);
		}
	}

	private void Update()
	{
		if (!off && targetTheme.volume != volume)
		{
			AudioSource[] array = allThemes;
			foreach (AudioSource audioSource in array)
			{
				if (audioSource == targetTheme)
				{
					if (audioSource.volume > volume)
					{
						audioSource.volume = volume;
					}
					if (Time.timeScale == 0f)
					{
						audioSource.volume = volume;
					}
					else
					{
						audioSource.volume = Mathf.MoveTowards(audioSource.volume, volume, fadeSpeed * Time.deltaTime);
					}
				}
				else if (Time.timeScale == 0f)
				{
					audioSource.volume = 0f;
				}
				else
				{
					audioSource.volume = Mathf.MoveTowards(audioSource.volume, 0f, fadeSpeed * Time.deltaTime);
				}
			}
			if (targetTheme.volume == volume)
			{
				array = allThemes;
				foreach (AudioSource audioSource2 in array)
				{
					if (audioSource2 != targetTheme)
					{
						audioSource2.volume = 0f;
					}
				}
			}
		}
		if (filtering)
		{
			MonoSingleton<AudioMixerController>.Instance.musicSound.GetFloat("highPassVolume", out var value);
			value = Mathf.MoveTowards(value, 0f, 1200f * Time.unscaledDeltaTime);
			MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("highPassVolume", value);
			if (value == 0f)
			{
				filtering = false;
			}
		}
		if (volume == 0f || off)
		{
			AudioSource[] array = allThemes;
			foreach (AudioSource obj in array)
			{
				obj.volume = Mathf.MoveTowards(obj.volume, 0f, Time.deltaTime / 5f * fadeSpeed);
			}
		}
	}

	public void ForceStartMusic()
	{
		forcedOff = false;
		StartMusic();
	}

	public void StartMusic()
	{
		if (forcedOff || !off)
		{
			return;
		}
		AudioSource[] array = allThemes;
		foreach (AudioSource audioSource in array)
		{
			if (audioSource.clip != null)
			{
				audioSource.Play();
				if (off && audioSource.time != 0f)
				{
					audioSource.time = 0f;
				}
			}
		}
		off = false;
		if (!arenaMode && requestedThemes <= 0f)
		{
			cleanTheme.volume = volume;
			targetTheme = cleanTheme;
			battleTheme.volume = 0f;
			bossTheme.volume = 0f;
		}
		else
		{
			battleTheme.volume = volume;
			targetTheme = battleTheme;
			cleanTheme.volume = 0f;
			bossTheme.volume = 0f;
		}
	}

	public void PlayBattleMusic()
	{
		if (!dontMatch && targetTheme != battleTheme)
		{
			battleTheme.time = cleanTheme.time;
		}
		if (targetTheme != bossTheme)
		{
			targetTheme = battleTheme;
		}
		requestedThemes += 1f;
	}

	public void PlayCleanMusic()
	{
		requestedThemes -= 1f;
		if (requestedThemes <= 0f && !arenaMode)
		{
			requestedThemes = 0f;
			if (!dontMatch && targetTheme != cleanTheme)
			{
				cleanTheme.time = battleTheme.time;
			}
			if (battleTheme.volume == volume)
			{
				cleanTheme.time = battleTheme.time;
			}
			targetTheme = cleanTheme;
		}
	}

	public void PlayBossMusic()
	{
		if (targetTheme != bossTheme)
		{
			bossTheme.time = cleanTheme.time;
		}
		targetTheme = bossTheme;
	}

	public void ArenaMusicStart()
	{
		if (forcedOff)
		{
			return;
		}
		if (off)
		{
			AudioSource[] array = allThemes;
			foreach (AudioSource audioSource in array)
			{
				if (audioSource.clip != null)
				{
					audioSource.Play();
					if (off && audioSource.time != 0f)
					{
						audioSource.time = 0f;
					}
				}
			}
			off = false;
			battleTheme.volume = volume;
			targetTheme = battleTheme;
		}
		if (!battleTheme.isPlaying)
		{
			AudioSource[] array = allThemes;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
			battleTheme.volume = volume;
		}
		if (targetTheme != bossTheme)
		{
			targetTheme = battleTheme;
		}
		arenaMode = true;
	}

	public void ArenaMusicEnd()
	{
		requestedThemes = 0f;
		targetTheme = cleanTheme;
		arenaMode = false;
	}

	public void ForceStopMusic()
	{
		forcedOff = true;
		StopMusic();
	}

	public void StopMusic()
	{
		off = true;
		AudioSource[] array = allThemes;
		foreach (AudioSource obj in array)
		{
			obj.volume = 0f;
			obj.Stop();
		}
	}

	public void FilterMusic()
	{
		MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("highPassVolume", -80f);
		CancelInvoke("RemoveHighPass");
		MonoSingleton<AudioMixerController>.Instance.musicSound.FindSnapshot("Paused").TransitionTo(0f);
		filtering = true;
	}

	public void UnfilterMusic()
	{
		filtering = false;
		MonoSingleton<AudioMixerController>.Instance.musicSound.FindSnapshot("Unpaused").TransitionTo(0.5f);
		Invoke("RemoveHighPass", 0.5f);
	}

	private void RemoveHighPass()
	{
		MonoSingleton<AudioMixerController>.Instance.musicSound.SetFloat("highPassVolume", -80f);
	}

	public bool IsInBattle()
	{
		if (!arenaMode)
		{
			return requestedThemes > 0f;
		}
		return true;
	}
}



public class MuteWhenPaused : MonoBehaviour
{
	private AudioSource aud;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
		aud.mute = Time.deltaTime == 0f;
	}

	private void Update()
	{
		aud.mute = Time.deltaTime == 0f;
	}
}



public class MuzzleFlash : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}



public class Nail : MonoBehaviour
{
	public GameObject sourceWeapon;

	[HideInInspector]
	public bool hit;

	public float damage;

	private AudioSource aud;

	[HideInInspector]
	public Rigidbody rb;

	public AudioClip environmentHitSound;

	public AudioClip enemyHitSound;

	public Material zapMaterial;

	public GameObject zapParticle;

	private bool zapped;

	public bool fodderDamageBoost;

	public string weaponType;

	public bool heated;

	[HideInInspector]
	public List<Magnet> magnets = new List<Magnet>();

	private bool launched;

	[HideInInspector]
	public NailBurstController nbc;

	public bool enemy;

	public EnemyType safeEnemyType;

	private Vector3 startPosition;

	[Header("Sawblades")]
	public bool sawblade;

	public bool chainsaw;

	public float hitAmount = 3.9f;

	private EnemyIdentifier currentHitEnemy;

	private float sameEnemyHitCooldown;

	[SerializeField]
	private GameObject sawBreakEffect;

	[SerializeField]
	private GameObject sawBounceEffect;

	[SerializeField]
	private GameObject sawHitEffect;

	[HideInInspector]
	public int magnetRotationDirection;

	private List<Transform> hitLimbs = new List<Transform>();

	private float removeTimeMultiplier = 1f;

	public bool bounceToSurfaceNormal;

	[HideInInspector]
	public bool stopped;

	public int multiHitAmount = 1;

	private int currentMultiHitAmount;

	private float multiHitCooldown;

	private Transform hitTarget;

	[HideInInspector]
	public Vector3 originalVelocity;

	public AudioSource stoppedAud;

	[HideInInspector]
	public bool punchable;

	[HideInInspector]
	public bool punched;

	[HideInInspector]
	public float punchDistance;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
		if (!rb)
		{
			rb = GetComponent<Rigidbody>();
		}
	}

	private void Start()
	{
		if (sawblade)
		{
			removeTimeMultiplier = 3f;
		}
		if (magnets.Count == 0)
		{
			Invoke("RemoveTime", 5f * removeTimeMultiplier);
		}
		Invoke("MasterRemoveTime", 60f);
		startPosition = base.transform.position;
		Invoke("SlowUpdate", 2f);
	}

	private void OnDestroy()
	{
		if (zapped)
		{
			UnityEngine.Object.Instantiate(zapParticle, base.transform.position, base.transform.rotation);
		}
	}

	private void SlowUpdate()
	{
		if (Vector3.Distance(base.transform.position, startPosition) > 1000f)
		{
			RemoveTime();
		}
		else
		{
			Invoke("SlowUpdate", 2f);
		}
	}

	private void Update()
	{
		if (!hit)
		{
			if (!rb)
			{
				rb = GetComponent<Rigidbody>();
			}
			if ((bool)rb)
			{
				base.transform.LookAt(base.transform.position + rb.velocity * -1f);
			}
		}
		if (sameEnemyHitCooldown > 0f && !stopped)
		{
			sameEnemyHitCooldown = Mathf.MoveTowards(sameEnemyHitCooldown, 0f, Time.deltaTime);
			if (sameEnemyHitCooldown <= 0f)
			{
				currentHitEnemy = null;
			}
		}
		if (multiHitAmount <= 1)
		{
			return;
		}
		if (multiHitCooldown > 0f)
		{
			multiHitCooldown = Mathf.MoveTowards(multiHitCooldown, 0f, Time.deltaTime);
		}
		else if (stopped)
		{
			if (!currentHitEnemy.dead && currentMultiHitAmount > 0)
			{
				currentMultiHitAmount--;
				hitAmount -= 1f;
				DamageEnemy(hitTarget, currentHitEnemy);
			}
			if (currentHitEnemy.dead || currentMultiHitAmount <= 0)
			{
				stopped = false;
				rb.velocity = originalVelocity;
				if (hitAmount <= 0f)
				{
					SawBreak();
				}
				return;
			}
			multiHitCooldown = 0.15f;
		}
		if ((bool)stoppedAud)
		{
			if (stopped)
			{
				stoppedAud.pitch = 2f;
				stoppedAud.volume = 0.5f;
			}
			else
			{
				stoppedAud.pitch = 1f;
				stoppedAud.volume = 0.25f;
			}
		}
	}

	private void FixedUpdate()
	{
		if (!sawblade || !rb || hit)
		{
			return;
		}
		if (stopped)
		{
			rb.velocity = Vector3.zero;
			return;
		}
		if (magnets.Count > 0)
		{
			magnets.RemoveAll((Magnet magnet) => magnet == null);
			if (magnets.Count == 0)
			{
				return;
			}
			Magnet targetMagnet = GetTargetMagnet();
			if (!targetMagnet)
			{
				return;
			}
			if (punched)
			{
				if (Vector3.Distance(base.transform.position, targetMagnet.transform.position) > punchDistance)
				{
					punched = false;
					punchDistance = 0f;
					rb.velocity = Vector3.RotateTowards(rb.velocity, Quaternion.Euler(0f, 85 * magnetRotationDirection, 0f) * (targetMagnet.transform.position - base.transform.position).normalized * rb.velocity.magnitude, float.PositiveInfinity, rb.velocity.magnitude);
				}
			}
			else
			{
				rb.velocity = Vector3.RotateTowards(rb.velocity, Quaternion.Euler(0f, 85 * magnetRotationDirection, 0f) * (targetMagnet.transform.position - base.transform.position).normalized * rb.velocity.magnitude, float.PositiveInfinity, rb.velocity.magnitude);
			}
		}
		RaycastHit[] array = rb.SweepTestAll(rb.velocity.normalized, rb.velocity.magnitude * Time.fixedDeltaTime, QueryTriggerInteraction.Ignore);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Array.Sort(array, (RaycastHit x, RaycastHit y) => x.distance.CompareTo(y.distance));
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = array[i].transform.gameObject;
			if (!hit && (gameObject.layer == 10 || gameObject.layer == 11) && (gameObject.gameObject.CompareTag("Head") || gameObject.gameObject.CompareTag("Body") || gameObject.gameObject.CompareTag("Limb") || gameObject.gameObject.CompareTag("EndLimb") || gameObject.gameObject.CompareTag("Enemy")))
			{
				TouchEnemy(gameObject.transform);
			}
			else
			{
				if (gameObject.layer != 8 && gameObject.layer != 24 && gameObject.layer != 26 && !gameObject.CompareTag("Armor"))
				{
					continue;
				}
				if (gameObject.TryGetComponent<Breakable>(out var component) && component.weak)
				{
					component.Break();
					return;
				}
				if (hitAmount <= 0f)
				{
					SawBreak();
					return;
				}
				base.transform.position = array[i].point;
				if (bounceToSurfaceNormal)
				{
					rb.velocity = array[i].normal * rb.velocity.magnitude;
				}
				else
				{
					rb.velocity = Vector3.Reflect(rb.velocity.normalized, array[i].normal) * rb.velocity.magnitude;
				}
				flag = true;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(sawBounceEffect, array[i].point, Quaternion.LookRotation(array[i].normal));
				if (flag2 && gameObject2.TryGetComponent<AudioSource>(out var component2))
				{
					component2.enabled = false;
				}
				else
				{
					flag2 = true;
				}
				punched = false;
				punchable = true;
				if (magnets.Count > 0)
				{
					magnetRotationDirection *= -1;
					hitAmount -= 0.1f;
				}
				else
				{
					hitAmount -= 0.25f;
				}
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		for (int j = 0; j < 3; j++)
		{
			if (!Physics.Raycast(base.transform.position, rb.velocity.normalized, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				break;
			}
			if (hitInfo.transform.TryGetComponent<Breakable>(out var component3) && component3.weak)
			{
				component3.Break();
				break;
			}
			base.transform.position = hitInfo.point;
			if (bounceToSurfaceNormal)
			{
				rb.velocity = hitInfo.normal * rb.velocity.magnitude;
			}
			else
			{
				rb.velocity = Vector3.Reflect(rb.velocity.normalized, hitInfo.normal) * rb.velocity.magnitude;
			}
			hitAmount -= 0.125f;
			GameObject gameObject3 = UnityEngine.Object.Instantiate(sawBounceEffect, hitInfo.point, Quaternion.LookRotation(hitInfo.normal));
			if (flag2 && gameObject3.TryGetComponent<AudioSource>(out var component4))
			{
				component4.enabled = false;
			}
			else
			{
				flag2 = true;
			}
			punched = false;
			punchable = true;
		}
	}

	public Magnet GetTargetMagnet()
	{
		Magnet result = null;
		float num = float.PositiveInfinity;
		for (int i = 0; i < magnets.Count; i++)
		{
			Vector3 lhs = magnets[i].transform.position - base.transform.position;
			float sqrMagnitude = lhs.sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				result = magnets[i];
				Vector3 normalized = new Vector3(rb.velocity.z, rb.velocity.y, 0f - rb.velocity.x).normalized;
				if (Vector3.Dot(lhs, normalized) > 0f)
				{
					magnetRotationDirection = -1;
				}
				else
				{
					magnetRotationDirection = 1;
				}
			}
		}
		return result;
	}

	private void OnCollisionEnter(Collision other)
	{
		if (hit)
		{
			return;
		}
		GameObject gameObject = other.gameObject;
		if ((gameObject.layer == 10 || gameObject.layer == 11) && (gameObject.CompareTag("Head") || gameObject.CompareTag("Body") || gameObject.CompareTag("Limb") || gameObject.CompareTag("EndLimb") || gameObject.CompareTag("Enemy")))
		{
			TouchEnemy(other.transform);
		}
		else if (enemy && gameObject.layer == 2)
		{
			MonoSingleton<NewMovement>.Instance.GetHurt(8, invincible: true);
			hit = true;
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			if (magnets.Count != 0 || (gameObject.layer != 8 && gameObject.layer != 24))
			{
				return;
			}
			hit = true;
			CancelInvoke("RemoveTime");
			Invoke("RemoveTime", 1f);
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = environmentHitSound;
			aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			aud.volume = 0.2f;
			aud.Play();
			Breakable component = gameObject.GetComponent<Breakable>();
			if (component != null && (component.weak || heated) && !component.precisionOnly)
			{
				component.Break();
			}
			if (gameObject.TryGetComponent<Bleeder>(out var component2))
			{
				component2.GetHit(base.transform.position, GoreType.Small);
			}
			if (heated)
			{
				Flammable componentInChildren = gameObject.GetComponentInChildren<Flammable>();
				if (componentInChildren != null && (enemy || !componentInChildren.enemyOnly) && (!enemy || !componentInChildren.playerOnly))
				{
					componentInChildren.Burn(2f);
				}
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!sawblade && !hit && (other.gameObject.layer == 10 || other.gameObject.layer == 11) && (other.gameObject.CompareTag("Head") || other.gameObject.CompareTag("Body") || other.gameObject.CompareTag("Limb") || other.gameObject.CompareTag("EndLimb") || other.gameObject.CompareTag("Enemy")))
		{
			hit = true;
			TouchEnemy(other.transform);
		}
	}

	private void TouchEnemy(Transform other)
	{
		if (sawblade && multiHitAmount > 1)
		{
			if (!stopped && other.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid)
			{
				if (component.eid.dead)
				{
					HitEnemy(other, component);
				}
				else if (!(sameEnemyHitCooldown > 0f) || !(currentHitEnemy != null) || !(currentHitEnemy == component.eid))
				{
					stopped = true;
					currentMultiHitAmount = multiHitAmount;
					hitTarget = other;
					currentHitEnemy = component.eid;
					originalVelocity = rb.velocity;
					sameEnemyHitCooldown = 0.05f;
				}
			}
		}
		else
		{
			HitEnemy(other);
		}
	}

	private void HitEnemy(Transform other, EnemyIdentifierIdentifier eidid = null)
	{
		if ((!eidid && !other.TryGetComponent<EnemyIdentifierIdentifier>(out eidid)) || !eidid.eid || (enemy && (bool)eidid && (bool)eidid.eid && eidid.eid.enemyType == safeEnemyType) || (sawblade && ((sameEnemyHitCooldown > 0f && currentHitEnemy != null && currentHitEnemy == eidid.eid) || hitLimbs.Contains(other))))
		{
			return;
		}
		if (!sawblade)
		{
			hit = true;
		}
		else if (!eidid.eid.dead)
		{
			sameEnemyHitCooldown = 0.05f;
			currentHitEnemy = eidid.eid;
			hitAmount -= 1f;
		}
		if (aud == null)
		{
			aud = GetComponent<AudioSource>();
		}
		aud.clip = enemyHitSound;
		aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
		aud.volume = 0.2f;
		aud.Play();
		if ((bool)eidid && (bool)eidid.eid)
		{
			if (sawblade && eidid.eid.zapperer != null)
			{
				eidid.eid.zapperer.damage += 0.5f;
				eidid.eid.zapperer.ChargeBoost(0.5f);
			}
			DamageEnemy(other, eidid.eid);
		}
		if (sawblade)
		{
			if (hitAmount < 1f)
			{
				SawBreak();
			}
			return;
		}
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
		rb.isKinematic = true;
		UnityEngine.Object.Destroy(rb);
		base.transform.position += base.transform.forward * -0.5f;
		base.transform.SetParent(other.transform, worldPositionStays: true);
		if (TryGetComponent<TrailRenderer>(out var component))
		{
			component.enabled = false;
		}
		CancelInvoke("RemoveTime");
	}

	private void DamageEnemy(Transform other, EnemyIdentifier eid)
	{
		if (!sawblade)
		{
			eid.hitter = "nail";
		}
		else if (chainsaw)
		{
			eid.hitter = "chainsawprojectile";
		}
		else
		{
			eid.hitter = "sawblade";
		}
		if (!eid.hitterWeapons.Contains(weaponType))
		{
			eid.hitterWeapons.Add(weaponType);
		}
		if (sawHitEffect != null)
		{
			UnityEngine.Object.Instantiate(sawHitEffect, other.transform.position, Quaternion.identity).transform.localScale *= 3f;
		}
		bool flag = false;
		if (magnets.Count > 0)
		{
			foreach (Magnet magnet in magnets)
			{
				if (magnet.ignoredEids.Contains(eid))
				{
					flag = true;
					break;
				}
			}
		}
		bool dead = eid.dead;
		if (fodderDamageBoost && !eid.dead)
		{
			damage *= GetFodderDamageMultiplier(eid.enemyType);
		}
		if ((bool)nbc && !sawblade)
		{
			if (!nbc.damagedEnemies.Contains(eid))
			{
				eid.DeliverDamage(other.gameObject, (other.transform.position - base.transform.position).normalized * 3000f, base.transform.position, damage * (float)(nbc.nails.Count / 2) * (float)((!punched) ? 1 : 2), tryForExplode: true, 0f, sourceWeapon);
				nbc.damagedEnemies.Add(eid);
			}
		}
		else
		{
			eid.DeliverDamage(other.gameObject, (other.transform.position - base.transform.position).normalized * 3000f, base.transform.position, damage * (float)((!punched) ? 1 : 2), tryForExplode: false, 0f, sourceWeapon);
		}
		if (!dead && eid.dead && !flag && magnets.Count > 0)
		{
			if (magnets.Count > 1)
			{
				StyleHUD instance = MonoSingleton<StyleHUD>.Instance;
				int points = Mathf.RoundToInt(120f);
				EnemyIdentifier eid2 = eid;
				instance.AddPoints(points, "ultrakill.bipolar", sourceWeapon, eid2);
			}
			else
			{
				StyleHUD instance2 = MonoSingleton<StyleHUD>.Instance;
				int points2 = Mathf.RoundToInt(60f);
				EnemyIdentifier eid2 = eid;
				instance2.AddPoints(points2, "ultrakill.attripator", sourceWeapon, eid2);
			}
		}
		else if (launched && !sawblade)
		{
			if (!dead && eid.dead)
			{
				StyleHUD instance3 = MonoSingleton<StyleHUD>.Instance;
				int points3 = Mathf.RoundToInt(120f);
				EnemyIdentifier eid2 = eid;
				instance3.AddPoints(points3, "ultrakill.nailbombed", sourceWeapon, eid2);
			}
			else if (!eid.dead)
			{
				StyleHUD instance4 = MonoSingleton<StyleHUD>.Instance;
				int points4 = Mathf.RoundToInt(10f);
				EnemyIdentifier eid2 = eid;
				instance4.AddPoints(points4, "ultrakill.nailbombedalive", sourceWeapon, eid2);
			}
		}
		if (!dead && !sawblade)
		{
			eid.nailsAmount++;
			eid.nails.Add(this);
		}
		else if (dead && sawblade)
		{
			hitLimbs.Add(other);
		}
		if (heated)
		{
			Flammable componentInChildren = eid.GetComponentInChildren<Flammable>();
			if (componentInChildren != null && (enemy || !componentInChildren.enemyOnly) && (!enemy || !componentInChildren.playerOnly))
			{
				componentInChildren.Burn(2f, componentInChildren.burning);
			}
		}
		if (dead)
		{
			_ = magnets.Count;
		}
	}

	public void MagnetCaught(Magnet mag)
	{
		CancelInvoke("RemoveTime");
		launched = false;
		enemy = false;
		if (sawblade)
		{
			punchable = true;
		}
		if (!magnets.Contains(mag))
		{
			magnets.Add(mag);
		}
		if ((bool)nbc)
		{
			nbc.nails.Remove(this);
			nbc = null;
		}
	}

	public void MagnetRelease(Magnet mag)
	{
		CancelInvoke("RemoveTime");
		if (magnets.Contains(mag))
		{
			magnets.Remove(mag);
			if (magnets.Count == 0)
			{
				if (TryGetComponent<SphereCollider>(out var component))
				{
					component.enabled = true;
				}
				launched = true;
			}
		}
		if (magnets.Count == 0)
		{
			Invoke("RemoveTime", 5f * removeTimeMultiplier);
		}
	}

	public void Zap()
	{
		MeshRenderer component = GetComponent<MeshRenderer>();
		if ((bool)component)
		{
			component.material = zapMaterial;
		}
		zapped = true;
	}

	private void RemoveTime()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void MasterRemoveTime()
	{
		RemoveTime();
	}

	public void SawBreak()
	{
		hit = true;
		UnityEngine.Object.Instantiate(sawBreakEffect, base.transform.position, Quaternion.identity);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private float GetFodderDamageMultiplier(EnemyType et)
	{
		return et switch
		{
			EnemyType.Filth => 2f, 
			EnemyType.Schism => 1.5f, 
			EnemyType.Soldier => 1.5f, 
			EnemyType.Stalker => 1.5f, 
			EnemyType.Stray => 2f, 
			_ => 1f, 
		};
	}

	public void ForceCheckSawbladeRicochet()
	{
		if (!rb)
		{
			rb = GetComponent<Rigidbody>();
		}
		bool flag = false;
		for (int i = 0; i < 3; i++)
		{
			if (!Physics.Raycast(base.transform.position, rb.velocity.normalized, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				break;
			}
			if (hitInfo.transform.TryGetComponent<Breakable>(out var component) && component.weak)
			{
				component.Break();
				return;
			}
			base.transform.position = hitInfo.point;
			if (bounceToSurfaceNormal)
			{
				rb.velocity = hitInfo.normal * rb.velocity.magnitude;
			}
			else
			{
				rb.velocity = Vector3.Reflect(rb.velocity.normalized, hitInfo.normal) * rb.velocity.magnitude;
			}
			hitAmount -= 0.125f;
			GameObject gameObject = UnityEngine.Object.Instantiate(sawBounceEffect, hitInfo.point, Quaternion.LookRotation(hitInfo.normal));
			if (flag && gameObject.TryGetComponent<AudioSource>(out var component2))
			{
				component2.enabled = false;
			}
			else
			{
				flag = true;
			}
		}
		Collider[] array = Physics.OverlapSphere(base.transform.position, 1.5f, LayerMaskDefaults.Get(LMD.Enemies));
		if (array.Length != 0)
		{
			TouchEnemy(array[0].transform);
		}
	}
}



public class NailBurstController : MonoBehaviour
{
	public List<EnemyIdentifier> damagedEnemies = new List<EnemyIdentifier>();

	public List<Nail> nails;

	private void Update()
	{
		for (int num = nails.Count - 1; num >= 0; num--)
		{
			if (nails[num] == null || nails[num].hit)
			{
				nails.RemoveAt(num);
			}
		}
		if (nails.Count == 0)
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class Nailgun : MonoBehaviour
{
	private InputManager inman;

	private WeaponIdentifier wid;

	public int variation;

	public bool altVersion;

	public GameObject[] shootPoints;

	private Spin[] barrels;

	private float spinSpeed;

	private int barrelNum;

	private Light[] barrelLights;

	[SerializeField]
	private Renderer[] barrelHeats;

	private float heatUp;

	private bool burnOut;

	public GameObject muzzleFlash;

	public GameObject muzzleFlash2;

	public AudioSource snapSound;

	public float fireRate;

	private float currentFireRate;

	private float fireCooldown;

	private AudioSource aud;

	private AudioSource barrelAud;

	public GameObject nail;

	public GameObject heatedNail;

	public GameObject magnetNail;

	public AudioSource magnetShotSound;

	private CameraController cc;

	public float spread;

	private float currentSpread;

	private int burstAmount;

	private Animator anim;

	private bool canShoot;

	private NewMovement nm;

	[Header("Magnet")]
	public Text ammoText;

	public GameObject noAmmoSound;

	public GameObject lastShotSound;

	private float harpoonCharge = 1f;

	private bool shotSuccesfully;

	[Header("Overheat")]
	public Color emptyColor;

	public Color fullColor;

	private Slider heatSlider;

	private Image sliderBg;

	private float heatSinks = 2f;

	private float heatSinkFill = 2f;

	public Image[] heatSinkImages;

	private ParticleSystem heatSteam;

	private AudioSource heatSteamAud;

	private float heatCharge = 1f;

	[Header("Zapper")]
	public Zapper zapper;

	private Zapper currentZapper;

	public Transform zapperAttachTransform;

	[SerializeField]
	private TMP_Text statusText;

	[SerializeField]
	private Slider distanceMeter;

	[SerializeField]
	private Slider zapMeter;

	[SerializeField]
	private Image warningX;

	[SerializeField]
	private GameObject rechargingOverlay;

	[SerializeField]
	private Image rechargingMeter;

	private WeaponCharges wc;

	private WeaponPos wpos;

	private GunControl gc;

	private bool lookingForValue;

	private CameraFrustumTargeter targeter;

	private MaterialPropertyBlock heatProps;

	private Color heatColor;

	private string[] projectileVariationTypes;

	private void Awake()
	{
		wid = GetComponent<WeaponIdentifier>();
		barrels = GetComponentsInChildren<Spin>(includeInactive: true);
		barrelLights = barrels[0].transform.parent.GetComponentsInChildren<Light>();
		barrelAud = barrels[0].GetComponent<AudioSource>();
		aud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
		if (variation != 2)
		{
			heatSlider = GetComponentInChildren<Slider>();
			if ((bool)heatSlider)
			{
				sliderBg = heatSlider.GetComponentInParent<Image>();
			}
		}
		if (!altVersion)
		{
			heatSteam = GetComponentInChildren<ParticleSystem>();
			heatSteamAud = heatSteam.GetComponent<AudioSource>();
		}
		wpos = GetComponent<WeaponPos>();
		gc = GetComponentInParent<GunControl>();
	}

	private void Start()
	{
		targeter = MonoSingleton<CameraFrustumTargeter>.Instance;
		inman = MonoSingleton<InputManager>.Instance;
		heatProps = new MaterialPropertyBlock();
		if (barrelHeats.Length != 0)
		{
			barrelHeats[0].GetPropertyBlock(heatProps);
			heatColor = Color.white;
			SetHeat(0f);
		}
		cc = MonoSingleton<CameraController>.Instance;
		nm = MonoSingleton<NewMovement>.Instance;
		currentFireRate = fireRate;
		if ((bool)aud)
		{
			aud.volume -= wid.delay * 2f;
			if (aud.volume < 0f)
			{
				aud.volume = 0f;
			}
		}
		if ((bool)barrelAud)
		{
			barrelAud.volume -= wid.delay * 2f;
			if (barrelAud.volume < 0f)
			{
				barrelAud.volume = 0f;
			}
		}
		if ((bool)heatSteamAud)
		{
			heatSteamAud.volume -= wid.delay * 2f;
			if (heatSteamAud.volume < 0f)
			{
				heatSteamAud.volume = 0f;
			}
		}
		if (wc == null)
		{
			wc = MonoSingleton<WeaponCharges>.Instance;
		}
		projectileVariationTypes = new string[4];
		for (int i = 0; i < projectileVariationTypes.Length; i++)
		{
			projectileVariationTypes[i] = "nailgun" + i;
		}
		if (altVersion && variation == 0 && heatSinks == 2f)
		{
			heatSinks = 1f;
		}
		anim.SetLayerWeight(1, 0f);
	}

	private void OnDisable()
	{
		canShoot = false;
		harpoonCharge = 1f;
		wc.naiheatUp = heatUp;
		wc.nai0set = true;
		if (variation == 0)
		{
			if (!altVersion)
			{
				wc.naiHeatsinks = heatSinks;
			}
			else
			{
				wc.naiSawHeatsinks = heatSinks;
			}
		}
		if (currentZapper != null && (bool)MonoSingleton<NewMovement>.Instance)
		{
			currentZapper.lineStartTransform = MonoSingleton<NewMovement>.Instance.transform;
		}
		if ((bool)MonoSingleton<WeaponCharges>.Instance)
		{
			MonoSingleton<WeaponCharges>.Instance.naiAmmoDontCharge = false;
		}
	}

	private void OnEnable()
	{
		if (wc == null)
		{
			wc = MonoSingleton<WeaponCharges>.Instance;
		}
		if (variation == 0)
		{
			if (!altVersion)
			{
				heatSinks = wc.naiHeatsinks;
			}
			else
			{
				heatSinks = wc.naiSawHeatsinks;
			}
		}
		if (variation == 1 && (bool)aud)
		{
			RefreshHeatSinkFill(wc.naiMagnetCharge, playSound: true);
		}
		if (wc.nai0set)
		{
			wc.nai0set = false;
			if (heatSinks >= 1f)
			{
				heatUp = wc.naiheatUp;
			}
		}
		else
		{
			lookingForValue = true;
		}
		spinSpeed = 250f + heatUp * 2250f;
		anim?.SetLayerWeight(1, 0f);
		if (currentZapper != null)
		{
			currentZapper.lineStartTransform = zapperAttachTransform;
		}
	}

	private void Update()
	{
		if (NoWeaponCooldown.NoCooldown)
		{
			if (altVersion)
			{
				heatSinks = 1f;
			}
			else
			{
				heatSinks = 2f;
			}
			wc.naiAmmo = 100f;
			wc.naiSaws = 10f;
			wc.naiMagnetCharge = 3f;
		}
		if (lookingForValue && (bool)wc && wc.nai0set)
		{
			wc.nai0set = false;
			heatUp = wc.naiheatUp;
			spinSpeed = 250f + heatUp * 2250f;
		}
		if (burnOut || heatSinks < 1f)
		{
			heatUp = Mathf.MoveTowards(heatUp, 0f, Time.deltaTime);
			if (burnOut && heatUp <= 0f)
			{
				burnOut = false;
				heatSteam?.Stop();
				heatSteamAud?.Stop();
			}
		}
		else if (canShoot && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && (heatUp < 1f || variation == 2) && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (variation == 2)
			{
				heatUp = (((bool)currentZapper && currentZapper.attached) ? 1f : 0.33f);
			}
			else if (variation == 1)
			{
				heatUp = 1f;
			}
			else if (!altVersion)
			{
				heatUp = Mathf.MoveTowards(heatUp, 1f, Time.deltaTime * 0.55f);
			}
		}
		else if (heatUp > 0f && (!canShoot || !MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed))
		{
			if (!altVersion)
			{
				heatUp = Mathf.MoveTowards(heatUp, 0f, Time.deltaTime * 0.3f);
			}
			else if (fireCooldown <= 0f)
			{
				heatUp = Mathf.MoveTowards(heatUp, 0f, Time.deltaTime * 0.2f);
			}
			else
			{
				heatUp = Mathf.MoveTowards(heatUp, 0f, Time.deltaTime * 0.03f);
			}
		}
		if ((bool)heatSlider)
		{
			if (heatSlider.value != heatUp)
			{
				heatSlider.value = heatUp;
				sliderBg.color = Color.Lerp(emptyColor, fullColor, heatUp);
				if (heatUp <= 0f && heatSinks < 1f)
				{
					sliderBg.color = new Color(0f, 0f, 0f, 0f);
				}
			}
			else if (heatUp == 0f && heatSinks >= 1f && sliderBg.color.a == 0f)
			{
				sliderBg.color = emptyColor;
			}
		}
		if (canShoot && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			spinSpeed = 250f + heatUp * 2250f;
		}
		else
		{
			spinSpeed = Mathf.MoveTowards(spinSpeed, 0f, Time.deltaTime * 1000f);
		}
		if (variation != 0)
		{
			if (variation == 2 && altVersion)
			{
				if (currentZapper != null)
				{
					currentFireRate = fireRate + 3.5f - heatUp * 3.5f;
				}
				else
				{
					currentFireRate = fireRate * 2f;
				}
			}
			else
			{
				currentFireRate = fireRate + 3.5f - heatUp * 3.5f;
			}
		}
		else if (burnOut)
		{
			if (altVersion)
			{
				currentFireRate = 3f;
			}
			else
			{
				currentFireRate = fireRate - 2.5f;
			}
		}
		else if (heatSinks >= 1f)
		{
			if (heatUp < 0.5f)
			{
				currentFireRate = fireRate;
			}
			else if (altVersion)
			{
				currentFireRate = fireRate + (heatUp - 0.5f) * 65f;
			}
			else
			{
				currentFireRate = fireRate + (heatUp - 0.5f) * 7f;
			}
		}
		else if (altVersion)
		{
			currentFireRate = fireRate + 50f;
		}
		else
		{
			currentFireRate = fireRate + 10f;
		}
		barrelAud.pitch = spinSpeed / 1500f * 2f;
		Spin[] array = barrels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].speed = spinSpeed;
		}
		if (heatUp > 0f)
		{
			Light[] array2 = barrelLights;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].intensity = heatUp * 10f;
			}
			SetHeat(heatUp);
		}
		else
		{
			Light[] array2 = barrelLights;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].intensity = 0f;
			}
			SetHeat(0f);
		}
		if (variation == 1)
		{
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
			{
				MonoSingleton<WeaponCharges>.Instance.naiAmmoDontCharge = true;
			}
			else
			{
				MonoSingleton<WeaponCharges>.Instance.naiAmmoDontCharge = false;
			}
			if (altVersion)
			{
				ammoText.text = Mathf.RoundToInt(wc.naiSaws).ToString();
			}
			else
			{
				ammoText.text = Mathf.RoundToInt(wc.naiAmmo).ToString();
			}
		}
		if (canShoot && !burnOut && heatSinks >= 1f && heatUp >= 0.1f && variation == 0 && MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (altVersion)
			{
				SuperSaw();
			}
			else
			{
				burnOut = true;
				fireCooldown = 0f;
				heatSinks -= 1f;
				heatSteam?.Play();
				heatSteamAud?.Play();
				currentFireRate = fireRate - 2.5f;
			}
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && variation != 0)
		{
			if (variation == 1 && (!wid || wid.delay == 0f))
			{
				if (wc.naiMagnetCharge >= 1f)
				{
					ShootMagnet();
				}
				else
				{
					Object.Instantiate(noAmmoSound);
				}
			}
			else if (variation == 2)
			{
				if (MonoSingleton<WeaponCharges>.Instance.naiZapperRecharge >= 5f)
				{
					if (!wid || wid.delay == 0f)
					{
						ShootZapper();
					}
					else
					{
						Invoke("ShootZapper", wid.delay);
					}
				}
				else
				{
					Object.Instantiate(noAmmoSound);
				}
			}
		}
		if (variation == 0 && !MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			if (heatSinks < 2f && !altVersion)
			{
				heatSinks = Mathf.MoveTowards(heatSinks, 2f, Time.deltaTime * 0.125f);
			}
			else if (altVersion && heatSinks < 1f)
			{
				heatSinks = Mathf.MoveTowards(heatSinks, 1f, Time.deltaTime * 0.125f);
			}
		}
		if (variation == 2)
		{
			UpdateZapHud();
		}
		if (heatSinkImages != null && heatSinkImages.Length != 0)
		{
			float naiMagnetCharge = heatSinks;
			if (variation == 1)
			{
				naiMagnetCharge = wc.naiMagnetCharge;
			}
			RefreshHeatSinkFill(naiMagnetCharge, heatSinkFill != naiMagnetCharge);
		}
	}

	private void UpdateZapHud()
	{
		if (wc.naiZapperRecharge < 5f)
		{
			rechargingOverlay.SetActive(value: true);
			rechargingMeter.fillAmount = wc.naiZapperRecharge / 5f;
			statusText.text = "";
			zapMeter.gameObject.SetActive(value: false);
			warningX.enabled = false;
			distanceMeter.value = 0f;
			return;
		}
		if (rechargingOverlay.activeSelf)
		{
			aud?.Play();
			rechargingOverlay.SetActive(value: false);
		}
		if (currentZapper == null)
		{
			zapMeter.gameObject.SetActive(value: false);
			warningX.enabled = false;
			float num = 0f;
			if (Physics.Raycast(cc.GetDefaultPos(), cc.transform.forward, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment)) && hitInfo.collider.gameObject.layer != 8 && hitInfo.collider.gameObject.layer != 24 && hitInfo.collider.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && !component.eid.dead)
			{
				if (hitInfo.distance < zapper.maxDistance - 5f)
				{
					statusText.text = "READY";
					num = 1f - (zapper.maxDistance - 5f - hitInfo.distance) / (zapper.maxDistance - 5f);
					statusText.color = Color.white;
				}
				else
				{
					statusText.text = (altVersion ? "TOO FAR" : "OUT OF RANGE");
					num = 0f;
					statusText.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[2];
				}
			}
			else
			{
				statusText.text = (altVersion ? "NULL" : "NO TARGET");
				num = 0f;
				statusText.color = Color.gray;
			}
			distanceMeter.value = Mathf.MoveTowards(distanceMeter.value, num, Time.deltaTime * 10f);
		}
		else
		{
			if (currentZapper.charge > 0f)
			{
				zapMeter.gameObject.SetActive(value: true);
				zapMeter.value = currentZapper.charge / 5f;
			}
			else
			{
				zapMeter.gameObject.SetActive(value: false);
			}
			if (currentZapper.distance > currentZapper.maxDistance || currentZapper.raycastBlocked)
			{
				warningX.enabled = true;
				warningX.color = ((currentZapper.breakTimer % 0.1f > 0.05f) ? Color.red : Color.white);
				distanceMeter.value = 1f;
				statusText.text = (currentZapper.raycastBlocked ? "BLOCKED" : (altVersion ? "TOO FAR" : "OUT OF RANGE"));
				statusText.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[2];
			}
			else
			{
				warningX.enabled = false;
				distanceMeter.value = 1f - (currentZapper.maxDistance - currentZapper.distance) / currentZapper.maxDistance;
				statusText.text = (altVersion ? "" : "DISTANCE: ") + currentZapper.distance.ToString("f1");
				statusText.color = Color.Lerp(Color.red, Color.white, (currentZapper.maxDistance - currentZapper.distance) / currentZapper.maxDistance);
			}
		}
	}

	private void FixedUpdate()
	{
		if (fireCooldown > 0f)
		{
			fireCooldown = Mathf.MoveTowards(fireCooldown, 0f, Time.deltaTime * 100f);
			if (fireCooldown < 0.01f)
			{
				fireCooldown = 0f;
			}
		}
		if (canShoot && ((!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed) || burnOut) && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (fireCooldown != 0f)
			{
				return;
			}
			if (variation == 1 && ((!altVersion && Mathf.RoundToInt(wc.naiAmmo) <= 0) || (altVersion && Mathf.RoundToInt(wc.naiSaws) <= 0)))
			{
				fireCooldown = currentFireRate * 2f;
				if (shotSuccesfully)
				{
					Object.Instantiate(lastShotSound);
				}
				else
				{
					Object.Instantiate(noAmmoSound);
				}
				shotSuccesfully = false;
			}
			else if (!wid || wid.delay == 0f)
			{
				Shoot();
			}
			else
			{
				fireCooldown = currentFireRate;
				Invoke("Shoot", wid.delay / 10f);
			}
		}
		else if (!MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			shotSuccesfully = false;
		}
	}

	private void UpdateAnimationWeight()
	{
		if (!burnOut && variation == 0)
		{
			if (heatSinks < 1f)
			{
				anim.SetLayerWeight(1, 0.9f);
			}
			else if (wpos.currentDefault == wpos.middlePos)
			{
				anim.SetLayerWeight(1, 0.75f);
			}
			else
			{
				anim.SetLayerWeight(1, heatUp * 0.6f);
			}
		}
		else if (wpos.currentDefault == wpos.middlePos || ((bool)MonoSingleton<PowerUpMeter>.Instance && MonoSingleton<PowerUpMeter>.Instance.juice > 0f))
		{
			anim.SetLayerWeight(1, 0.75f);
		}
		else
		{
			anim.SetLayerWeight(1, 0f);
		}
	}

	private void SetHeat(float heat)
	{
		heatColor.a = heat * 0.5f;
		heatProps.SetColor("_Color", heatColor);
		for (int i = 0; i < barrelHeats.Length; i++)
		{
			barrelHeats[i].SetPropertyBlock(heatProps);
		}
		if (heat == 0f)
		{
			MonoSingleton<RumbleManager>.Instance.StopVibration(RumbleProperties.NailgunFire);
		}
		else if (barrelHeats != null && barrelHeats.Length != 0 && !altVersion)
		{
			bool flag = variation == 0 && burnOut;
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.NailgunFire, barrelHeats[0].gameObject).intensityMultiplier = (flag ? 3f : heat);
		}
	}

	private void Shoot()
	{
		UpdateAnimationWeight();
		fireCooldown = currentFireRate;
		shotSuccesfully = true;
		if (variation == 1 && (!wid || wid.delay == 0f))
		{
			if (altVersion)
			{
				wc.naiSaws -= 1f;
			}
			else
			{
				wc.naiAmmo -= 1f;
			}
		}
		anim.SetTrigger("Shoot");
		barrelNum++;
		if (barrelNum >= shootPoints.Length)
		{
			barrelNum = 0;
		}
		GameObject gameObject = ((!burnOut) ? Object.Instantiate(muzzleFlash, shootPoints[barrelNum].transform) : Object.Instantiate(muzzleFlash2, shootPoints[barrelNum].transform));
		if (!altVersion)
		{
			AudioSource component = gameObject.GetComponent<AudioSource>();
			if (burnOut)
			{
				component.volume = 0.65f - wid.delay * 2f;
				if (component.volume < 0f)
				{
					component.volume = 0f;
				}
				component.pitch = 2f;
				currentSpread = spread * 2f;
			}
			else
			{
				if (heatSinks < 1f)
				{
					component.pitch = 0.75f;
					component.volume = 0.25f - wid.delay * 2f;
					if (component.volume < 0f)
					{
						component.volume = 0f;
					}
				}
				else
				{
					component.volume = 0.65f - wid.delay * 2f;
					if (component.volume < 0f)
					{
						component.volume = 0f;
					}
				}
				currentSpread = spread;
			}
		}
		else if (burnOut)
		{
			currentSpread = 45f;
		}
		else if (altVersion && variation == 0)
		{
			if (heatSinks < 1f)
			{
				currentSpread = 45f;
			}
			else
			{
				currentSpread = Mathf.Lerp(0f, 45f, Mathf.Max(0f, heatUp - 0.25f));
			}
		}
		else
		{
			currentSpread = 0f;
		}
		GameObject gameObject2 = ((!burnOut) ? Object.Instantiate(nail, cc.transform.position + cc.transform.forward, base.transform.rotation) : Object.Instantiate(heatedNail, cc.transform.position + cc.transform.forward, base.transform.rotation));
		if (altVersion && variation == 0 && heatSinks >= 1f)
		{
			heatUp = Mathf.MoveTowards(heatUp, 1f, 0.125f);
		}
		gameObject2.transform.forward = cc.transform.forward;
		if (Physics.Raycast(cc.transform.position, cc.transform.forward, 1f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			gameObject2.transform.position = cc.transform.position;
		}
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject2.transform.position = cc.transform.position + (targeter.CurrentTarget.bounds.center - cc.transform.position).normalized;
			gameObject2.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		gameObject2.transform.Rotate(Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f));
		if (gameObject2.TryGetComponent<Rigidbody>(out var component2))
		{
			component2.velocity = gameObject2.transform.forward * 200f;
		}
		if (gameObject2.TryGetComponent<Nail>(out var component3))
		{
			component3.sourceWeapon = gc.currentWeapon;
			component3.weaponType = projectileVariationTypes[variation];
			if (altVersion && variation != 1)
			{
				if (heatSinks >= 1f && variation != 2)
				{
					component3.hitAmount = Mathf.Lerp(3f, 1f, heatUp);
				}
				else
				{
					component3.hitAmount = 1f;
				}
			}
			if (component3.sawblade)
			{
				component3.ForceCheckSawbladeRicochet();
			}
		}
		if (!burnOut)
		{
			cc.CameraShake(0.1f);
		}
		else
		{
			cc.CameraShake(0.35f);
		}
		if (altVersion)
		{
			MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Sawblade);
		}
	}

	public void BurstFire()
	{
		UpdateAnimationWeight();
		burstAmount--;
		barrelNum++;
		if (barrelNum >= shootPoints.Length)
		{
			barrelNum = 0;
		}
		Object.Instantiate(muzzleFlash2, shootPoints[barrelNum].transform);
		currentSpread = spread;
		GameObject gameObject = Object.Instantiate(heatedNail, base.transform.position + base.transform.forward, base.transform.rotation);
		gameObject.transform.forward = base.transform.forward * -1f;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
			gameObject.transform.forward *= -1f;
		}
		gameObject.transform.Rotate(Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f), Random.Range((0f - currentSpread) / 3f, currentSpread / 3f));
		gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * -100f, ForceMode.VelocityChange);
		Nail component = gameObject.GetComponent<Nail>();
		component.weaponType = projectileVariationTypes[variation];
		component.sourceWeapon = gc.currentWeapon;
		cc.CameraShake(0.5f);
		if (burstAmount > 0)
		{
			Invoke("BurstFire", 0.03f);
		}
	}

	public void SuperSaw()
	{
		fireCooldown = currentFireRate;
		shotSuccesfully = true;
		anim.SetLayerWeight(1, 0f);
		anim.SetTrigger("SuperShoot");
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.SuperSaw);
		barrelNum++;
		if (barrelNum >= shootPoints.Length)
		{
			barrelNum = 0;
		}
		Object.Instantiate(muzzleFlash2, shootPoints[barrelNum].transform);
		currentSpread = 0f;
		GameObject gameObject = Object.Instantiate(heatedNail, cc.transform.position + cc.transform.forward, base.transform.rotation);
		gameObject.transform.forward = cc.transform.forward;
		if (Physics.Raycast(cc.transform.position, cc.transform.forward, 1f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			gameObject.transform.position = cc.transform.position;
		}
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject.transform.position = cc.transform.position + (targeter.CurrentTarget.bounds.center - cc.transform.position).normalized;
			gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		if (gameObject.TryGetComponent<Rigidbody>(out var component))
		{
			component.velocity = gameObject.transform.forward * 200f;
		}
		if (gameObject.TryGetComponent<Nail>(out var component2))
		{
			component2.weaponType = projectileVariationTypes[variation];
			component2.multiHitAmount = Mathf.RoundToInt(heatUp * 3f);
			component2.ForceCheckSawbladeRicochet();
			component2.sourceWeapon = gc.currentWeapon;
		}
		heatSinks -= 1f;
		heatUp = 0f;
		cc.CameraShake(0.5f);
	}

	public void ShootMagnet()
	{
		UpdateAnimationWeight();
		GameObject gameObject = Object.Instantiate(magnetNail, cc.transform.position, base.transform.rotation);
		gameObject.transform.forward = base.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 100f, ForceMode.VelocityChange);
		if (canShoot)
		{
			anim.SetTrigger("Shoot");
		}
		Object.Instantiate(magnetShotSound);
		Magnet componentInChildren = gameObject.GetComponentInChildren<Magnet>();
		if ((bool)componentInChildren)
		{
			wc.magnets.Add(componentInChildren);
		}
		wc.naiMagnetCharge -= 1f;
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Magnet);
	}

	public void ShootZapper()
	{
		UpdateAnimationWeight();
		if ((bool)currentZapper)
		{
			currentZapper.Break();
		}
		currentZapper = Object.Instantiate(zapper, cc.GetDefaultPos(), base.transform.rotation);
		currentZapper.transform.forward = base.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			currentZapper.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		currentZapper.GetComponent<Rigidbody>().AddForce(currentZapper.transform.forward * 100f, ForceMode.VelocityChange);
		if (canShoot)
		{
			anim.SetTrigger("Shoot");
		}
		Object.Instantiate(magnetShotSound);
		currentZapper.lineStartTransform = zapperAttachTransform;
		currentZapper.connectedRB = MonoSingleton<NewMovement>.Instance.rb;
		currentZapper.sourceWeapon = base.gameObject;
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Magnet);
	}

	public void CanShoot()
	{
		canShoot = true;
	}

	private void MaxCharge()
	{
		if (variation == 0 && (heatSinks < 1f || (heatSinks < 2f && !altVersion)))
		{
			if (altVersion)
			{
				heatSinks = 1f;
			}
			else
			{
				heatSinks = 2f;
			}
		}
	}

	private void RefreshHeatSinkFill(float charge, bool playSound = false)
	{
		heatSinkFill = Mathf.MoveTowards(heatSinkFill, charge, Time.deltaTime * (Mathf.Abs((charge - heatSinkFill) * 20f) + 1f));
		for (int i = 0; i < heatSinkImages.Length; i++)
		{
			if (heatSinkFill > (float)i)
			{
				heatSinkImages[i].fillAmount = heatSinkFill - (float)i;
				int num = CorrectVariation();
				if (heatSinkFill >= (float)(i + 1) && heatSinkImages[i].color != MonoSingleton<ColorBlindSettings>.Instance.variationColors[num])
				{
					if (playSound)
					{
						aud.pitch = (float)i * 0.5f + 1f;
						aud.Play();
					}
					heatSinkImages[i].color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[num];
				}
				else if (heatSinkFill < (float)(i + 1))
				{
					heatSinkImages[i].color = emptyColor;
				}
			}
			else
			{
				heatSinkImages[i].fillAmount = 0f;
			}
		}
		if ((bool)ammoText)
		{
			ammoText.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[CorrectVariation()];
		}
	}

	public void SnapSound()
	{
		Object.Instantiate(snapSound);
	}

	private int CorrectVariation()
	{
		if (variation == 0)
		{
			return 1;
		}
		if (variation == 1)
		{
			return 0;
		}
		return variation;
	}
}



public class NailgunAnimationReceiver : MonoBehaviour
{
	private Nailgun ng;

	private void Start()
	{
		ng = GetComponentInParent<Nailgun>();
	}

	public void CanShoot()
	{
		ng.CanShoot();
	}

	public void SnapSound()
	{
		ng.SnapSound();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class NewMovement : MonoSingleton<NewMovement>
{
	[HideInInspector]
	public bool modNoDashSlide;

	[HideInInspector]
	public bool modNoJump;

	[HideInInspector]
	public float modForcedFrictionMultip = 1f;

	private float friction;

	private InputManager inman;

	[HideInInspector]
	public AssistController asscon;

	public float walkSpeed;

	public float jumpPower;

	public float airAcceleration;

	public float wallJumpPower;

	private bool jumpCooldown;

	private bool falling;

	[HideInInspector]
	public Rigidbody rb;

	private Vector3 movementDirection;

	private Vector3 movementDirection2;

	private Vector3 airDirection;

	public float timeBetweenSteps;

	private float stepTime;

	private int currentStep;

	[HideInInspector]
	public Animator anim;

	private Quaternion tempRotation;

	private GameObject forwardPoint;

	public GroundCheck gc;

	public GroundCheck slopeCheck;

	private WallCheck wc;

	private PlayerAnimations pa;

	private Vector3 wallJumpPos;

	public int currentWallJumps;

	private AudioSource aud;

	private AudioSource aud2;

	private AudioSource aud3;

	private int currentSound;

	public AudioClip jumpSound;

	public AudioClip landingSound;

	public AudioClip finalWallJump;

	public bool walking;

	public int hp = 100;

	public float antiHp;

	private float antiHpCooldown;

	public Image hurtScreen;

	private AudioSource hurtAud;

	private Color hurtColor;

	private Color currentColor;

	private bool hurting;

	public bool dead;

	public bool endlessMode;

	public Image blackScreen;

	private Color blackColor;

	public Text youDiedText;

	private Color youDiedColor;

	public FlashImage hpFlash;

	public FlashImage antiHpFlash;

	private AudioSource greenHpAud;

	private float currentAllPitch = 1f;

	private float currentAllVolume;

	public bool boost;

	public Vector3 dodgeDirection;

	private float boostLeft;

	private float dashStorage;

	public float boostCharge = 300f;

	public AudioClip dodgeSound;

	public CameraController cc;

	public GameObject staminaFailSound;

	public GameObject screenHud;

	private Vector3 hudOriginalPos;

	public GameObject dodgeParticle;

	public GameObject scrnBlood;

	private Canvas fullHud;

	public GameObject hudCam;

	private Vector3 camOriginalPos;

	private RigidbodyConstraints defaultRBConstraints;

	private GameObject revolver;

	private StyleHUD shud;

	public GameObject scrapePrefab;

	private GameObject scrapeParticle;

	public LayerMask lmask;

	public StyleCalculator scalc;

	public bool activated;

	public int gamepadFreezeCount;

	private float fallSpeed;

	public bool jumping;

	private float fallTime;

	public GameObject impactDust;

	public GameObject fallParticle;

	private GameObject currentFallParticle;

	[HideInInspector]
	public CapsuleCollider playerCollider;

	public bool sliding;

	private float slideSafety;

	public GameObject slideParticle;

	private GameObject currentSlideParticle;

	private ParticleSystem.TrailModule slideTrail;

	private ParticleSystem.MinMaxGradient normalSlideGradient;

	public ParticleSystem.MinMaxGradient invincibleSlideGradient;

	public GameObject slideScrapePrefab;

	private GameObject slideScrape;

	private Vector3 slideMovDirection;

	public GameObject slideStopSound;

	private bool crouching;

	public bool standing;

	public bool rising;

	private bool slideEnding;

	private Vector3 groundCheckPos;

	public AudioSource oilSlideEffect;

	private GunControl gunc;

	public float currentSpeed;

	private FistControl punch;

	public GameObject dashJumpSound;

	public bool slowMode;

	public Vector3 pushForce;

	private float slideLength;

	[HideInInspector]
	public float longestSlide;

	private float preSlideSpeed;

	private float preSlideDelay;

	public bool quakeJump;

	public GameObject quakeJumpSound;

	[HideInInspector]
	public bool exploded;

	[HideInInspector]
	public float safeExplosionLaunchCooldown;

	private float clingFade;

	public bool stillHolding;

	public float slamForce;

	private bool slamStorage;

	private bool launched;

	private int difficulty;

	[HideInInspector]
	public int sameCheckpointRestarts;

	public CustomGroundProperties groundProperties;

	[HideInInspector]
	public int rocketJumps;

	[HideInInspector]
	public int hammerJumps;

	[HideInInspector]
	public Grenade ridingRocket;

	[HideInInspector]
	public int rocketRides;

	private float ssjMaxFrames = 4f;

	public Light pointLight;

	public TimeSince sinceSlideEnd;

	[HideInInspector]
	public bool levelOver;

	private Vector3Int? lastCheckedGasolineVoxel;

	private int framesSinceSlide;

	private Vector3 velocityAfterSlide;

	protected override void Awake()
	{
		base.Awake();
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
		wc = GetComponentInChildren<WallCheck>();
		aud2 = gc.GetComponent<AudioSource>();
		pa = GetComponentInChildren<PlayerAnimations>();
		aud3 = wc.GetComponent<AudioSource>();
		cc = GetComponentInChildren<CameraController>();
		playerCollider = GetComponent<CapsuleCollider>();
	}

	private void Start()
	{
		inman = MonoSingleton<InputManager>.Instance;
		asscon = MonoSingleton<AssistController>.Instance;
		if ((bool)hurtScreen)
		{
			hurtColor = hurtScreen.color;
			currentColor = hurtColor;
			currentColor.a = 0f;
			hurtScreen.color = currentColor;
			hurtAud = hurtScreen.GetComponent<AudioSource>();
			blackColor = blackScreen.color;
			youDiedColor = youDiedText.color;
			fullHud = hurtScreen.GetComponentInParent<Canvas>();
		}
		hudOriginalPos = screenHud.transform.localPosition;
		camOriginalPos = hudCam.transform.localPosition;
		currentAllPitch = 1f;
		MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", 1f);
		MonoSingleton<AudioMixerController>.Instance.doorSound.SetFloat("allPitch", 1f);
		defaultRBConstraints = rb.constraints;
		rb.solverIterations *= 5;
		rb.solverVelocityIterations *= 5;
		groundCheckPos = gc.transform.localPosition;
		scalc = MonoSingleton<StyleCalculator>.Instance;
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		normalSlideGradient = slideParticle.GetComponent<ParticleSystem>().trails.colorOverLifetime;
		if (difficulty == 0 && hp == 100)
		{
			hp = 200;
		}
	}

	public AudioSource DuplicateDetachWhoosh()
	{
		if (!aud3)
		{
			return null;
		}
		float time = aud3.time;
		aud3.enabled = false;
		GameObject obj = UnityEngine.Object.Instantiate(aud3.gameObject, aud3.transform.parent, worldPositionStays: true);
		UnityEngine.Object.Destroy(obj.GetComponent<WallCheck>());
		AudioSource component = obj.GetComponent<AudioSource>();
		component.time = time;
		component.Play();
		return component;
	}

	public AudioSource RestoreWhoosh()
	{
		aud3.enabled = true;
		return aud3;
	}

	private void OnDisable()
	{
		if (sliding)
		{
			StopSlide();
		}
		if ((bool)currentFallParticle)
		{
			UnityEngine.Object.Destroy(currentFallParticle);
		}
		if ((bool)scrapeParticle)
		{
			UnityEngine.Object.Destroy(scrapeParticle);
		}
		Physics.IgnoreLayerCollision(2, 12, ignore: false);
	}

	private void Update()
	{
		if (gc.onGround)
		{
			CheckForGasoline();
		}
		else if (oilSlideEffect.gameObject.activeSelf)
		{
			oilSlideEffect.gameObject.SetActive(value: false);
		}
		Vector2 vector = Vector2.zero;
		if (activated)
		{
			vector = MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>();
			cc.movementHor = vector.x;
			cc.movementVer = vector.y;
			movementDirection = Vector3.ClampMagnitude(vector.x * base.transform.right + vector.y * base.transform.forward, 1f);
			if (punch == null)
			{
				punch = GetComponentInChildren<FistControl>();
			}
			else if (!punch.enabled)
			{
				punch.YesFist();
			}
		}
		else
		{
			if (currentFallParticle != null)
			{
				UnityEngine.Object.Destroy(currentFallParticle);
			}
			if (currentSlideParticle != null)
			{
				UnityEngine.Object.Destroy(currentSlideParticle);
			}
			else if (slideScrape != null)
			{
				UnityEngine.Object.Destroy(slideScrape);
			}
			if (punch == null)
			{
				punch = GetComponentInChildren<FistControl>();
			}
			else
			{
				punch.NoFist();
			}
		}
		if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad && gamepadFreezeCount > 0)
		{
			vector = Vector2.zero;
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			cc.movementHor = 0f;
			cc.movementVer = 0f;
			movementDirection = Vector3.zero;
			return;
		}
		if (dead && !endlessMode)
		{
			currentAllPitch -= 0.1f * Time.deltaTime;
			MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", currentAllPitch);
			MonoSingleton<AudioMixerController>.Instance.doorSound.SetFloat("allPitch", currentAllPitch);
			if (blackColor.a < 0.5f)
			{
				blackColor.a += 0.75f * Time.deltaTime;
				youDiedColor.a += 0.75f * Time.deltaTime;
			}
			else
			{
				blackColor.a += 0.05f * Time.deltaTime;
				youDiedColor.a += 0.05f * Time.deltaTime;
			}
			blackScreen.color = blackColor;
			youDiedText.color = youDiedColor;
		}
		if (gc.onGround != pa.onGround)
		{
			pa.onGround = gc.onGround;
		}
		if (!gc.onGround)
		{
			if (fallTime < 1f)
			{
				fallTime += Time.deltaTime * 5f;
				if (fallTime > 1f)
				{
					falling = true;
				}
			}
			else if (rb.velocity.y < -2f)
			{
				fallSpeed = rb.velocity.y;
			}
		}
		else if (gc.onGround)
		{
			fallTime = 0f;
			clingFade = 0f;
		}
		if (!gc.onGround && rb.velocity.y < -20f)
		{
			aud3.pitch = rb.velocity.y * -1f / 120f;
			if (activated)
			{
				aud3.volume = rb.velocity.y * -1f / 80f;
			}
			else
			{
				aud3.volume = rb.velocity.y * -1f / 240f;
			}
		}
		else if (rb.velocity.y > -20f)
		{
			aud3.pitch = 0f;
			aud3.volume = 0f;
		}
		if (rb.velocity.y < -100f)
		{
			rb.velocity = new Vector3(rb.velocity.x, -100f, rb.velocity.z);
		}
		if (gc.onGround && falling && !jumpCooldown)
		{
			falling = false;
			slamStorage = false;
			if (fallSpeed > -50f)
			{
				aud2.clip = landingSound;
				aud2.volume = 0.5f + fallSpeed * -0.01f;
				aud2.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
				aud2.Play();
			}
			else
			{
				UnityEngine.Object.Instantiate(impactDust, gc.transform.position, Quaternion.identity).transform.forward = Vector3.up;
				cc.CameraShake(0.5f);
				MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.FallImpact);
			}
			fallSpeed = 0f;
			gc.heavyFall = false;
			if (currentFallParticle != null)
			{
				UnityEngine.Object.Destroy(currentFallParticle);
			}
		}
		if (!gc.onGround && activated && MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (sliding)
			{
				StopSlide();
			}
			if (boost)
			{
				boostLeft = 0f;
				boost = false;
			}
			if (fallTime > 0.5f && !Physics.Raycast(gc.transform.position + base.transform.up, base.transform.up * -1f, out var _, 3f, lmask) && !gc.heavyFall)
			{
				stillHolding = true;
				rb.velocity = new Vector3(0f, -100f, 0f);
				falling = true;
				fallSpeed = -100f;
				gc.heavyFall = true;
				slamForce = 1f;
				if (currentFallParticle != null)
				{
					UnityEngine.Object.Destroy(currentFallParticle);
				}
				currentFallParticle = UnityEngine.Object.Instantiate(fallParticle, base.transform);
			}
		}
		if (gc.heavyFall && !slamStorage)
		{
			rb.velocity = new Vector3(0f, -100f, 0f);
		}
		if (gc.heavyFall || sliding)
		{
			Physics.IgnoreLayerCollision(2, 12, ignore: true);
		}
		else
		{
			Physics.IgnoreLayerCollision(2, 12, ignore: false);
		}
		if (!slopeCheck.onGround && slopeCheck.forcedOff <= 0 && modForcedFrictionMultip != 0f && !jumping && !boost)
		{
			float num = playerCollider.height / 2f - playerCollider.center.y;
			if (rb.velocity != Vector3.zero && Physics.Raycast(base.transform.position, base.transform.up * -1f, out var hitInfo2, num + 1f, lmask, QueryTriggerInteraction.Ignore))
			{
				Vector3 target = new Vector3(base.transform.position.x, base.transform.position.y - hitInfo2.distance + num, base.transform.position.z);
				base.transform.position = Vector3.MoveTowards(base.transform.position, target, hitInfo2.distance * Time.deltaTime * 10f);
				if (rb.velocity.y > 0f)
				{
					rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
				}
			}
		}
		if (gc.heavyFall)
		{
			slamForce += Time.deltaTime * 5f;
			if (Physics.Raycast(gc.transform.position + base.transform.up, base.transform.up * -1f, out var hitInfo3, 5f, lmask) || Physics.SphereCast(gc.transform.position + base.transform.up, 1f, base.transform.up * -1f, out hitInfo3, 5f, lmask))
			{
				Breakable component = hitInfo3.collider.GetComponent<Breakable>();
				if (component != null && ((component.weak && !component.precisionOnly) || component.forceGroundSlammable) && !component.unbreakable)
				{
					UnityEngine.Object.Instantiate(impactDust, hitInfo3.point, Quaternion.identity);
					component.Break();
				}
				if (hitInfo3.collider.gameObject.TryGetComponent<Bleeder>(out var component2))
				{
					component2.GetHit(hitInfo3.point, GoreType.Head);
				}
				if (hitInfo3.transform.TryGetComponent<Idol>(out var component3))
				{
					component3.Death();
				}
			}
		}
		if (stillHolding && MonoSingleton<InputManager>.Instance.InputSource.Slide.WasCanceledThisFrame)
		{
			stillHolding = false;
		}
		if (activated)
		{
			if (!GameStateManager.Instance.PlayerInputLocked && MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame && (!falling || gc.canJump || wc.CheckForEnemyCols()) && !jumpCooldown)
			{
				if (gc.canJump || wc.CheckForEnemyCols())
				{
					currentWallJumps = 0;
					rocketJumps = 0;
					hammerJumps = 0;
					clingFade = 0f;
					rocketRides = 0;
				}
				Jump();
			}
			if (!gc.onGround && wc.onWall)
			{
				if (!sliding && Physics.Raycast(base.transform.position, movementDirection, out var hitInfo4, 1f, lmask))
				{
					if (rb.velocity.y < -1f && !gc.heavyFall)
					{
						rb.velocity = new Vector3(Mathf.Clamp(rb.velocity.x, -1f, 1f), -2f * clingFade, Mathf.Clamp(rb.velocity.z, -1f, 1f));
						if (scrapeParticle == null)
						{
							scrapeParticle = UnityEngine.Object.Instantiate(scrapePrefab, hitInfo4.point, Quaternion.identity);
						}
						scrapeParticle.transform.position = new Vector3(hitInfo4.point.x, hitInfo4.point.y + 1f, hitInfo4.point.z);
						scrapeParticle.transform.forward = hitInfo4.normal;
						clingFade = Mathf.MoveTowards(clingFade, 50f, Time.deltaTime * 4f);
					}
				}
				else if (scrapeParticle != null)
				{
					UnityEngine.Object.Destroy(scrapeParticle);
					scrapeParticle = null;
				}
				if (!GameStateManager.Instance.PlayerInputLocked && MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame && !jumpCooldown && currentWallJumps < 3 && (bool)wc && wc.CheckForCols())
				{
					WallJump();
				}
			}
			else if (scrapeParticle != null)
			{
				UnityEngine.Object.Destroy(scrapeParticle);
				scrapeParticle = null;
			}
		}
		if (!GameStateManager.Instance.PlayerInputLocked && !GameStateManager.Instance.IsStateActive("alter-menu"))
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame && (gc.onGround || (float)gc.sinceLastGrounded < 0.03f) && activated && (!slowMode || crouching) && !GameStateManager.Instance.PlayerInputLocked && !sliding)
			{
				StartSlide();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame && !gc.onGround && !sliding && !jumping && activated && !slowMode && !GameStateManager.Instance.PlayerInputLocked && Physics.Raycast(gc.transform.position + base.transform.up, base.transform.up * -1f, out var _, 2f, lmask, QueryTriggerInteraction.Ignore))
			{
				StartSlide();
			}
		}
		if ((MonoSingleton<InputManager>.Instance.InputSource.Slide.WasCanceledThisFrame || (slowMode && !crouching)) && sliding)
		{
			StopSlide();
		}
		if (sliding && activated)
		{
			standing = false;
			slideLength += Time.deltaTime;
			if (cc.defaultPos.y != cc.originalPos.y - 0.625f)
			{
				Vector3 vector2 = new Vector3(cc.originalPos.x, cc.originalPos.y - 0.625f, cc.originalPos.z);
				cc.defaultPos = Vector3.MoveTowards(cc.defaultPos, vector2, ((cc.defaultPos - vector2).magnitude + 0.5f) * Time.deltaTime * 20f);
			}
			Vector3 normalized = Vector3.ProjectOnPlane(rb.velocity.normalized, Vector3.up).normalized;
			if (currentSlideParticle != null)
			{
				currentSlideParticle.transform.position = base.transform.position + normalized * 10f;
				currentSlideParticle.transform.forward = -dodgeDirection;
				slideTrail.colorOverLifetime = ((boostLeft > 0f && base.gameObject.layer == 15) ? invincibleSlideGradient : normalSlideGradient);
			}
			if (slideSafety > 0f)
			{
				slideSafety -= Time.deltaTime * 5f;
			}
			if (gc.onGround || wc.onWall)
			{
				slideScrape.transform.position = base.transform.position + normalized;
				slideScrape.transform.forward = -normalized;
				cc.CameraShake(0.1f);
			}
			else
			{
				slideScrape.transform.position = Vector3.one * 5000f;
			}
			if (rising)
			{
				if (cc.defaultPos != cc.originalPos - Vector3.up * 0.625f)
				{
					cc.defaultPos = Vector3.MoveTowards(cc.defaultPos, cc.originalPos, ((cc.originalPos - cc.defaultPos).magnitude + 0.5f) * Time.deltaTime * 10f);
				}
				else
				{
					rising = false;
				}
			}
		}
		else if ((bool)groundProperties && groundProperties.forceCrouch)
		{
			playerCollider.height = 1.25f;
			crouching = true;
			if (standing)
			{
				standing = false;
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 1.125f, base.transform.position.z);
				gc.transform.localPosition = groundCheckPos + Vector3.up * 1.125f;
			}
			if (cc.defaultPos != cc.originalPos - Vector3.up * 0.625f)
			{
				cc.defaultPos = Vector3.MoveTowards(cc.defaultPos, cc.originalPos - Vector3.up * 0.625f, ((cc.originalPos - Vector3.up * 0.625f - cc.defaultPos).magnitude + 0.5f) * Time.deltaTime * 10f);
			}
		}
		else
		{
			if (activated)
			{
				if ((bool)playerCollider && playerCollider.height != 3.5f)
				{
					if (!Physics.Raycast(base.transform.position, Vector3.up, 2.25f, lmask, QueryTriggerInteraction.Ignore) && !Physics.SphereCast(new Ray(base.transform.position, Vector3.up), 0.5f, 2f, lmask, QueryTriggerInteraction.Ignore))
					{
						playerCollider.height = 3.5f;
						gc.transform.localPosition = groundCheckPos;
						if (Physics.Raycast(base.transform.position, Vector3.up * -1f, 2.25f, lmask, QueryTriggerInteraction.Ignore))
						{
							base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 1.125f, base.transform.position.z);
						}
						else
						{
							base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.625f, base.transform.position.z);
							cc.defaultPos = cc.originalPos;
							standing = true;
						}
						if (crouching)
						{
							crouching = false;
							slowMode = false;
						}
					}
					else
					{
						crouching = true;
						slowMode = true;
					}
				}
				else if (cc.defaultPos.y != cc.originalPos.y)
				{
					cc.defaultPos = Vector3.MoveTowards(cc.defaultPos, cc.originalPos, (cc.originalPos.y - cc.defaultPos.y + 0.5f) * Time.deltaTime * 10f);
				}
				else
				{
					standing = true;
				}
				if (rising)
				{
					if (cc.defaultPos != cc.originalPos)
					{
						cc.defaultPos = Vector3.MoveTowards(cc.defaultPos, cc.originalPos, ((cc.originalPos - cc.defaultPos).magnitude + 0.5f) * Time.deltaTime * 10f);
					}
					else
					{
						rising = false;
					}
				}
			}
			if (currentSlideParticle != null)
			{
				UnityEngine.Object.Destroy(currentSlideParticle);
			}
			if (slideScrape != null)
			{
				UnityEngine.Object.Destroy(slideScrape);
			}
		}
		if (rising && Vector3.Distance(cc.defaultPos, cc.originalPos) > 10f)
		{
			rising = false;
			cc.defaultPos = cc.originalPos;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.WasPerformedThisFrame && activated && !slowMode && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (((bool)groundProperties && !groundProperties.canDash) || modNoDashSlide)
			{
				if (modNoDashSlide || !groundProperties.silentDashFail)
				{
					UnityEngine.Object.Instantiate(staminaFailSound);
				}
			}
			else if (boostCharge >= 100f)
			{
				if (sliding)
				{
					StopSlide();
				}
				boostLeft = 100f;
				dashStorage = 1f;
				boost = true;
				dodgeDirection = movementDirection;
				if (dodgeDirection == Vector3.zero)
				{
					dodgeDirection = base.transform.forward;
				}
				Quaternion identity = Quaternion.identity;
				identity.SetLookRotation(dodgeDirection * -1f);
				UnityEngine.Object.Instantiate(dodgeParticle, base.transform.position + dodgeDirection * 10f, identity);
				if (!asscon.majorEnabled || !asscon.infiniteStamina)
				{
					boostCharge -= 100f;
				}
				if (dodgeDirection == base.transform.forward)
				{
					cc.dodgeDirection = 0;
				}
				else if (dodgeDirection == base.transform.forward * -1f)
				{
					cc.dodgeDirection = 1;
				}
				else
				{
					cc.dodgeDirection = 2;
				}
				aud.clip = dodgeSound;
				aud.volume = 1f;
				aud.pitch = 1f;
				aud.Play();
				MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Dash);
				if (gc.heavyFall)
				{
					fallSpeed = 0f;
					gc.heavyFall = false;
					if (currentFallParticle != null)
					{
						UnityEngine.Object.Destroy(currentFallParticle);
					}
				}
			}
			else
			{
				UnityEngine.Object.Instantiate(staminaFailSound);
			}
		}
		if (!walking && vector.sqrMagnitude > 0f && !sliding && gc.onGround)
		{
			walking = true;
			anim.SetBool("WalkF", value: true);
		}
		else if ((walking && Mathf.Approximately(vector.sqrMagnitude, 0f)) || !gc.onGround || sliding)
		{
			walking = false;
			anim.SetBool("WalkF", value: false);
		}
		if (hurting && hp > 0)
		{
			currentColor.a -= Time.deltaTime;
			hurtScreen.color = currentColor;
			if (currentColor.a <= 0f)
			{
				hurting = false;
			}
		}
		if (safeExplosionLaunchCooldown > 0f)
		{
			safeExplosionLaunchCooldown = Mathf.MoveTowards(safeExplosionLaunchCooldown, 0f, Time.deltaTime);
		}
		if (boostCharge != 300f && !sliding && !slowMode)
		{
			float num2 = 1f;
			if (difficulty == 1)
			{
				num2 = 1.5f;
			}
			else if (difficulty == 0)
			{
				num2 = 2f;
			}
			boostCharge = Mathf.MoveTowards(boostCharge, 300f, 70f * Time.deltaTime * num2);
		}
		Vector3 vector3 = hudOriginalPos - cc.transform.InverseTransformDirection(rb.velocity) / 1000f;
		float num3 = Vector3.Distance(vector3, screenHud.transform.localPosition);
		screenHud.transform.localPosition = Vector3.MoveTowards(screenHud.transform.localPosition, vector3, Time.deltaTime * 15f * num3);
		Vector3 vector4 = Vector3.ClampMagnitude(camOriginalPos - cc.transform.InverseTransformDirection(rb.velocity) / 350f * -1f, 0.2f);
		float num4 = Vector3.Distance(vector4, hudCam.transform.localPosition);
		hudCam.transform.localPosition = Vector3.MoveTowards(hudCam.transform.localPosition, vector4, Time.deltaTime * 25f * num4);
		int rankIndex = MonoSingleton<StyleHUD>.Instance.rankIndex;
		if (rankIndex == 7 || difficulty <= 1)
		{
			antiHp = 0f;
			antiHpCooldown = 0f;
		}
		else if (antiHpCooldown > 0f)
		{
			if (rankIndex >= 4)
			{
				antiHpCooldown = Mathf.MoveTowards(antiHpCooldown, 0f, Time.deltaTime * (float)(rankIndex / 2));
			}
			else
			{
				antiHpCooldown = Mathf.MoveTowards(antiHpCooldown, 0f, Time.deltaTime);
			}
		}
		else if (antiHp > 0f)
		{
			if (rankIndex >= 4)
			{
				antiHp = Mathf.MoveTowards(antiHp, 0f, Time.deltaTime * (float)rankIndex * 10f);
			}
			else
			{
				antiHp = Mathf.MoveTowards(antiHp, 0f, Time.deltaTime * 15f);
			}
		}
		if (!gc.heavyFall && currentFallParticle != null)
		{
			UnityEngine.Object.Destroy(currentFallParticle);
		}
	}

	private void FixedUpdate()
	{
		friction = modForcedFrictionMultip * (groundProperties ? groundProperties.friction : 1f);
		if (sliding)
		{
			if (slideSafety <= 0f)
			{
				Vector3 vector = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
				float num = 10f;
				if ((bool)groundProperties && groundProperties.speedMultiplier < 1f)
				{
					num *= groundProperties.speedMultiplier;
				}
				if (vector.magnitude < num && !rising)
				{
					slideSafety = Mathf.MoveTowards(slideSafety, -0.1f, Time.deltaTime);
					if (slideSafety <= -0.1f)
					{
						StopSlide();
					}
				}
				else
				{
					slideSafety = 0f;
				}
			}
			if (wc.onWall && rb.velocity.y < 0f)
			{
				rb.AddForce(-Physics.gravity * 0.4f, ForceMode.Acceleration);
			}
		}
		if (!sliding && activated)
		{
			framesSinceSlide++;
			if (gc.heavyFall)
			{
				preSlideDelay = 0.2f;
				preSlideSpeed = slamForce;
				if (Physics.SphereCast(base.transform.position - Vector3.up * 1.5f, 0.35f, Vector3.down, out var hitInfo, Time.fixedDeltaTime * Mathf.Abs(rb.velocity.y), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
				{
					base.transform.position = hitInfo.point + Vector3.up * 1.5f;
					rb.velocity = Vector3.zero;
				}
			}
			else if (!boost && falling && rb.velocity.magnitude / 24f > preSlideSpeed)
			{
				preSlideSpeed = rb.velocity.magnitude / 24f;
				preSlideDelay = 0.2f;
			}
			else
			{
				preSlideDelay = Mathf.MoveTowards(preSlideDelay, 0f, Time.fixedDeltaTime);
				if (preSlideDelay <= 0f)
				{
					preSlideDelay = 0.2f;
					preSlideSpeed = rb.velocity.magnitude / 24f;
				}
			}
		}
		if (!boost)
		{
			Move();
			return;
		}
		rb.useGravity = true;
		Dodge();
	}

	private void Move()
	{
		slideEnding = false;
		if (!hurting && !levelOver)
		{
			base.gameObject.layer = 2;
			exploded = false;
		}
		if (gc.onGround && !jumping)
		{
			currentWallJumps = 0;
			rocketJumps = 0;
			hammerJumps = 0;
			rocketRides = 0;
		}
		if (gc.onGround && friction > 0f && !jumping)
		{
			float y = rb.velocity.y;
			if (slopeCheck.onGround && movementDirection.x == 0f && movementDirection.z == 0f)
			{
				y = 0f;
				rb.useGravity = false;
			}
			else
			{
				rb.useGravity = true;
			}
			float num = 2.75f;
			if (slowMode)
			{
				num = 1.25f;
			}
			if ((bool)groundProperties)
			{
				num *= groundProperties.speedMultiplier;
			}
			movementDirection2 = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * num, y, movementDirection.z * walkSpeed * Time.deltaTime * num);
			Vector3 vector = pushForce;
			if ((bool)groundProperties && groundProperties.push)
			{
				Vector3 vector2 = groundProperties.pushForce;
				if (groundProperties.pushDirectionRelative)
				{
					vector2 = groundProperties.transform.rotation * vector2;
				}
				vector += vector2;
			}
			rb.velocity = Vector3.Lerp(rb.velocity, movementDirection2 + vector, 0.25f * friction);
			anim.SetBool("Run", value: false);
		}
		else
		{
			rb.useGravity = true;
			if (slowMode)
			{
				movementDirection2 = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * 1.25f, rb.velocity.y, movementDirection.z * walkSpeed * Time.deltaTime * 1.25f);
			}
			else
			{
				movementDirection2 = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * 2.75f, rb.velocity.y, movementDirection.z * walkSpeed * Time.deltaTime * 2.75f);
			}
			airDirection.y = 0f;
			if ((movementDirection2.x > 0f && rb.velocity.x < movementDirection2.x) || (movementDirection2.x < 0f && rb.velocity.x > movementDirection2.x))
			{
				airDirection.x = movementDirection2.x;
			}
			else
			{
				airDirection.x = 0f;
			}
			if ((movementDirection2.z > 0f && rb.velocity.z < movementDirection2.z) || (movementDirection2.z < 0f && rb.velocity.z > movementDirection2.z))
			{
				airDirection.z = movementDirection2.z;
			}
			else
			{
				airDirection.z = 0f;
			}
			rb.AddForce(airDirection.normalized * airAcceleration);
		}
	}

	private void Dodge()
	{
		if (sliding)
		{
			if (!hurting && !levelOver && boostLeft <= 0f)
			{
				base.gameObject.layer = 2;
				exploded = false;
			}
			float num = 1f;
			if (preSlideSpeed > 1f)
			{
				if (preSlideSpeed > 3f)
				{
					preSlideSpeed = 3f;
				}
				num = preSlideSpeed;
				if (gc.onGround && friction != 0f)
				{
					preSlideSpeed -= Time.fixedDeltaTime * preSlideSpeed * friction;
				}
				preSlideDelay = 0f;
			}
			if (modNoDashSlide)
			{
				StopSlide();
				return;
			}
			if ((bool)groundProperties)
			{
				if (!groundProperties.canSlide)
				{
					StopSlide();
					return;
				}
				num *= groundProperties.speedMultiplier;
			}
			Vector3 vector = new Vector3(dodgeDirection.x * walkSpeed * Time.deltaTime * 4f * num, rb.velocity.y, dodgeDirection.z * walkSpeed * Time.deltaTime * 4f * num);
			if ((bool)groundProperties && groundProperties.push)
			{
				Vector3 vector2 = groundProperties.pushForce;
				if (groundProperties.pushDirectionRelative)
				{
					vector2 = groundProperties.transform.rotation * vector2;
				}
				vector += vector2;
			}
			if (boostLeft > 0f)
			{
				dashStorage = Mathf.MoveTowards(dashStorage, 0f, Time.fixedDeltaTime);
				if (dashStorage <= 0f)
				{
					boostLeft = 0f;
				}
			}
			movementDirection = Vector3.ClampMagnitude(MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>().x * base.transform.right, 1f) * 5f;
			if (!MonoSingleton<HookArm>.Instance || !MonoSingleton<HookArm>.Instance.beingPulled)
			{
				rb.velocity = vector + pushForce + movementDirection;
			}
			else
			{
				StopSlide();
			}
			return;
		}
		float y = 0f;
		if (slideEnding)
		{
			y = rb.velocity.y;
		}
		float num2 = 2.75f;
		movementDirection2 = new Vector3(dodgeDirection.x * walkSpeed * Time.deltaTime * num2, y, dodgeDirection.z * walkSpeed * Time.deltaTime * num2);
		base.gameObject.layer = 15;
		if (slideEnding)
		{
			slideEnding = false;
			if (!gc.onGround || friction == 0f)
			{
				boost = false;
				return;
			}
		}
		if (boostLeft > 0f)
		{
			rb.velocity = movementDirection2 * 3f;
			boostLeft -= 4f;
			return;
		}
		if (!gc.onGround || friction != 0f)
		{
			rb.velocity = movementDirection2;
		}
		boost = false;
	}

	public void Jump()
	{
		float num = 1500f;
		if (modNoJump || (bool)groundProperties)
		{
			if (modNoJump || !groundProperties.canJump)
			{
				if (modNoJump || !groundProperties.silentJumpFail)
				{
					aud.clip = jumpSound;
					aud.volume = 0.75f;
					aud.pitch = 0.25f;
					aud.Play();
				}
				return;
			}
			num *= groundProperties.jumpForceMultiplier;
		}
		jumping = true;
		Invoke("NotJumping", 0.25f);
		falling = true;
		if (quakeJump)
		{
			UnityEngine.Object.Instantiate(quakeJumpSound).GetComponent<AudioSource>().pitch = 1f + UnityEngine.Random.Range(0f, 0.1f);
		}
		aud.clip = jumpSound;
		if (gc.superJumpChance > 0f)
		{
			aud.volume = 0.85f;
			aud.pitch = 2f;
		}
		else
		{
			aud.volume = 0.75f;
			aud.pitch = 1f;
		}
		aud.Play();
		rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
		if (sliding)
		{
			if (slowMode)
			{
				rb.AddForce(Vector3.up * jumpPower * num);
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * num * 2f);
			}
			StopSlide();
		}
		else if (boost)
		{
			if (boostCharge >= 100f)
			{
				if (!asscon.majorEnabled || !asscon.infiniteStamina)
				{
					boostCharge -= 100f;
				}
				UnityEngine.Object.Instantiate(dashJumpSound);
			}
			else
			{
				rb.velocity = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * 2.75f, 0f, movementDirection.z * walkSpeed * Time.deltaTime * 2.75f);
				UnityEngine.Object.Instantiate(staminaFailSound);
			}
			if (slowMode)
			{
				rb.AddForce(Vector3.up * jumpPower * num * 0.75f);
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * num * 1.5f);
			}
		}
		else if (slowMode)
		{
			rb.AddForce(Vector3.up * jumpPower * num * 1.25f);
		}
		else if (gc.superJumpChance > 0f || gc.extraJumpChance > 0f)
		{
			if (slamForce < 5.5f)
			{
				rb.AddForce(Vector3.up * jumpPower * num * (3f + (slamForce - 1f)));
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * num * 12.5f);
			}
			slamForce = 0f;
		}
		else
		{
			rb.AddForce(Vector3.up * jumpPower * num * 2.6f);
		}
		TrySSJ(dodgeDirection.normalized, 0.5f, (int frame) => 1f / Mathf.Pow(2f, frame - 1));
		jumpCooldown = true;
		Invoke("JumpReady", 0.2f);
		boost = false;
	}

	private void TrySSJ(Vector3 direction, float speedMultiplier, Func<int, float> speedLossFormula)
	{
		if (framesSinceSlide > 0 && (float)framesSinceSlide < ssjMaxFrames && !boost)
		{
			float num = speedLossFormula(framesSinceSlide);
			float num2 = speedMultiplier * walkSpeed * 2.75f * 3f * Time.fixedDeltaTime;
			float y = rb.velocity.y;
			float num3 = num * num2;
			rb.velocity = velocityAfterSlide + direction * num3;
			rb.velocity = new Vector3(rb.velocity.x, y, rb.velocity.z);
			rb.velocity = Mathf.Min(rb.velocity.magnitude, 100f) * rb.velocity.normalized;
			if (MonoSingleton<PrefsManager>.Instance.GetBool("ssjIndicator"))
			{
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle($"SSJ: {rb.velocity.magnitude} (+{num3})u/s, {num * 100f}% speed (Frame {framesSinceSlide}/{ssjMaxFrames - 1f})", null, ignoreSetting: true);
			}
		}
	}

	private void WallJump()
	{
		jumping = true;
		Invoke("NotJumping", 0.25f);
		currentWallJumps++;
		if (gc.heavyFall)
		{
			slamStorage = true;
		}
		if (quakeJump)
		{
			UnityEngine.Object.Instantiate(quakeJumpSound).GetComponent<AudioSource>().pitch = 1.1f + (float)currentWallJumps * 0.05f;
		}
		aud.clip = jumpSound;
		aud.pitch += 0.25f;
		aud.volume = 0.75f;
		aud.Play();
		if (currentWallJumps == 3)
		{
			aud2.clip = finalWallJump;
			aud2.volume = 0.75f;
			aud2.Play();
		}
		wallJumpPos = base.transform.position - wc.poc;
		if (NonConvexJumpDebug.Active)
		{
			for (int i = 0; i < 4; i++)
			{
				NonConvexJumpDebug.CreateBall(Color.white, Vector3.Lerp(base.transform.position, wc.poc, (float)i / 4f), 0.4f);
			}
		}
		if (sliding || framesSinceSlide < MonoSingleton<PrefsManager>.Instance.GetIntLocal("ssjMaxFrames", 4))
		{
			Vector3.ProjectOnPlane(rb.velocity, Vector3.up);
			Vector3 vector = Vector3.Reflect(dodgeDirection.normalized, wallJumpPos.normalized);
			vector = Vector3.ProjectOnPlane(vector, Vector3.up).normalized;
			vector = (dodgeDirection = (vector + wallJumpPos.normalized * 0.35f).normalized);
			rb.velocity = vector.normalized * rb.velocity.magnitude;
			TrySSJ(vector, 0.75f, (int frame) => (ssjMaxFrames - (float)frame + 1f) / ssjMaxFrames);
			rb.velocity = new Vector3(rb.velocity.x, Mathf.Max(rb.velocity.y, 15f), rb.velocity.z);
		}
		else
		{
			boost = false;
			rb.velocity = Vector3.zero;
			Vector3 vector2 = new Vector3(wallJumpPos.normalized.x, 1f, wallJumpPos.normalized.z);
			rb.AddForce(vector2 * 2000f * wallJumpPower);
		}
		jumpCooldown = true;
		Invoke("JumpReady", 0.1f);
	}

	private void OnCollisionEnter(Collision other)
	{
		if (sliding)
		{
			ContactPoint[] contacts = other.contacts;
			foreach (ContactPoint contactPoint in contacts)
			{
				Vector3.Angle(Vector3.ProjectOnPlane(dodgeDirection, contactPoint.normal).normalized, dodgeDirection);
				_ = 60f;
			}
		}
	}

	public void Launch(Vector3 direction, float multiplier = 8f, bool ignoreMass = false)
	{
		if (((bool)groundProperties && !groundProperties.launchable) || (direction == Vector3.down && gc.onGround))
		{
			return;
		}
		jumping = true;
		Invoke("NotJumping", 0.5f);
		jumpCooldown = true;
		Invoke("JumpReady", 0.2f);
		boost = false;
		if (gc.heavyFall)
		{
			fallSpeed = 0f;
			gc.heavyFall = false;
			if (currentFallParticle != null)
			{
				UnityEngine.Object.Destroy(currentFallParticle);
			}
		}
		if (direction.magnitude > 0f)
		{
			rb.velocity = Vector3.zero;
		}
		rb.AddForce(Vector3.ClampMagnitude(direction, 1000f) * multiplier, (!ignoreMass) ? ForceMode.Impulse : ForceMode.VelocityChange);
	}

	public void LaunchFromPoint(Vector3 position, float strength, float maxDistance = 1f)
	{
		if (!groundProperties || groundProperties.launchable)
		{
			Vector3 vector = (base.transform.position - position).normalized;
			if (position == base.transform.position)
			{
				vector = Vector3.up;
			}
			Vector3 direction;
			if (jumping)
			{
				direction = vector * maxDistance * strength;
				direction.y = 0.5f * maxDistance * strength;
			}
			else
			{
				float num = maxDistance - Vector3.Distance(base.transform.position, position);
				direction = vector * num * strength;
				direction.y = 0.5f * num * strength;
			}
			Launch(direction);
		}
	}

	public void LaunchFromPointAtSpeed(Vector3 position, float speed)
	{
		if (!groundProperties || groundProperties.launchable)
		{
			Vector3 vector = (base.transform.position - position).normalized;
			if (position == base.transform.position)
			{
				vector = Vector3.up;
			}
			Vector3 direction = vector * speed;
			direction.y = Mathf.Max(0.5f * speed, direction.y);
			Launch(direction, 1f, ignoreMass: true);
		}
	}

	public void Slamdown(float strength)
	{
		boost = false;
		if (gc.heavyFall)
		{
			fallSpeed = 0f;
			gc.heavyFall = false;
			if (currentFallParticle != null)
			{
				UnityEngine.Object.Destroy(currentFallParticle);
			}
		}
		rb.velocity = Vector3.zero;
		rb.velocity = new Vector3(0f, 0f - strength, 0f);
	}

	private void JumpReady()
	{
		jumpCooldown = false;
	}

	public void FakeHurt(bool silent = false)
	{
		currentColor.a = 0.25f;
		hurting = true;
		cc.CameraShake(0.1f);
		if (!silent)
		{
			hurtAud.pitch = UnityEngine.Random.Range(0.8f, 1f);
			hurtAud.PlayOneShot(hurtAud.clip);
		}
	}

	public void GetHurt(int damage, bool invincible, float scoreLossMultiplier = 1f, bool explosion = false, bool instablack = false, float hardDamageMultiplier = 0.35f, bool ignoreInvincibility = false)
	{
		if (dead || levelOver || !(!invincible || base.gameObject.layer != 15 || ignoreInvincibility) || damage <= 0)
		{
			return;
		}
		if (explosion)
		{
			exploded = true;
		}
		if (asscon.majorEnabled)
		{
			damage = Mathf.RoundToInt((float)damage * asscon.damageTaken);
		}
		if (Invincibility.Enabled)
		{
			damage = 0;
		}
		if (invincible)
		{
			base.gameObject.layer = 15;
		}
		if (damage >= 50)
		{
			currentColor.a = 0.8f;
		}
		else
		{
			currentColor.a = 0.5f;
		}
		hurting = true;
		cc.CameraShake(damage / 20);
		hurtAud.pitch = UnityEngine.Random.Range(0.8f, 1f);
		hurtAud.PlayOneShot(hurtAud.clip);
		if (hp - damage > 0)
		{
			hp -= damage;
		}
		else
		{
			hp = 0;
		}
		if (invincible && scoreLossMultiplier != 0f && difficulty >= 2 && (!asscon.majorEnabled || !asscon.disableHardDamage) && hp <= 100)
		{
			if (antiHp + (float)damage * hardDamageMultiplier < 99f)
			{
				antiHp += (float)damage * hardDamageMultiplier;
			}
			else
			{
				antiHp = 99f;
			}
			if (antiHpCooldown == 0f)
			{
				antiHpCooldown += 1f;
			}
			if (difficulty >= 3)
			{
				antiHpCooldown += 1f;
			}
			antiHpFlash.Flash(1f);
			antiHpCooldown += damage / 20;
		}
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		if (scoreLossMultiplier > 0.5f)
		{
			shud.RemovePoints(0);
			shud.DescendRank();
		}
		else
		{
			shud.RemovePoints(Mathf.RoundToInt(damage));
		}
		StatsManager statsManager = MonoSingleton<StatsManager>.Instance;
		if (damage <= 200)
		{
			statsManager.stylePoints -= Mathf.RoundToInt((float)(damage * 5) * scoreLossMultiplier);
		}
		else
		{
			statsManager.stylePoints -= Mathf.RoundToInt(1000f * scoreLossMultiplier);
		}
		statsManager.tookDamage = true;
		if (hp != 0)
		{
			return;
		}
		if (!endlessMode)
		{
			blackScreen.gameObject.SetActive(value: true);
			MonoSingleton<TimeController>.Instance.controlPitch = false;
			if (instablack)
			{
				blackColor.a = 1f;
			}
			screenHud.SetActive(value: false);
		}
		else
		{
			GetComponentInChildren<FinalCyberRank>().GameOver();
			CrowdReactions crowdReactions = MonoSingleton<CrowdReactions>.Instance;
			if (crowdReactions != null)
			{
				crowdReactions.React(crowdReactions.aww);
			}
		}
		rb.constraints = RigidbodyConstraints.None;
		if ((bool)MonoSingleton<PowerUpMeter>.Instance)
		{
			MonoSingleton<PowerUpMeter>.Instance.juice = 0f;
		}
		cc.enabled = false;
		if (gunc == null)
		{
			gunc = GetComponentInChildren<GunControl>();
		}
		gunc.NoWeapon();
		rb.constraints = RigidbodyConstraints.None;
		dead = true;
		activated = false;
		if (punch == null)
		{
			punch = GetComponentInChildren<FistControl>();
		}
		punch.NoFist();
	}

	public void ForceAntiHP(float amount, bool silent = false, bool dontOverwriteHp = false, bool addToCooldown = true)
	{
		if ((asscon.majorEnabled && asscon.disableHardDamage) || hp > 100)
		{
			return;
		}
		amount = Mathf.Clamp(amount, 0f, 99f);
		float num = antiHp;
		if ((float)hp > 100f - amount)
		{
			if (dontOverwriteHp)
			{
				amount = 100 - hp;
			}
			else
			{
				hp = Mathf.RoundToInt(100f - amount);
			}
		}
		if (MonoSingleton<StyleHUD>.Instance.rankIndex < 7)
		{
			antiHpFlash.Flash(1f);
			if (amount > antiHp)
			{
				FakeHurt(silent);
			}
		}
		antiHp = amount;
		if (addToCooldown)
		{
			if (antiHpCooldown < 1f || (difficulty >= 3 && antiHpCooldown < 2f))
			{
				antiHpCooldown = ((difficulty < 3) ? 1 : 2);
			}
			if (amount - num < 50f)
			{
				antiHpCooldown += (amount - num) / 20f;
			}
			else
			{
				antiHpCooldown += 2.5f;
			}
		}
		else if (antiHpCooldown <= 1f)
		{
			antiHpCooldown = 1f;
		}
	}

	public void ForceAddAntiHP(float amount, bool silent = false, bool dontOverwriteHp = false, bool addToCooldown = true)
	{
		ForceAntiHP(antiHp + amount, silent, dontOverwriteHp, addToCooldown);
	}

	public void GetHealth(int health, bool silent, bool fromExplosion = false)
	{
		if (dead || (exploded && fromExplosion))
		{
			return;
		}
		float num = health;
		float num2 = 100f;
		if (difficulty == 0 || (difficulty == 1 && sameCheckpointRestarts > 2))
		{
			num2 = 200f;
		}
		if (num < 1f)
		{
			num = 1f;
		}
		if ((float)hp <= num2)
		{
			if ((float)hp + num < num2 - (float)Mathf.RoundToInt(antiHp))
			{
				hp += Mathf.RoundToInt(num);
			}
			else if ((float)hp != num2 - (float)Mathf.RoundToInt(antiHp))
			{
				hp = Mathf.RoundToInt(num2) - Mathf.RoundToInt(antiHp);
			}
			hpFlash.Flash(1f);
			if (!silent && health > 5)
			{
				if (greenHpAud == null)
				{
					greenHpAud = hpFlash.GetComponent<AudioSource>();
				}
				greenHpAud.Play();
			}
		}
		if (!silent && health > 5 && MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled"))
		{
			UnityEngine.Object.Instantiate(scrnBlood, fullHud.transform);
		}
	}

	public void Parry(EnemyIdentifier eid = null, string customParryText = "")
	{
		MonoSingleton<TimeController>.Instance.ParryFlash();
		exploded = false;
		GetHealth(999, silent: false);
		FullStamina();
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		if (!eid || !eid.blessed)
		{
			shud.AddPoints(100, (customParryText != "") ? ("<color=green>" + customParryText + "</color>") : "ultrakill.parry");
		}
	}

	public void SuperCharge()
	{
		GetHealth(100, silent: true);
		hp = 200;
	}

	public void Respawn()
	{
		MonoSingleton<CameraController>.Instance.cam.useOcclusionCulling = true;
		if (sliding)
		{
			StopSlide();
		}
		sameCheckpointRestarts++;
		if (difficulty == 0)
		{
			hp = 200;
		}
		else
		{
			hp = 100;
		}
		boostCharge = 299f;
		antiHp = 0f;
		antiHpCooldown = 0f;
		rb.constraints = defaultRBConstraints;
		activated = true;
		blackScreen.gameObject.SetActive(value: false);
		cc.enabled = true;
		if ((bool)MonoSingleton<PowerUpMeter>.Instance)
		{
			MonoSingleton<PowerUpMeter>.Instance.juice = 0f;
		}
		StatsManager statsManager = MonoSingleton<StatsManager>.Instance;
		statsManager.stylePoints = statsManager.stylePoints / 3 * 2;
		if (gunc == null)
		{
			gunc = GetComponentInChildren<GunControl>();
		}
		gunc.YesWeapon();
		screenHud.SetActive(value: true);
		dead = false;
		blackColor.a = 0f;
		youDiedColor.a = 0f;
		currentAllPitch = 1f;
		blackScreen.color = blackColor;
		youDiedText.color = youDiedColor;
		MonoSingleton<TimeController>.Instance.controlPitch = true;
		MonoSingleton<HookArm>.Instance?.Cancel();
		if (punch == null)
		{
			punch = GetComponentInChildren<FistControl>();
		}
		punch.activated = true;
		punch.YesFist();
		slowMode = false;
		MonoSingleton<WeaponCharges>.Instance.MaxCharges();
		if (MonoSingleton<WeaponCharges>.Instance.rocketFrozen)
		{
			MonoSingleton<WeaponCharges>.Instance.rocketLauncher.UnfreezeRockets();
		}
	}

	public void ResetHardDamage()
	{
		antiHp = 0f;
		antiHpCooldown = 0f;
	}

	private void NotJumping()
	{
		jumping = false;
	}

	private void StartSlide()
	{
		if (currentSlideParticle != null)
		{
			UnityEngine.Object.Destroy(currentSlideParticle);
		}
		if (slideScrape != null)
		{
			UnityEngine.Object.Destroy(slideScrape);
		}
		if (modNoDashSlide)
		{
			StopSlide();
		}
		else
		{
			if ((bool)MonoSingleton<HookArm>.Instance && MonoSingleton<HookArm>.Instance.beingPulled)
			{
				return;
			}
			if ((bool)groundProperties && !groundProperties.canSlide)
			{
				if (!groundProperties.silentSlideFail)
				{
					StopSlide();
				}
				return;
			}
			if (!crouching)
			{
				playerCollider.height = 1.25f;
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 1.125f, base.transform.position.z);
				gc.transform.localPosition = groundCheckPos + Vector3.up * 1.125f;
			}
			slideSafety = 1f;
			sliding = true;
			boost = true;
			dodgeDirection = movementDirection;
			if (dodgeDirection == Vector3.zero)
			{
				dodgeDirection = base.transform.forward;
			}
			Quaternion identity = Quaternion.identity;
			identity.SetLookRotation(dodgeDirection * -1f);
			currentSlideParticle = UnityEngine.Object.Instantiate(slideParticle, base.transform.position + dodgeDirection * 10f, identity);
			slideTrail = currentSlideParticle.GetComponent<ParticleSystem>().trails;
			slideTrail.colorOverLifetime = ((boostLeft > 0f) ? invincibleSlideGradient : normalSlideGradient);
			slideScrape = UnityEngine.Object.Instantiate(slideScrapePrefab, base.transform.position + dodgeDirection * 2f, identity);
			if (dodgeDirection == base.transform.forward)
			{
				cc.dodgeDirection = 0;
			}
			else if (dodgeDirection == base.transform.forward * -1f)
			{
				cc.dodgeDirection = 1;
			}
			else
			{
				cc.dodgeDirection = 2;
			}
			MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Slide);
		}
	}

	private void CheckForGasoline()
	{
		Vector3Int vector3Int = StainVoxelManager.WorldToVoxelPosition(base.transform.position + Vector3.down * 1.8333334f);
		if (!lastCheckedGasolineVoxel.HasValue || lastCheckedGasolineVoxel.Value != vector3Int)
		{
			lastCheckedGasolineVoxel = vector3Int;
			modForcedFrictionMultip = ((!MonoSingleton<StainVoxelManager>.Instance.HasProxiesAt(vector3Int, 3, VoxelCheckingShape.VerticalBox, ProxySearchMode.AnyFloor)) ? 1 : 0);
		}
		if (oilSlideEffect.gameObject.activeSelf != (modForcedFrictionMultip == 0f))
		{
			oilSlideEffect.gameObject.SetActive(modForcedFrictionMultip == 0f);
		}
		if (modForcedFrictionMultip == 0f)
		{
			float num = Mathf.Min(35f, rb.velocity.magnitude) / 35f;
			oilSlideEffect.volume = Mathf.Lerp(0f, 0.85f, num);
			oilSlideEffect.transform.localScale = Vector3.one * num;
			oilSlideEffect.pitch = Mathf.Lerp(1.75f, 2.75f, num);
		}
	}

	public void StopSlide()
	{
		if (currentSlideParticle != null)
		{
			UnityEngine.Object.Destroy(currentSlideParticle);
		}
		if (slideScrape != null)
		{
			UnityEngine.Object.Destroy(slideScrape);
		}
		UnityEngine.Object.Instantiate(slideStopSound);
		cc.ResetToDefaultPos();
		sliding = false;
		slideEnding = true;
		if (slideLength > longestSlide)
		{
			longestSlide = slideLength;
		}
		slideLength = 0f;
		if (!gc.heavyFall)
		{
			Physics.IgnoreLayerCollision(2, 12, ignore: false);
		}
		framesSinceSlide = 0;
		velocityAfterSlide = rb.velocity;
		sinceSlideEnd = 0f;
		MonoSingleton<RumbleManager>.Instance.StopVibration(RumbleProperties.Slide);
	}

	public void EmptyStamina()
	{
		boostCharge = 0f;
	}

	public void FullStamina()
	{
		boostCharge = 300f;
	}

	public void DeactivatePlayer()
	{
		activated = false;
		MonoSingleton<CameraController>.Instance.activated = false;
		MonoSingleton<GunControl>.Instance.NoWeapon();
		MonoSingleton<FistControl>.Instance.NoFist();
		if (sliding)
		{
			StopSlide();
		}
	}

	public void ActivatePlayer()
	{
		activated = true;
		MonoSingleton<CameraController>.Instance.activated = true;
		MonoSingleton<GunControl>.Instance.YesWeapon();
		MonoSingleton<FistControl>.Instance.YesFist();
	}

	public void StopMovement()
	{
		if (sliding)
		{
			StopSlide();
		}
		if (boost)
		{
			boostLeft = 0f;
			boost = false;
		}
		movementDirection = Vector3.zero;
		rb.velocity = Vector3.zero;
	}

	public void DeactivateMovement()
	{
		activated = false;
		movementDirection = Vector3.zero;
	}

	public void ReactivateMovement()
	{
		activated = true;
		punch.YesFist();
	}

	public void LockMovementAxes()
	{
		rb.constraints = (RigidbodyConstraints)122;
	}

	public void UnlockMovementAxes()
	{
		rb.constraints = RigidbodyConstraints.FreezeRotation;
	}
}



public class NextRoomInfo : MonoBehaviour
{
	public GameObject nextRoom;
}



public static class NormalSolver
{
	private struct VertexKey
	{
		private readonly long _x;

		private readonly long _y;

		private readonly long _z;

		private const int Tolerance = 100000;

		private const long FNV32Init = 2166136261L;

		private const long FNV32Prime = 16777619L;

		public VertexKey(Vector3 position)
		{
			_x = (long)Mathf.Round(position.x * 100000f);
			_y = (long)Mathf.Round(position.y * 100000f);
			_z = (long)Mathf.Round(position.z * 100000f);
		}

		public override bool Equals(object obj)
		{
			VertexKey vertexKey = (VertexKey)obj;
			if (_x == vertexKey._x && _y == vertexKey._y)
			{
				return _z == vertexKey._z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			long num = 2166136261L;
			num ^= _x;
			num *= 16777619;
			num ^= _y;
			num *= 16777619;
			num ^= _z;
			return (num * 16777619).GetHashCode();
		}
	}

	private struct VertexEntry
	{
		public int MeshIndex;

		public int TriangleIndex;

		public int VertexIndex;

		public VertexEntry(int meshIndex, int triIndex, int vertIndex)
		{
			MeshIndex = meshIndex;
			TriangleIndex = triIndex;
			VertexIndex = vertIndex;
		}
	}

	public static void RecalculateNormals(this Mesh mesh, float angle)
	{
		float num = Mathf.Cos(angle * ((float)Math.PI / 180f));
		Vector3[] vertices = mesh.vertices;
		Vector3[] array = new Vector3[vertices.Length];
		Vector3[][] array2 = new Vector3[mesh.subMeshCount][];
		Dictionary<VertexKey, List<VertexEntry>> dictionary = new Dictionary<VertexKey, List<VertexEntry>>(vertices.Length);
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			int[] triangles = mesh.GetTriangles(i);
			array2[i] = new Vector3[triangles.Length / 3];
			for (int j = 0; j < triangles.Length; j += 3)
			{
				int num2 = triangles[j];
				int num3 = triangles[j + 1];
				int num4 = triangles[j + 2];
				Vector3 lhs = vertices[num3] - vertices[num2];
				Vector3 rhs = vertices[num4] - vertices[num2];
				Vector3 normalized = Vector3.Cross(lhs, rhs).normalized;
				int num5 = j / 3;
				array2[i][num5] = normalized;
				VertexKey key = new VertexKey(vertices[num2]);
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = new List<VertexEntry>(4);
					dictionary.Add(key, value);
				}
				value.Add(new VertexEntry(i, num5, num2));
				key = new VertexKey(vertices[num3]);
				if (!dictionary.TryGetValue(key, out value))
				{
					value = new List<VertexEntry>();
					dictionary.Add(key, value);
				}
				value.Add(new VertexEntry(i, num5, num3));
				key = new VertexKey(vertices[num4]);
				if (!dictionary.TryGetValue(key, out value))
				{
					value = new List<VertexEntry>();
					dictionary.Add(key, value);
				}
				value.Add(new VertexEntry(i, num5, num4));
			}
		}
		foreach (List<VertexEntry> value2 in dictionary.Values)
		{
			for (int k = 0; k < value2.Count; k++)
			{
				Vector3 vector = default(Vector3);
				VertexEntry vertexEntry = value2[k];
				for (int l = 0; l < value2.Count; l++)
				{
					VertexEntry vertexEntry2 = value2[l];
					if (vertexEntry.VertexIndex == vertexEntry2.VertexIndex)
					{
						vector += array2[vertexEntry2.MeshIndex][vertexEntry2.TriangleIndex];
					}
					else if (Vector3.Dot(array2[vertexEntry.MeshIndex][vertexEntry.TriangleIndex], array2[vertexEntry2.MeshIndex][vertexEntry2.TriangleIndex]) >= num)
					{
						vector += array2[vertexEntry2.MeshIndex][vertexEntry2.TriangleIndex];
					}
				}
				array[vertexEntry.VertexIndex] = vector.normalized;
			}
		}
		mesh.normals = array;
	}
}



public class ObjectActivationCheck : MonoBehaviour
{
	public bool readyToActivate;

	public void StateChange(bool state)
	{
		readyToActivate = state;
	}
}



public class ObjectActivator : MonoBehaviour
{
	public bool oneTime;

	public bool disableOnExit;

	public bool dontActivateOnEnable;

	public bool reactivateOnEnable;

	public bool forEnemies;

	public bool notIfEnemiesDisabled;

	public bool onlyIfPlayerIsAlive;

	public bool dontUseEventsIfEnemiesDisabled;

	[HideInInspector]
	public bool activated;

	[HideInInspector]
	public bool activating;

	public float delay;

	private bool nonCollider;

	private int playerIn;

	[Space(20f)]
	public Collider[] ignoreColliders;

	[Space(20f)]
	public ObjectActivationCheck obac;

	public bool onlyCheckObacOnce;

	public bool disableIfObacOff;

	[Space(10f)]
	public UltrakillEvent events;

	private bool canUseEvents
	{
		get
		{
			if (DisableEnemySpawns.DisableArenaTriggers)
			{
				return !dontUseEventsIfEnemiesDisabled;
			}
			return true;
		}
	}

	private void Start()
	{
		if (!dontActivateOnEnable && GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null)
		{
			nonCollider = true;
			if ((!obac || obac.readyToActivate) && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead) && (!oneTime || (!activating && !activated)))
			{
				Invoke("Activate", delay);
			}
		}
	}

	private void Update()
	{
		if ((nonCollider || playerIn > 0) && !activating && !activated && (bool)obac && obac.readyToActivate && !onlyCheckObacOnce && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead))
		{
			activating = true;
			Invoke("Activate", delay);
		}
		if (disableIfObacOff && activated && (bool)obac && !obac.readyToActivate)
		{
			Deactivate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (ignoreColliders != null && ignoreColliders.Contains(other))
		{
			return;
		}
		if ((forEnemies && other.gameObject.CompareTag("Enemy")) || (!forEnemies && other.gameObject.CompareTag("Player")))
		{
			playerIn++;
		}
		if (((!forEnemies && (!oneTime || (!activating && !activated)) && other.gameObject.CompareTag("Player")) || (forEnemies && !activating && !activated && other.gameObject.CompareTag("Enemy"))) && playerIn == 1 && (!obac || obac.readyToActivate) && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead))
		{
			if (oneTime)
			{
				activating = true;
			}
			Invoke("Activate", delay);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (ignoreColliders == null || !ignoreColliders.Contains(other))
		{
			if ((forEnemies && other.gameObject.CompareTag("Enemy")) || (!forEnemies && other.gameObject.CompareTag("Player")))
			{
				playerIn--;
			}
			if (disableOnExit && ((!forEnemies && (activating || activated) && other.gameObject.CompareTag("Player") && playerIn == 0) || (forEnemies && (activating || activated) && other.gameObject.CompareTag("Enemy"))) && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead))
			{
				Deactivate();
			}
		}
	}

	public void ActivateDelayed(float delay)
	{
		Invoke("Activate", delay);
	}

	public void Activate()
	{
		if (base.gameObject.activeSelf && (!activated || !oneTime) && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead) && (!notIfEnemiesDisabled || !DisableEnemySpawns.DisableArenaTriggers) && (!obac || obac.readyToActivate))
		{
			activating = false;
			activated = true;
			if (canUseEvents)
			{
				events.Invoke();
			}
		}
	}

	public void Deactivate()
	{
		if (!oneTime)
		{
			activated = false;
			activating = false;
		}
		if (canUseEvents)
		{
			events.Revert();
		}
		CancelInvoke("Activate");
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			if (activated && nonCollider && disableOnExit && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead))
			{
				Deactivate();
			}
			activating = false;
			playerIn = 0;
			CancelInvoke("Activate");
		}
	}

	private void OnEnable()
	{
		if ((!activated || reactivateOnEnable) && nonCollider && (!obac || obac.readyToActivate) && (!onlyIfPlayerIsAlive || !MonoSingleton<NewMovement>.Instance.dead))
		{
			activating = true;
			Invoke("Activate", delay);
		}
	}
}



public class ObjectActivatorStay : MonoBehaviour
{
	public bool oneTime;

	public bool skippable;

	public bool disableOnExit;

	private bool activated;

	public float delay;

	public GameObject[] toActivate;

	public GameObject[] toDisActivate;

	public bool forEnemies;

	private void OnTriggerEnter(Collider other)
	{
		if ((!forEnemies && !activated && other.gameObject.CompareTag("Player")) || (forEnemies && !activated && other.gameObject.CompareTag("Enemy")))
		{
			if (oneTime)
			{
				activated = true;
			}
			Invoke("Activate", delay);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!oneTime && ((!forEnemies && !activated && other.gameObject.CompareTag("Player")) || (forEnemies && !activated && other.gameObject.CompareTag("Enemy"))) && ((toActivate.Length != 0 && !toActivate[0].activeSelf) || (toDisActivate.Length != 0 && toDisActivate[0].activeSelf)))
		{
			Activate();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!disableOnExit)
		{
			return;
		}
		GameObject[] array = toDisActivate;
		foreach (GameObject gameObject in array)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(value: true);
			}
		}
		array = toActivate;
		foreach (GameObject gameObject2 in array)
		{
			if (gameObject2 != null)
			{
				gameObject2.SetActive(value: false);
			}
		}
	}

	private void Activate()
	{
		GameObject[] array = toDisActivate;
		foreach (GameObject gameObject in array)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(value: false);
			}
		}
		array = toActivate;
		foreach (GameObject gameObject2 in array)
		{
			if (gameObject2 != null)
			{
				gameObject2.SetActive(value: true);
			}
		}
	}

	private void OnDisable()
	{
		CancelInvoke("Activate");
	}
}



public class ObjectBounds : MonoBehaviour
{
	public Transform target;

	public bool cancelMomentum;

	private Rigidbody rb;

	private Collider[] cols;

	private void Start()
	{
		cols = GetComponents<Collider>();
	}

	private void Update()
	{
		bool flag = false;
		for (int num = cols.Length - 1; num >= 0; num--)
		{
			if (!(cols[num] == null) && Vector3.Distance(cols[num].ClosestPoint(target.position), target.position) <= 0.1f)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			target.position = base.transform.position;
			if (cancelMomentum && ((bool)rb || target.TryGetComponent<Rigidbody>(out rb)))
			{
				rb.velocity = Vector3.zero;
			}
		}
	}
}



public class ObjectSpawner : MonoBehaviour
{
	public GameObject[] spawnables;

	public void SpawnObject(int objectNumber)
	{
		if (spawnables != null && spawnables.Length > objectNumber && spawnables[objectNumber] != null)
		{
			Object.Instantiate(spawnables[objectNumber], spawnables[objectNumber].transform.position, spawnables[objectNumber].transform.rotation, spawnables[objectNumber].transform.parent).SetActive(value: true);
		}
	}
}



public class ObjectTracker : MonoSingleton<ObjectTracker>
{
	public List<Grenade> grenadeList = new List<Grenade>();

	public List<Cannonball> cannonballList = new List<Cannonball>();

	public List<Landmine> landmineList = new List<Landmine>();

	public List<Magnet> magnetList = new List<Magnet>();

	public List<Zappable> zappablesList = new List<Zappable>();

	public void AddGrenade(Grenade gren)
	{
		if (!grenadeList.Contains(gren))
		{
			grenadeList.Add(gren);
		}
	}

	public void AddCannonball(Cannonball cb)
	{
		if (!cannonballList.Contains(cb))
		{
			cannonballList.Add(cb);
		}
	}

	public void AddLandmine(Landmine lm)
	{
		if (!landmineList.Contains(lm))
		{
			landmineList.Add(lm);
		}
	}

	public void AddMagnet(Magnet mag)
	{
		if (!magnetList.Contains(mag))
		{
			magnetList.Add(mag);
		}
	}

	public void AddZappable(Zappable zap)
	{
		if (!zappablesList.Contains(zap))
		{
			zappablesList.Add(zap);
		}
	}

	public void RemoveGrenade(Grenade gren)
	{
		if (grenadeList.Contains(gren))
		{
			grenadeList.Remove(gren);
		}
	}

	public void RemoveCannonball(Cannonball cb)
	{
		if (cannonballList.Contains(cb))
		{
			cannonballList.Remove(cb);
		}
	}

	public void RemoveLandmine(Landmine lm)
	{
		if (landmineList.Contains(lm))
		{
			landmineList.Remove(lm);
		}
	}

	public void RemoveMagnet(Magnet mag)
	{
		if (magnetList.Contains(mag))
		{
			magnetList.Remove(mag);
		}
	}

	public void RemoveZappable(Zappable zap)
	{
		if (zappablesList.Contains(zap))
		{
			zappablesList.Remove(zap);
		}
	}

	public Grenade GetGrenade(Transform tf)
	{
		for (int num = grenadeList.Count - 1; num >= 0; num--)
		{
			if (grenadeList[num] != null && grenadeList[num].transform == tf)
			{
				return grenadeList[num];
			}
		}
		return null;
	}

	public Cannonball GetCannonball(Transform tf)
	{
		for (int num = cannonballList.Count - 1; num >= 0; num--)
		{
			if (cannonballList[num] != null && cannonballList[num].transform == tf)
			{
				return cannonballList[num];
			}
		}
		return null;
	}

	public Landmine GetLandmine(Transform tf)
	{
		for (int num = landmineList.Count - 1; num >= 0; num--)
		{
			if (landmineList[num] != null && landmineList[num].transform == tf)
			{
				return landmineList[num];
			}
		}
		return null;
	}

	public bool HasTransform(Transform tf)
	{
		for (int num = grenadeList.Count - 1; num >= 0; num--)
		{
			if (grenadeList[num] != null && grenadeList[num].transform == tf)
			{
				return true;
			}
		}
		for (int num2 = cannonballList.Count - 1; num2 >= 0; num2--)
		{
			if (cannonballList[num2] != null && cannonballList[num2].transform == tf)
			{
				return true;
			}
		}
		for (int num3 = landmineList.Count - 1; num3 >= 0; num3--)
		{
			if (landmineList[num3] != null && landmineList[num3].transform == tf)
			{
				return true;
			}
		}
		return false;
	}

	private void Start()
	{
		Invoke("SlowUpdate", 30f);
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 30f);
		for (int num = grenadeList.Count - 1; num >= 0; num--)
		{
			if (grenadeList[num] == null)
			{
				grenadeList.RemoveAt(num);
			}
		}
		for (int num2 = cannonballList.Count - 1; num2 >= 0; num2--)
		{
			if (cannonballList[num2] == null)
			{
				cannonballList.RemoveAt(num2);
			}
		}
		for (int num3 = landmineList.Count - 1; num3 >= 0; num3--)
		{
			if (landmineList[num3] == null)
			{
				landmineList.RemoveAt(num3);
			}
		}
		for (int num4 = magnetList.Count - 1; num4 >= 0; num4--)
		{
			if (magnetList[num4] == null)
			{
				magnetList.RemoveAt(num4);
			}
		}
		for (int num5 = zappablesList.Count - 1; num5 >= 0; num5--)
		{
			if (zappablesList[num5] == null)
			{
				zappablesList.RemoveAt(num5);
			}
		}
	}
}



public class OnCheatsEnable : MonoBehaviour
{
	public bool includeMajorAssists;

	public UltrakillEvent onCheatsEnable;

	private void Update()
	{
		if (MonoSingleton<CheatsController>.Instance.cheatsEnabled || (includeMajorAssists && MonoSingleton<StatsManager>.Instance.majorUsed))
		{
			onCheatsEnable.Invoke();
			base.enabled = false;
		}
	}
}



public static class OneShotAudioExtension
{
	public static AudioSource PlayClipAtPoint(this AudioClip clip, AudioMixerGroup mixGroup, Vector3 position, int priority = 128, float spatialBlend = 0f, float volume = 1f, float pitch = 1f, AudioRolloffMode rolloffMode = AudioRolloffMode.Linear, float minimumDistance = 1f, float maximumDistance = 100f)
	{
		GameObject gameObject = new GameObject("TempAudio");
		gameObject.transform.position = position;
		AudioSource audioSource = gameObject.AddComponent<AudioSource>();
		audioSource.clip = clip;
		audioSource.outputAudioMixerGroup = mixGroup;
		audioSource.priority = priority;
		audioSource.volume = volume;
		audioSource.pitch = pitch;
		audioSource.spatialBlend = spatialBlend;
		audioSource.rolloffMode = rolloffMode;
		audioSource.minDistance = minimumDistance;
		audioSource.maxDistance = maximumDistance;
		audioSource.Play();
		Object.Destroy(gameObject, clip.length / pitch);
		return audioSource;
	}
}



public class OptionsCheckbox : MonoBehaviour
{
	public Toggle toggle;

	public string prefsKey;

	private void Awake()
	{
		toggle.SetIsOnWithoutNotify(MonoSingleton<PrefsManager>.Instance.GetBool(prefsKey, toggle.isOn));
		toggle.onValueChanged.AddListener(OnChanged);
	}

	private void OnChanged(bool value)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool(prefsKey, value);
	}
}



public class OptionsDropdown : MonoBehaviour
{
	public TMP_Dropdown dropdown;

	public string prefName;

	private void Awake()
	{
		dropdown.SetValueWithoutNotify(MonoSingleton<PrefsManager>.Instance.GetInt(prefName, dropdown.value));
		dropdown.onValueChanged.AddListener(OnValueChanged);
	}

	private void OnValueChanged(int value)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt(prefName, value);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class OptionsManager : MonoSingleton<OptionsManager>
{
	public bool mainMenu;

	[HideInInspector]
	public bool paused;

	public bool inIntro;

	public bool frozen;

	[HideInInspector]
	public GameObject pauseMenu;

	[HideInInspector]
	public GameObject optionsMenu;

	[HideInInspector]
	public GameObject progressChecker;

	private NewMovement nm;

	private GunControl gc;

	private FistControl fc;

	[HideInInspector]
	public float mouseSensitivity;

	[HideInInspector]
	public float simplifiedDistance;

	[HideInInspector]
	public bool simplifyEnemies;

	[HideInInspector]
	public bool outlinesOnly;

	private int screenWidth;

	private int screenHeight;

	[HideInInspector]
	public Toggle fullScreen;

	[HideInInspector]
	public float bloodstainChance;

	[HideInInspector]
	public float maxGore;

	[HideInInspector]
	public float maxStains;

	[HideInInspector]
	public GameObject playerPosInfo;

	[HideInInspector]
	public bool dontUnpause;

	public bool previousWeaponState;

	public static bool forceRadiance;

	public static bool forceSand;

	public static bool forcePuppet;

	public static bool forceBossBars;

	public static float radianceTier = 1f;

	protected override void Awake()
	{
		base.Awake();
		if (GameObject.FindWithTag("OptionsManager") == null)
		{
			Object.Instantiate(progressChecker);
		}
		base.transform.SetParent(null);
	}

	private void Start()
	{
		if (!MonoSingleton<CheatsController>.Instance.cheatsEnabled)
		{
			if (forceRadiance)
			{
				forceRadiance = false;
			}
			if (forceSand)
			{
				forceSand = false;
			}
			if (forcePuppet)
			{
				forcePuppet = false;
			}
			if (forceBossBars)
			{
				forceBossBars = false;
			}
			if (radianceTier != 1f)
			{
				radianceTier = 1f;
			}
		}
	}

	private void Update()
	{
		if ((Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)) && Input.GetKeyDown(KeyCode.Return))
		{
			if (!Screen.fullScreen)
			{
				Screen.SetResolution(Screen.resolutions.Last().width, Screen.resolutions.Last().height, fullscreen: true);
			}
			else
			{
				Screen.fullScreen = false;
			}
		}
		if (frozen)
		{
			return;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame && !inIntro && !mainMenu)
		{
			if (!paused)
			{
				Pause();
			}
			else if (!dontUnpause)
			{
				if (SandboxHud.SavesMenuOpen)
				{
					Debug.Log("Closing sandbox saves menu first");
					MonoSingleton<SandboxHud>.Instance.HideSavesMenu();
					return;
				}
				CloseOptions();
				UnPause();
			}
		}
		if (mainMenu && !paused)
		{
			Pause();
		}
		if (paused)
		{
			if (mainMenu)
			{
				Time.timeScale = 1f;
			}
			else
			{
				Time.timeScale = 0f;
			}
		}
	}

	public void Pause()
	{
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
			gc = nm.GetComponentInChildren<GunControl>();
			fc = nm.GetComponentInChildren<FistControl>();
		}
		if (!mainMenu)
		{
			nm.enabled = false;
			MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", 0f);
			MonoSingleton<AudioMixerController>.Instance.doorSound.SetFloat("allPitch", 0f);
			if ((bool)MonoSingleton<MusicManager>.Instance)
			{
				MonoSingleton<MusicManager>.Instance.FilterMusic();
			}
		}
		GameStateManager.Instance.RegisterState(new GameState("pause", new GameObject[2] { pauseMenu, optionsMenu })
		{
			cursorLock = LockMode.Unlock,
			cameraInputLock = LockMode.Lock,
			playerInputLock = LockMode.Lock
		});
		MonoSingleton<CameraController>.Instance.activated = false;
		gc.activated = false;
		paused = true;
		if ((bool)pauseMenu)
		{
			pauseMenu.SetActive(value: true);
		}
		VideoPlayer[] array = Object.FindObjectsOfType<VideoPlayer>();
		foreach (VideoPlayer videoPlayer in array)
		{
			if (videoPlayer.isPlaying)
			{
				videoPlayer.Pause();
			}
		}
	}

	public void UnPause()
	{
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
			gc = nm.GetComponentInChildren<GunControl>();
			fc = nm.GetComponentInChildren<FistControl>();
		}
		CloseOptions();
		paused = false;
		Time.timeScale = MonoSingleton<TimeController>.Instance.timeScale * MonoSingleton<TimeController>.Instance.timeScaleModifier;
		MonoSingleton<AudioMixerController>.Instance.allSound.SetFloat("allPitch", 1f);
		MonoSingleton<AudioMixerController>.Instance.doorSound.SetFloat("allPitch", 1f);
		if ((bool)MonoSingleton<MusicManager>.Instance)
		{
			MonoSingleton<MusicManager>.Instance.UnfilterMusic();
		}
		if (!nm.dead)
		{
			nm.enabled = true;
			MonoSingleton<CameraController>.Instance.activated = true;
			if (!fc || !fc.shopping)
			{
				if (!gc.stayUnarmed)
				{
					gc.activated = true;
				}
				if (fc != null)
				{
					fc.activated = true;
				}
			}
		}
		if ((bool)pauseMenu)
		{
			pauseMenu.SetActive(value: false);
		}
		VideoPlayer[] array = Object.FindObjectsOfType<VideoPlayer>();
		foreach (VideoPlayer videoPlayer in array)
		{
			if (videoPlayer.isPaused)
			{
				videoPlayer.Play();
			}
		}
	}

	public void Freeze()
	{
		frozen = true;
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
			gc = nm.GetComponentInChildren<GunControl>();
			fc = nm.GetComponentInChildren<FistControl>();
		}
		MonoSingleton<CameraController>.Instance.activated = false;
		previousWeaponState = !gc.noWeapons;
		gc.NoWeapon();
		gc.enabled = false;
	}

	public void UnFreeze()
	{
		frozen = false;
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
			gc = nm.GetComponentInChildren<GunControl>();
			fc = nm.GetComponentInChildren<FistControl>();
		}
		MonoSingleton<CameraController>.Instance.activated = true;
		if (previousWeaponState)
		{
			gc.YesWeapon();
		}
		gc.enabled = true;
	}

	public void RestartCheckpoint()
	{
		UnPause();
		StatsManager statsManager = MonoSingleton<StatsManager>.Instance;
		if (!statsManager.infoSent)
		{
			statsManager.Restart();
		}
	}

	public void RestartMission()
	{
		Time.timeScale = 1f;
		SceneHelper.RestartScene();
		if ((bool)MonoSingleton<MapVarManager>.Instance)
		{
			MonoSingleton<MapVarManager>.Instance.ResetStores();
		}
		Object.Destroy(base.gameObject);
	}

	public void OpenOptions()
	{
		pauseMenu.SetActive(value: false);
		optionsMenu.SetActive(value: true);
	}

	public void CloseOptions()
	{
		optionsMenu.SetActive(value: false);
		if ((bool)MonoSingleton<CheatsManager>.Instance)
		{
			MonoSingleton<CheatsManager>.Instance.HideMenu();
		}
		pauseMenu.SetActive(value: true);
	}

	public void QuitMission()
	{
		Time.timeScale = 1f;
		SceneHelper.LoadScene("Main Menu");
	}

	public void QuitGame()
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			Application.Quit();
		}
	}

	public void ChangeLevel(string levelname)
	{
		SetChangeLevelPosition(noPosition: true);
		SceneHelper.LoadScene(levelname);
	}

	public void ChangeLevelAbrupt(string scene)
	{
		SceneHelper.LoadScene(scene);
	}

	public void ChangeLevelWithPosition(string levelname)
	{
		if (Application.CanStreamedLevelBeLoaded(levelname))
		{
			SetChangeLevelPosition(noPosition: false);
			SceneManager.LoadScene(levelname);
		}
		else
		{
			SceneHelper.LoadScene("Main Menu");
		}
	}

	public void SetChangeLevelPosition(bool noPosition)
	{
		if (nm == null)
		{
			nm = MonoSingleton<NewMovement>.Instance;
		}
		PlayerPosInfo component = Object.Instantiate(playerPosInfo).GetComponent<PlayerPosInfo>();
		component.velocity = nm.GetComponent<Rigidbody>().velocity;
		component.wooshTime = nm.GetComponentInChildren<WallCheck>().GetComponent<AudioSource>().time;
		component.noPosition = noPosition;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class OptionsMenuToManager : MonoSingleton<OptionsMenuToManager>
{
	public static bool introCheckComplete = false;

	public GameObject pauseMenu;

	public GameObject optionsMenu;

	public Slider mouseSensitivitySlider;

	private bool ignoreSensitivitySliderChange;

	public Toggle reverseMouseX;

	public Toggle reverseMouseY;

	public Slider simplifiedDistanceSlider;

	public GameObject simplifiedDistanceGroup;

	public TMP_Dropdown simplifyEnemies;

	public Slider outlineThickness;

	public Slider screenShakeSlider;

	public Toggle cameraTilt;

	public Toggle parryFlash;

	public Toggle discordIntegration;

	[FormerlySerializedAs("steamLeaderboards")]
	public Toggle levelLeaderboards;

	public Toggle seasonalEvents;

	public TMP_Dropdown restartWarning;

	public Toggle sandboxWarning;

	public TMP_Dropdown resolutionDropdown;

	private Resolution[] resolutions;

	private List<Resolution> availableResolutions = new List<Resolution>();

	public Toggle fullScreen;

	public TMP_Dropdown framerateLimiter;

	public Toggle simplerExplosions;

	public Toggle simplerFire;

	public Toggle simplerSpawns;

	public Toggle noEnviroParts;

	[SerializeField]
	private Toggle simpleNailPhysicsToggle;

	[HideInInspector]
	public static bool simpleNailPhysics = true;

	public Toggle bloodAndGore;

	[HideInInspector]
	public static bool bloodEnabled = true;

	public Toggle freezeGore;

	public Slider bloodstainChanceSlider;

	public Slider maxGoreSlider;

	public Toggle subtitles;

	public Slider masterVolume;

	public Slider sfxVolume;

	public Slider musicVolume;

	public Toggle muffleMusic;

	private OptionsManager opm;

	private MusicManager muman;

	private Camera mainCam;

	private CameraController cc;

	public Slider fovSlider;

	public Slider maxBloodstainSlider;

	public TMP_Dropdown weaponPosDropdown;

	public Toggle variationMemory;

	private List<string> options;

	public AudioClip normalJump;

	public AudioClip quakeJump;

	public bool selectedSomethingThisFrame;

	[Space]
	public BasicConfirmationDialog quitDialog;

	public BasicConfirmationDialog resetDialog;

	private NewMovement nmov;

	private void LateUpdate()
	{
		selectedSomethingThisFrame = false;
	}

	private void Start()
	{
		SetPauseMenu();
		framerateLimiter.value = MonoSingleton<PrefsManager>.Instance.GetIntLocal("frameRateLimit");
		framerateLimiter.RefreshShownValue();
		FrameRateLimiter(framerateLimiter.value);
		simplerExplosions.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleExplosions");
		Physics.IgnoreLayerCollision(23, 9, simplerExplosions.isOn);
		Physics.IgnoreLayerCollision(23, 27, simplerExplosions.isOn);
		fullScreen.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("fullscreen");
		simplerFire.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleFire");
		simplerSpawns.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleSpawns");
		noEnviroParts.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("disableEnvironmentParticles");
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleNailPhysics"))
		{
			simpleNailPhysicsToggle.isOn = true;
		}
		else
		{
			simpleNailPhysics = false;
		}
		if (!MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled"))
		{
			bloodAndGore.isOn = false;
			bloodEnabled = false;
		}
		freezeGore.isOn = MonoSingleton<PrefsManager>.Instance.GetBoolLocal("freezeGore");
		simplifyEnemies.value = MonoSingleton<PrefsManager>.Instance.GetInt("simplifyEnemies");
		simplifyEnemies.RefreshShownValue();
		SimplifyEnemies(simplifyEnemies.value);
		opm.simplifiedDistance = MonoSingleton<PrefsManager>.Instance.GetFloat("simplifyEnemiesDistance");
		simplifiedDistanceSlider.value = opm.simplifiedDistance;
		MonoSingleton<PostProcessV2_Handler>.Instance.distance = MonoSingleton<PrefsManager>.Instance.GetInt("outlineThickness", 1);
		outlineThickness.value = MonoSingleton<PostProcessV2_Handler>.Instance.distance;
		opm.mouseSensitivity = MonoSingleton<PrefsManager>.Instance.GetFloatLocal("mouseSensitivity");
		UpdateSensitivitySlider(opm.mouseSensitivity);
		reverseMouseX.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("mouseReverseX");
		reverseMouseY.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("mouseReverseY");
		screenShakeSlider.value = MonoSingleton<PrefsManager>.Instance.GetFloat("screenShake") * 100f;
		cameraTilt.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("cameraTilt");
		parryFlash.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("parryFlash");
		discordIntegration.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("discordIntegration");
		levelLeaderboards.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("levelLeaderboards");
		seasonalEvents.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("seasonalEvents");
		restartWarning.SetValueWithoutNotify(MonoSingleton<PrefsManager>.Instance.GetInt("pauseMenuConfirmationDialogs"));
		restartWarning.RefreshShownValue();
		sandboxWarning.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("sandboxSaveOverwriteWarnings");
		opm.bloodstainChance = MonoSingleton<PrefsManager>.Instance.GetFloatLocal("bloodStainChance") * 100f;
		bloodstainChanceSlider.value = opm.bloodstainChance;
		opm.maxStains = MonoSingleton<PrefsManager>.Instance.GetFloatLocal("bloodStainMax", 100000f);
		maxBloodstainSlider.value = opm.maxStains / 1000f;
		opm.maxGore = MonoSingleton<PrefsManager>.Instance.GetFloatLocal("maxGore");
		maxGoreSlider.value = opm.maxGore / 100f;
		subtitles.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("subtitlesEnabled");
		muffleMusic.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("muffleMusic");
		if ((bool)MonoSingleton<SubtitleController>.Instance)
		{
			MonoSingleton<SubtitleController>.Instance.SubtitlesEnabled = subtitles.isOn;
		}
		if (GameProgressSaver.GetIntro() || introCheckComplete)
		{
			introCheckComplete = true;
			AudioListener.volume = MonoSingleton<PrefsManager>.Instance.GetFloat("allVolume");
			masterVolume.value = AudioListener.volume * 100f;
			if ((bool)MonoSingleton<AudioMixerController>.Instance)
			{
				float @float = MonoSingleton<PrefsManager>.Instance.GetFloat("sfxVolume");
				MonoSingleton<AudioMixerController>.Instance.SetSFXVolume(@float);
				sfxVolume.value = @float * 100f;
				float float2 = MonoSingleton<PrefsManager>.Instance.GetFloat("musicVolume");
				MonoSingleton<AudioMixerController>.Instance.SetMusicVolume(float2);
				musicVolume.value = float2 * 100f;
			}
		}
		resolutions = Screen.resolutions;
		availableResolutions.Clear();
		resolutionDropdown.ClearOptions();
		options = new List<string>();
		int valueWithoutNotify = 0;
		for (int i = 0; i < resolutions.Length; i++)
		{
			string item = resolutions[i].width + " x " + resolutions[i].height;
			if (!options.Contains(item))
			{
				options.Add(item);
				availableResolutions.Add(resolutions[i]);
				if (resolutions[i].width == Screen.width && resolutions[i].height == Screen.height)
				{
					valueWithoutNotify = availableResolutions.Count - 1;
				}
			}
		}
		resolutionDropdown.AddOptions(options);
		resolutionDropdown.SetValueWithoutNotify(valueWithoutNotify);
		resolutionDropdown.RefreshShownValue();
		weaponPosDropdown.value = MonoSingleton<PrefsManager>.Instance.GetInt("weaponHoldPosition");
		weaponPosDropdown.RefreshShownValue();
		variationMemory.isOn = MonoSingleton<PrefsManager>.Instance.GetBool("variationMemory");
		nmov = MonoSingleton<NewMovement>.Instance;
		cc = MonoSingleton<CameraController>.Instance;
		mainCam = cc.GetComponent<Camera>();
		cc.defaultFov = MonoSingleton<PrefsManager>.Instance.GetFloat("fieldOfView");
		mainCam.fieldOfView = cc.defaultFov;
		fovSlider.value = cc.defaultFov;
	}

	private new void OnEnable()
	{
		SetPauseMenu();
	}

	private void SetPauseMenu()
	{
		opm = MonoSingleton<OptionsManager>.Instance;
		muman = MonoSingleton<MusicManager>.Instance;
		if ((bool)opm.pauseMenu)
		{
			if (opm.pauseMenu == pauseMenu)
			{
				return;
			}
			opm.pauseMenu.SetActive(value: false);
			opm.optionsMenu.SetActive(value: false);
		}
		opm.pauseMenu = pauseMenu;
		opm.optionsMenu = optionsMenu;
	}

	public void EnableGamepadLookAndMove()
	{
		EnableGamepadLook();
		EnableGamepadMove();
	}

	public void DisableGamepadLookAndMove()
	{
		DisableGamepadLook();
		DisableGamepadMove();
	}

	public void EnableGamepadMove()
	{
		if (MonoSingleton<NewMovement>.Instance.gamepadFreezeCount > 0)
		{
			MonoSingleton<NewMovement>.Instance.gamepadFreezeCount--;
		}
	}

	public void EnableGamepadLook()
	{
		if (MonoSingleton<CameraController>.Instance.gamepadFreezeCount > 0)
		{
			MonoSingleton<CameraController>.Instance.gamepadFreezeCount--;
		}
	}

	public void DisableGamepadMove()
	{
		MonoSingleton<NewMovement>.Instance.gamepadFreezeCount++;
	}

	public void DisableGamepadLook()
	{
		MonoSingleton<CameraController>.Instance.gamepadFreezeCount++;
	}

	public void SetSelected(Selectable selectable)
	{
		selectedSomethingThisFrame = true;
		EventSystem.current.SetSelectedGameObject(selectable.gameObject);
	}

	public void ResolutionChange(int stuff)
	{
		Resolution resolution = availableResolutions[stuff];
		Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);
		MonoSingleton<PrefsManager>.Instance.SetIntLocal("resolutionWidth", resolution.width);
		MonoSingleton<PrefsManager>.Instance.SetIntLocal("resolutionHeight", resolution.height);
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("fullscreen", Screen.fullScreen);
		MonoSingleton<CameraController>.Instance.CheckAspectRatio();
	}

	public void SetFullScreen(bool stuff)
	{
		Screen.fullScreen = stuff;
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("fullscreen", stuff);
	}

	public void FrameRateLimiter(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetIntLocal("frameRateLimit", stuff);
		switch (stuff)
		{
		case 0:
			Application.targetFrameRate = -1;
			break;
		case 1:
			Application.targetFrameRate = Screen.currentResolution.refreshRate * 2;
			break;
		case 2:
			Application.targetFrameRate = 30;
			break;
		case 3:
			Application.targetFrameRate = 60;
			break;
		case 4:
			Application.targetFrameRate = 120;
			break;
		case 5:
			Application.targetFrameRate = 144;
			break;
		case 6:
			Application.targetFrameRate = 240;
			break;
		case 7:
			Application.targetFrameRate = 288;
			break;
		}
	}

	public void Pause()
	{
		opm.Pause();
	}

	public void UnPause()
	{
		opm.UnPause();
	}

	public void RestartCheckpoint()
	{
		opm.RestartCheckpoint();
	}

	public void RestartMission()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("pauseMenuConfirmationDialogs");
		string currentScene = SceneHelper.CurrentScene;
		if (@int == 0 || (@int == 1 && currentScene == "Endless"))
		{
			resetDialog.ShowDialog();
		}
		else
		{
			RestartMissionNoConfirm();
		}
	}

	public void RestartMissionNoConfirm()
	{
		opm.RestartMission();
	}

	public void OpenOptions()
	{
		opm.OpenOptions();
	}

	public void CloseOptions()
	{
		opm.CloseOptions();
	}

	public void QuitMission()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("pauseMenuConfirmationDialogs");
		string currentScene = SceneHelper.CurrentScene;
		if (@int == 0 || (@int == 1 && currentScene == "Endless"))
		{
			quitDialog.ShowDialog();
		}
		else
		{
			QuitMissionNoConfirm();
		}
	}

	public void QuitMissionNoConfirm()
	{
		opm.QuitMission();
	}

	public void QuitGame()
	{
		opm.QuitGame();
	}

	public void CheckIfTutorialBeaten()
	{
		if (!GameProgressSaver.GetTutorial())
		{
			SceneHelper.LoadScene("Tutorial");
		}
	}

	public void ChangeLevel(string levelname)
	{
		opm.ChangeLevel(levelname);
	}

	public void SimpleExplosions(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("simpleExplosions", stuff);
		Physics.IgnoreLayerCollision(23, 9, stuff);
		Physics.IgnoreLayerCollision(23, 27, stuff);
	}

	public void SimpleFire(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("simpleFire", stuff);
	}

	public void SimpleSpawns(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("simpleSpawns", stuff);
	}

	public void DisableEnviroParts(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("disableEnvironmentParticles", stuff);
		EnviroParticle[] array = Object.FindObjectsOfType<EnviroParticle>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckEnviroParticles();
		}
	}

	public void SimpleNailPhysics(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("simpleNailPhysics", stuff);
		simpleNailPhysics = stuff;
		Nail[] array = Object.FindObjectsOfType<Nail>();
		foreach (Nail nail in array)
		{
			if (nail.magnets.Count > 0 && nail.TryGetComponent<Rigidbody>(out var component))
			{
				if (simpleNailPhysics)
				{
					component.collisionDetectionMode = CollisionDetectionMode.Discrete;
				}
				else
				{
					component.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
				}
			}
		}
	}

	public void BloodAndGoreOn(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("bloodEnabled", stuff);
		bloodEnabled = stuff;
	}

	public void FreezeGore(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("freezeGore", stuff);
	}

	public void SimplifyEnemies(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("simplifyEnemies", stuff);
		bool flag = stuff != 0;
		Shader.SetGlobalFloat("_UseEdgeDetection", flag ? 1 : 0);
		opm.simplifyEnemies = flag;
		simplifiedDistanceGroup.SetActive(flag);
		PostProcessV2_Handler postProcessV2_Handler = MonoSingleton<PostProcessV2_Handler>.Instance;
		if ((bool)postProcessV2_Handler)
		{
			postProcessV2_Handler.enableJFA = flag;
		}
		opm.outlinesOnly = stuff == 1;
	}

	public void SimplifyEnemiesDistance(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("simplifyEnemiesDistance", stuff);
		opm.simplifiedDistance = stuff;
	}

	public void OutlineThickness(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("outlineThickness", (int)stuff);
		MonoSingleton<PostProcessV2_Handler>.Instance.distance = (int)stuff;
	}

	public void MouseSensitivity(float stuff)
	{
		if (!ignoreSensitivitySliderChange)
		{
			MonoSingleton<PrefsManager>.Instance.SetFloatLocal("mouseSensitivity", stuff);
			opm.mouseSensitivity = stuff;
		}
	}

	public void UpdateSensitivitySlider(float stuff)
	{
		ignoreSensitivitySliderChange = true;
		mouseSensitivitySlider.value = stuff;
		ignoreSensitivitySliderChange = false;
	}

	public void ReverseMouseX(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("mouseReverseX", stuff);
		MonoSingleton<CameraController>.Instance.CheckMouseReverse();
	}

	public void ReverseMouseY(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("mouseReverseY", stuff);
		MonoSingleton<CameraController>.Instance.CheckMouseReverse();
	}

	public void ScreenShake(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("screenShake", stuff / 100f);
	}

	public void CameraTilt(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("cameraTilt", stuff);
		if (cc == null)
		{
			cc = MonoSingleton<CameraController>.Instance;
			mainCam = cc.GetComponent<Camera>();
		}
		cc.CheckTilt();
	}

	public void ParryFlash(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("parryFlash", stuff);
		MonoSingleton<TimeController>.Instance.parryFlashEnabled = stuff;
	}

	public void DiscordIntegration(bool stuff)
	{
		if (stuff)
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("discordIntegration", content: true);
			DiscordController.Enable();
		}
		else
		{
			MonoSingleton<PrefsManager>.Instance.SetBool("discordIntegration", content: false);
			DiscordController.Disable();
		}
	}

	public void LevelLeaderboards(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("levelLeaderboards", stuff);
	}

	public void SeasonalEvents(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("seasonalEvents", stuff);
	}

	public void RestartWarning(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("pauseMenuConfirmationDialogs", stuff);
	}

	public void SandboxSaveWarning(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("sandboxSaveOverwriteWarnings", stuff);
	}

	public void VariationMemory(bool stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("variationMemory", stuff);
		if ((bool)MonoSingleton<GunControl>.Instance)
		{
			MonoSingleton<GunControl>.Instance.variationMemory = stuff;
		}
	}

	public void BloodStainChance(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloatLocal("bloodStainChance", stuff / 100f);
		opm.bloodstainChance = stuff;
	}

	public void maxBloodstains(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloatLocal("bloodStainMax", Mathf.FloorToInt(stuff) * 1000);
		opm.maxStains = stuff;
	}

	public void maxGore(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloatLocal("maxGore", stuff * 100f);
		opm.maxGore = stuff * 100f;
		GoreZone[] array = Object.FindObjectsOfType<GoreZone>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateMaxGore(stuff * 100f);
		}
	}

	public void MasterVolume(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("allVolume", stuff / 100f);
		AudioListener.volume = stuff / 100f;
	}

	public void SFXVolume(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("sfxVolume", stuff / 100f);
		if ((bool)MonoSingleton<AudioMixerController>.Instance)
		{
			MonoSingleton<AudioMixerController>.Instance.SetSFXVolume(stuff / 100f);
		}
	}

	public void MusicVolume(float stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("musicVolume", stuff / 100f);
		if ((bool)MonoSingleton<AudioMixerController>.Instance)
		{
			MonoSingleton<AudioMixerController>.Instance.optionsMusicVolume = stuff / 100f;
			MonoSingleton<AudioMixerController>.Instance.SetMusicVolume(stuff / 100f);
		}
	}

	public void MuffleMusic(bool state)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("muffleMusic", state);
		if ((bool)MonoSingleton<AudioMixerController>.Instance)
		{
			MonoSingleton<AudioMixerController>.Instance.MuffleMusic(state);
		}
	}

	public void SetSubtitles(bool state)
	{
		MonoSingleton<PrefsManager>.Instance.SetBool("subtitlesEnabled", state);
		if ((bool)MonoSingleton<SubtitleController>.Instance)
		{
			MonoSingleton<SubtitleController>.Instance.SubtitlesEnabled = state;
		}
	}

	public void FieldOfView(float stuff)
	{
		if (cc == null)
		{
			cc = MonoSingleton<CameraController>.Instance;
			mainCam = cc.GetComponent<Camera>();
		}
		MonoSingleton<PrefsManager>.Instance.SetFloat("fieldOfView", stuff);
		mainCam.fieldOfView = stuff;
		cc.defaultFov = stuff;
	}

	public void WeaponPosition(int stuff)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("weaponHoldPosition", stuff);
		ViewModelFlip[] componentsInChildren = MonoSingleton<NewMovement>.Instance.GetComponentsInChildren<ViewModelFlip>();
		WeaponPos weaponPos = Object.FindObjectOfType<WeaponPos>();
		HUDPos[] array = Object.FindObjectsOfType<HUDPos>();
		if (weaponPos != null)
		{
			weaponPos.CheckPosition();
		}
		HUDPos[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].CheckPos();
		}
		if (stuff == 2)
		{
			ViewModelFlip[] array3 = componentsInChildren;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].Left();
			}
		}
		else
		{
			ViewModelFlip[] array3 = componentsInChildren;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].Right();
			}
		}
		CheckEasterEgg();
	}

	public void CheckEasterEgg()
	{
		if (!nmov)
		{
			nmov = MonoSingleton<NewMovement>.Instance;
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weaponHoldPosition") == 1 && MonoSingleton<PrefsManager>.Instance.GetInt("hudType") >= 2)
		{
			nmov.quakeJump = true;
		}
		else
		{
			nmov.quakeJump = false;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class OutdoorLightMaster : MonoSingleton<OutdoorLightMaster>
{
	public bool inverse;

	private List<Light> outdoorLights = new List<Light>();

	public Light[] extraLights;

	public GameObject[] activateWhenOutside;

	[HideInInspector]
	public LayerMask normalMask;

	[HideInInspector]
	public LayerMask playerMask;

	private int requests;

	public bool dontRotateSkybox;

	private float skyboxRotation;

	private bool firstDoorOpened;

	public bool waitForFirstDoorOpen;

	private Material skyboxMaterial;

	private Material tempSkybox;

	public List<AudioLowPassFilter> muffleWhenIndoors = new List<AudioLowPassFilter>();

	private List<float> muffleGoals = new List<float>();

	private bool muffleSounds;

	private float currentMuffle;

	public bool muffleWhenOutdoors;

	[HideInInspector]
	public List<Collider> outdoorsZones = new List<Collider>();

	private void Start()
	{
		Light[] componentsInChildren = GetComponentsInChildren<Light>(includeInactive: true);
		outdoorLights.AddRange(componentsInChildren);
		if (extraLights != null)
		{
			outdoorLights.AddRange(extraLights);
		}
		if (outdoorLights.Count != 0)
		{
			normalMask = 16777216;
			normalMask = (int)normalMask | 0x2000000;
			LayerMask layerMask = 8192;
			playerMask = (int)normalMask | (int)layerMask;
		}
		foreach (Light outdoorLight in outdoorLights)
		{
			if (inverse && (!waitForFirstDoorOpen || firstDoorOpened))
			{
				outdoorLight.cullingMask = playerMask;
			}
			else
			{
				outdoorLight.cullingMask = normalMask;
			}
		}
		if (activateWhenOutside != null)
		{
			GameObject[] array = activateWhenOutside;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(inverse && (!waitForFirstDoorOpen || firstDoorOpened));
			}
		}
		for (int j = 0; j < muffleWhenIndoors.Count; j++)
		{
			muffleGoals.Add(muffleWhenIndoors[j].cutoffFrequency);
		}
		muffleSounds = inverse && waitForFirstDoorOpen && !firstDoorOpened;
		currentMuffle = (muffleSounds ? 1 : 0);
		UpdateMuffle();
	}

	private void Update()
	{
		if (!dontRotateSkybox && (bool)RenderSettings.skybox)
		{
			if (!tempSkybox)
			{
				UpdateSkyboxMaterial();
			}
			else
			{
				skyboxRotation += Time.deltaTime;
				if (skyboxRotation >= 360f)
				{
					skyboxRotation -= 360f;
				}
				RenderSettings.skybox.SetFloat("_Rotation", skyboxRotation);
			}
		}
		if ((muffleSounds && currentMuffle != 1f) || (!muffleSounds && currentMuffle != 0f))
		{
			currentMuffle = Mathf.MoveTowards(currentMuffle, muffleSounds ? 1 : 0, Time.deltaTime * 3f);
			UpdateMuffle();
		}
	}

	public void AddRequest()
	{
		requests++;
		if (requests != 1)
		{
			return;
		}
		foreach (Light outdoorLight in outdoorLights)
		{
			outdoorLight.cullingMask = (inverse ? normalMask : playerMask);
		}
		GameObject[] array = activateWhenOutside;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(!inverse);
		}
		muffleSounds = (muffleWhenOutdoors ? (!inverse) : inverse);
	}

	public void RemoveRequest()
	{
		requests--;
		if (requests != 0)
		{
			return;
		}
		foreach (Light outdoorLight in outdoorLights)
		{
			outdoorLight.cullingMask = (inverse ? playerMask : normalMask);
		}
		GameObject[] array = activateWhenOutside;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(inverse);
		}
		muffleSounds = (muffleWhenOutdoors ? inverse : (!inverse));
	}

	public void FirstDoorOpen()
	{
		if (firstDoorOpened)
		{
			return;
		}
		firstDoorOpened = true;
		if (!inverse || !waitForFirstDoorOpen || requests > 0)
		{
			return;
		}
		foreach (Light outdoorLight in outdoorLights)
		{
			outdoorLight.cullingMask = playerMask;
		}
		if (activateWhenOutside != null)
		{
			GameObject[] array = activateWhenOutside;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
		muffleSounds = (muffleWhenOutdoors ? inverse : (!inverse));
	}

	public void UpdateSkyboxMaterial()
	{
		if (!skyboxMaterial)
		{
			skyboxMaterial = RenderSettings.skybox;
		}
		tempSkybox = new Material(skyboxMaterial);
		RenderSettings.skybox = tempSkybox;
	}

	public void ForceMuffle(float target)
	{
		currentMuffle = Mathf.Clamp(target, 0f, 1f);
		UpdateMuffle();
	}

	private void UpdateMuffle()
	{
		for (int i = 0; i < muffleWhenIndoors.Count; i++)
		{
			if (!(muffleWhenIndoors[i] == null))
			{
				muffleWhenIndoors[i].enabled = currentMuffle != 0f;
				muffleWhenIndoors[i].cutoffFrequency = Mathf.Lerp(5000f, muffleGoals[i], currentMuffle);
			}
		}
	}
}



public class OutdoorsChecker : MonoBehaviour
{
	private bool inverse;

	public bool nonSolid = true;

	public bool oneTime;

	public GameObject[] targets;

	[Header("Additional Events")]
	public UltrakillEvent onIndoors;

	public UltrakillEvent onOutdoors;

	private BoxCollider boxCol;

	private void Start()
	{
		if (!MonoSingleton<OutdoorLightMaster>.Instance)
		{
			base.enabled = false;
			return;
		}
		if (MonoSingleton<OutdoorLightMaster>.Instance.inverse)
		{
			inverse = true;
		}
		if (targets.Length == 0)
		{
			targets = new GameObject[1];
			targets[0] = base.gameObject;
		}
		boxCol = GetComponent<BoxCollider>();
		SlowUpdate();
	}

	public void SlowUpdate()
	{
		if (!oneTime)
		{
			Invoke("SlowUpdate", 0.5f);
		}
		GameObject[] array;
		if (CheckIfPositionOutdoors(boxCol ? boxCol.bounds.center : base.transform.position))
		{
			array = targets;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject && gameObject.layer != 13)
				{
					gameObject.layer = (nonSolid ? 25 : 24);
				}
			}
			onOutdoors?.Invoke();
			return;
		}
		array = targets;
		foreach (GameObject gameObject2 in array)
		{
			if ((bool)gameObject2 && gameObject2.layer != 13)
			{
				gameObject2.layer = (nonSolid ? 27 : 8);
			}
		}
		onIndoors?.Invoke();
	}

	public static bool CheckIfPositionOutdoors(Vector3 position)
	{
		if (!MonoSingleton<OutdoorLightMaster>.Instance)
		{
			return false;
		}
		Collider[] array = Physics.OverlapSphere(position, 0.1f, 262144, QueryTriggerInteraction.Collide);
		if (array != null && array.Length != 0)
		{
			Collider[] array2 = array;
			foreach (Collider collider in array2)
			{
				if (!(collider == null) && MonoSingleton<OutdoorLightMaster>.Instance.outdoorsZones.Contains(collider))
				{
					return !MonoSingleton<OutdoorLightMaster>.Instance.inverse;
				}
			}
		}
		return MonoSingleton<OutdoorLightMaster>.Instance.inverse;
	}
}



public class OutdoorsZone : MonoBehaviour
{
	private int hasRequested;

	private void Start()
	{
		if (!MonoSingleton<OutdoorLightMaster>.Instance)
		{
			return;
		}
		Collider component2;
		if (TryGetComponent<Rigidbody>(out var component))
		{
			Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
			foreach (Collider collider in componentsInChildren)
			{
				if ((bool)collider.attachedRigidbody && collider.attachedRigidbody == component)
				{
					MonoSingleton<OutdoorLightMaster>.Instance.outdoorsZones.Add(collider);
				}
			}
		}
		else if (TryGetComponent<Collider>(out component2) && (bool)MonoSingleton<OutdoorLightMaster>.Instance && !MonoSingleton<OutdoorLightMaster>.Instance.outdoorsZones.Contains(component2))
		{
			MonoSingleton<OutdoorLightMaster>.Instance.outdoorsZones.Add(component2);
		}
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<OutdoorLightMaster>.Instance && hasRequested > 0)
		{
			for (int num = hasRequested; num > 0; num--)
			{
				MonoSingleton<OutdoorLightMaster>.Instance.RemoveRequest();
			}
			hasRequested = 0;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((bool)MonoSingleton<OutdoorLightMaster>.Instance && other.gameObject.CompareTag("Player"))
		{
			if (hasRequested == 0)
			{
				MonoSingleton<OutdoorLightMaster>.Instance.AddRequest();
			}
			hasRequested++;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if ((bool)MonoSingleton<OutdoorLightMaster>.Instance && other.gameObject.CompareTag("Player"))
		{
			if (hasRequested == 1)
			{
				MonoSingleton<OutdoorLightMaster>.Instance.RemoveRequest();
			}
			hasRequested--;
		}
	}
}



public class OutOfBounds : MonoBehaviour
{
	public AffectedSubjects targets;

	private StatsManager sman;

	public Vector3 overrideResetPosition;

	public GameObject[] toActivate;

	public GameObject[] toDisactivate;

	public Door[] toUnlock;

	public UnityEvent toEvent;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player") && targets != AffectedSubjects.EnemiesOnly)
		{
			if ((MonoSingleton<PlayerTracker>.Instance.playerType != 0 || MonoSingleton<NewMovement>.Instance.hp <= 0) && (MonoSingleton<PlayerTracker>.Instance.playerType != PlayerType.Platformer || MonoSingleton<PlatformerMovement>.Instance.dead))
			{
				return;
			}
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.zero;
			}
			else
			{
				MonoSingleton<PlatformerMovement>.Instance.rb.velocity = Vector3.zero;
			}
			if (sman == null)
			{
				sman = MonoSingleton<StatsManager>.Instance;
			}
			if ((bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
			{
				MonoSingleton<NewMovement>.Instance.ridingRocket.PlayerRideEnd();
			}
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Whoops, sorry about that.");
			if (overrideResetPosition != Vector3.zero)
			{
				other.transform.position = overrideResetPosition + Vector3.up * 1.25f;
			}
			else if (sman.currentCheckPoint != null)
			{
				other.transform.position = sman.currentCheckPoint.transform.position + Vector3.up * 1.25f;
				if (sman.currentCheckPoint.toActivate != null)
				{
					sman.currentCheckPoint.toActivate.SetActive(value: true);
				}
				Door[] doorsToUnlock = sman.currentCheckPoint.doorsToUnlock;
				for (int i = 0; i < doorsToUnlock.Length; i++)
				{
					doorsToUnlock[i].Unlock();
				}
			}
			else
			{
				other.transform.position = sman.spawnPos;
				GameObject[] array = toActivate;
				for (int i = 0; i < array.Length; i++)
				{
					array[i]?.SetActive(value: true);
				}
				array = toDisactivate;
				for (int i = 0; i < array.Length; i++)
				{
					array[i]?.SetActive(value: false);
				}
				Door[] doorsToUnlock = toUnlock;
				for (int i = 0; i < doorsToUnlock.Length; i++)
				{
					doorsToUnlock[i]?.Unlock();
				}
			}
			toEvent?.Invoke();
		}
		else
		{
			if (targets == AffectedSubjects.PlayerOnly)
			{
				return;
			}
			if (other.gameObject.layer == 10 || other.gameObject.layer == 9)
			{
				if (other.gameObject.layer == 10)
				{
					EnemyIdentifier componentInParent = other.gameObject.GetComponentInParent<EnemyIdentifier>();
					if ((bool)componentInParent && !componentInParent.dead)
					{
						return;
					}
					if (!componentInParent && other.gameObject.CompareTag("Coin"))
					{
						other.GetComponent<Coin>()?.GetDeleted();
						return;
					}
				}
				other.gameObject.SetActive(value: false);
				other.transform.position = Vector3.zero;
				other.transform.localScale = Vector3.zero;
			}
			else
			{
				if (!other.gameObject.CompareTag("Enemy") || !(GetComponentInChildren<DeathZone>() == null))
				{
					return;
				}
				EnemyIdentifier component = other.gameObject.GetComponent<EnemyIdentifier>();
				if (!component.dead)
				{
					if (component.specialOob)
					{
						component.SendMessage("OutOfBounds", SendMessageOptions.DontRequireReceiver);
					}
					else
					{
						component.InstaKill();
					}
				}
			}
		}
	}
}



public class OutOfBoundsTargetSetter : MonoBehaviour
{
	public DeathZone[] deathZones;

	public OutOfBounds[] oobs;

	private void Start()
	{
		if (!TryGetComponent<Collider>(out var _) && !TryGetComponent<Rigidbody>(out var _))
		{
			Activate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			Activate();
		}
	}

	public void Activate()
	{
		bool flag = false;
		if (deathZones == null || deathZones.Length == 0)
		{
			deathZones = Object.FindObjectsOfType<DeathZone>();
		}
		else
		{
			flag = true;
		}
		DeathZone[] array = deathZones;
		foreach (DeathZone deathZone in array)
		{
			if ((bool)deathZone && (!deathZone.dontChangeRespawnTarget || flag))
			{
				deathZone.respawnTarget = base.transform.position;
			}
		}
		if (oobs == null || oobs.Length == 0)
		{
			oobs = Object.FindObjectsOfType<OutOfBounds>();
		}
		OutOfBounds[] array2 = oobs;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].overrideResetPosition = base.transform.position;
		}
	}
}



public class PacifistChallenge : MonoBehaviour
{
	private void Update()
	{
		if ((bool)MonoSingleton<StyleCalculator>.Instance)
		{
			if (!MonoSingleton<StyleCalculator>.Instance.enemiesShot)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
			}
			else
			{
				MonoSingleton<ChallengeManager>.Instance.challengeDone = false;
			}
		}
	}
}



public class Parasite : MonoBehaviour
{
	public EnemyIdentifier parent;

	private EnemyTarget localTarget;

	public Transform projectileSpawnPos;

	private Animator anim;

	public GameObject[] decProjectiles;

	public GameObject[] projectiles;

	private GameObject currentDecProjectile;

	private bool inAction = true;

	private float cooldown;

	public GameObject windUpSound;

	private int shootType;

	private GoreZone gz;

	private int difficulty;

	public float speedMultiplier = 1f;

	public float damageMultiplier = 1f;

	private EnemyTarget target
	{
		get
		{
			object obj = localTarget;
			if (obj == null)
			{
				if (!(parent == null))
				{
					return parent.target;
				}
				obj = null;
			}
			return (EnemyTarget)obj;
		}
	}

	private void Start()
	{
		cooldown = Random.Range(0, 3);
		anim = GetComponent<Animator>();
		gz = GoreZone.ResolveGoreZone(base.transform);
		if (parent == null)
		{
			localTarget = new EnemyTarget(MonoSingleton<CameraController>.Instance.transform);
		}
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
	}

	private void Update()
	{
		if (target == null)
		{
			return;
		}
		Quaternion quaternion = Quaternion.LookRotation(target.position - base.transform.position, Vector3.up);
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * (Quaternion.Angle(base.transform.rotation, quaternion) + 1f) * speedMultiplier);
		if (inAction)
		{
			return;
		}
		float num = 1f;
		if (difficulty == 1)
		{
			num = 0.75f;
		}
		else if (difficulty == 0)
		{
			num = 0.5f;
		}
		if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * num * speedMultiplier);
		}
		else if (!anim.IsInTransition(0))
		{
			if (Random.Range(0f, 1f) > 0.5f || difficulty < 2)
			{
				Shoot1();
			}
			else
			{
				Shoot2();
			}
		}
	}

	private void Shoot1()
	{
		Object.Instantiate(windUpSound, projectileSpawnPos);
		inAction = true;
		cooldown = Random.Range(2, 4);
		shootType = 0;
		anim.SetTrigger("Shoot1");
	}

	private void Shoot2()
	{
		Object.Instantiate(windUpSound, projectileSpawnPos);
		inAction = true;
		cooldown = Random.Range(2, 4);
		shootType = 1;
		anim.SetTrigger("Shoot2");
	}

	public void SpawnProjectile()
	{
		if ((bool)currentDecProjectile)
		{
			Object.Destroy(currentDecProjectile);
		}
		currentDecProjectile = Object.Instantiate(decProjectiles[shootType], projectileSpawnPos.position, projectileSpawnPos.rotation);
		currentDecProjectile.transform.localScale *= 5f;
		currentDecProjectile.transform.SetParent(projectileSpawnPos, worldPositionStays: true);
	}

	public void ShootProjectile()
	{
		if ((bool)currentDecProjectile)
		{
			Object.Destroy(currentDecProjectile);
		}
		GameObject obj = Object.Instantiate(projectiles[shootType], projectileSpawnPos.position, Quaternion.LookRotation(target.position - projectileSpawnPos.position));
		obj.transform.localScale *= 5f;
		obj.transform.SetParent(gz.transform, worldPositionStays: true);
		Projectile componentInChildren = obj.GetComponentInChildren<Projectile>();
		componentInChildren.target = target;
		componentInChildren.safeEnemyType = EnemyType.Minos;
		float num = Vector3.Distance(projectileSpawnPos.position, target.position);
		if (num > 65f)
		{
			componentInChildren.speed = num;
		}
		if (difficulty == 1)
		{
			componentInChildren.speed *= 0.75f;
		}
		else if (difficulty == 0)
		{
			componentInChildren.speed *= 0.5f;
		}
		componentInChildren.damage *= damageMultiplier;
		ProjectileSpread componentInChildren2 = obj.GetComponentInChildren<ProjectileSpread>();
		if (componentInChildren2 != null)
		{
			componentInChildren2.spreadAmount = 3f;
			componentInChildren2.projectileAmount = 8;
		}
	}

	public void StopAction()
	{
		inAction = false;
	}
}



public class ParryFlash : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}



public class ParryHelper : MonoBehaviour
{
	public Transform target;
}



public class ParryReceiver : MonoBehaviour
{
	public bool parryHeal;

	public bool disappearOnParry;

	[Space]
	public UnityEvent onParry;

	public void Parry()
	{
		onParry.Invoke();
		if (disappearOnParry)
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void Update()
	{
	}
}



public class ParticleCluster : MonoBehaviour
{
	[SerializeField]
	private ParticleSystem[] particles;

	private ParticleSystem.EmissionModule[] emissionModules;

	private void Awake()
	{
		emissionModules = new ParticleSystem.EmissionModule[particles.Length];
		for (int i = 0; i < particles.Length; i++)
		{
			emissionModules[i] = particles[i].emission;
		}
	}

	public void EmissionOn()
	{
		for (int i = 0; i < particles.Length; i++)
		{
			emissionModules[i].enabled = true;
		}
	}

	public void EmissionOff()
	{
		for (int i = 0; i < particles.Length; i++)
		{
			emissionModules[i].enabled = false;
		}
	}
}



public class ParticleCollisionSpawn : MonoBehaviour
{
	private ParticleSystem part;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	public GameObject toSpawn;

	private void OnParticleCollision(GameObject other)
	{
		if (part == null)
		{
			part = GetComponent<ParticleSystem>();
		}
		part.GetCollisionEvents(other, collisionEvents);
		if (collisionEvents.Count > 0)
		{
			Object.Instantiate(toSpawn, collisionEvents[0].intersection, Quaternion.LookRotation(collisionEvents[0].normal)).SetActive(value: true);
		}
	}
}



[DisallowMultipleComponent]
public sealed class ParticleSystemStoppedMessage : MessageDispatcher
{
	private void OnParticleSystemStopped()
	{
		base.Handler.Invoke();
	}
}



public class PendingVibration
{
	public TimeSince timeSinceStart;

	public RumbleKey key;

	public float intensityMultiplier = 1f;

	public bool isTracking;

	public GameObject trackedObject;

	public float Duration => MonoSingleton<RumbleManager>.Instance.ResolveDuration(key);

	public float Intensity => Mathf.Clamp01(MonoSingleton<RumbleManager>.Instance.ResolveIntensity(key) * intensityMultiplier);

	public bool IsFinished => (float)timeSinceStart >= Duration;
}



[CreateAssetMenu(menuName = "ULTRAKILL/Persistent Colors")]
public class PersistentColors : ScriptableObject
{
	public Color[] colors;
}



public class PhysicalShockwave : MonoBehaviour
{
	public EnemyTarget target;

	public int damage;

	public float speed;

	public float maxSize;

	public float force;

	public bool hasHurtPlayer;

	public bool enemy;

	public bool noDamageToEnemy;

	private List<Collider> hitColliders = new List<Collider>();

	public EnemyType enemyType;

	public GameObject soundEffect;

	[HideInInspector]
	public bool fading;

	private ScaleNFade[] faders;

	private void Start()
	{
		if (soundEffect != null)
		{
			Object.Instantiate(soundEffect, base.transform.position, Quaternion.identity);
		}
		faders = GetComponentsInChildren<ScaleNFade>();
		if (!fading)
		{
			ScaleNFade[] array = faders;
			foreach (ScaleNFade obj in array)
			{
				obj.enabled = false;
				obj.fade = true;
				obj.fadeSpeed = speed / 10f;
			}
		}
	}

	private void Update()
	{
		base.transform.localScale = new Vector3(base.transform.localScale.x + Time.deltaTime * speed, base.transform.localScale.y, base.transform.localScale.z + Time.deltaTime * speed);
		if (!fading && (base.transform.localScale.x > maxSize || base.transform.localScale.z > maxSize))
		{
			fading = true;
			ScaleNFade[] array = faders;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
			Invoke("GetDestroyed", speed / 10f);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!fading)
		{
			CheckCollision(collision.collider);
		}
	}

	private void OnTriggerEnter(Collider collision)
	{
		if (!fading)
		{
			CheckCollision(collision);
		}
	}

	private void CheckCollision(Collider col)
	{
		Landmine component4;
		if (!hasHurtPlayer && col.gameObject.layer != 15 && col.gameObject.CompareTag("Player"))
		{
			hasHurtPlayer = true;
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				NewMovement instance = MonoSingleton<NewMovement>.Instance;
				instance.GetHurt(damage, invincible: true);
				instance.LaunchFromPoint(instance.transform.position + Vector3.down, 30f, 30f);
			}
			else if (damage == 0)
			{
				MonoSingleton<PlatformerMovement>.Instance.Jump();
			}
			else
			{
				MonoSingleton<PlatformerMovement>.Instance.Explode();
			}
		}
		else if (col.gameObject.layer == 10)
		{
			EnemyIdentifierIdentifier component = col.gameObject.GetComponent<EnemyIdentifierIdentifier>();
			if (!(component != null) || !(component.eid != null) || (enemy && (component.eid.enemyType == enemyType || component.eid.immuneToFriendlyFire || EnemyIdentifier.CheckHurtException(enemyType, component.eid.enemyType, target))))
			{
				return;
			}
			Collider component2 = component.eid.GetComponent<Collider>();
			float multiplier = (float)damage / 10f;
			if (noDamageToEnemy || base.transform.localScale.x > 10f || base.transform.localScale.z > 10f)
			{
				multiplier = 0f;
			}
			if (component2 != null && !hitColliders.Contains(component2) && !component.eid.dead)
			{
				hitColliders.Add(component2);
				if (enemy)
				{
					component.eid.hitter = "enemy";
				}
				else
				{
					component.eid.hitter = "explosion";
				}
				if (component.eid.enemyType == EnemyType.Turret && component.eid.TryGetComponent<Turret>(out var component3) && component3.lodged)
				{
					component3.Unlodge();
				}
				component.eid.DeliverDamage(col.gameObject, Vector3.up * force * 2f, col.transform.position, multiplier, tryForExplode: false);
			}
			else if (component2 != null && component.eid.dead)
			{
				hitColliders.Add(component2);
				component.eid.hitter = "explosion";
				component.eid.DeliverDamage(col.gameObject, Vector3.up * 2000f, col.transform.position, multiplier, tryForExplode: false);
			}
		}
		else if (!enemy && (bool)col.attachedRigidbody && col.attachedRigidbody.TryGetComponent<Landmine>(out component4))
		{
			component4.Activate(1.5f);
		}
	}

	private void GetDestroyed()
	{
		Object.Destroy(base.gameObject);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class PhysicsSounds : MonoSingleton<PhysicsSounds>
{
	[Serializable]
	public struct PhysSounds
	{
		public AudioClip plastic;

		public AudioClip wood;

		public AudioClip stone;

		public AudioClip metal;

		public AudioClip fleshy;

		public AudioClip glass;

		public AudioClip grass;
	}

	public enum PhysMaterial
	{
		Plastic,
		Wood,
		Stone,
		Metal,
		Fleshy,
		Glass,
		Grass
	}

	[SerializeField]
	private PhysSounds sounds;

	[SerializeField]
	private AudioSource template;

	public AudioClip ResolveSound(PhysMaterial material)
	{
		return material switch
		{
			PhysMaterial.Plastic => sounds.plastic, 
			PhysMaterial.Wood => sounds.wood, 
			PhysMaterial.Stone => sounds.stone, 
			PhysMaterial.Metal => sounds.metal, 
			PhysMaterial.Fleshy => sounds.fleshy, 
			PhysMaterial.Grass => sounds.grass, 
			PhysMaterial.Glass => sounds.glass, 
			_ => sounds.plastic, 
		};
	}

	public void ImpactAt(Vector3 point, float magnitude, PhysMaterial material)
	{
		if (!(magnitude < 3.5f))
		{
			AudioSource audioSource = UnityEngine.Object.Instantiate(template);
			audioSource.transform.position = point;
			audioSource.clip = ResolveSound(material);
			audioSource.volume = Mathf.Lerp(0.2f, 1f, magnitude / 60f);
			audioSource.pitch = Mathf.Lerp(0.65f, 2.2f, (60f - magnitude) / 60f);
			audioSource.gameObject.SetActive(value: true);
			audioSource.Play();
		}
	}
}



public class PickClosestPoint : MonoBehaviour
{
	public Transform target;

	public Transform[] points;

	public Transform customComparisonPoint;

	[SerializeField]
	private bool pickOnEnable = true;

	[SerializeField]
	private bool parentTargetToClosestPoint = true;

	[SerializeField]
	private bool mimicRotation = true;

	[SerializeField]
	private bool mimicPosition = true;

	[SerializeField]
	private bool mimicScale = true;

	[SerializeField]
	private bool closestToPlayer = true;

	private void OnEnable()
	{
		if (pickOnEnable)
		{
			Pick();
		}
	}

	private void Pick()
	{
		Transform transform = null;
		float num = float.MaxValue;
		Transform transform2 = (closestToPlayer ? MonoSingleton<PlayerTracker>.Instance.GetPlayer() : customComparisonPoint);
		Transform[] array = points;
		foreach (Transform transform3 in array)
		{
			float num2 = Vector3.Distance(transform3.position, transform2.position);
			if (num2 < num)
			{
				num = num2;
				transform = transform3;
			}
		}
		if (transform == null)
		{
			return;
		}
		if (parentTargetToClosestPoint)
		{
			target.SetParent(transform);
			target.localRotation = Quaternion.identity;
			target.localScale = Vector3.one;
			target.localPosition = Vector3.zero;
			return;
		}
		if (mimicRotation)
		{
			target.rotation = transform.rotation;
		}
		if (mimicScale)
		{
			target.localScale = transform.localScale;
		}
		if (mimicPosition)
		{
			target.position = transform.position;
		}
	}
}



public class PinConsole : MonoBehaviour
{
	private Image image;

	private bool pinned;

	private void Awake()
	{
		image = GetComponent<Image>();
	}

	public void TogglePin()
	{
		pinned = !pinned;
		MonoSingleton<Console>.Instance.pinned = pinned;
		image.color = (pinned ? Color.red : Color.white);
	}
}



public class Piston : MonoBehaviour
{
	public bool off;

	private RaycastHit rhit;

	public LayerMask enviroMask;

	public Vector3 minPos;

	public Vector3 maxPos;

	public Vector3 targetPos;

	private Collider dzone;

	private Collider basedzone;

	public float timer;

	public float returnTime;

	public float attackTime;

	private ParticleSystem part;

	private ParticleSystem[] steamParts;

	private AudioSource partAud;

	private AudioSource aud;

	private void Awake()
	{
		if (minPos == Vector3.zero)
		{
			maxPos = base.transform.localPosition;
			minPos = new Vector3(0f, -7f, 0f);
		}
		base.transform.localPosition = minPos;
		dzone = GetComponentInChildren<DeathZone>().GetComponent<Collider>();
		dzone.enabled = false;
		basedzone = base.transform.parent.Find("Base").GetComponentInChildren<DeathZone>().GetComponent<Collider>();
		basedzone.enabled = false;
		targetPos = Vector3.one;
		part = GetComponentInChildren<ParticleSystem>();
		partAud = part.GetComponent<AudioSource>();
		aud = GetComponent<AudioSource>();
		steamParts = base.transform.parent.GetChild(0).GetComponentsInChildren<ParticleSystem>();
	}

	private void Update()
	{
		if (off)
		{
			return;
		}
		timer -= Time.deltaTime * 2f;
		if (timer <= 0f)
		{
			if (base.transform.localPosition == minPos)
			{
				targetPos = maxPos;
				timer = returnTime;
				dzone.enabled = true;
				basedzone.enabled = false;
			}
			else
			{
				targetPos = minPos;
				timer = attackTime;
			}
		}
		if (timer <= 1f && !aud.isPlaying && base.transform.localPosition == minPos)
		{
			aud.Play();
			ParticleSystem[] array = steamParts;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
		}
		if (base.transform.localPosition != targetPos && targetPos != Vector3.one)
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Time.deltaTime * 75f);
		}
		if (base.transform.localPosition == maxPos && dzone.enabled)
		{
			dzone.enabled = false;
			part.Play();
			partAud.Play();
			if (aud.isPlaying)
			{
				aud.Stop();
				ParticleSystem[] array = steamParts;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Stop();
				}
			}
		}
		if (base.transform.localPosition == minPos)
		{
			basedzone.enabled = true;
		}
	}
}



[DefaultExecutionOrder(-150)]
public class PlaceholderPrefab : MonoBehaviour
{
	public string uniqueId;

	private void Awake()
	{
		PrefabReplacer.Instance.ReplacePrefab(this);
	}
}



[CreateAssetMenu(fileName = "Placeholder Prefab Database", menuName = "ULTRAKILL/PrefabPlaceholderDB")]
public class PlaceholderPrefabDatabase : ScriptableObject
{
	public PlaceholderPrefabTarget[] placeholderPrefabs;
}



[Serializable]
public class PlaceholderPrefabTarget
{
	public bool delayedSwap = true;

	public string uniqueId;

	[HideInInspector]
	public GameObject actualPrefab;

	public string assetPath;
}



public class PlatformDependantObject : MonoBehaviour
{
	[SerializeField]
	private bool requiresSteam;

	[SerializeField]
	private bool requiresDiscord;

	[SerializeField]
	private bool requiresFileSystemAccess;

	[SerializeField]
	private bool hideInSolsticeRelease;

	[SerializeField]
	private UltrakillEvent onDestroy;

	private void Awake()
	{
		_ = requiresSteam;
		_ = requiresDiscord;
		_ = requiresFileSystemAccess;
		if (hideInSolsticeRelease && Environment.GetEnvironmentVariable("SOLSTICE_LAUNCH_MODE") == "RELEASE")
		{
			onDestroy.Invoke();
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}



public class PlatformerCameraSetter : MonoBehaviour
{
	public Vector3 position = new Vector3(0f, 7f, -5.5f);

	public Vector3 rotation = new Vector3(20f, 0f, 0f);

	private void OnTriggerEnter(Collider other)
	{
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && !(MonoSingleton<PlatformerMovement>.Instance == null) && other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject)
		{
			MonoSingleton<PlatformerMovement>.Instance.cameraTargets.Add(new CameraTargetInfo(position, rotation, base.gameObject));
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (MonoSingleton<PlayerTracker>.Instance.playerType != PlayerType.Platformer || !(other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject) || MonoSingleton<PlatformerMovement>.Instance.cameraTargets.Count <= 0)
		{
			return;
		}
		for (int num = MonoSingleton<PlatformerMovement>.Instance.cameraTargets.Count - 1; num >= 0; num--)
		{
			if (MonoSingleton<PlatformerMovement>.Instance.cameraTargets[num] != null && MonoSingleton<PlatformerMovement>.Instance.cameraTargets[num].caller == base.gameObject)
			{
				MonoSingleton<PlatformerMovement>.Instance.cameraTargets.RemoveAt(num);
				break;
			}
		}
	}
}


public enum PlatformerCameraType
{
	PlayerControlled,
	LevelControlled
}



public class PlatformerChecker : MonoBehaviour
{
	public bool activated;

	public UltrakillEvent onPlatformer;

	private void Update()
	{
		if (!activated && MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			activated = true;
			onPlatformer.Invoke();
		}
	}
}



public class PlatformerDancer : MonoBehaviour
{
	private AudioSource aud;

	public void Whoosh(float pitch)
	{
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		aud.pitch = pitch + Random.Range(-0.05f, 0.05f);
		aud.Play();
	}

	public void DanceEnd()
	{
		MonoSingleton<PlatformerMovement>.Instance.transform.position = base.transform.position;
		MonoSingleton<PlatformerMovement>.Instance.gameObject.SetActive(value: true);
		base.gameObject.SetActive(value: false);
		MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=orange>CLASH MODE</color> CHEAT UNLOCKED");
	}
}



public class PlatformerEnding : MonoBehaviour
{
	[SerializeField]
	private Transform teleportEffect;

	[SerializeField]
	private UltrakillEvent onActivate;

	private bool activated;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player") && other.gameObject == MonoSingleton<PlatformerMovement>.Instance.gameObject)
		{
			Activate();
		}
	}

	private void Update()
	{
		if (activated)
		{
			teleportEffect.localScale = Vector3.MoveTowards(teleportEffect.localScale, Vector3.up * teleportEffect.localScale.y, Time.deltaTime * 2.5f);
			if (teleportEffect.localScale.x == 0f && teleportEffect.localScale.z == 0f)
			{
				Done();
			}
		}
	}

	public void Activate()
	{
		MonoSingleton<PlatformerMovement>.Instance.transform.parent.GetComponentInChildren<Canvas>().gameObject.SetActive(value: false);
		MonoSingleton<PlatformerMovement>.Instance.gameObject.SetActive(value: false);
		GameObject obj = Object.Instantiate(MonoSingleton<PlatformerMovement>.Instance.gameObject, MonoSingleton<PlatformerMovement>.Instance.transform.position, MonoSingleton<PlatformerMovement>.Instance.transform.rotation, teleportEffect);
		SandboxUtils.StripForPreview(obj.transform);
		obj.SetActive(value: true);
		Invoke("DelayedActivateEffect", 0.5f);
	}

	private void DelayedActivateEffect()
	{
		activated = true;
		onActivate.Invoke();
	}

	public void Done()
	{
		activated = false;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class PlatformerMovement : MonoSingleton<PlatformerMovement>
{
	public Transform platformerCamera;

	public Vector3 cameraTarget = new Vector3(0f, 7f, -5.5f);

	private Vector3 defaultCameraTarget = new Vector3(0f, 7f, -5.5f);

	public Vector3 cameraRotation = new Vector3(20f, 0f, 0f);

	private Vector3 defaultCameraRotation = new Vector3(20f, 0f, 0f);

	[HideInInspector]
	public List<CameraTargetInfo> cameraTargets = new List<CameraTargetInfo>();

	private bool cameraTrack = true;

	public bool freeCamera;

	[HideInInspector]
	public float rotationY;

	[HideInInspector]
	public float rotationX;

	public GroundCheck groundCheck;

	[SerializeField]
	private GroundCheck slopeCheck;

	public Transform playerModel;

	[HideInInspector]
	public Rigidbody rb;

	private AudioSource aud;

	private CapsuleCollider playerCollider;

	private Animator anim;

	[SerializeField]
	private AudioClip jumpSound;

	[SerializeField]
	private AudioClip dodgeSound;

	[SerializeField]
	private AudioClip bounceSound;

	[HideInInspector]
	public bool activated = true;

	private Vector3 movementDirection;

	private Vector3 movementDirection2;

	private Vector3 airDirection;

	private Vector3 dodgeDirection;

	private float walkSpeed = 600f;

	private float jumpPower = 80f;

	private bool boost;

	private float boostCharge = 300f;

	private float boostLeft;

	[SerializeField]
	private GameObject staminaFailSound;

	[SerializeField]
	private GameObject dodgeParticle;

	[SerializeField]
	private GameObject dashJumpSound;

	[HideInInspector]
	public bool sliding;

	private bool crouching;

	private bool slideEnding;

	private float preSlideSpeed;

	private float preSlideDelay;

	private float slideSafety;

	private float slideLength;

	[SerializeField]
	private GameObject slideStopSound;

	[SerializeField]
	private GameObject slideEffect;

	[SerializeField]
	private GameObject slideScrape;

	private GameObject currentSlideEffect;

	private GameObject currentSlideScrape;

	private bool jumping;

	private bool jumpCooldown;

	[HideInInspector]
	public CustomGroundProperties groundProperties;

	public Transform jumpShadow;

	private bool falling;

	private float fallSpeed;

	private float fallTime;

	public float slamForce;

	private bool spinning;

	private float spinJuice;

	private Vector3 spinDirection;

	private float spinSpeed;

	private float spinCooldown;

	public Transform holder;

	private int difficulty;

	[SerializeField]
	private GameObject spinZone;

	[SerializeField]
	private GameObject coinGet;

	private float coinTimer;

	private float coinPitch;

	private int queuedCoins;

	private float coinEffectTimer;

	public int extraHits;

	private bool invincible;

	private float blinkTimer;

	public GameObject[] protectors;

	private float superTimer;

	public GameObject protectorGet;

	public GameObject protectorLose;

	public GameObject protectorOof;

	private InputBinding rbSlide;

	private InputBinding dpadMove;

	[Header("Death Stuff")]
	[SerializeField]
	private Material burnMaterial;

	[SerializeField]
	private GameObject defaultBurnEffect;

	[SerializeField]
	private GameObject ashParticle;

	[SerializeField]
	private GameObject ashSound;

	private GameObject currentCorpse;

	[SerializeField]
	private GameObject fallSound;

	[HideInInspector]
	public bool dead;

	protected override void Awake()
	{
		base.Awake();
		rbSlide = new InputBinding("<Gamepad>/rightShoulder", null, "Gamepad", null, null, "rbSlide");
		dpadMove = new InputBinding("<Gamepad>/dpad", null, "Gamepad", null, null, "dpadMove");
	}

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		playerCollider = GetComponent<CapsuleCollider>();
		anim = GetComponent<Animator>();
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		base.transform.position = MonoSingleton<NewMovement>.Instance.gc.transform.position;
		rb.velocity = MonoSingleton<NewMovement>.Instance.rb.velocity;
		if (MonoSingleton<PlayerTracker>.Instance.pmov == null)
		{
			MonoSingleton<PlayerTracker>.Instance.currentPlatformerPlayerPrefab = base.transform.parent.gameObject;
			MonoSingleton<PlayerTracker>.Instance.pmov = this;
			MonoSingleton<PlayerTracker>.Instance.ChangeToPlatformer();
		}
	}

	public void CheckItem()
	{
		if ((bool)MonoSingleton<FistControl>.Instance && (bool)MonoSingleton<FistControl>.Instance.heldObject)
		{
			MonoSingleton<FistControl>.Instance.heldObject.transform.SetParent(holder, worldPositionStays: true);
			MonoSingleton<FistControl>.Instance.ResetHeldItemPosition();
			Transform[] componentsInChildren = MonoSingleton<FistControl>.Instance.heldObject.GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].gameObject.layer = 22;
			}
		}
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		PlayerInput inputSource = MonoSingleton<InputManager>.Instance.InputSource;
		inputSource.Jump.Action.ApplyBindingOverride("<Gamepad>/buttonSouth", "Gamepad");
		inputSource.Fire1.Action.ApplyBindingOverride("<Gamepad>/buttonWest", "Gamepad");
		inputSource.Dodge.Action.ApplyBindingOverride("<Gamepad>/buttonNorth", "Gamepad");
		inputSource.Slide.Action.ApplyBindingOverride("<Gamepad>/buttonEast", "Gamepad");
		inputSource.Slide.Action.AddBinding(rbSlide);
		inputSource.Move.Action.AddBinding(dpadMove);
		slideLength = 0f;
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			PlayerInput inputSource = MonoSingleton<InputManager>.Instance.InputSource;
			inputSource.Jump.Action.RemoveAllBindingOverrides();
			inputSource.Fire1.Action.RemoveAllBindingOverrides();
			inputSource.Dodge.Action.RemoveAllBindingOverrides();
			inputSource.Slide.Action.RemoveAllBindingOverrides();
			inputSource.Slide.Action.ChangeBinding(rbSlide).Erase();
			inputSource.Move.Action.ChangeBinding(dpadMove).Erase();
			cameraTargets.Clear();
			if (sliding)
			{
				StopSlide();
			}
		}
	}

	private void Update()
	{
		if (MonoSingleton<OptionsManager>.Instance.paused)
		{
			return;
		}
		Vector2 zero = Vector2.zero;
		if (activated)
		{
			zero = MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>();
			movementDirection = Vector3.ClampMagnitude(zero.x * Vector3.right + zero.y * Vector3.forward, 1f);
			movementDirection = Quaternion.Euler(0f, platformerCamera.rotation.eulerAngles.y, 0f) * movementDirection;
		}
		else
		{
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			movementDirection = Vector3.zero;
		}
		if (movementDirection.magnitude > 0f)
		{
			anim.SetBool("Running", value: true);
		}
		else
		{
			anim.SetBool("Running", value: false);
		}
		if (rb.velocity.y < -100f)
		{
			rb.velocity = new Vector3(rb.velocity.x, -100f, rb.velocity.z);
		}
		if (activated && MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame && !falling && !jumpCooldown)
		{
			Jump();
		}
		if (!groundCheck.onGround)
		{
			if (fallTime < 1f)
			{
				fallTime += Time.deltaTime * 5f;
				if (fallTime > 1f)
				{
					falling = true;
				}
			}
			else if (rb.velocity.y < -2f)
			{
				fallSpeed = rb.velocity.y;
			}
		}
		else
		{
			fallTime = 0f;
		}
		if (groundCheck.onGround && falling && !jumpCooldown)
		{
			falling = false;
			fallSpeed = 0f;
			groundCheck.heavyFall = false;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame && groundCheck.onGround && activated && !sliding)
		{
			StartSlide();
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame && !groundCheck.onGround && !sliding && !jumping && activated && Physics.Raycast(groundCheck.transform.position + base.transform.up, base.transform.up * -1f, out var _, 2f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			StartSlide();
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasCanceledThisFrame && sliding)
		{
			StopSlide();
		}
		if (sliding && activated)
		{
			slideLength += Time.deltaTime;
			if (currentSlideEffect != null)
			{
				currentSlideEffect.transform.position = base.transform.position + dodgeDirection * 10f;
			}
			if (slideSafety > 0f)
			{
				slideSafety -= Time.deltaTime * 5f;
			}
			if (groundCheck.onGround)
			{
				currentSlideScrape.transform.position = base.transform.position + dodgeDirection;
			}
			else
			{
				currentSlideScrape.transform.position = Vector3.one * 5000f;
			}
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.WasPerformedThisFrame && activated)
		{
			if ((bool)groundProperties && !groundProperties.canDash)
			{
				if (!groundProperties.silentDashFail)
				{
					Object.Instantiate(staminaFailSound);
				}
			}
			else if (boostCharge >= 100f)
			{
				if (sliding)
				{
					StopSlide();
				}
				boostLeft = 100f;
				boost = true;
				anim.Play("Dash", -1, 0f);
				dodgeDirection = movementDirection;
				if (dodgeDirection == Vector3.zero)
				{
					dodgeDirection = playerModel.forward;
				}
				Quaternion identity = Quaternion.identity;
				identity.SetLookRotation(dodgeDirection * -1f);
				Object.Instantiate(dodgeParticle, base.transform.position + Vector3.up * 2f + dodgeDirection * 10f, identity).transform.localScale *= 2f;
				if (!MonoSingleton<AssistController>.Instance.majorEnabled || !MonoSingleton<AssistController>.Instance.infiniteStamina)
				{
					boostCharge -= 100f;
				}
				aud.clip = dodgeSound;
				aud.volume = 1f;
				aud.pitch = 1f;
				aud.Play();
			}
			else
			{
				Object.Instantiate(staminaFailSound);
			}
		}
		if (boostCharge != 300f && !sliding && !spinning)
		{
			float num = 1f;
			if (difficulty == 1)
			{
				num = 1.5f;
			}
			else if (difficulty == 0)
			{
				num = 2f;
			}
			boostCharge = Mathf.MoveTowards(boostCharge, 300f, 70f * Time.deltaTime * num);
		}
		if (spinCooldown > 0f)
		{
			spinCooldown = Mathf.MoveTowards(spinCooldown, 0f, Time.deltaTime);
		}
		if (activated && !spinning && spinCooldown <= 0f && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame || MonoSingleton<InputManager>.Instance.InputSource.Punch.WasPerformedThisFrame) && !MonoSingleton<OptionsManager>.Instance.paused)
		{
			Spin();
		}
		if (spinning)
		{
			playerModel.Rotate(Vector3.up, Time.deltaTime * 3600f, Space.Self);
		}
		else if (movementDirection.magnitude != 0f || boost)
		{
			Quaternion quaternion = Quaternion.LookRotation(movementDirection);
			if (boost)
			{
				quaternion = Quaternion.LookRotation(dodgeDirection);
			}
			playerModel.rotation = Quaternion.RotateTowards(playerModel.rotation, quaternion, (Quaternion.Angle(playerModel.rotation, quaternion) + 20f) * 35f * movementDirection.magnitude * Time.deltaTime);
		}
		if (cameraTrack)
		{
			if (!freeCamera)
			{
				CheckCameraTarget();
				Vector3 position = Vector3.MoveTowards(platformerCamera.position, base.transform.position + cameraTarget, Time.deltaTime * 15f * (0.1f + Vector3.Distance(platformerCamera.position, cameraTarget)));
				Quaternion rotation = Quaternion.RotateTowards(platformerCamera.transform.rotation, Quaternion.Euler(cameraRotation), Time.deltaTime * 15f * (0.1f + Vector3.Distance(platformerCamera.rotation.eulerAngles, cameraRotation)));
				platformerCamera.transform.SetPositionAndRotation(position, rotation);
			}
			else if (!MonoSingleton<OptionsManager>.Instance.paused)
			{
				platformerCamera.SetPositionAndRotation(base.transform.position + defaultCameraTarget, Quaternion.Euler(defaultCameraRotation));
				Vector2 vector = MonoSingleton<InputManager>.Instance.InputSource.Look.ReadValue<Vector2>();
				if (!MonoSingleton<CameraController>.Instance.reverseY)
				{
					rotationX += vector.y * (MonoSingleton<OptionsManager>.Instance.mouseSensitivity / 10f);
				}
				else
				{
					rotationX -= vector.y * (MonoSingleton<OptionsManager>.Instance.mouseSensitivity / 10f);
				}
				if (!MonoSingleton<CameraController>.Instance.reverseX)
				{
					rotationY += vector.x * (MonoSingleton<OptionsManager>.Instance.mouseSensitivity / 10f);
				}
				else
				{
					rotationY -= vector.x * (MonoSingleton<OptionsManager>.Instance.mouseSensitivity / 10f);
				}
				if (rotationY > 180f)
				{
					rotationY -= 360f;
				}
				else if (rotationY < -180f)
				{
					rotationY += 360f;
				}
				rotationX = Mathf.Clamp(rotationX, -69f, 109f);
				float num2 = 2.5f;
				if (sliding || Physics.Raycast(base.transform.position + Vector3.up * 0.625f, Vector3.up, 2.5f, LayerMaskDefaults.Get(LMD.Environment)))
				{
					num2 = 0.625f;
				}
				if (Input.GetKeyDown(KeyCode.L))
				{
					Debug.Log("Height: " + num2);
				}
				Vector3 vector2 = base.transform.position + Vector3.up * num2;
				platformerCamera.RotateAround(vector2, Vector3.left, rotationX);
				platformerCamera.RotateAround(vector2, Vector3.up, rotationY);
				if (Physics.SphereCast(vector2, 0.25f, platformerCamera.position - vector2, out var hitInfo2, Vector3.Distance(vector2, platformerCamera.position), LayerMaskDefaults.Get(LMD.Environment)))
				{
					platformerCamera.position = hitInfo2.point + 0.5f * hitInfo2.normal;
				}
			}
		}
		if (Physics.SphereCast(base.transform.position + Vector3.up, 0.5f, Vector3.down, out var hitInfo3, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			jumpShadow.position = hitInfo3.point + Vector3.up * 0.05f;
			jumpShadow.forward = hitInfo3.normal;
		}
		else
		{
			jumpShadow.position = base.transform.position - Vector3.up * 1000f;
			jumpShadow.forward = Vector3.up;
		}
		if (coinTimer > 0f)
		{
			coinTimer = Mathf.MoveTowards(coinTimer, 0f, Time.deltaTime);
		}
		if (coinEffectTimer > 0f)
		{
			coinEffectTimer = Mathf.MoveTowards(coinEffectTimer, 0f, Time.deltaTime);
		}
		else if (queuedCoins > 0)
		{
			CoinGetEffect();
		}
		if (invincible && extraHits < 3)
		{
			if (blinkTimer > 0f)
			{
				blinkTimer = Mathf.MoveTowards(blinkTimer, 0f, Time.deltaTime);
			}
			else
			{
				blinkTimer = 0.05f;
				if (playerModel.gameObject.activeSelf)
				{
					playerModel.gameObject.SetActive(value: false);
				}
				else
				{
					playerModel.gameObject.SetActive(value: true);
				}
			}
		}
		if (superTimer > 0f)
		{
			if (!NoWeaponCooldown.NoCooldown)
			{
				superTimer = Mathf.MoveTowards(superTimer, 0f, Time.deltaTime);
			}
			if (superTimer == 0f)
			{
				GetHit();
			}
		}
	}

	private void CheckCameraTarget(bool instant = false)
	{
		Vector3 position = defaultCameraTarget;
		Vector3 rotation = defaultCameraRotation;
		if (cameraTargets.Count > 0)
		{
			for (int num = cameraTargets.Count - 1; num >= 0; num--)
			{
				if ((bool)cameraTargets[num].caller && cameraTargets[num].caller.activeInHierarchy)
				{
					position = cameraTargets[num].position;
					rotation = cameraTargets[num].rotation;
					break;
				}
				cameraTargets.RemoveAt(num);
			}
		}
		if (instant)
		{
			cameraTarget = position;
			cameraRotation = rotation;
		}
		else
		{
			cameraTarget = Vector3.MoveTowards(cameraTarget, position, Time.deltaTime * 2f * (0.1f + Vector3.Distance(cameraTarget, position)));
			cameraRotation = Vector3.MoveTowards(cameraRotation, rotation, Time.deltaTime * 2f * (0.1f + Vector3.Distance(cameraRotation, rotation)));
		}
	}

	private void FixedUpdate()
	{
		SlideValues();
		if (boost || spinning)
		{
			rb.useGravity = true;
			Dodge();
			return;
		}
		base.gameObject.layer = 2;
		if (groundCheck.onGround && !jumping)
		{
			anim.SetBool("InAir", value: false);
			float y = rb.velocity.y;
			if (slopeCheck.onGround && movementDirection.x == 0f && movementDirection.z == 0f)
			{
				y = 0f;
				rb.useGravity = false;
			}
			else
			{
				rb.useGravity = true;
			}
			float num = 2.75f;
			if ((bool)groundProperties)
			{
				num *= groundProperties.speedMultiplier;
			}
			movementDirection2 = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * num, y, movementDirection.z * walkSpeed * Time.deltaTime * num);
			float num2 = 2.5f;
			Vector3 zero = Vector3.zero;
			if ((bool)groundProperties)
			{
				num2 *= groundProperties.friction;
				if (groundProperties.push)
				{
					Vector3 vector = groundProperties.pushForce;
					if (groundProperties.pushDirectionRelative)
					{
						vector = groundProperties.transform.rotation * vector;
					}
					zero += vector;
				}
			}
			rb.velocity = Vector3.MoveTowards(rb.velocity, movementDirection2 + zero, num2);
			return;
		}
		anim.SetBool("InAir", value: true);
		rb.useGravity = true;
		movementDirection2 = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * 2.75f, rb.velocity.y, movementDirection.z * walkSpeed * Time.deltaTime * 2.75f);
		airDirection.y = 0f;
		if ((movementDirection2.x > 0f && rb.velocity.x < movementDirection2.x) || (movementDirection2.x < 0f && rb.velocity.x > movementDirection2.x))
		{
			airDirection.x = movementDirection2.x;
		}
		else
		{
			airDirection.x = 0f;
		}
		if ((movementDirection2.z > 0f && rb.velocity.z < movementDirection2.z) || (movementDirection2.z < 0f && rb.velocity.z > movementDirection2.z))
		{
			airDirection.z = movementDirection2.z;
		}
		else
		{
			airDirection.z = 0f;
		}
		rb.AddForce(airDirection.normalized * 6000f);
		LayerMask layerMask = LayerMaskDefaults.Get(LMD.Environment);
		if (rb.velocity.y < 0f)
		{
			layerMask = (int)layerMask | 0x1000;
		}
		if (!Physics.SphereCast(base.transform.position + Vector3.up * 2.5f * base.transform.localScale.y, (base.transform.localScale.x + base.transform.localScale.z) / 2f * 0.75f - 0.1f, Vector3.up * rb.velocity.y, out var hitInfo, 2.51f + rb.velocity.y * Time.fixedDeltaTime, layerMask))
		{
			return;
		}
		EnemyIdentifier component3;
		if (hitInfo.transform.gameObject.layer == 8 || hitInfo.transform.gameObject.layer == 24)
		{
			EnemyIdentifier component2;
			if (hitInfo.transform.TryGetComponent<Breakable>(out var component) && component.crate)
			{
				if (component.bounceHealth > 1)
				{
					aud.clip = bounceSound;
					aud.pitch = Mathf.Lerp(1f, 2f, (float)(component.originalBounceHealth - component.bounceHealth) / (float)component.originalBounceHealth);
					aud.volume = 0.75f;
					aud.Play();
				}
				component.Bounce();
				if (base.transform.position.y < hitInfo.transform.position.y)
				{
					rb.velocity = new Vector3(MonoSingleton<PlatformerMovement>.Instance.rb.velocity.x, -10f, MonoSingleton<PlatformerMovement>.Instance.rb.velocity.z);
				}
				else if (MonoSingleton<InputManager>.Instance.InputSource.Jump.IsPressed)
				{
					Jump(silent: true, 1.35f);
				}
				else
				{
					Jump(silent: true, 0.75f);
				}
			}
			else if (hitInfo.transform.gameObject.CompareTag("Armor") && hitInfo.transform.TryGetComponent<EnemyIdentifier>(out component2))
			{
				component2.InstaKill();
			}
		}
		else if (hitInfo.transform.TryGetComponent<EnemyIdentifier>(out component3) && !component3.dead)
		{
			if (!component3.blessed)
			{
				component3.Splatter();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Jump.IsPressed)
			{
				Jump(silent: true, 1.25f);
			}
			else
			{
				Jump(silent: true, 0.75f);
			}
		}
	}

	public void Jump(bool silent = false, float multiplier = 1f)
	{
		float num = 1500f * multiplier;
		if ((bool)groundProperties)
		{
			if (!groundProperties.canJump)
			{
				if (!groundProperties.silentJumpFail)
				{
					aud.clip = jumpSound;
					aud.volume = 0.75f;
					aud.pitch = 0.25f;
					aud.Play();
				}
				return;
			}
			num *= groundProperties.jumpForceMultiplier;
		}
		anim.SetBool("InAir", value: true);
		anim.Play("Jump");
		falling = true;
		jumping = true;
		Invoke("NotJumping", 0.25f);
		if (!silent)
		{
			aud.clip = jumpSound;
			if (groundCheck.superJumpChance > 0f)
			{
				aud.volume = 0.85f;
				aud.pitch = 2f;
			}
			else
			{
				aud.volume = 0.75f;
				aud.pitch = 1f;
			}
			aud.Play();
		}
		rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
		if (sliding)
		{
			rb.AddForce(Vector3.up * jumpPower * num * 2f);
			StopSlide();
		}
		else if (boost)
		{
			if (boostCharge >= 100f)
			{
				if (!MonoSingleton<AssistController>.Instance.majorEnabled || !MonoSingleton<AssistController>.Instance.infiniteStamina)
				{
					boostCharge -= 100f;
				}
				Object.Instantiate(dashJumpSound);
			}
			else
			{
				rb.velocity = new Vector3(movementDirection.x * walkSpeed * Time.deltaTime * 2.75f, 0f, movementDirection.z * walkSpeed * Time.deltaTime * 2.75f);
				Object.Instantiate(staminaFailSound);
			}
			rb.AddForce(Vector3.up * jumpPower * num * 1.5f);
		}
		else if (groundCheck.superJumpChance > 0f || groundCheck.extraJumpChance > 0f)
		{
			if (slamForce < 5.5f)
			{
				rb.AddForce(Vector3.up * jumpPower * num * (3f + (slamForce - 1f)));
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * num * 12.5f);
			}
			slamForce = 0f;
		}
		else
		{
			rb.AddForce(Vector3.up * jumpPower * num * 2.6f);
		}
		jumpCooldown = true;
		Invoke("JumpReady", 0.2f);
		boost = false;
	}

	private void Dodge()
	{
		if (spinning)
		{
			movementDirection2 = new Vector3(movementDirection.x * spinSpeed, rb.velocity.y, movementDirection.z * spinSpeed);
			if (movementDirection.magnitude == 0f && !falling)
			{
				rb.velocity = new Vector3(Mathf.MoveTowards(rb.velocity.x, 0f, Time.fixedDeltaTime * 150f), rb.velocity.y, Mathf.MoveTowards(rb.velocity.z, 0f, Time.fixedDeltaTime * 150f));
			}
			else
			{
				airDirection.y = 0f;
				if ((movementDirection2.x > 0f && rb.velocity.x < movementDirection2.x) || (movementDirection2.x < 0f && rb.velocity.x > movementDirection2.x))
				{
					airDirection.x = movementDirection2.x;
				}
				else
				{
					airDirection.x = 0f;
				}
				if ((movementDirection2.z > 0f && rb.velocity.z < movementDirection2.z) || (movementDirection2.z < 0f && rb.velocity.z > movementDirection2.z))
				{
					airDirection.z = movementDirection2.z;
				}
				else
				{
					airDirection.z = 0f;
				}
				if (falling)
				{
					rb.AddForce(airDirection.normalized * 4000f);
				}
				else
				{
					rb.AddForce(airDirection.normalized * 24000f);
				}
			}
			spinJuice = Mathf.MoveTowards(spinJuice, 0f, Time.fixedDeltaTime * 3f);
			if (spinJuice <= 0f)
			{
				StopSpin();
			}
			return;
		}
		if (sliding)
		{
			float num = 1f;
			if (preSlideSpeed > 1f)
			{
				if (preSlideSpeed > 3f)
				{
					preSlideSpeed = 3f;
				}
				num = preSlideSpeed;
				preSlideSpeed -= Time.fixedDeltaTime * preSlideSpeed;
				preSlideDelay = 0f;
			}
			if ((bool)groundProperties)
			{
				if (!groundProperties.canSlide)
				{
					StopSlide();
					return;
				}
				num *= groundProperties.speedMultiplier;
			}
			Vector3 velocity = new Vector3(dodgeDirection.x * walkSpeed * Time.fixedDeltaTime * 5f * num, rb.velocity.y, dodgeDirection.z * walkSpeed * Time.fixedDeltaTime * 5f * num);
			if ((bool)groundProperties && groundProperties.push)
			{
				Vector3 vector = groundProperties.pushForce;
				if (groundProperties.pushDirectionRelative)
				{
					vector = groundProperties.transform.rotation * vector;
				}
				velocity += vector;
			}
			rb.velocity = velocity;
			return;
		}
		float y = 0f;
		if (slideEnding)
		{
			y = rb.velocity.y;
		}
		float num2 = 2.25f;
		movementDirection2 = new Vector3(dodgeDirection.x * walkSpeed * Time.fixedDeltaTime * num2, y, dodgeDirection.z * walkSpeed * Time.fixedDeltaTime * num2);
		if (!slideEnding || groundCheck.onGround)
		{
			rb.velocity = movementDirection2 * 3f;
		}
		base.gameObject.layer = 15;
		boostLeft -= 4f;
		if (boostLeft <= 0f)
		{
			boost = false;
			if (!groundCheck.onGround && !slideEnding)
			{
				rb.velocity = movementDirection2;
			}
		}
		slideEnding = false;
	}

	private void Spin()
	{
		anim.Play("Spin", -1, 0f);
		anim.SetBool("Spinning", value: true);
		spinning = true;
		spinJuice = 1f;
		spinZone.SetActive(value: true);
		if (sliding)
		{
			float num = 1f;
			if (preSlideSpeed > 1f)
			{
				if (preSlideSpeed > 3f)
				{
					preSlideSpeed = 3f;
				}
				num = preSlideSpeed;
			}
			if ((bool)groundProperties)
			{
				num *= groundProperties.speedMultiplier;
			}
			spinDirection = dodgeDirection;
			spinSpeed = walkSpeed * 5f * num * Time.fixedDeltaTime;
			StopSlide();
			boostLeft = 0f;
			boost = false;
		}
		else if (boost)
		{
			spinDirection = dodgeDirection;
			spinSpeed = walkSpeed * 8.25f * Time.fixedDeltaTime;
			boostLeft = 0f;
			boost = false;
		}
		else
		{
			Vector3 velocity = rb.velocity;
			velocity += movementDirection * walkSpeed * Time.fixedDeltaTime;
			velocity.y = 0f;
			if (velocity.magnitude <= 0.25f)
			{
				spinDirection = playerModel.forward;
			}
			else
			{
				spinDirection = velocity;
			}
			spinSpeed = velocity.magnitude;
		}
		rb.velocity = new Vector3(spinDirection.normalized.x * spinSpeed, rb.velocity.y, spinDirection.normalized.z * spinSpeed);
	}

	private void StopSpin()
	{
		spinning = false;
		anim.SetBool("Spinning", value: false);
		spinJuice = 0f;
		playerModel.forward = spinDirection;
		spinCooldown = 0.2f;
		spinZone.SetActive(value: false);
	}

	private void StartSlide()
	{
		slideLength = 0f;
		anim.SetBool("Sliding", value: true);
		if (currentSlideEffect != null)
		{
			Object.Destroy(currentSlideEffect);
		}
		if (currentSlideScrape != null)
		{
			Object.Destroy(currentSlideScrape);
		}
		if ((bool)groundProperties && !groundProperties.canSlide)
		{
			if (!groundProperties.silentSlideFail)
			{
				StopSlide();
			}
			return;
		}
		playerCollider.height = 1.25f;
		playerCollider.center = Vector3.up * 0.625f;
		slideSafety = 1f;
		sliding = true;
		boost = true;
		dodgeDirection = movementDirection;
		if (dodgeDirection == Vector3.zero)
		{
			dodgeDirection = playerModel.forward;
		}
		Quaternion identity = Quaternion.identity;
		identity.SetLookRotation(dodgeDirection * -1f);
		currentSlideEffect = Object.Instantiate(slideEffect, base.transform.position + dodgeDirection * 10f, identity);
		currentSlideScrape = Object.Instantiate(slideScrape, base.transform.position + dodgeDirection * 2f, identity);
	}

	public void StopSlide()
	{
		anim.SetBool("Sliding", value: false);
		if (currentSlideEffect != null)
		{
			Object.Destroy(currentSlideEffect);
		}
		if (currentSlideScrape != null)
		{
			Object.Destroy(currentSlideScrape);
		}
		if (sliding)
		{
			Object.Instantiate(slideStopSound);
		}
		sliding = false;
		slideEnding = true;
		if (slideLength > MonoSingleton<NewMovement>.Instance.longestSlide)
		{
			MonoSingleton<NewMovement>.Instance.longestSlide = slideLength;
		}
		slideLength = 0f;
		if (!crouching)
		{
			playerCollider.height = 5f;
			playerCollider.center = Vector3.up * 2.5f;
		}
	}

	private void SlideValues()
	{
		if (sliding && slideSafety <= 0f)
		{
			Vector3 vector = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			float num = 10f;
			if ((bool)groundProperties && groundProperties.speedMultiplier < 1f)
			{
				num *= groundProperties.speedMultiplier;
			}
			if (vector.magnitude < num)
			{
				slideSafety = Mathf.MoveTowards(slideSafety, -0.1f, Time.deltaTime);
				if (slideSafety <= -0.1f)
				{
					StopSlide();
				}
			}
			else
			{
				slideSafety = 0f;
			}
		}
		if (sliding || !activated)
		{
			return;
		}
		if (groundCheck.heavyFall)
		{
			preSlideDelay = 0.2f;
			preSlideSpeed = slamForce;
			if (Physics.SphereCast(base.transform.position - Vector3.up * 1.5f, 0.35f, Vector3.down, out var hitInfo, Time.fixedDeltaTime * Mathf.Abs(rb.velocity.y), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				base.transform.position = hitInfo.point + Vector3.up * 1.5f;
				rb.velocity = Vector3.zero;
			}
		}
		else if (!boost && !falling && rb.velocity.magnitude / 24f > preSlideSpeed)
		{
			preSlideSpeed = rb.velocity.magnitude / 24f;
			preSlideDelay = 0.2f;
		}
		else
		{
			preSlideDelay = Mathf.MoveTowards(preSlideDelay, 0f, Time.fixedDeltaTime);
			if (preSlideDelay <= 0f)
			{
				preSlideDelay = 0.2f;
				preSlideSpeed = rb.velocity.magnitude / 24f;
			}
		}
	}

	public void EmptyStamina()
	{
		boostCharge = 0f;
	}

	public void FullStamina()
	{
		boostCharge = 300f;
	}

	private void JumpReady()
	{
		jumpCooldown = false;
	}

	private void NotJumping()
	{
		jumping = false;
	}

	public void AddExtraHit(int amount = 1)
	{
		extraHits = Mathf.Clamp(extraHits + amount, 0, 3);
		CheckProtector();
		Object.Instantiate(protectorGet, playerCollider.bounds.center, Quaternion.identity, base.transform);
		if (extraHits >= 3)
		{
			invincible = true;
			playerModel.gameObject.SetActive(value: true);
			superTimer = 20f;
		}
	}

	private void CheckProtector()
	{
		extraHits = Mathf.Clamp(extraHits, 0, 3);
		for (int i = 0; i <= 2; i++)
		{
			if (i == extraHits - 1)
			{
				protectors[i].SetActive(value: true);
			}
			else
			{
				protectors[i].SetActive(value: false);
			}
		}
	}

	private void GetHit()
	{
		MonoSingleton<StatsManager>.Instance.tookDamage = true;
		extraHits--;
		CheckProtector();
		Object.Instantiate(protectorLose, playerCollider.bounds.center, Quaternion.identity, base.transform);
		invincible = true;
		Invoke("StopInvincibility", 3f);
	}

	private void StopInvincibility()
	{
		playerModel.gameObject.SetActive(value: true);
		invincible = false;
	}

	private void Death()
	{
		cameraTrack = false;
		dead = true;
		MonoSingleton<StatsManager>.Instance.tookDamage = true;
		if (extraHits > 0)
		{
			extraHits = 0;
			CheckProtector();
		}
		if (!freeCamera)
		{
			platformerCamera.transform.position = base.transform.position + cameraTarget;
		}
		if (boost || spinning)
		{
			StopSpin();
			boost = false;
		}
	}

	public void Fall()
	{
		if (!dead)
		{
			Death();
			Object.Instantiate(fallSound, base.transform.position, Quaternion.identity);
			Invoke("DeathOver", 2f);
		}
	}

	public void Explode(bool ignoreInvincible = false)
	{
		if (dead || (!ignoreInvincible && (invincible || Invincibility.Enabled)))
		{
			if (!dead && (extraHits == 3 || Invincibility.Enabled))
			{
				Object.Instantiate(protectorOof, playerCollider.bounds.center, Quaternion.identity, base.transform);
				Jump(silent: true);
			}
			return;
		}
		if (!ignoreInvincible && extraHits > 0)
		{
			GetHit();
			return;
		}
		Death();
		GoreZone goreZone = GoreZone.ResolveGoreZone(base.transform);
		GameObject gameObject = Object.Instantiate(MonoSingleton<BloodsplatterManager>.Instance.head, playerCollider.bounds.center, Quaternion.identity, goreZone.goreZone);
		Transform[] componentsInChildren = playerModel.GetComponentsInChildren<Transform>(includeInactive: true);
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.childCount <= 0 && !(Random.Range(0f, 1f) > 0.5f))
			{
				gameObject = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Body);
				if (!gameObject)
				{
					break;
				}
				gameObject.transform.parent = goreZone.goreZone;
				gameObject.transform.position = transform.position;
				gameObject.SetActive(value: true);
				gameObject = null;
			}
		}
		base.gameObject.SetActive(value: false);
		Invoke("DeathOver", 2f);
	}

	public void Burn(bool ignoreInvincible = false)
	{
		if (dead || (!ignoreInvincible && (invincible || Invincibility.Enabled)))
		{
			if (!dead && (extraHits == 3 || Invincibility.Enabled))
			{
				Object.Instantiate(protectorOof, playerCollider.bounds.center, Quaternion.identity, base.transform);
				Jump(silent: true);
			}
			return;
		}
		if (!ignoreInvincible && extraHits > 0)
		{
			GetHit();
			return;
		}
		if (currentCorpse != null)
		{
			CancelInvoke();
			Object.Destroy(currentCorpse);
		}
		Death();
		if ((bool)defaultBurnEffect)
		{
			Object.Instantiate(defaultBurnEffect, base.transform.position, Quaternion.identity);
		}
		currentCorpse = Object.Instantiate(playerModel.gameObject, playerModel.position, playerModel.rotation);
		base.gameObject.SetActive(value: false);
		SandboxUtils.StripForPreview(currentCorpse.transform, burnMaterial);
		Invoke("BecomeAsh", 1f);
	}

	private void BecomeAsh()
	{
		if ((bool)currentCorpse)
		{
			Object.Instantiate(ashSound, base.transform.position, Quaternion.identity);
			Transform[] componentsInChildren = currentCorpse.transform.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				Object.Instantiate(ashParticle, transform.position, Quaternion.identity);
			}
			Object.Destroy(currentCorpse);
			Invoke("DeathOver", 1f);
		}
	}

	private void DeathOver()
	{
		Respawn();
		MonoSingleton<StatsManager>.Instance.Restart();
	}

	public void Respawn()
	{
		cameraTrack = true;
		dead = false;
		jumping = false;
		jumpCooldown = false;
		extraHits = 0;
		boostCharge = 300f;
		rb.velocity = Vector3.zero;
		CancelInvoke();
		if ((bool)currentCorpse)
		{
			Object.Destroy(currentCorpse);
		}
		CheckProtector();
		StopInvincibility();
	}

	public void CoinGet()
	{
		queuedCoins++;
	}

	public void CoinGetEffect()
	{
		AudioSource component = Object.Instantiate(coinGet, playerCollider.bounds.center, Quaternion.identity).GetComponent<AudioSource>();
		if (coinTimer > 0f)
		{
			if (coinPitch < 1.35f)
			{
				coinPitch += 0.025f;
			}
			component.pitch = coinPitch;
		}
		else
		{
			coinPitch = 1f;
		}
		coinTimer = 1.5f;
		coinEffectTimer = 0.05f;
		queuedCoins--;
	}

	public void SnapCamera()
	{
		CheckCameraTarget(instant: true);
		platformerCamera.SetPositionAndRotation(base.transform.position + cameraTarget, Quaternion.Euler(cameraRotation));
	}

	public void SnapCamera(Vector3 targetPos, Vector3 targetRot)
	{
		cameraTarget = targetPos;
		cameraRotation = targetRot;
		platformerCamera.SetPositionAndRotation(targetPos, Quaternion.Euler(targetRot));
	}

	public void ResetCamera(float degreesY, float degreesX = 0f)
	{
		rotationY = degreesY;
		rotationX = degreesX;
	}
}



public static class PlatformTools
{
	public static string ResolveArg(string key)
	{
		string[] commandLineArgs = Environment.GetCommandLineArgs();
		for (int i = 0; i < commandLineArgs.Length; i++)
		{
			if (!(commandLineArgs[i] != key) && commandLineArgs.Length > i + 1)
			{
				return commandLineArgs[i + 1];
			}
		}
		return null;
	}
}



public class PlayerActivator : MonoBehaviour
{
	private NewMovement nm;

	private bool activated;

	[SerializeField]
	private bool startTimer;

	[SerializeField]
	private bool onlyActivatePlayer;

	private GunControl gc;

	public static Vector3 lastActivatedPosition;

	private void OnTriggerEnter(Collider other)
	{
		if (activated || !other.gameObject.CompareTag("Player"))
		{
			return;
		}
		nm = MonoSingleton<NewMovement>.Instance;
		gc = MonoSingleton<GunControl>.Instance;
		GameStateManager.Instance.PopState("pit-falling");
		if (!nm.activated)
		{
			nm.activated = true;
			nm.cc.activated = true;
			nm.cc.CameraShake(1f);
			AudioSource component = GetComponent<AudioSource>();
			if ((bool)component)
			{
				component.Play();
			}
		}
		activated = true;
		if (!onlyActivatePlayer)
		{
			gc.YesWeapon();
			ActivateObjects();
		}
		if (startTimer)
		{
			MonoSingleton<StatsManager>.Instance.StartTimer();
		}
		MonoSingleton<FistControl>.Instance.YesFist();
	}

	private void ActivateObjects()
	{
		MonoSingleton<PlayerActivatorRelay>.Instance.Activate();
		lastActivatedPosition = MonoSingleton<NewMovement>.Instance.transform.position;
	}
}



public class PlayerActivatorRelay : MonoSingleton<PlayerActivatorRelay>
{
	[SerializeField]
	private GameObject[] toActivate;

	[SerializeField]
	private GameObject gunPanel;

	[SerializeField]
	private GameObject crosshair;

	[SerializeField]
	private float delay = 0.2f;

	private int index;

	private void Start()
	{
		GameStateManager.Instance.RegisterState(new GameState("pit-falling", base.gameObject)
		{
			cameraInputLock = LockMode.Lock,
			cursorLock = LockMode.Lock
		});
	}

	public void Activate()
	{
		if (index >= toActivate.Length)
		{
			return;
		}
		if (toActivate[index] == gunPanel)
		{
			if (!MonoSingleton<GunControl>.Instance.noWeapons && MonoSingleton<PrefsManager>.Instance.GetBool("weaponIcons") && !MapInfoBase.InstanceAnyType.hideStockHUD)
			{
				gunPanel.SetActive(value: true);
			}
		}
		else if (toActivate[index] == crosshair)
		{
			crosshair.SetActive(value: true);
		}
		else if (!MapInfoBase.InstanceAnyType.hideStockHUD)
		{
			toActivate[index].SetActive(value: true);
		}
		index++;
		if (index < toActivate.Length)
		{
			Invoke("Activate", delay);
		}
	}
}



public class PlayerAnimations : MonoBehaviour
{
	public bool onGround;

	public AudioClip[] footsteps;

	private AudioSource aud;

	private Animator anim;

	public bool enemy = true;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if (!enemy)
		{
			anim = GetComponent<Animator>();
		}
	}

	private void Update()
	{
		if ((bool)anim)
		{
			anim.speed = Mathf.Min(MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude, 15f) / 15f;
		}
	}

	public void Footstep()
	{
		if (aud == null)
		{
			aud = GetComponent<AudioSource>();
		}
		else
		{
			if (!onGround || !aud)
			{
				return;
			}
			if (!MonoSingleton<NewMovement>.Instance || !MonoSingleton<NewMovement>.Instance.groundProperties || !MonoSingleton<NewMovement>.Instance.groundProperties.overrideFootsteps)
			{
				if (footsteps.Length != 0)
				{
					aud.pitch = Random.Range(0.9f, 1.1f);
					aud.clip = footsteps[Random.Range(0, footsteps.Length)];
					aud.Play();
				}
			}
			else if (MonoSingleton<NewMovement>.Instance.groundProperties.newFootstepSound != null)
			{
				aud.clip = MonoSingleton<NewMovement>.Instance.groundProperties.newFootstepSound;
				aud.pitch = Random.Range(0.9f, 1.1f);
				aud.Play();
			}
		}
	}
}



public class PlayerDistanceDecal : MonoBehaviour
{
	public GameObject decal;

	private GameObject currentDecal;

	private Collider col;

	private GameObject camObj;

	private void Update()
	{
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.CompareTag("Player"))
		{
			if (col == null)
			{
				col = GetComponent<Collider>();
			}
			if (camObj == null)
			{
				camObj = MonoSingleton<CameraController>.Instance.gameObject;
			}
			if (currentDecal == null)
			{
				currentDecal = Object.Instantiate(decal, base.transform.position, Quaternion.identity);
			}
			currentDecal.transform.position = col.ClosestPointOnBounds(camObj.transform.position);
			currentDecal.transform.LookAt(camObj.transform.position);
			currentDecal.transform.position += currentDecal.transform.forward * 0.1f;
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (currentDecal != null)
		{
			Object.Destroy(currentDecal);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			if (col == null)
			{
				col = GetComponent<Collider>();
			}
			if (camObj == null)
			{
				camObj = MonoSingleton<CameraController>.Instance.gameObject;
			}
			if (currentDecal == null)
			{
				currentDecal = Object.Instantiate(decal, base.transform.position, Quaternion.identity);
			}
			currentDecal.transform.position = col.ClosestPointOnBounds(camObj.transform.position);
			currentDecal.transform.LookAt(camObj.transform.position);
			currentDecal.transform.position += currentDecal.transform.forward * 0.1f;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (currentDecal != null)
		{
			Object.Destroy(currentDecal);
		}
	}
}



public class PlayerInput
{
	public InputActions Actions;

	public InputActionState Move;

	public InputActionState Look;

	public InputActionState WheelLook;

	public InputActionState Punch;

	public InputActionState Hook;

	public InputActionState Fire1;

	public InputActionState Fire2;

	public InputActionState Jump;

	public InputActionState Slide;

	public InputActionState Dodge;

	public InputActionState ChangeFist;

	public InputActionState NextVariation;

	public InputActionState PreviousVariation;

	public InputActionState NextWeapon;

	public InputActionState PrevWeapon;

	public InputActionState LastWeapon;

	public InputActionState SelectVariant1;

	public InputActionState SelectVariant2;

	public InputActionState SelectVariant3;

	public InputActionState Pause;

	public InputActionState Stats;

	public InputActionState Slot1;

	public InputActionState Slot2;

	public InputActionState Slot3;

	public InputActionState Slot4;

	public InputActionState Slot5;

	public InputActionState Slot6;

	private Dictionary<InputControl, InputBinding[]> conflicts = new Dictionary<InputControl, InputBinding[]>();

	public PlayerInput()
	{
		Actions = new InputActions();
		RebuildActions();
	}

	public void ValidateBindings(InputControlScheme scheme)
	{
		conflicts.Clear();
		IEnumerable<InputAction> source = from action in new InputActionMap[4] { Actions.Movement, Actions.Weapon, Actions.Fist, Actions.HUD }.SelectMany((InputActionMap map) => map.actions)
			where action.name != "Look" && action.name != "WheelLook"
			select action;
		Actions.RemoveAllBindingOverrides();
		foreach (IGrouping<InputControl, InputBinding> item in from binding in source.SelectMany((InputAction action) => action.bindings)
			where binding.groups != null
			where binding.groups.Contains(scheme.bindingGroup)
			where !binding.isComposite
			group binding by InputSystem.FindControl(binding.path))
		{
			if (item.Key == null)
			{
				continue;
			}
			InputBinding[] array = item.ToArray();
			if (array.Length > 1)
			{
				conflicts.Add(item.Key, array);
				for (int i = 0; i < array.Length; i++)
				{
					InputBinding bindingOverride = array[i];
					InputAction action2 = Actions.FindAction(bindingOverride.action);
					bindingOverride.overridePath = "";
					action2.ApplyBindingOverride(bindingOverride);
				}
			}
		}
	}

	private void RebuildActions()
	{
		Move = new InputActionState(Actions.Movement.Move);
		Look = new InputActionState(Actions.Movement.Look);
		WheelLook = new InputActionState(Actions.Weapon.WheelLook);
		Punch = new InputActionState(Actions.Fist.Punch);
		Hook = new InputActionState(Actions.Fist.Hook);
		Fire1 = new InputActionState(Actions.Weapon.PrimaryFire);
		Fire2 = new InputActionState(Actions.Weapon.SecondaryFire);
		Jump = new InputActionState(Actions.Movement.Jump);
		Slide = new InputActionState(Actions.Movement.Slide);
		Dodge = new InputActionState(Actions.Movement.Dodge);
		ChangeFist = new InputActionState(Actions.Fist.ChangeFist);
		NextVariation = new InputActionState(Actions.Weapon.NextVariation);
		PreviousVariation = new InputActionState(Actions.Weapon.PreviousVariation);
		NextWeapon = new InputActionState(Actions.Weapon.NextWeapon);
		PrevWeapon = new InputActionState(Actions.Weapon.PreviousWeapon);
		LastWeapon = new InputActionState(Actions.Weapon.LastUsedWeapon);
		SelectVariant1 = new InputActionState(Actions.Weapon.VariationSlot1);
		SelectVariant2 = new InputActionState(Actions.Weapon.VariationSlot2);
		SelectVariant3 = new InputActionState(Actions.Weapon.VariationSlot3);
		Pause = new InputActionState(Actions.UI.Pause);
		Stats = new InputActionState(Actions.HUD.Stats);
		Slot1 = new InputActionState(Actions.Weapon.Revolver);
		Slot2 = new InputActionState(Actions.Weapon.Shotgun);
		Slot3 = new InputActionState(Actions.Weapon.Nailgun);
		Slot4 = new InputActionState(Actions.Weapon.Railcannon);
		Slot5 = new InputActionState(Actions.Weapon.RocketLauncher);
		Slot6 = new InputActionState(Actions.Weapon.SpawnerArm);
	}

	public InputBinding[] GetConflicts(InputBinding binding)
	{
		InputControl inputControl = InputSystem.FindControl(binding.path);
		if (inputControl == null)
		{
			return new InputBinding[0];
		}
		if (conflicts.TryGetValue(inputControl, out var value))
		{
			return value;
		}
		return new InputBinding[0];
	}

	public void Enable()
	{
		Actions.Enable();
		ValidateBindings(Actions.KeyboardMouseScheme);
	}

	public void Disable()
	{
		Actions.Disable();
	}
}



public class PlayerInputHooks : MonoBehaviour
{
	[Header("Fire1")]
	[SerializeField]
	private UnityEvent onFire1Pressed;

	[SerializeField]
	private UnityEvent onFire1Released;

	[Space]
	[Header("Fire2")]
	[SerializeField]
	private UnityEvent onFire2Pressed;

	[SerializeField]
	private UnityEvent onFire2Released;

	[Space]
	[Header("Slide")]
	[SerializeField]
	private UnityEvent onSlideInputStart;

	[SerializeField]
	private UnityEvent onSlideInputEnd;

	[Space]
	[Header("Jump")]
	[SerializeField]
	private UnityEvent onJumpPressed;

	[SerializeField]
	private UnityEvent onJumpReleased;

	[Header("Dash")]
	[SerializeField]
	private UnityEvent onDashPressed;

	[SerializeField]
	private UnityEvent onDashReleased;

	private void Update()
	{
		if (!MonoSingleton<OptionsManager>.Instance || !MonoSingleton<OptionsManager>.Instance.paused)
		{
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)
			{
				onFire1Pressed.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasCanceledThisFrame)
			{
				onFire1Released.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame)
			{
				onFire2Pressed.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasCanceledThisFrame)
			{
				onFire2Released.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasPerformedThisFrame)
			{
				onSlideInputStart.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Slide.WasCanceledThisFrame)
			{
				onSlideInputEnd.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Jump.WasPerformedThisFrame)
			{
				onJumpPressed.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Jump.WasCanceledThisFrame)
			{
				onJumpReleased.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.WasPerformedThisFrame)
			{
				onDashPressed.Invoke();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.WasCanceledThisFrame)
			{
				onDashReleased.Invoke();
			}
		}
	}
}



public class PlayerLoadout : MonoBehaviour, IPlaceholdableComponent
{
	[FormerlySerializedAs("forceLoadout")]
	public bool forceStartLoadout;

	public ForcedLoadout loadout;

	public void WillReplace(GameObject oldObject, GameObject newObject, bool isSelfBeingReplaced)
	{
		if (isSelfBeingReplaced && forceStartLoadout)
		{
			PlayerLoadoutTarget component = newObject.GetComponent<PlayerLoadoutTarget>();
			if ((bool)component)
			{
				component.CommitLoadout(loadout);
			}
		}
	}

	public void SetLoadout()
	{
		MonoSingleton<GunSetter>.Instance.forcedLoadout = loadout;
		MonoSingleton<GunSetter>.Instance.ResetWeapons();
		MonoSingleton<FistControl>.Instance.forcedLoadout = loadout;
		MonoSingleton<FistControl>.Instance.ResetFists();
	}
}



public class PlayerLoadoutTarget : MonoBehaviour
{
	public void CommitLoadout(ForcedLoadout loadout)
	{
		Debug.Log($"Setting loadout on {loadout}");
		MonoSingleton<GunSetter>.Instance.forcedLoadout = loadout;
		MonoSingleton<GunSetter>.Instance.ResetWeapons();
		MonoSingleton<FistControl>.Instance.forcedLoadout = loadout;
		MonoSingleton<FistControl>.Instance.ResetFists();
	}
}



public class PlayerMovementLimiter : MonoBehaviour
{
	[SerializeField]
	private float animatorInteractionSpeedCap = 30f;

	private Rigidbody rigidbody;

	private Vector3 lastVel;

	private void Awake()
	{
		rigidbody = GetComponent<Rigidbody>();
	}

	private void LateUpdate()
	{
		lastVel = rigidbody.velocity;
	}

	private bool AnimatorCheck(Collision collision)
	{
		if (collision.gameObject.TryGetComponent<Animator>(out var component))
		{
			return true;
		}
		if ((bool)collision.transform.parent && collision.transform.parent.TryGetComponent<Animator>(out component))
		{
			return true;
		}
		return false;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (AnimatorCheck(collision) && (lastVel - rigidbody.velocity).magnitude > animatorInteractionSpeedCap)
		{
			StartCoroutine(CancelOnNext(lastVel, lastVel - rigidbody.velocity));
		}
	}

	private void OnCollisionStay(Collision collision)
	{
		if (AnimatorCheck(collision) && (lastVel - rigidbody.velocity).magnitude > animatorInteractionSpeedCap)
		{
			StartCoroutine(CancelOnNext(lastVel, lastVel - rigidbody.velocity));
		}
	}

	private IEnumerator CancelOnNext(Vector3 lastVelocity, Vector3 newDelta)
	{
		rigidbody.velocity = lastVelocity;
		yield return new WaitForFixedUpdate();
		rigidbody.velocity = lastVelocity;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class PlayerMovementParenting : MonoSingleton<PlayerMovementParenting>
{
	private static readonly plog.Logger Log = new plog.Logger("PlayerMovementParenting");

	public Transform deltaReceiver;

	private Vector3 lastTrackedPos;

	private float lastAngle;

	private Transform playerTracker;

	[HideInInspector]
	public bool lockParent;

	private Vector3 teleportLockDelta;

	private List<Transform> trackedObjects = new List<Transform>();

	public Vector3 currentDelta { get; private set; }

	public List<Transform> TrackedObjects => trackedObjects;

	private new void Awake()
	{
		if (deltaReceiver == null)
		{
			deltaReceiver = base.transform;
		}
	}

	private void FixedUpdate()
	{
		currentDelta = Vector3.zero;
		if (playerTracker == null)
		{
			return;
		}
		if (!MonoSingleton<NewMovement>.Instance.enabled)
		{
			DetachPlayer();
			return;
		}
		Vector3 position = playerTracker.transform.position;
		float y = playerTracker.transform.eulerAngles.y;
		Vector3 vector = position - lastTrackedPos;
		lastTrackedPos = position;
		bool flag = true;
		if ((bool)MonoSingleton<NewMovement>.Instance && (bool)MonoSingleton<NewMovement>.Instance.groundProperties && MonoSingleton<NewMovement>.Instance.groundProperties.dontRotateCamera)
		{
			flag = false;
		}
		float num = y - lastAngle;
		lastAngle = y;
		float num2 = Mathf.Abs(num);
		if (num2 > 180f)
		{
			num2 = 360f - num2;
		}
		if (num2 > 5f)
		{
			if (PlayerParentingDebug.Active)
			{
				Log.Fine($"Angle delta too high: {num2} degrees");
			}
			DetachPlayer();
			return;
		}
		if (vector.magnitude > 2f)
		{
			if (PlayerParentingDebug.Active)
			{
				Log.Fine($"Position delta too high: {vector.magnitude} units");
			}
			DetachPlayer();
			return;
		}
		deltaReceiver.position += vector;
		playerTracker.transform.position = deltaReceiver.position;
		lastTrackedPos = playerTracker.transform.position;
		currentDelta = vector;
		if (flag)
		{
			MonoSingleton<CameraController>.Instance.rotationY += num;
		}
	}

	public bool IsPlayerTracking()
	{
		return playerTracker != null;
	}

	public bool IsObjectTracked(Transform other)
	{
		return trackedObjects.Contains(other);
	}

	public void AttachPlayer(Transform other)
	{
		if (!lockParent)
		{
			trackedObjects.Add(other);
			GameObject obj = new GameObject("Player Position Proxy");
			obj.transform.parent = other;
			obj.transform.position = deltaReceiver.position;
			obj.transform.rotation = deltaReceiver.rotation;
			GameObject gameObject = obj;
			lastTrackedPos = gameObject.transform.position;
			lastAngle = gameObject.transform.eulerAngles.y;
			if (playerTracker != null)
			{
				Object.Destroy(playerTracker.gameObject);
			}
			playerTracker = gameObject.transform;
			ClearTrackedNulls();
		}
	}

	public void DetachPlayer([CanBeNull] Transform other = null)
	{
		if (lockParent)
		{
			return;
		}
		if (other == null)
		{
			trackedObjects.Clear();
		}
		else
		{
			trackedObjects.Remove(other);
		}
		if (trackedObjects.Count == 0)
		{
			Object.Destroy(playerTracker.gameObject);
			playerTracker = null;
			return;
		}
		ClearTrackedNulls();
		if (playerTracker != null && trackedObjects.Count > 0)
		{
			playerTracker.SetParent(trackedObjects.First());
		}
	}

	private void ClearTrackedNulls()
	{
		for (int num = trackedObjects.Count - 1; num >= 0; num--)
		{
			if (trackedObjects[num] == null)
			{
				trackedObjects.RemoveAt(num);
			}
		}
	}

	public void LockMovementParent(bool fuck)
	{
		lockParent = fuck;
	}

	public void LockMovementParentTeleport(bool fuck)
	{
		if ((bool)playerTracker)
		{
			if (fuck)
			{
				teleportLockDelta = lastTrackedPos - playerTracker.position;
			}
			if (lockParent && !fuck)
			{
				lastTrackedPos = playerTracker.position - teleportLockDelta;
			}
		}
		else
		{
			teleportLockDelta = lastTrackedPos;
		}
		lockParent = fuck;
	}
}



public class PlayerPosInfo : MonoBehaviour
{
	public bool noPosition;

	public Vector3 velocity;

	public Vector3 position;

	public float wooshTime;

	private void Start()
	{
		Object.DontDestroyOnLoad(base.gameObject);
	}
}



public class PlayerPrefButton : MonoBehaviour
{
	[Header("ONLY FOR CYBER GRIND THEME FUCK YOU FIELD IGNORED FUCK YOU")]
	public string playerPref;

	public int defaultValue;

	public UnityEvent[] onIntValues;

	private void Start()
	{
		CheckPref();
	}

	public void SetValue(int value)
	{
		MonoSingleton<PrefsManager>.Instance.SetInt("cyberGrind.theme", value);
		CheckPref();
	}

	public void CheckPref()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("cyberGrind.theme", defaultValue);
		if (onIntValues != null && onIntValues.Length != 0)
		{
			if (@int < onIntValues.Length)
			{
				onIntValues[@int]?.Invoke();
			}
			else if (@int == 0)
			{
				onIntValues[0]?.Invoke();
			}
			else
			{
				onIntValues[onIntValues.Length - 1]?.Invoke();
			}
		}
	}
}



public class PlayerTracker : MonoSingleton<PlayerTracker>
{
	public PlayerType playerType;

	private bool initialized;

	private NewMovement nmov;

	private CameraController cc;

	public GameObject platformerPlayerPrefab;

	[HideInInspector]
	public GameObject currentPlatformerPlayerPrefab;

	[HideInInspector]
	public PlatformerMovement pmov;

	private Transform player;

	private Transform target;

	private Rigidbody playerRb;

	[HideInInspector]
	public bool levelStarted;

	private bool startAsPlatformer;

	public PlatformerCameraType cameraType;

	public GameObject[] platformerFailSafes;

	private void Start()
	{
		if (!initialized)
		{
			Initialize();
		}
	}

	public Transform GetPlayer()
	{
		if (!initialized)
		{
			Initialize();
		}
		return player;
	}

	public Transform GetTarget()
	{
		if (!initialized)
		{
			Initialize();
		}
		return target;
	}

	public Rigidbody GetRigidbody()
	{
		if (!initialized)
		{
			Initialize();
		}
		return playerRb;
	}

	public Vector3 PredictPlayerPosition(float time, bool aimAtHead = false, bool ignoreCollision = false)
	{
		Vector3 vector = GetPlayerVelocity() * time;
		if (!ignoreCollision && Physics.Raycast(playerRb.position, vector, out var hitInfo, vector.magnitude, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
		{
			return hitInfo.point;
		}
		if (aimAtHead)
		{
			return target.position + vector;
		}
		return playerRb.position + vector;
	}

	public Vector3 GetPlayerVelocity(bool trueVelocity = false)
	{
		if (!initialized)
		{
			Initialize();
		}
		Vector3 velocity = playerRb.velocity;
		if (!trueVelocity && MonoSingleton<NewMovement>.Instance.boost && !MonoSingleton<NewMovement>.Instance.sliding)
		{
			velocity /= 3f;
		}
		if ((bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
		{
			velocity += MonoSingleton<NewMovement>.Instance.ridingRocket.rb.velocity;
		}
		if (MonoSingleton<PlayerMovementParenting>.Instance != null)
		{
			Vector3 currentDelta = MonoSingleton<PlayerMovementParenting>.Instance.currentDelta;
			currentDelta *= 60f;
			velocity += currentDelta;
		}
		return velocity;
	}

	public bool GetOnGround()
	{
		if (!initialized)
		{
			Initialize();
		}
		if (playerType != 0 || !MonoSingleton<NewMovement>.Instance.gc.onGround)
		{
			if (playerType == PlayerType.Platformer)
			{
				return MonoSingleton<PlatformerMovement>.Instance.groundCheck.onGround;
			}
			return false;
		}
		return true;
	}

	public void ChangeToPlatformer()
	{
		ChangeToPlatformer(ignorePreviousRotation: false);
	}

	public void ChangeToPlatformer(bool ignorePreviousRotation = false)
	{
		if (!initialized)
		{
			Initialize();
		}
		if (!pmov || !nmov || !currentPlatformerPlayerPrefab)
		{
			return;
		}
		if (cameraType == PlatformerCameraType.PlayerControlled)
		{
			pmov.freeCamera = true;
		}
		else
		{
			pmov.freeCamera = false;
		}
		if (!levelStarted)
		{
			startAsPlatformer = true;
		}
		else
		{
			if (playerType == PlayerType.Platformer)
			{
				return;
			}
			if (cameraType == PlatformerCameraType.PlayerControlled && !ignorePreviousRotation)
			{
				pmov.ResetCamera(MonoSingleton<CameraController>.Instance.rotationY, MonoSingleton<CameraController>.Instance.rotationX + 20f);
			}
			playerType = PlayerType.Platformer;
			currentPlatformerPlayerPrefab.SetActive(value: true);
			pmov.gameObject.SetActive(value: true);
			ChangeTargetParent(player, pmov.transform, Vector3.up * 2.5f);
			ChangeTargetParent(target, pmov.transform, Vector3.up * 2.5f);
			nmov.gameObject.SetActive(value: false);
			currentPlatformerPlayerPrefab.transform.position = nmov.transform.position - Vector3.up * 1.5f;
			pmov.transform.position = currentPlatformerPlayerPrefab.transform.position;
			pmov.platformerCamera.transform.localPosition = Vector3.up * 2.5f;
			pmov.playerModel.transform.rotation = nmov.transform.rotation;
			if ((bool)pmov.rb)
			{
				playerRb = pmov.rb;
			}
			else
			{
				playerRb = pmov.GetComponent<Rigidbody>();
			}
			pmov.CheckItem();
			playerRb.velocity = nmov.rb.velocity;
			MonoSingleton<PostProcessV2_Handler>.Instance?.ChangeCamera(hudless: true);
			GameObject[] array = platformerFailSafes;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: true);
				}
			}
		}
	}

	public void ChangeToFPS()
	{
		if (!initialized)
		{
			Initialize();
		}
		if (!pmov || !nmov || !currentPlatformerPlayerPrefab)
		{
			return;
		}
		if (!levelStarted)
		{
			startAsPlatformer = false;
		}
		else
		{
			if (playerType == PlayerType.FPS)
			{
				return;
			}
			playerType = PlayerType.FPS;
			nmov.transform.position = pmov.transform.position + Vector3.up * 1.5f;
			currentPlatformerPlayerPrefab.SetActive(value: false);
			playerRb = nmov.rb;
			nmov.gameObject.SetActive(value: true);
			ChangeTargetParent(player, nmov.transform);
			ChangeTargetParent(target, cc.transform);
			pmov.gameObject.SetActive(value: false);
			MonoSingleton<PostProcessV2_Handler>.Instance?.ChangeCamera(hudless: false);
			if (pmov.freeCamera)
			{
				MonoSingleton<CameraController>.Instance.ResetCamera(pmov.rotationY, pmov.rotationX - 20f);
			}
			else
			{
				MonoSingleton<CameraController>.Instance.ResetCamera(pmov.playerModel.transform.rotation.eulerAngles.y);
			}
			if ((bool)pmov.rb)
			{
				nmov.rb.velocity = pmov.rb.velocity;
			}
			GameObject[] array = platformerFailSafes;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: false);
				}
			}
		}
	}

	private void Initialize()
	{
		if (initialized)
		{
			return;
		}
		initialized = true;
		nmov = MonoSingleton<NewMovement>.Instance;
		cc = MonoSingleton<CameraController>.Instance;
		if (!nmov || !cc)
		{
			return;
		}
		Camera camera = null;
		if ((bool)cc && (bool)cc.cam)
		{
			camera = cc.cam;
		}
		else if ((bool)cc)
		{
			camera = cc.GetComponent<Camera>();
		}
		if (playerType == PlayerType.Platformer && !levelStarted)
		{
			startAsPlatformer = true;
			playerType = PlayerType.FPS;
		}
		GameObject gameObject = new GameObject();
		player = gameObject.transform;
		ChangeTargetParent(player, nmov.transform);
		if ((bool)nmov.rb)
		{
			playerRb = nmov.rb;
		}
		else
		{
			playerRb = nmov.GetComponent<Rigidbody>();
		}
		GameObject gameObject2 = new GameObject();
		target = gameObject2.transform;
		ChangeTargetParent(target, cc.transform);
		if (!pmov && !(player == null) && !(platformerPlayerPrefab == null))
		{
			currentPlatformerPlayerPrefab = Object.Instantiate(platformerPlayerPrefab, player.position, Quaternion.identity);
			pmov = currentPlatformerPlayerPrefab.GetComponentInChildren<PlatformerMovement>(includeInactive: true);
			if ((bool)camera)
			{
				currentPlatformerPlayerPrefab.GetComponentInChildren<Camera>(includeInactive: true).clearFlags = camera.clearFlags;
			}
			currentPlatformerPlayerPrefab.GetComponentInChildren<UnderwaterController>(includeInactive: true).overlay = MonoSingleton<UnderwaterController>.Instance.overlay;
		}
	}

	private void ChangeTargetParent(Transform toMove, Transform newParent, Vector3 offset = default(Vector3))
	{
		toMove.position = newParent.position + offset;
		toMove.SetParent(newParent);
	}

	public void CheckPlayerType()
	{
		if (playerType == PlayerType.FPS && (!MonoSingleton<NewMovement>.Instance || !MonoSingleton<NewMovement>.Instance.gameObject.activeInHierarchy))
		{
			ChangeToFPS();
		}
		else if (playerType == PlayerType.Platformer && (!currentPlatformerPlayerPrefab || !currentPlatformerPlayerPrefab.gameObject.activeInHierarchy))
		{
			ChangeToPlatformer();
		}
	}

	public void LevelStart()
	{
		if (levelStarted)
		{
			return;
		}
		levelStarted = true;
		if (startAsPlatformer)
		{
			ChangeToPlatformer(pmov.freeCamera);
		}
		else
		{
			if (playerType != 0)
			{
				return;
			}
			GameObject[] array = platformerFailSafes;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: false);
				}
			}
		}
	}
}


public enum PlayerType
{
	FPS,
	Platformer
}



public class PlayerUtilities : MonoSingleton<PlayerUtilities>
{
	public bool enableOutput;

	public string distanceTraveledMapVar;

	public string currentHealthVar;

	public string currentHardDamageVar;

	public string currentStyleScoreVar;

	public string currentTimeVar;

	public string currentKillCountVar;

	public string currentRankVar;

	private static AudioSource detachedWhoosh;

	private float distanceTraveled;

	private Vector3? lastRecordedPosition;

	public void Update()
	{
		if (!enableOutput)
		{
			return;
		}
		if (!string.IsNullOrEmpty(distanceTraveledMapVar))
		{
			if (!lastRecordedPosition.HasValue)
			{
				lastRecordedPosition = MonoSingleton<NewMovement>.Instance.transform.position;
			}
			distanceTraveled += Vector3.Distance(lastRecordedPosition.Value, MonoSingleton<NewMovement>.Instance.transform.position);
			lastRecordedPosition = MonoSingleton<NewMovement>.Instance.transform.position;
			MonoSingleton<MapVarManager>.Instance.SetFloat(distanceTraveledMapVar, distanceTraveled);
		}
		if (!string.IsNullOrEmpty(currentHealthVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetInt(currentHealthVar, MonoSingleton<NewMovement>.Instance.hp);
		}
		if (!string.IsNullOrEmpty(currentHardDamageVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetFloat(currentHardDamageVar, MonoSingleton<NewMovement>.Instance.antiHp);
		}
		if (!string.IsNullOrEmpty(currentStyleScoreVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetInt(currentStyleScoreVar, MonoSingleton<StatsManager>.Instance.stylePoints);
		}
		if (!string.IsNullOrEmpty(currentTimeVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetFloat(currentTimeVar, MonoSingleton<StatsManager>.Instance.seconds);
		}
		if (!string.IsNullOrEmpty(currentKillCountVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetInt(currentKillCountVar, MonoSingleton<StatsManager>.Instance.kills);
		}
		if (!string.IsNullOrEmpty(currentRankVar))
		{
			MonoSingleton<MapVarManager>.Instance.SetInt(currentRankVar, MonoSingleton<StatsManager>.Instance.rankScore);
		}
	}

	public void DisablePlayer()
	{
		MonoSingleton<NewMovement>.Instance.gameObject.SetActive(value: false);
	}

	public void EnablePlayer()
	{
		MonoSingleton<NewMovement>.Instance.gameObject.SetActive(value: true);
	}

	public void FreezePlayer()
	{
		MonoSingleton<NewMovement>.Instance.enabled = false;
		MonoSingleton<NewMovement>.Instance.rb.isKinematic = true;
		MonoSingleton<CameraController>.Instance.activated = false;
	}

	public void UnfreezePlayer()
	{
		MonoSingleton<NewMovement>.Instance.enabled = true;
		MonoSingleton<NewMovement>.Instance.rb.isKinematic = false;
		MonoSingleton<CameraController>.Instance.activated = true;
	}

	public void FadeOutFallingWhoosh()
	{
		if ((bool)detachedWhoosh)
		{
			Object.Destroy(detachedWhoosh.gameObject);
		}
		detachedWhoosh = MonoSingleton<NewMovement>.Instance.DuplicateDetachWhoosh();
		FadeOut fadeOut = detachedWhoosh.gameObject.AddComponent<FadeOut>();
		fadeOut.auds = new AudioSource[1] { detachedWhoosh };
		fadeOut.speed = 0.1f;
	}

	public void FadeOutFallingWhooshCustomSpeed(float speed)
	{
		if ((bool)detachedWhoosh)
		{
			Object.Destroy(detachedWhoosh.gameObject);
		}
		detachedWhoosh = MonoSingleton<NewMovement>.Instance.DuplicateDetachWhoosh();
		FadeOut fadeOut = detachedWhoosh.gameObject.AddComponent<FadeOut>();
		fadeOut.auds = new AudioSource[1] { detachedWhoosh };
		fadeOut.speed = speed;
	}

	public void RestoreFallingWhoosh()
	{
		if ((bool)detachedWhoosh)
		{
			AudioSource audioSource = MonoSingleton<NewMovement>.Instance.RestoreWhoosh();
			audioSource.time = detachedWhoosh.time;
			audioSource.Play();
			Object.Destroy(detachedWhoosh.gameObject);
		}
	}

	public void YesWeapon()
	{
		MonoSingleton<GunControl>.Instance.YesWeapon();
	}

	public void NoWeapon()
	{
		MonoSingleton<GunControl>.Instance.NoWeapon();
	}

	public void YesFist()
	{
		MonoSingleton<FistControl>.Instance.YesFist();
	}

	public void NoFist()
	{
		MonoSingleton<FistControl>.Instance.NoFist();
	}

	public void HealPlayer(int health)
	{
		MonoSingleton<NewMovement>.Instance.GetHealth(health, silent: false);
	}

	public void HealPlayerSilent(int health)
	{
		MonoSingleton<NewMovement>.Instance.GetHealth(health, silent: true);
	}

	public void EmptyStamina()
	{
		MonoSingleton<NewMovement>.Instance.EmptyStamina();
	}

	public void FullStamina()
	{
		MonoSingleton<NewMovement>.Instance.FullStamina();
	}

	public void ResetHardDamage()
	{
		MonoSingleton<NewMovement>.Instance.ResetHardDamage();
	}

	public void MaxCharges()
	{
		MonoSingleton<WeaponCharges>.Instance.MaxCharges();
	}

	public void DestroyHeldObject()
	{
		if ((bool)MonoSingleton<FistControl>.Instance && (bool)MonoSingleton<FistControl>.Instance.heldObject)
		{
			Object.Destroy(MonoSingleton<FistControl>.Instance.heldObject.gameObject);
			MonoSingleton<FistControl>.Instance.currentPunch.ResetHeldState();
		}
	}

	public void PlaceHeldObject(ItemPlaceZone target)
	{
		if ((bool)MonoSingleton<FistControl>.Instance && (bool)MonoSingleton<FistControl>.Instance.currentPunch && (bool)target)
		{
			MonoSingleton<FistControl>.Instance.currentPunch.PlaceHeldObject(new ItemPlaceZone[1] { target }, target.transform);
		}
	}

	public void ForceHoldObject(ItemIdentifier pickup)
	{
		DestroyHeldObject();
		if ((bool)MonoSingleton<FistControl>.Instance && (bool)MonoSingleton<FistControl>.Instance.currentPunch)
		{
			MonoSingleton<FistControl>.Instance.currentPunch.ForceHold(pickup);
		}
	}

	public void ParryFlash()
	{
		MonoSingleton<TimeController>.Instance.ParryFlash();
	}

	public void QuitMap()
	{
		MonoSingleton<OptionsManager>.Instance.QuitMission();
	}

	public void FinishMap()
	{
		SceneHelper.SpawnFinalPitAndFinish();
	}

	public void SetGravity(float gravity)
	{
		Physics.gravity = new Vector3(0f, gravity, 0f);
	}

	public void SetGravity(Vector3 gravity)
	{
		Physics.gravity = gravity;
	}

	public void SetPlayerHealth(int health)
	{
		MonoSingleton<NewMovement>.Instance.hp = health;
	}

	public void SetPlayerHardDamage(float damage)
	{
		MonoSingleton<NewMovement>.Instance.antiHp = damage;
	}

	public void SetPlayerStamina(float boostCharge)
	{
		MonoSingleton<NewMovement>.Instance.boostCharge = boostCharge;
	}
}



[JsonObject(MemberSerialization.OptIn)]
public class Playlist
{
	public enum LoopMode
	{
		Loop,
		LoopOne
	}

	public class SongMetadata
	{
		public string displayName;

		public Sprite icon;

		public int maxClips;

		public SongMetadata(string displayName, Sprite icon, int maxClips = 1)
		{
			this.displayName = displayName;
			this.icon = icon;
			this.maxClips = maxClips;
		}
	}

	public class SongIdentifier
	{
		public enum IdentifierType
		{
			Addressable,
			File
		}

		public string path;

		public IdentifierType type;

		public SongIdentifier(string id, IdentifierType type)
		{
			path = id;
			this.type = type;
		}

		public static implicit operator SongIdentifier(string id)
		{
			return new SongIdentifier(id, IdentifierType.Addressable);
		}

		public override bool Equals(object obj)
		{
			SongIdentifier songIdentifier = obj as SongIdentifier;
			if (songIdentifier?.path == path)
			{
				return songIdentifier?.type == type;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (-1056084179 * -1521134295 + EqualityComparer<string>.Default.GetHashCode(path)) * -1521134295 + type.GetHashCode();
		}
	}

	[JsonProperty]
	private List<SongIdentifier> _ids = new List<SongIdentifier>();

	[JsonProperty]
	private LoopMode _loopMode = LoopMode.LoopOne;

	[JsonProperty]
	private int _selected;

	[JsonProperty]
	private bool _shuffled = true;

	public static DirectoryInfo directory => Directory.CreateDirectory(Path.Combine(Directory.GetParent(Application.dataPath).FullName, "Preferences", "Playlists"));

	public static string currentPath
	{
		get
		{
			string text = Path.Combine(directory.Parent.FullName, "Playlist.json");
			string text2 = Path.Combine(directory.FullName, $"slot{GameProgressSaver.currentSlot + 1}.json");
			if (File.Exists(text) && !File.Exists(text2))
			{
				File.Move(text, text2);
			}
			return text2;
		}
	}

	public List<SongIdentifier> ids => _ids;

	public LoopMode loopMode
	{
		get
		{
			return _loopMode;
		}
		set
		{
			_loopMode = value;
			this.OnChanged?.Invoke();
		}
	}

	public int selected
	{
		get
		{
			return _selected;
		}
		set
		{
			_selected = value;
			this.OnChanged?.Invoke();
		}
	}

	public bool shuffled
	{
		get
		{
			return _shuffled;
		}
		set
		{
			_shuffled = value;
			this.OnChanged?.Invoke();
		}
	}

	public int Count => _ids.Count;

	public event Action OnChanged;

	public Playlist()
	{
	}

	public Playlist(IEnumerable<SongIdentifier> passedIds)
	{
		_ids.AddRange(passedIds);
	}

	public void Add(SongIdentifier id)
	{
		_ids.Add(id);
		this.OnChanged?.Invoke();
	}

	public void Remove(int index)
	{
		if (_ids.Count <= 1)
		{
			Debug.LogWarning("Attempted to remove last song from playlist!");
			return;
		}
		if (index < 0 && index > _ids.Count - 1)
		{
			Debug.LogError($"Attempted to remove index '{index}' from playlist, which is out of bounds. (0..{_ids.Count - 1})");
			return;
		}
		_ids.RemoveAt(index);
		this.OnChanged?.Invoke();
	}

	public void Swap(int index1, int index2)
	{
		SongIdentifier value = _ids[index1];
		_ids[index1] = _ids[index2];
		_ids[index2] = value;
		this.OnChanged?.Invoke();
	}
}



public class PolymorphicFieldAttribute : PropertyAttribute
{
	public Type baseType;

	public PolymorphicFieldAttribute(Type baseType)
	{
		this.baseType = baseType;
	}
}



public class Pond : MonoBehaviour, IBloodstainReceiver
{
	public GameObject owningRoom;

	public float bloodFillSpeed;

	public float bloodDrainSpeed = 0.1f;

	public Color surfaceBloodColor = Color.red;

	public Color underwaterBloodColor = Color.red;

	public float bloodFillAmount;

	private Color underwaterColor;

	private Color waterSurfaceColor;

	private Water waterComponent;

	public Renderer waterSurface;

	private MaterialPropertyBlock propertyBlock;

	public bool isDraining;

	public float bloodFillAmountCopy;

	private float lastBloodFillAmount = 9999f;

	private void Start()
	{
		waterComponent = GetComponent<Water>();
		underwaterColor = waterComponent.clr;
		waterSurfaceColor = waterSurface.sharedMaterials[0].GetColor("_Color");
		propertyBlock = new MaterialPropertyBlock();
		bloodFillAmountCopy = bloodFillAmount;
	}

	private void Update()
	{
		bloodFillAmount = Mathf.Clamp01(bloodFillAmount);
		if (isDraining)
		{
			bloodFillAmount -= bloodDrainSpeed * Time.deltaTime;
			bloodFillAmount = Mathf.Clamp01(bloodFillAmount);
		}
		if (bloodFillAmount != lastBloodFillAmount)
		{
			UpdateVisuals();
		}
		lastBloodFillAmount = bloodFillAmount;
	}

	public void StoreBlood()
	{
		bloodFillAmountCopy = bloodFillAmount;
	}

	public void RestoreBlood()
	{
		bloodFillAmount = bloodFillAmountCopy;
		UpdateVisuals();
	}

	private void UpdateVisuals()
	{
		Color value = Color.Lerp(waterSurfaceColor, surfaceBloodColor, bloodFillAmount);
		propertyBlock.SetColor("_Color", value);
		waterSurface.SetPropertyBlock(propertyBlock);
		Color newColor = Color.Lerp(underwaterColor, underwaterBloodColor, bloodFillAmount);
		waterComponent.UpdateColor(newColor);
	}

	public bool HandleBloodstainHit(ref RaycastHit rhit)
	{
		bloodFillAmount += bloodFillSpeed;
		return true;
	}

	private void OnTriggerEnter(Collider col)
	{
		EnemyIdentifierIdentifier component2;
		UnderwaterController component3;
		if (col.TryGetComponent<GoreSplatter>(out var component))
		{
			component.bloodAbsorberCount++;
			MonoSingleton<BloodCheckerManager>.Instance.AddPondGore(component);
		}
		else if (col.TryGetComponent<EnemyIdentifierIdentifier>(out component2))
		{
			component2.bloodAbsorberCount++;
			MonoSingleton<BloodCheckerManager>.Instance.AddPondGib(component2);
		}
		else if (col.TryGetComponent<UnderwaterController>(out component3))
		{
			MonoSingleton<BloodCheckerManager>.Instance.playerInPond = true;
		}
	}

	private void OnTriggerExit(Collider col)
	{
		EnemyIdentifierIdentifier component2;
		UnderwaterController component3;
		if (col.TryGetComponent<GoreSplatter>(out var component))
		{
			component.bloodAbsorberCount--;
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
			{
				component.Invoke("RepoolIfNoAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
		}
		else if (col.TryGetComponent<EnemyIdentifierIdentifier>(out component2))
		{
			component2.bloodAbsorberCount--;
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers)
			{
				component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
		}
		else if (col.TryGetComponent<UnderwaterController>(out component3))
		{
			MonoSingleton<BloodCheckerManager>.Instance.playerInPond = false;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class PostProcessV2_Handler : MonoSingleton<PostProcessV2_Handler>
{
	public Shader outlineCreate;

	private Material outlineProcessor;

	public Material postProcessV2_VSRM;

	[Space(10f)]
	public Texture oilTex;

	public Texture sandTex;

	public Texture buffTex;

	public Texture ditherTexture;

	public int distance = 1;

	private Camera mainCam;

	public Camera hudCam;

	public Camera virtualCam;

	private RenderBuffer[] buffers = new RenderBuffer[2];

	private RenderTexture mainTex;

	private RenderTexture hudTex;

	private RenderTexture outlineTex_BufferA;

	private RenderTexture outlineTex_BufferB;

	private int width;

	private int height;

	private int lastWidth;

	private int lastHeight;

	private bool reinitializeTextures;

	private bool mainCameraOnly;

	[HideInInspector]
	public bool enableJFA;

	[HideInInspector]
	public float downscaleResolution;

	public Texture CurrentTexture;

	public Texture CurrentMapPaletteOverride;

	public Material radiantBuff;

	private OptionsManager oman;

	public bool debugFooled;

	[SerializeField]
	private Material conversionMaterial;

	private bool isGLCore;

	private void OnValidate()
	{
		if (debugFooled)
		{
			Shader.EnableKeyword("Fooled");
		}
		else
		{
			Shader.DisableKeyword("Fooled");
		}
	}

	private void Start()
	{
		DateTime now = DateTime.Now;
		Fooled(now.Month == 4 && now.Day == 1);
		isGLCore = SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLCore;
		if (isGLCore)
		{
			Shader.EnableKeyword("NOOUTLINES");
		}
		else
		{
			Shader.DisableKeyword("NOOUTLINES");
		}
		outlineProcessor = new Material(outlineCreate);
		mainCam = MonoSingleton<CameraController>.Instance.cam;
		hudCam = mainCam.transform.Find("HUD Camera").GetComponent<Camera>();
		virtualCam = mainCam.transform.Find("Virtual Camera").GetComponent<Camera>();
		ReinitializeCameras();
		postProcessV2_VSRM.SetTexture("_Dither", ditherTexture);
		if (oilTex != null)
		{
			Shader.SetGlobalTexture("_OilSlick", oilTex);
		}
		if (sandTex != null)
		{
			Shader.SetGlobalTexture("_SandTex", sandTex);
		}
		if (buffTex != null)
		{
			Shader.SetGlobalTexture("_BuffTex", buffTex);
		}
		oman = MonoSingleton<OptionsManager>.Instance;
	}

	public void Fooled(bool doEnable)
	{
		if (doEnable)
		{
			Shader.EnableKeyword("Fooled");
		}
		else
		{
			Shader.DisableKeyword("Fooled");
		}
	}

	public void ColorPalette(bool stuff)
	{
		if (!(CurrentMapPaletteOverride != null))
		{
			MonoSingleton<PrefsManager>.Instance.SetBoolLocal("colorPalette", stuff);
			if (stuff && CurrentTexture != null)
			{
				Shader.EnableKeyword("PALETTIZE");
				Shader.SetGlobalInt("_ColorPrecision", 2048);
				MonoSingleton<ConvertPaletteToLUT>.Instance.ConvertPalette((Texture2D)CurrentTexture, conversionMaterial);
			}
			else
			{
				Shader.DisableKeyword("PALETTIZE");
				GraphicsOptions.ColorCompressionApply(MonoSingleton<PrefsManager>.Instance.GetInt("colorCompression"));
			}
		}
	}

	public void ApplyUserColorPalette(Texture tex)
	{
		CurrentTexture = tex;
		if (!(CurrentMapPaletteOverride != null))
		{
			MonoSingleton<ConvertPaletteToLUT>.Instance.ConvertPalette((Texture2D)tex, conversionMaterial);
		}
	}

	public void ApplyMapColorPalette(Texture tex)
	{
		if (tex == null)
		{
			CurrentMapPaletteOverride = null;
			ColorPalette(MonoSingleton<PrefsManager>.Instance.GetBoolLocal("colorPalette"));
			return;
		}
		MonoSingleton<ConvertPaletteToLUT>.Instance.ConvertPalette((Texture2D)tex, conversionMaterial);
		CurrentMapPaletteOverride = tex;
		Shader.SetGlobalTexture("_PaletteTex", tex);
		Shader.EnableKeyword("PALETTIZE");
		Shader.SetGlobalInt("_ColorPrecision", 2048);
	}

	private void ReinitializeCameras()
	{
		if (Application.isPlaying)
		{
			Camera.onPreRender = null;
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnPreRenderCallback));
			Camera.onPostRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPostRender, new Camera.CameraCallback(OnPostRenderCallback));
		}
	}

	private void SetupRTs()
	{
		if ((bool)outlineTex_BufferA)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = outlineTex_BufferA;
			GL.Clear(clearDepth: false, clearColor: true, Color.clear);
			RenderTexture.active = active;
		}
		width = Screen.width;
		height = Screen.height;
		if (downscaleResolution != 0f)
		{
			float num = width;
			float num2 = height;
			float num3 = Mathf.Min(num, num2);
			Vector2 vector = new Vector2(num / num3, num2 / num3) * downscaleResolution;
			width = (int)vector.x;
			height = (int)vector.y;
		}
		bool flag = width != lastWidth || height != lastHeight;
		reinitializeTextures |= flag;
		lastWidth = width;
		lastHeight = height;
		Vector2 vector2 = new Vector2(width, height);
		postProcessV2_VSRM.SetVector("_VirtualRes", vector2);
		if (!reinitializeTextures)
		{
			return;
		}
		if ((bool)mainTex)
		{
			mainTex.Release();
			if ((bool)mainTex)
			{
				UnityEngine.Object.Destroy(mainTex);
			}
		}
		if ((bool)hudTex)
		{
			hudTex.Release();
			if ((bool)hudTex)
			{
				UnityEngine.Object.Destroy(hudTex);
			}
		}
		if ((bool)outlineTex_BufferA)
		{
			outlineTex_BufferA.Release();
			if ((bool)outlineTex_BufferA)
			{
				UnityEngine.Object.Destroy(outlineTex_BufferA);
			}
		}
		if ((bool)outlineTex_BufferB)
		{
			outlineTex_BufferB.Release();
			if ((bool)outlineTex_BufferB)
			{
				UnityEngine.Object.Destroy(outlineTex_BufferB);
			}
		}
		mainTex = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32)
		{
			antiAliasing = 1,
			filterMode = FilterMode.Point
		};
		hudTex = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32)
		{
			antiAliasing = 1,
			filterMode = FilterMode.Point
		};
		outlineTex_BufferA = new RenderTexture(width, height, 0, RenderTextureFormat.RG16)
		{
			name = "A",
			antiAliasing = 1,
			filterMode = FilterMode.Point
		};
		outlineTex_BufferB = new RenderTexture(width, height, 0, RenderTextureFormat.RG16)
		{
			name = "B",
			antiAliasing = 1,
			filterMode = FilterMode.Point
		};
		buffers[0] = mainTex.colorBuffer;
		buffers[1] = outlineTex_BufferA.colorBuffer;
		mainCam.SetTargetBuffers(buffers, mainTex.depthBuffer);
		hudCam.targetTexture = hudTex;
		postProcessV2_VSRM.SetTexture("_MainTex", mainTex);
		postProcessV2_VSRM.SetTexture("_HudTex", hudTex);
		reinitializeTextures = false;
	}

	private void ComputeOutlines()
	{
		Vector2 vector = new Vector2(outlineTex_BufferB.width, outlineTex_BufferB.height);
		Vector2 vector2 = vector / new Vector2(Screen.width, Screen.height);
		float num = distance;
		if (distance > 1)
		{
			num = (float)distance * Mathf.Max(vector2.x, vector2.y);
		}
		postProcessV2_VSRM.SetFloat("_OutlineDist", num);
		bool simplifyEnemies = oman.simplifyEnemies;
		postProcessV2_VSRM.SetFloat("_OutlinesEnabled", simplifyEnemies ? 1 : 0);
		if (!isGLCore)
		{
			Shader.DisableKeyword("NOOUTLINES");
		}
		else
		{
			Shader.EnableKeyword("NOOUTLINES");
		}
		if (!MonoSingleton<OptionsManager>.Instance.simplifyEnemies)
		{
			Shader.DisableKeyword("WIDEOUTLINES");
		}
		else
		{
			Shader.EnableKeyword("WIDEOUTLINES");
		}
		if (distance > 1 && num > 1f && MonoSingleton<OptionsManager>.Instance.simplifyEnemies)
		{
			distance = Mathf.Min(distance, 16);
			outlineProcessor.SetVector("_ScreenRes", new Vector2(width, height));
			outlineProcessor.SetFloat("_OutlinesEnabled", oman.simplifyEnemies ? 1 : 0);
			Graphics.Blit(outlineTex_BufferA, outlineTex_BufferB, outlineProcessor, 0);
			float num2 = 8f;
			int num3 = 0;
			while (num2 >= 0.5f)
			{
				outlineProcessor.SetFloat("_Distance", num2);
				outlineProcessor.SetTexture("_MainTex", outlineTex_BufferB);
				outlineProcessor.SetVector("_Resolution", vector);
				Graphics.Blit(null, outlineTex_BufferA, outlineProcessor, 1);
				RenderTexture renderTexture = outlineTex_BufferA;
				outlineTex_BufferA = outlineTex_BufferB;
				outlineTex_BufferB = renderTexture;
				num2 *= 0.5f;
				num3++;
			}
			if (outlineTex_BufferA.name == "B")
			{
				RenderTexture renderTexture2 = outlineTex_BufferB;
				RenderTexture renderTexture3 = outlineTex_BufferA;
				outlineTex_BufferA = renderTexture2;
				outlineTex_BufferB = renderTexture3;
			}
			outlineProcessor.SetFloat("_Distance", distance);
			outlineProcessor.SetVector("_ResolutionDiff", vector2);
			Graphics.Blit(outlineTex_BufferB, outlineTex_BufferA, outlineProcessor, 2);
		}
		postProcessV2_VSRM.SetTexture("_OutlineTex", outlineTex_BufferA);
	}

	public void ChangeCamera(bool hudless)
	{
		mainCameraOnly = hudless;
		mainCam.targetTexture = null;
		MonoSingleton<CameraController>.Instance.cam.clearFlags = mainCam.clearFlags;
		mainCam = MonoSingleton<CameraController>.Instance.cam;
		virtualCam = mainCam.transform.Find("Virtual Camera").GetComponent<Camera>();
		reinitializeTextures = true;
		SetupRTs();
	}

	public void OnPreRenderCallback(Camera cam)
	{
		if (cam == mainCam)
		{
			SetupRTs();
		}
	}

	private void OnPostRenderCallback(Camera cam)
	{
		if (cam == mainCam)
		{
			ComputeOutlines();
		}
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnPreRenderCallback));
		Camera.onPostRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPostRender, new Camera.CameraCallback(OnPostRenderCallback));
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class PowerUpMeter : MonoSingleton<PowerUpMeter>
{
	public float juice;

	public float latestMaxJuice;

	private Image meter;

	public Image vignette;

	public Color powerUpColor;

	private Color currentColor;

	public GameObject endEffect;

	private bool hasPowerUp;

	private void Start()
	{
		meter = GetComponent<Image>();
		meter.fillAmount = 0f;
	}

	private void Update()
	{
		UpdateMeter();
		UpdateCheats();
	}

	public void UpdateMeter()
	{
		if (juice > 0f)
		{
			hasPowerUp = true;
			if (!InfinitePowerUps.Enabled)
			{
				juice -= Time.deltaTime;
			}
			if (HUDOptions.powerUpMeterEnabled && !HideUI.Active)
			{
				meter.fillAmount = juice / latestMaxJuice;
			}
			else
			{
				meter.fillAmount = 0f;
			}
			if (currentColor != powerUpColor)
			{
				currentColor = powerUpColor;
				currentColor.a = juice / latestMaxJuice;
				vignette.color = currentColor;
			}
		}
		else if (hasPowerUp)
		{
			EndPowerUp();
		}
	}

	public void EndPowerUp()
	{
		hasPowerUp = false;
		juice = 0f;
		latestMaxJuice = 0f;
		meter.fillAmount = 0f;
		if (vignette.color.a != 0f)
		{
			currentColor.a = 0f;
			vignette.color = currentColor;
		}
		if ((bool)endEffect)
		{
			Object.Instantiate(endEffect, MonoSingleton<NewMovement>.Instance.transform.position, Quaternion.identity);
		}
	}

	private void UpdateCheats()
	{
		if (HideUI.Active)
		{
			vignette.color = Color.clear;
		}
	}
}



[CreateAssetMenu(fileName = "Prefab Database", menuName = "ULTRAKILL/Prefab Database")]
public class PrefabDatabase : ScriptableObject
{
	[Header("Enemies")]
	public EndlessEnemy[] meleeEnemies;

	public EndlessEnemy[] projectileEnemies;

	public EndlessEnemy[] uncommonEnemies;

	public EndlessEnemy[] specialEnemies;

	[Header("Other Prefabs")]
	public GameObject jumpPad;

	public GameObject stairs;

	public GameObject hideousMass;
}



[DefaultExecutionOrder(-20)]
public class PrefabReplacer : MonoBehaviour
{
	public static bool ForceDisable;

	public static PrefabReplacer Instance;

	private void Awake()
	{
		Instance = this;
	}

	public GameObject LoadPrefab(string address)
	{
		return AssetHelper.LoadPrefab(address);
	}

	private void PerformSwap(PlaceholderPrefab placeholder)
	{
		if (ForceDisable || !placeholder.gameObject.activeSelf)
		{
			return;
		}
		Debug.Log("Swapping " + placeholder.name);
		Transform transform = placeholder.transform;
		if (!(transform == null))
		{
			AsyncOperationHandle<GameObject> asyncOperationHandle = Addressables.LoadAssetAsync<GameObject>(placeholder.uniqueId);
			asyncOperationHandle.WaitForCompletion();
			GameObject gameObject = Object.Instantiate(asyncOperationHandle.Result, transform.position, transform.rotation, transform.parent);
			Debug.Log("Swapped " + placeholder.name + " with " + gameObject.name);
			IPlaceholdableComponent[] componentsInChildren = placeholder.GetComponentsInChildren<IPlaceholdableComponent>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].WillReplace(placeholder.gameObject, gameObject, isSelfBeingReplaced: true);
			}
			componentsInChildren = gameObject.GetComponentsInChildren<IPlaceholdableComponent>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].WillReplace(placeholder.gameObject, gameObject, isSelfBeingReplaced: false);
			}
			Object.Destroy(placeholder.gameObject);
		}
	}

	public void ReplacePrefab(PlaceholderPrefab placeholder)
	{
		PerformSwap(placeholder);
	}
}



public class PrefConditional : MonoBehaviour
{
	public string prefName;

	public bool isLocal;

	public bool isInt;

	public UltrakillEvent valueEvent;

	private void Start()
	{
		CheckValue();
	}

	public void CheckValue()
	{
		if (isInt)
		{
			if ((isLocal ? MonoSingleton<PrefsManager>.Instance.GetIntLocal(prefName) : MonoSingleton<PrefsManager>.Instance.GetInt(prefName)) > 0)
			{
				valueEvent.Invoke();
			}
			else
			{
				valueEvent.Revert();
			}
		}
		else if (isLocal ? MonoSingleton<PrefsManager>.Instance.GetBoolLocal(prefName) : MonoSingleton<PrefsManager>.Instance.GetBool(prefName))
		{
			valueEvent.Invoke();
		}
		else
		{
			valueEvent.Revert();
		}
	}
}



public class PrefOptionToggle : MonoBehaviour
{
	public string prefName;

	public bool isLocal;

	public bool fallbackValue;

	public Toggle toggle;

	private void Awake()
	{
		toggle.SetIsOnWithoutNotify(GetPref());
		toggle.onValueChanged.AddListener(OnToggle);
	}

	private bool GetPref()
	{
		if (MonoSingleton<PrefsManager>.Instance == null)
		{
			return fallbackValue;
		}
		if (isLocal)
		{
			return MonoSingleton<PrefsManager>.Instance.GetBoolLocal(prefName, fallbackValue);
		}
		return MonoSingleton<PrefsManager>.Instance.GetBool(prefName, fallbackValue);
	}

	private void OnToggle(bool value)
	{
		if (!(MonoSingleton<PrefsManager>.Instance == null))
		{
			if (isLocal)
			{
				MonoSingleton<PrefsManager>.Instance.SetBoolLocal(prefName, value);
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.SetBool(prefName, value);
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.PersistAutoInstance | SingletonFlags.DestroyDuplicates)]
public class PrefsManager : MonoSingleton<PrefsManager>
{
	private enum PrefsCommitMode
	{
		Immediate,
		OnQuit,
		DirtySlowTick
	}

	private static readonly plog.Logger Log = new plog.Logger("PrefsManager");

	private FileStream prefsStream;

	private FileStream localPrefsStream;

	private static PrefsCommitMode CommitMode = ((!Application.isEditor) ? PrefsCommitMode.DirtySlowTick : PrefsCommitMode.Immediate);

	private TimeSince timeSinceLastTick;

	private const float SlowTickCommitInterval = 3f;

	private const bool DebugLogging = false;

	private bool isDirty;

	private bool isLocalDirty;

	public static int monthsSinceLastPlayed = 0;

	public Action<string, object> prefChanged;

	public Dictionary<string, object> prefMap;

	public Dictionary<string, object> localPrefMap;

	private readonly Dictionary<string, Func<object, object>> propertyValidators = new Dictionary<string, Func<object, object>> { 
	{
		"difficulty",
		delegate(object value)
		{
			if (!(value is int num))
			{
				Log.Warning("Difficulty value is not an int");
				return 2;
			}
			if (num < 0 || num > 4)
			{
				Log.Warning("Difficulty validation error");
				return 4;
			}
			return (object)null;
		}
	} };

	public readonly Dictionary<string, object> defaultValues = new Dictionary<string, object>
	{
		{ "difficulty", 2 },
		{ "scrollEnabled", true },
		{ "scrollWeapons", true },
		{ "scrollVariations", false },
		{ "scrollReversed", false },
		{ "mouseSensitivity", 50f },
		{ "discordIntegration", true },
		{ "levelLeaderboards", true },
		{ "subtitlesEnabled", false },
		{ "seasonalEvents", true },
		{ "majorAssist", false },
		{ "gameSpeed", 1f },
		{ "damageTaken", 1f },
		{ "infiniteStamina", false },
		{ "disableWhiplashHardDamage", false },
		{ "disableHardDamage", false },
		{ "disableWeaponFreshness", false },
		{ "autoAim", false },
		{ "autoAimAmount", 0.2f },
		{ "bossDifficultyOverride", 0 },
		{ "hideMajorAssistPopup", false },
		{ "outlineThickness", 1 },
		{ "frameRateLimit", 1 },
		{ "fullscreen", true },
		{ "fieldOfView", 105f },
		{ "vSync", true },
		{ "totalRumbleIntensity", 1f },
		{ "musicVolume", 0.6f },
		{ "sfxVolume", 1f },
		{ "allVolume", 1f },
		{ "muffleMusic", true },
		{ "screenShake", 1f },
		{ "cameraTilt", true },
		{ "parryFlash", true },
		{ "dithering", 0.2f },
		{ "colorCompression", 2 },
		{ "vertexWarping", 0 },
		{ "textureWarping", 0f },
		{ "pixelization", 0 },
		{ "gamma", 1f },
		{ "crossHair", 1 },
		{ "crossHairColor", 1 },
		{ "crossHairHud", 2 },
		{ "hudType", 1 },
		{ "hudBackgroundOpacity", 50f },
		{ "WeaponRedrawBehaviour", 0 },
		{ "weaponHoldPosition", 0 },
		{ "variationMemory", false },
		{ "pauseMenuConfirmationDialogs", 0 },
		{ "sandboxSaveOverwriteWarnings", true },
		{ "bloodEnabled", true },
		{ "bloodStainChance", 0.5f },
		{ "bloodStainMax", 100000f },
		{ "maxGore", 3000f },
		{ "weaponIcons", true },
		{ "armIcons", true },
		{ "styleMeter", true },
		{ "styleInfo", true },
		{ "crossHairHudFade", true },
		{ "powerUpMeter", true },
		{ "railcannonMeter", true },
		{ "simpleNailPhysics", true },
		{ "selectedSaveSlot", 0 }
	};

	private static string prefsNote = "LocalPrefs.json contains preferences local to this machine. It does NOT get backed up in any way.\nPrefs.json contains preferences that are synced across all of your machines via Steam Cloud.\n\nPlaylist.json contains the IDs of all the songs in the user's Cybergrind Playlist.All prefs files must be valid json.\nIf you edit them, make sure you don't break the format.\n\nIf a pref key is missing from the prefs files, the game will use the default value and save ONLY if overridden.\nAdditionally, you can NOT move things between Prefs.json and LocalPrefs.json, the game will ignore them if misplaced.";

	public static string PrefsPath => Path.Combine(Directory.GetParent(Application.dataPath).FullName, "Preferences");

	public bool HasKey(string key)
	{
		EnsureInitialized();
		if (!prefMap.ContainsKey(key))
		{
			return localPrefMap.ContainsKey(key);
		}
		return true;
	}

	public void DeleteKey(string key)
	{
		EnsureInitialized();
		if (prefMap.ContainsKey(key))
		{
			prefMap.Remove(key);
			if (CommitMode == PrefsCommitMode.DirtySlowTick)
			{
				isDirty = true;
			}
			if (CommitMode == PrefsCommitMode.Immediate)
			{
				CommitPrefs(local: false);
			}
		}
		if (localPrefMap.ContainsKey(key))
		{
			localPrefMap.Remove(key);
			if (CommitMode == PrefsCommitMode.DirtySlowTick)
			{
				isLocalDirty = true;
			}
			if (CommitMode == PrefsCommitMode.Immediate)
			{
				CommitPrefs(local: true);
			}
		}
	}

	public bool GetBoolLocal(string key, bool fallback = false)
	{
		EnsureInitialized();
		object obj;
		if (localPrefMap.ContainsKey(key) && (obj = localPrefMap[key]) is bool)
		{
			return (bool)obj;
		}
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is bool)
		{
			return (bool)obj;
		}
		return fallback;
	}

	public bool GetBool(string key, bool fallback = false)
	{
		EnsureInitialized();
		object obj;
		if (prefMap.ContainsKey(key) && (obj = prefMap[key]) is bool)
		{
			return (bool)obj;
		}
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is bool)
		{
			return (bool)obj;
		}
		return fallback;
	}

	public void SetBoolLocal(string key, bool content)
	{
		EnsureInitialized();
		if (localPrefMap.ContainsKey(key))
		{
			localPrefMap[key] = content;
		}
		else
		{
			localPrefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: true);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isLocalDirty = true;
		}
	}

	public void SetBool(string key, bool content)
	{
		EnsureInitialized();
		if (prefMap.ContainsKey(key))
		{
			prefMap[key] = content;
		}
		else
		{
			prefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: false);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isDirty = true;
		}
		prefChanged?.Invoke(key, content);
	}

	public int GetIntLocal(string key, int fallback = 0)
	{
		EnsureInitialized();
		if (localPrefMap.ContainsKey(key))
		{
			if (localPrefMap[key] is int num)
			{
				return (int)EnsureValid(key, num);
			}
			if (localPrefMap[key] is long num2)
			{
				return (int)EnsureValid(key, (int)num2);
			}
			if (localPrefMap[key] is float num3)
			{
				return (int)EnsureValid(key, (int)num3);
			}
			if (localPrefMap[key] is double num4)
			{
				return (int)EnsureValid(key, (int)num4);
			}
		}
		object obj;
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is int)
		{
			return (int)obj;
		}
		return fallback;
	}

	public int GetInt(string key, int fallback = 0)
	{
		EnsureInitialized();
		if (prefMap.ContainsKey(key))
		{
			if (prefMap[key] is int num)
			{
				return (int)EnsureValid(key, num);
			}
			if (prefMap[key] is long num2)
			{
				return (int)EnsureValid(key, (int)num2);
			}
			if (prefMap[key] is float num3)
			{
				return (int)EnsureValid(key, (int)num3);
			}
			if (prefMap[key] is double num4)
			{
				return (int)EnsureValid(key, (int)num4);
			}
		}
		object obj;
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is int)
		{
			return (int)obj;
		}
		return fallback;
	}

	public void SetIntLocal(string key, int content)
	{
		EnsureInitialized();
		content = (int)EnsureValid(key, content);
		if (localPrefMap.ContainsKey(key))
		{
			localPrefMap[key] = content;
		}
		else
		{
			localPrefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: true);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isLocalDirty = true;
		}
	}

	public void SetInt(string key, int content)
	{
		EnsureInitialized();
		content = (int)EnsureValid(key, content);
		if (prefMap.ContainsKey(key))
		{
			prefMap[key] = content;
		}
		else
		{
			prefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: false);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isDirty = true;
		}
		prefChanged?.Invoke(key, content);
	}

	public float GetFloatLocal(string key, float fallback = 0f)
	{
		EnsureInitialized();
		if (localPrefMap.ContainsKey(key))
		{
			if (localPrefMap[key] is float num)
			{
				return (float)EnsureValid(key, num);
			}
			if (localPrefMap[key] is int num2)
			{
				return (int)EnsureValid(key, num2);
			}
			if (localPrefMap[key] is long num3)
			{
				return (long)EnsureValid(key, num3);
			}
			if (localPrefMap[key] is double num4)
			{
				return (float)EnsureValid(key, (float)num4);
			}
		}
		object obj;
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is float)
		{
			return (float)obj;
		}
		return fallback;
	}

	public float GetFloat(string key, float fallback = 0f)
	{
		EnsureInitialized();
		if (prefMap.ContainsKey(key))
		{
			if (prefMap[key] is float num)
			{
				return (float)EnsureValid(key, num);
			}
			if (prefMap[key] is int num2)
			{
				return (int)EnsureValid(key, num2);
			}
			if (prefMap[key] is long num3)
			{
				return (long)EnsureValid(key, num3);
			}
			if (prefMap[key] is double num4)
			{
				return (float)EnsureValid(key, (float)num4);
			}
		}
		object obj;
		if (defaultValues.ContainsKey(key) && (obj = defaultValues[key]) is float)
		{
			return (float)obj;
		}
		return fallback;
	}

	public void SetFloatLocal(string key, float content)
	{
		EnsureInitialized();
		content = (float)EnsureValid(key, content);
		if (localPrefMap.ContainsKey(key))
		{
			localPrefMap[key] = content;
		}
		else
		{
			localPrefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: true);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isLocalDirty = true;
		}
	}

	public void SetFloat(string key, float content)
	{
		EnsureInitialized();
		content = (float)EnsureValid(key, content);
		if (prefMap.ContainsKey(key))
		{
			prefMap[key] = content;
		}
		else
		{
			prefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: false);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isDirty = true;
		}
		prefChanged?.Invoke(key, content);
	}

	public string GetStringLocal(string key, string fallback = null)
	{
		EnsureInitialized();
		if (localPrefMap.ContainsKey(key) && localPrefMap[key] is string value)
		{
			return EnsureValid(key, value) as string;
		}
		if (defaultValues.ContainsKey(key) && defaultValues[key] is string result)
		{
			return result;
		}
		return fallback;
	}

	public string GetString(string key, string fallback = null)
	{
		EnsureInitialized();
		if (prefMap.ContainsKey(key) && prefMap[key] is string value)
		{
			return EnsureValid(key, value) as string;
		}
		if (defaultValues.ContainsKey(key) && defaultValues[key] is string result)
		{
			return result;
		}
		return fallback;
	}

	public void SetStringLocal(string key, string content)
	{
		EnsureInitialized();
		content = EnsureValid(key, content) as string;
		if (localPrefMap.ContainsKey(key))
		{
			localPrefMap[key] = content;
		}
		else
		{
			localPrefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: true);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isLocalDirty = true;
		}
	}

	public void SetString(string key, string content)
	{
		EnsureInitialized();
		content = EnsureValid(key, content) as string;
		if (prefMap.ContainsKey(key))
		{
			prefMap[key] = content;
		}
		else
		{
			prefMap.Add(key, content);
		}
		if (CommitMode == PrefsCommitMode.Immediate)
		{
			CommitPrefs(local: false);
		}
		if (CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			isDirty = true;
		}
		prefChanged?.Invoke(key, content);
	}

	private void CommitPrefs(bool local)
	{
		if (local)
		{
			string value = JsonConvert.SerializeObject(localPrefMap, Formatting.Indented);
			localPrefsStream.SetLength(0L);
			StreamWriter streamWriter = new StreamWriter(localPrefsStream);
			streamWriter.Write(value);
			streamWriter.Flush();
		}
		else
		{
			string value2 = JsonConvert.SerializeObject(prefMap, Formatting.Indented);
			prefsStream.SetLength(0L);
			StreamWriter streamWriter2 = new StreamWriter(prefsStream);
			streamWriter2.Write(value2);
			streamWriter2.Flush();
		}
	}

	private void UpdateTimestamp()
	{
		EnsureInitialized();
		DateTime now = DateTime.Now;
		if (!prefMap.ContainsKey("lastTimePlayed.year"))
		{
			prefMap.Add("lastTimePlayed.year", now.Year);
			isDirty = true;
		}
		if (!prefMap.ContainsKey("lastTimePlayed.month"))
		{
			prefMap.Add("lastTimePlayed.month", now.Month);
			isDirty = true;
		}
		if (prefMap["lastTimePlayed.year"] is int num)
		{
			if (num != now.Year)
			{
				prefMap["lastTimePlayed.year"] = now.Year;
				prefMap["lastTimePlayed.month"] = now.Month;
				isDirty = true;
			}
			if (prefMap["lastTimePlayed.month"] is int num2 && num2 != now.Month)
			{
				prefMap["lastTimePlayed.month"] = now.Month;
				isDirty = true;
			}
		}
		else
		{
			prefMap["lastTimePlayed.year"] = now.Year;
			prefMap["lastTimePlayed.month"] = now.Month;
			isDirty = true;
		}
	}

	private void EnsureInitialized()
	{
		if (prefMap == null || localPrefMap == null)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		if (!Directory.Exists(PrefsPath))
		{
			Directory.CreateDirectory(PrefsPath);
		}
		timeSinceLastTick = 0f;
		if (prefsStream == null)
		{
			prefsStream = new FileStream(Path.Combine(PrefsPath, "Prefs.json"), FileMode.OpenOrCreate);
		}
		if (localPrefsStream == null)
		{
			localPrefsStream = new FileStream(Path.Combine(PrefsPath, "LocalPrefs.json"), FileMode.OpenOrCreate);
		}
		prefMap = LoadPrefs(prefsStream);
		localPrefMap = LoadPrefs(localPrefsStream);
		if (!File.Exists(Path.Combine(PrefsPath, "NOTE.txt")))
		{
			File.WriteAllText(Path.Combine(PrefsPath, "NOTE.txt"), prefsNote);
			Log.Warning("NOTE.txt created in prefs folder. Please read it.");
		}
		Log.Info("PrefsManager initialized");
	}

	private object EnsureValid(string key, object value)
	{
		if (!propertyValidators.ContainsKey(key))
		{
			return value;
		}
		return propertyValidators[key](value) ?? value;
	}

	private Dictionary<string, object> LoadPrefs(FileStream stream)
	{
		return JsonConvert.DeserializeObject<Dictionary<string, object>>(new StreamReader(stream).ReadToEnd()) ?? new Dictionary<string, object>();
	}

	protected override void Awake()
	{
		base.Awake();
		if (!(MonoSingleton<PrefsManager>.Instance != this))
		{
			Initialize();
			int @int = GetInt("lastTimePlayed.year", -1);
			int int2 = GetInt("lastTimePlayed.month", -1);
			if (@int == -1 || int2 == -1)
			{
				monthsSinceLastPlayed = 0;
				return;
			}
			DateTime now = DateTime.Now;
			monthsSinceLastPlayed = (now.Year - @int) * 12 + now.Month - int2;
		}
	}

	private void Start()
	{
		UpdateTimestamp();
	}

	private void FixedUpdate()
	{
		if ((isDirty || isLocalDirty) && CommitMode == PrefsCommitMode.DirtySlowTick && (float)timeSinceLastTick >= 3f)
		{
			timeSinceLastTick = 0f;
			if (isLocalDirty)
			{
				CommitPrefs(local: true);
			}
			if (isDirty)
			{
				CommitPrefs(local: false);
			}
			isLocalDirty = false;
			isDirty = false;
		}
	}

	private void OnApplicationQuit()
	{
		UpdateTimestamp();
		if (CommitMode == PrefsCommitMode.OnQuit || CommitMode == PrefsCommitMode.DirtySlowTick)
		{
			CommitPrefs(local: false);
			CommitPrefs(local: true);
		}
		prefsStream?.Close();
		localPrefsStream?.Close();
	}
}



public static class PrefsManagerHelper
{
	public static void SetPref(string key, object value, bool noSteamCloud)
	{
		if (value is float content)
		{
			if (noSteamCloud)
			{
				MonoSingleton<PrefsManager>.Instance.SetFloatLocal(key, content);
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.SetFloat(key, content);
			}
		}
		else if (value is int content2)
		{
			if (noSteamCloud)
			{
				MonoSingleton<PrefsManager>.Instance.SetIntLocal(key, content2);
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.SetInt(key, content2);
			}
		}
		else if (value is string content3)
		{
			if (noSteamCloud)
			{
				MonoSingleton<PrefsManager>.Instance.SetStringLocal(key, content3);
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.SetString(key, content3);
			}
		}
		else if (value is bool content4)
		{
			if (noSteamCloud)
			{
				MonoSingleton<PrefsManager>.Instance.SetBoolLocal(key, content4);
			}
			else
			{
				MonoSingleton<PrefsManager>.Instance.SetBool(key, content4);
			}
		}
		else
		{
			Debug.LogError("Unsupported type for PrefsManagerHelper.SetPref");
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance | SingletonFlags.DestroyDuplicates)]
public class PresenceController : MonoSingleton<PresenceController>
{
	private static readonly plog.Logger Log = new plog.Logger("Presence");

	public string[] diffNames;

	private bool trackingTimeInSandbox;

	private TimeSince timeInSandbox;

	private void Start()
	{
		base.transform.SetParent(null);
		Object.DontDestroyOnLoad(base.gameObject);
		SceneManager.sceneLoaded += SceneManagerOnsceneLoaded;
		SceneManagerOnsceneLoaded(SceneManager.GetActiveScene(), LoadSceneMode.Single);
		if (SteamClient.IsValid)
		{
			SteamUGC.StopPlaytimeTrackingForAllItems();
		}
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= SceneManagerOnsceneLoaded;
	}

	public static void UpdateCyberGrindWave(int wave)
	{
		DiscordController.UpdateWave(wave);
		SteamController.Instance.UpdateWave(wave);
	}

	private void SceneManagerOnsceneLoaded(Scene _, LoadSceneMode mode)
	{
		if (mode == LoadSceneMode.Additive)
		{
			return;
		}
		string currentScene = SceneHelper.CurrentScene;
		Log.Info("Scene loaded: " + currentScene);
		DiscordController.Instance.FetchSceneActivity(currentScene);
		SteamController.Instance.FetchSceneActivity(currentScene);
		if (MapInfoBase.InstanceAnyType != null && MapInfoBase.InstanceAnyType.sandboxTools)
		{
			if (!trackingTimeInSandbox)
			{
				Log.Info("Starting sandbox time tracking");
				trackingTimeInSandbox = true;
				timeInSandbox = 0f;
			}
		}
		else if (trackingTimeInSandbox)
		{
			Log.Info("Submitting sandbox time");
			trackingTimeInSandbox = false;
			SteamController.Instance.UpdateTimeInSandbox(timeInSandbox);
		}
	}

	public void AddToStatInt(string statKey, int amount)
	{
		SteamController.Instance.AddToStatInt(statKey, amount);
	}

	private void OnApplicationQuit()
	{
		if (trackingTimeInSandbox)
		{
			SteamController.Instance.UpdateTimeInSandbox(timeInSandbox);
		}
	}
}


[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class PreviousMissionSaver : MonoSingleton<PreviousMissionSaver>
{
	public int previousMission;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ProgressChecker : MonoSingleton<ProgressChecker>
{
	public bool continueWithoutSaving;

	protected override void Awake()
	{
		base.Awake();
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		if (!GameProgressSaver.GetTutorial() || !GameProgressSaver.GetIntro())
		{
			MonoSingleton<PrefsManager>.Instance.SetInt("weapon.arm0", 1);
			SceneHelper.LoadScene("Tutorial");
			continueWithoutSaving = false;
		}
	}

	public void DisableSaving()
	{
		continueWithoutSaving = true;
	}

	public void SaveLoadError(SaveLoadFailMessage.SaveLoadError error = SaveLoadFailMessage.SaveLoadError.Generic, string tempValidationError = "", Action saveRedo = null)
	{
		if (!continueWithoutSaving)
		{
			if (error == SaveLoadFailMessage.SaveLoadError.Generic)
			{
				continueWithoutSaving = true;
			}
			MonoSingleton<SaveLoadFailMessage>.Instance.ShowError(error, tempValidationError, saveRedo);
		}
	}
}



public class Projectile : MonoBehaviour
{
	public GameObject sourceWeapon;

	private Rigidbody rb;

	public float speed;

	public float turnSpeed;

	public float speedRandomizer;

	private AudioSource aud;

	public GameObject explosionEffect;

	public float damage;

	public float enemyDamageMultiplier = 1f;

	public bool friendly;

	public bool playerBullet;

	public string bulletType;

	public string weaponType;

	public bool decorative;

	private Vector3 origScale;

	private bool active = true;

	public EnemyType safeEnemyType;

	public bool explosive;

	public bool bigExplosion;

	public List<EnemyIdentifier> alreadyHitEnemies = new List<EnemyIdentifier>();

	public HomingType homingType;

	public float turningSpeedMultiplier = 1f;

	public EnemyTarget target;

	private float maxSpeed;

	private Quaternion targetRotation;

	public float predictiveHomingMultiplier;

	public bool hittingPlayer;

	private NewMovement nmov;

	public bool boosted;

	[HideInInspector]
	public bool parried;

	private Collider col;

	private float radius;

	public bool undeflectable;

	public bool unparryable;

	public bool keepTrail;

	public bool strong;

	public bool spreaded;

	private int difficulty;

	public bool precheckForCollisions;

	public bool canHitCoin;

	public bool ignoreExplosions;

	private List<Collider> alreadyDeflectedBy = new List<Collider>();

	private void Start()
	{
		if ((bool)aud)
		{
			aud.pitch = Random.Range(1.8f, 2f);
			if (aud.enabled)
			{
				aud.Play();
			}
		}
		if (decorative)
		{
			origScale = base.transform.localScale;
			base.transform.localScale = Vector3.zero;
		}
		if (speed != 0f)
		{
			speed += Random.Range(0f - speedRandomizer, speedRandomizer);
		}
		if (col != null && !decorative)
		{
			col.enabled = false;
			col.enabled = true;
		}
		maxSpeed = speed;
		if (target == null)
		{
			target = EnemyTarget.TrackPlayerIfAllowed();
		}
	}

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		if (col == null)
		{
			col = GetComponentInChildren<Collider>();
		}
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
	}

	public static float GetProjectileSpeedMulti(int difficulty)
	{
		if (difficulty > 2)
		{
			return 1.35f;
		}
		return difficulty switch
		{
			1 => 0.75f, 
			0 => 0.5f, 
			_ => 1f, 
		};
	}

	private void Update()
	{
		if (homingType == HomingType.None || target == null || hittingPlayer)
		{
			return;
		}
		float num = predictiveHomingMultiplier;
		Vector3 vector = (target.isPlayer ? target.headPosition : target.position);
		if (Vector3.Distance(base.transform.position, vector) < 15f)
		{
			num = 0f;
		}
		switch (homingType)
		{
		case HomingType.Gradual:
		{
			if (difficulty == 1)
			{
				maxSpeed += Time.deltaTime * 17.5f;
			}
			else if (difficulty == 0)
			{
				maxSpeed += Time.deltaTime * 10f;
			}
			else
			{
				maxSpeed += Time.deltaTime * 25f;
			}
			Quaternion to = Quaternion.LookRotation(vector + target.GetVelocity() * num - base.transform.position);
			if (difficulty == 0)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 100f * turningSpeedMultiplier);
			}
			else if (difficulty == 1)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 135f * turningSpeedMultiplier);
			}
			else if (difficulty == 2)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 185f * turningSpeedMultiplier);
			}
			else
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 200f * turningSpeedMultiplier);
			}
			rb.velocity = base.transform.forward * maxSpeed;
			break;
		}
		case HomingType.Instant:
		{
			Quaternion to = Quaternion.LookRotation(vector + target.GetVelocity() * num - base.transform.position);
			if (difficulty == 0)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 100f * turningSpeedMultiplier);
			}
			else if (difficulty == 1)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 135f * turningSpeedMultiplier);
			}
			else if (difficulty == 2)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 185f * turningSpeedMultiplier);
			}
			else
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 200f * turningSpeedMultiplier);
			}
			rb.velocity = base.transform.forward * speed;
			break;
		}
		case HomingType.Loose:
		{
			maxSpeed += Time.deltaTime * 10f;
			base.transform.LookAt(base.transform.position + rb.velocity);
			Vector3 normalized = (vector + target.GetVelocity() * num - base.transform.position).normalized;
			rb.AddForce(normalized * speed * Time.deltaTime * 200f, ForceMode.Acceleration);
			rb.velocity = Vector3.ClampMagnitude(rb.velocity, maxSpeed);
			break;
		}
		case HomingType.HorizontalOnly:
		{
			base.transform.LookAt(target.position + rb.velocity);
			Vector3 vector2 = vector + target.GetVelocity() * num;
			vector2.y = base.transform.position.y;
			float num2 = Mathf.Clamp(vector2.x - base.transform.position.x, 0f - turnSpeed, turnSpeed);
			float num3 = Mathf.Clamp(vector2.z - base.transform.position.z, 0f - turnSpeed, turnSpeed);
			if (Vector3.Distance(base.transform.position, vector2) < turnSpeed / 20f)
			{
				num2 = (vector2 - base.transform.position).x;
				num3 = (vector2 - base.transform.position).z;
			}
			float num4 = 15f;
			if (difficulty == 1)
			{
				num4 = 10f;
			}
			else if (difficulty == 0)
			{
				num4 = 5f;
			}
			else if (difficulty >= 3)
			{
				num4 = 25f;
			}
			float x = Mathf.MoveTowards(rb.velocity.x, num2, Time.deltaTime * num4 * turningSpeedMultiplier);
			float z = Mathf.MoveTowards(rb.velocity.z, num3, Time.deltaTime * num4 * turningSpeedMultiplier);
			rb.velocity = new Vector3(x, rb.velocity.y, z);
			break;
		}
		default:
			maxSpeed += Time.deltaTime * 10f;
			targetRotation = Quaternion.LookRotation(vector + target.GetVelocity() * num - base.transform.position);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRotation, Time.deltaTime * turnSpeed);
			rb.velocity = base.transform.forward * maxSpeed;
			break;
		}
	}

	private void FixedUpdate()
	{
		if (!hittingPlayer && !undeflectable && !decorative && speed != 0f && homingType == HomingType.None)
		{
			rb.velocity = base.transform.forward * speed;
		}
		if (decorative && base.transform.localScale.x < origScale.x)
		{
			aud.pitch = base.transform.localScale.x / origScale.x * 2.8f;
			base.transform.localScale = Vector3.Slerp(base.transform.localScale, origScale, Time.deltaTime * speed);
		}
		if (precheckForCollisions)
		{
			LayerMask layerMask = LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment);
			layerMask = (int)layerMask | 4;
			if (Physics.SphereCast(base.transform.position, radius, rb.velocity.normalized, out var hitInfo, rb.velocity.magnitude * Time.fixedDeltaTime, layerMask))
			{
				base.transform.position = base.transform.position + rb.velocity.normalized * hitInfo.distance;
				Collided(hitInfo.collider);
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		Collided(other);
	}

	private void Collided(Collider other)
	{
		if (!active)
		{
			return;
		}
		EnemyIdentifierIdentifier component2;
		EnemyIdentifierIdentifier component3;
		if (!friendly && !hittingPlayer && other.gameObject.CompareTag("Player"))
		{
			if (target.isPlayer && MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
			{
				MonoSingleton<PlatformerMovement>.Instance.Explode();
				if (explosive)
				{
					Explode();
					return;
				}
				if (keepTrail)
				{
					KeepTrail();
				}
				CreateExplosionEffect();
				Object.Destroy(base.gameObject);
				return;
			}
			if (spreaded)
			{
				ProjectileSpread componentInParent = GetComponentInParent<ProjectileSpread>();
				if (componentInParent != null && componentInParent.parried)
				{
					return;
				}
			}
			hittingPlayer = true;
			rb.velocity = Vector3.zero;
			if (keepTrail)
			{
				KeepTrail();
			}
			base.transform.position = new Vector3(other.transform.position.x, base.transform.position.y, other.transform.position.z);
			nmov = other.gameObject.GetComponentInParent<NewMovement>();
			Invoke("RecheckPlayerHit", 0.05f);
		}
		else if (canHitCoin && other.gameObject.CompareTag("Coin"))
		{
			Coin component = other.gameObject.GetComponent<Coin>();
			if ((bool)component && !component.shot)
			{
				if (!friendly)
				{
					if (target != null)
					{
						component.customTarget = target;
					}
					component.DelayedEnemyReflect();
				}
				else
				{
					component.DelayedReflectRevolver(component.transform.position);
				}
			}
			if (explosive)
			{
				Explode();
				return;
			}
			if (keepTrail)
			{
				KeepTrail();
			}
			active = false;
			CreateExplosionEffect();
			Object.Destroy(base.gameObject);
		}
		else if ((other.gameObject.CompareTag("Armor") && (friendly || !other.TryGetComponent<EnemyIdentifierIdentifier>(out component2) || !component2.eid || component2.eid.enemyType != safeEnemyType)) || (boosted && other.gameObject.layer == 11 && other.gameObject.CompareTag("Body") && other.TryGetComponent<EnemyIdentifierIdentifier>(out component3) && (bool)component3.eid && component3.eid.enemyType == EnemyType.MaliciousFace && !component3.eid.isGasolined))
		{
			if (!alreadyDeflectedBy.Contains(other) && Physics.Raycast(base.transform.position - base.transform.forward, base.transform.forward, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment)))
			{
				base.transform.forward = Vector3.Reflect(base.transform.forward, hitInfo.normal).normalized;
				base.transform.position = hitInfo.point + base.transform.forward;
				Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.ineffectiveSound, base.transform.position, Quaternion.identity);
				alreadyDeflectedBy.Add(other);
			}
		}
		else if (active && (other.gameObject.CompareTag("Head") || other.gameObject.CompareTag("Body") || other.gameObject.CompareTag("Limb") || other.gameObject.CompareTag("EndLimb")) && !other.gameObject.CompareTag("Armor"))
		{
			EnemyIdentifierIdentifier componentInParent2 = other.gameObject.GetComponentInParent<EnemyIdentifierIdentifier>();
			EnemyIdentifier enemyIdentifier = null;
			if (componentInParent2 != null && componentInParent2.eid != null)
			{
				enemyIdentifier = componentInParent2.eid;
			}
			if (!(enemyIdentifier != null) || (alreadyHitEnemies.Count != 0 && alreadyHitEnemies.Contains(enemyIdentifier)) || ((enemyIdentifier.enemyType == safeEnemyType || EnemyIdentifier.CheckHurtException(safeEnemyType, enemyIdentifier.enemyType, target)) && (!friendly || enemyIdentifier.immuneToFriendlyFire) && !playerBullet && !parried))
			{
				return;
			}
			if (explosive)
			{
				Explode();
			}
			active = false;
			bool tryForExplode = false;
			bool dead = enemyIdentifier.dead;
			if (playerBullet)
			{
				enemyIdentifier.hitter = bulletType;
				if (!enemyIdentifier.hitterWeapons.Contains(weaponType))
				{
					enemyIdentifier.hitterWeapons.Add(weaponType);
				}
			}
			else if (!friendly)
			{
				enemyIdentifier.hitter = "enemy";
			}
			else
			{
				enemyIdentifier.hitter = "projectile";
				tryForExplode = true;
			}
			if (boosted && !enemyIdentifier.blessed && !enemyIdentifier.dead)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(90, "ultrakill.projectileboost", sourceWeapon, enemyIdentifier);
			}
			bool flag = true;
			if (spreaded)
			{
				ProjectileSpread componentInParent3 = GetComponentInParent<ProjectileSpread>();
				if (componentInParent3 != null)
				{
					if (componentInParent3.hitEnemies.Contains(enemyIdentifier))
					{
						flag = false;
					}
					else
					{
						componentInParent3.hitEnemies.Add(enemyIdentifier);
					}
				}
			}
			if (!explosive)
			{
				if (flag)
				{
					if (playerBullet)
					{
						enemyIdentifier.DeliverDamage(other.gameObject, rb.velocity.normalized * 2500f, base.transform.position, damage / 4f * enemyDamageMultiplier, tryForExplode, 0f, sourceWeapon);
					}
					else if (friendly)
					{
						enemyIdentifier.DeliverDamage(other.gameObject, rb.velocity.normalized * 10000f, base.transform.position, damage / 4f * enemyDamageMultiplier, tryForExplode, 0f, sourceWeapon);
					}
					else
					{
						enemyIdentifier.DeliverDamage(other.gameObject, rb.velocity.normalized * 100f, base.transform.position, damage / 10f * enemyDamageMultiplier, tryForExplode, 0f, sourceWeapon);
					}
				}
				CreateExplosionEffect();
			}
			if (keepTrail)
			{
				KeepTrail();
			}
			if (!dead)
			{
				MonoSingleton<TimeController>.Instance.HitStop(0.005f);
			}
			if (!dead || other.gameObject.layer == 11 || boosted)
			{
				Object.Destroy(base.gameObject);
				return;
			}
			alreadyHitEnemies.Add(enemyIdentifier);
			active = true;
		}
		else if (!hittingPlayer && (other.gameObject.layer == 8 || other.gameObject.layer == 24) && active)
		{
			Breakable component4 = other.gameObject.GetComponent<Breakable>();
			if (component4 != null && !component4.precisionOnly && (component4.weak || strong))
			{
				component4.Break();
			}
			if (other.gameObject.TryGetComponent<Bleeder>(out var component5))
			{
				bool flag2 = false;
				if (!friendly && !playerBullet && component5.ignoreTypes.Length != 0)
				{
					EnemyType[] ignoreTypes = component5.ignoreTypes;
					for (int i = 0; i < ignoreTypes.Length; i++)
					{
						if (ignoreTypes[i] == safeEnemyType)
						{
							flag2 = true;
							break;
						}
					}
				}
				if (!flag2)
				{
					if (damage <= 10f)
					{
						component5.GetHit(base.transform.position, GoreType.Body);
					}
					else if (damage <= 30f)
					{
						component5.GetHit(base.transform.position, GoreType.Limb);
					}
					else
					{
						component5.GetHit(base.transform.position, GoreType.Head);
					}
				}
			}
			if (explosive)
			{
				Explode();
			}
			else
			{
				if (keepTrail)
				{
					KeepTrail();
				}
				CreateExplosionEffect();
				Object.Destroy(base.gameObject);
			}
			active = false;
		}
		else if (other.gameObject.layer == 0)
		{
			Rigidbody componentInParent4 = other.GetComponentInParent<Rigidbody>();
			if (componentInParent4 != null)
			{
				componentInParent4.AddForce(base.transform.forward * 1000f);
			}
		}
	}

	private void CreateExplosionEffect()
	{
		if (explosionEffect == null)
		{
			return;
		}
		Explosion[] componentsInChildren = Object.Instantiate(explosionEffect, base.transform.position, base.transform.rotation).GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			explosion.sourceWeapon = sourceWeapon ?? explosion.sourceWeapon;
			if (explosion.damage != 0 && ((!friendly && !playerBullet) || (float)explosion.damage < damage))
			{
				explosion.damage = (int)damage;
			}
		}
		if (boosted || parried)
		{
			MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position);
		}
	}

	public void Explode()
	{
		if (!active)
		{
			return;
		}
		active = false;
		if (keepTrail)
		{
			KeepTrail();
		}
		Explosion[] componentsInChildren = Object.Instantiate(explosionEffect, base.transform.position - rb.velocity * 0.02f, base.transform.rotation).GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			explosion.sourceWeapon = sourceWeapon ?? explosion.sourceWeapon;
			if (bigExplosion)
			{
				explosion.maxSize *= 1.5f;
			}
			if (explosion.damage != 0)
			{
				explosion.damage = Mathf.RoundToInt(damage);
			}
			explosion.enemy = true;
		}
		MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(base.transform.position);
		Object.Destroy(base.gameObject);
	}

	private void RecheckPlayerHit()
	{
		if (hittingPlayer)
		{
			hittingPlayer = false;
			col.enabled = false;
			undeflectable = true;
			Invoke("TimeToDie", 0.01f);
		}
	}

	private void TimeToDie()
	{
		bool flag = false;
		if (spreaded)
		{
			ProjectileSpread componentInParent = GetComponentInParent<ProjectileSpread>();
			if (componentInParent != null && componentInParent.parried)
			{
				flag = true;
			}
		}
		CreateExplosionEffect();
		if (!flag)
		{
			if (explosive)
			{
				base.transform.position = base.transform.position - base.transform.forward;
				Explode();
			}
			else
			{
				nmov.GetHurt(Mathf.RoundToInt(damage), invincible: true);
			}
		}
		Object.Destroy(base.gameObject);
	}

	private void KeepTrail()
	{
		TrailRenderer componentInChildren = GetComponentInChildren<TrailRenderer>();
		if (componentInChildren != null)
		{
			componentInChildren.transform.parent = null;
			componentInChildren.gameObject.AddComponent<RemoveOnTime>().time = 3f;
		}
	}
}



public class ProjectileParryZone : MonoBehaviour
{
	private List<GameObject> projs = new List<GameObject>();

	public Material origMat;

	public Material newMat;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 14 && other.gameObject.GetComponentInChildren<Projectile>() != null)
		{
			projs.Add(other.gameObject);
			MeshRenderer component = other.GetComponent<MeshRenderer>();
			if (component != null && component.sharedMaterial == origMat)
			{
				component.material = newMat;
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == 14 && projs.Contains(other.gameObject))
		{
			projs.Remove(other.gameObject);
			MeshRenderer component = other.GetComponent<MeshRenderer>();
			if (component != null && component.sharedMaterial == origMat)
			{
				component.material = origMat;
			}
		}
	}

	public Projectile CheckParryZone()
	{
		Projectile projectile = null;
		float num = 100f;
		List<GameObject> list = new List<GameObject>();
		if (projs.Count > 0)
		{
			foreach (GameObject proj in projs)
			{
				if (proj != null && proj.activeInHierarchy && Vector3.Distance(base.transform.parent.position, proj.transform.position) < num)
				{
					projectile = proj.GetComponentInChildren<Projectile>();
					if (projectile != null && !projectile.undeflectable)
					{
						num = Vector3.Distance(base.transform.parent.position, proj.transform.position);
					}
					else
					{
						list.Add(proj);
					}
				}
				else if (proj == null || !proj.activeInHierarchy)
				{
					list.Add(proj);
				}
			}
		}
		if (list.Count > 0)
		{
			foreach (GameObject item in list)
			{
				projs.Remove(item);
			}
		}
		if (projectile != null)
		{
			return projectile;
		}
		return null;
	}
}



public class ProjectileSpread : MonoBehaviour
{
	private GameObject projectile;

	public float spreadAmount;

	public int projectileAmount;

	public float timeUntilDestroy;

	public bool parried;

	public bool dontSpawn;

	public EnemyTarget target;

	[HideInInspector]
	public List<EnemyIdentifier> hitEnemies = new List<EnemyIdentifier>();

	private void Start()
	{
		if (!dontSpawn && spreadAmount > 0f)
		{
			Projectile componentInChildren = GetComponentInChildren<Projectile>();
			if (componentInChildren.target == null || (target != null && componentInChildren.target != target))
			{
				componentInChildren.target = target;
			}
			projectile = componentInChildren.gameObject;
			GameObject gameObject = new GameObject();
			gameObject.transform.SetPositionAndRotation(base.transform.position, base.transform.rotation);
			for (int i = 0; i <= projectileAmount; i++)
			{
				GameObject obj = Object.Instantiate(projectile, gameObject.transform.position + gameObject.transform.up * 0.1f, gameObject.transform.rotation);
				obj.transform.Rotate(Vector3.right * spreadAmount);
				obj.transform.SetParent(base.transform, worldPositionStays: true);
				gameObject.transform.Rotate(Vector3.forward * (360 / projectileAmount));
			}
			Object.Destroy(gameObject);
		}
		if (timeUntilDestroy == 0f)
		{
			timeUntilDestroy = 5f;
		}
		Invoke("Remove", timeUntilDestroy);
	}

	public void ParriedProjectile()
	{
		parried = true;
		CancelInvoke("NoLongerParried");
		Invoke("NoLongerParried", 1f);
	}

	private void NoLongerParried()
	{
		parried = false;
	}

	private void Remove()
	{
		Object.Destroy(base.gameObject);
	}
}





[Flags]
public enum ProxySearchMode
{
	None = 0,
	IncludeStatic = 1,
	IncludeDynamic = 2,
	FloorOnly = 4,
	IncludeBurning = 8,
	IncludeNotBurning = 0x10,
	Any = 0x1B,
	AnyFloor = 0x1F,
	AnyNotBurning = 0x13,
	AnyBurning = 0xB
}



public class Punch : MonoBehaviour
{
	private InputManager inman;

	public FistType type;

	private string hitter;

	private float damage;

	private float screenShakeMultiplier;

	private float force;

	private bool tryForExplode;

	private float cooldownCost;

	public bool ready = true;

	[HideInInspector]
	public Animator anim;

	private SkinnedMeshRenderer smr;

	private Revolver rev;

	[SerializeField]
	private AudioSource aud;

	private GameObject camObj;

	private CameraController cc;

	private RaycastHit hit;

	public LayerMask deflectionLayerMask;

	public LayerMask ignoreEnemyTrigger;

	public LayerMask environmentMask;

	private NewMovement nmov;

	private TrailRenderer tr;

	private Light parryLight;

	private GameObject currentDustParticle;

	public GameObject dustParticle;

	public AudioSource normalHit;

	public AudioSource heavyHit;

	public AudioSource specialHit;

	private StyleHUD shud;

	private StatsManager sman;

	public bool holding;

	public Transform holder;

	public ItemIdentifier heldItem;

	private bool hasHeldItem;

	private FistControl fc;

	private bool shopping;

	private int shopRequests;

	public GameObject parriedProjectileHitObject;

	private ProjectileParryZone ppz;

	private bool returnToOrigRot;

	public GameObject blastWave;

	private bool holdingInput;

	public GameObject shell;

	public Transform shellEjector;

	private AudioSource ejectorAud;

	private bool alreadyBoostedProjectile;

	private bool ignoreDoublePunch;

	public bool hitSomething;

	public bool parriedSomething;

	public bool alreadyHitCoin;

	public int activeFrames;

	public InputAction heldAction;

	private List<Chainsaw> punchedChainsaws = new List<Chainsaw>();

	private Coroutine punchChainsawsRoutine;

	private void Awake()
	{
		inman = MonoSingleton<InputManager>.Instance;
		anim = GetComponent<Animator>();
		smr = GetComponentInChildren<SkinnedMeshRenderer>();
		rev = base.transform.parent.parent.GetComponentInChildren<Revolver>();
		camObj = MonoSingleton<CameraController>.Instance.gameObject;
		cc = MonoSingleton<CameraController>.Instance;
		aud = GetComponent<AudioSource>();
		parryLight = base.transform.Find("PunchZone").GetComponent<Light>();
		nmov = GetComponentInParent<NewMovement>();
		tr = GetComponentInChildren<TrailRenderer>();
		shud = MonoSingleton<StyleHUD>.Instance;
		sman = MonoSingleton<StatsManager>.Instance;
	}

	private void Start()
	{
		holdingInput = false;
		if (fc == null)
		{
			fc = MonoSingleton<FistControl>.Instance;
		}
		switch (type)
		{
		case FistType.Standard:
			damage = 1f;
			screenShakeMultiplier = 1f;
			force = 25f;
			tryForExplode = false;
			cooldownCost = 2f;
			hitter = "punch";
			break;
		case FistType.Heavy:
			damage = 2.5f;
			screenShakeMultiplier = 2f;
			force = 100f;
			tryForExplode = true;
			cooldownCost = 3f;
			hitter = "heavypunch";
			break;
		}
	}

	private void OnEnable()
	{
		holdingInput = false;
		ReadyToPunch();
		ignoreDoublePunch = false;
		if (fc == null)
		{
			fc = GetComponentInParent<FistControl>();
			anim = GetComponent<Animator>();
		}
		if (fc.heldObject != null)
		{
			heldItem = fc.heldObject;
			heldItem.transform.SetParent(holder, worldPositionStays: true);
			holding = true;
			if (!heldItem.noHoldingAnimation && fc.forceNoHold <= 0)
			{
				anim.SetBool("SemiHolding", value: false);
				anim.SetBool("Holding", value: true);
				anim.Play("Holding", -1, 0f);
			}
			else
			{
				anim.SetBool("SemiHolding", value: true);
			}
			ResetHeldItemPosition();
		}
	}

	public void ResetHeldState()
	{
		holding = false;
		anim.SetBool("Holding", value: false);
		anim.SetBool("SemiHolding", value: false);
	}

	public void ForceThrow()
	{
		if (!heldItem)
		{
			ResetHeldState();
			return;
		}
		Rigidbody[] componentsInChildren = heldItem.GetComponentsInChildren<Rigidbody>();
		if (componentsInChildren == null || componentsInChildren.Length == 0)
		{
			return;
		}
		heldItem.transform.SetParent(null, worldPositionStays: true);
		heldItem.pickedUp = false;
		if (heldItem.reverseTransformSettings)
		{
			heldItem.transform.localScale = Vector3.one;
		}
		else
		{
			heldItem.transform.localScale = heldItem.putDownScale;
		}
		Transform[] componentsInChildren2 = heldItem.GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren2)
		{
			obj.gameObject.layer = 22;
			if (obj.TryGetComponent<OutdoorsChecker>(out var component) && component.enabled)
			{
				component.CancelInvoke("SlowUpdate");
				component.SlowUpdate();
			}
		}
		Rigidbody[] array = componentsInChildren;
		foreach (Rigidbody obj2 in array)
		{
			obj2.isKinematic = false;
			obj2.AddForce((base.transform.parent.forward + Vector3.up * 0.1f) * 5000f);
		}
		Collider[] componentsInChildren3 = heldItem.GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			componentsInChildren3[i].enabled = true;
		}
		heldItem.transform.position = base.transform.parent.position + base.transform.parent.forward;
		heldItem.SendMessage("PutDown", SendMessageOptions.DontRequireReceiver);
		anim.SetBool("Holding", value: false);
		anim.SetBool("SemiHolding", value: false);
		holding = false;
		fc.heldObject = null;
		heldItem = null;
	}

	public void PlaceHeldObject(ItemPlaceZone[] placeZones, Transform target)
	{
		if (!heldItem)
		{
			ResetHeldState();
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = anim.GetCurrentAnimatorStateInfo(0);
		if (currentAnimatorStateInfo.IsName("JabHolding"))
		{
			ignoreDoublePunch = true;
			anim.Play("Jab", 0, currentAnimatorStateInfo.normalizedTime);
		}
		holding = false;
		anim.SetBool("Holding", value: false);
		anim.SetBool("SemiHolding", value: false);
		heldItem.transform.SetParent(target);
		heldItem.pickedUp = false;
		if (heldItem.reverseTransformSettings)
		{
			heldItem.transform.localPosition = Vector3.zero;
			heldItem.transform.localScale = Vector3.one;
			heldItem.transform.localRotation = Quaternion.identity;
		}
		else
		{
			heldItem.transform.localPosition = heldItem.putDownPosition;
			heldItem.transform.localScale = heldItem.putDownScale;
			heldItem.transform.localRotation = Quaternion.Euler(heldItem.putDownRotation);
		}
		Transform[] componentsInChildren = heldItem.GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			obj.gameObject.layer = 22;
			if (obj.TryGetComponent<OutdoorsChecker>(out var component) && component.enabled)
			{
				component.CancelInvoke("SlowUpdate");
				component.SlowUpdate();
			}
		}
		Collider[] componentsInChildren2 = heldItem.GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].enabled = true;
		}
		heldItem.SendMessage("PutDown", SendMessageOptions.DontRequireReceiver);
		Object.Instantiate(heldItem.pickUpSound);
		heldItem = null;
		fc.heldObject = null;
		for (int i = 0; i < placeZones.Length; i++)
		{
			placeZones[i].CheckItem();
		}
		ResetHeldState();
	}

	public void ResetHeldItemPosition()
	{
		if (heldItem.reverseTransformSettings)
		{
			heldItem.transform.localPosition = heldItem.putDownPosition;
			heldItem.transform.localScale = heldItem.putDownScale;
			heldItem.transform.localRotation = Quaternion.Euler(heldItem.putDownRotation);
		}
		else
		{
			heldItem.transform.localPosition = Vector3.zero;
			heldItem.transform.localScale = Vector3.one;
			heldItem.transform.localRotation = Quaternion.identity;
		}
		Transform[] componentsInChildren = heldItem.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.layer = 13;
		}
	}

	public void ForceHold(ItemIdentifier itid)
	{
		holding = true;
		if (itid.TryGetComponent<FishObjectReference>(out var component) && (bool)MonoSingleton<FishManager>.Instance && MonoSingleton<FishManager>.Instance.recognizedFishes.ContainsKey(component.fishObject) && !MonoSingleton<FishManager>.Instance.recognizedFishes[component.fishObject])
		{
			MonoSingleton<FishManager>.Instance.UnlockFish(component.fishObject);
			MonoSingleton<FishingHUD>.Instance.ShowFishCaught(show: true, component.fishObject);
		}
		if (!itid.noHoldingAnimation && fc.forceNoHold <= 0)
		{
			anim.SetBool("SemiHolding", value: false);
			anim.SetBool("Holding", value: true);
		}
		else
		{
			anim.SetBool("SemiHolding", value: true);
		}
		AnimatorStateInfo currentAnimatorStateInfo = anim.GetCurrentAnimatorStateInfo(0);
		if (currentAnimatorStateInfo.IsName("Jab") || currentAnimatorStateInfo.IsName("Jab2"))
		{
			ignoreDoublePunch = true;
			anim.Play("JabHolding", 0, currentAnimatorStateInfo.normalizedTime);
		}
		ItemPlaceZone[] componentsInParent = itid.GetComponentsInParent<ItemPlaceZone>();
		itid.ipz = null;
		heldItem = itid;
		itid.transform.SetParent(holder);
		fc.heldObject = itid;
		itid.pickedUp = true;
		itid.beenPickedUp = true;
		ResetHeldItemPosition();
		Transform[] componentsInChildren = heldItem.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.layer = 13;
		}
		Rigidbody[] componentsInChildren2 = heldItem.GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].isKinematic = true;
		}
		Collider[] componentsInChildren3 = heldItem.GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			componentsInChildren3[i].enabled = false;
		}
		Object.Instantiate(itid.pickUpSound);
		heldItem.SendMessage("PickUp", SendMessageOptions.DontRequireReceiver);
		if (componentsInParent != null && componentsInParent.Length != 0)
		{
			ItemPlaceZone[] array = componentsInParent;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].CheckItem();
			}
		}
	}

	private void OnDisable()
	{
		holding = false;
		anim.SetBool("Holding", value: false);
		anim.SetBool("SemiHolding", value: false);
		ignoreDoublePunch = false;
		if (punchChainsawsRoutine == null)
		{
			return;
		}
		Debug.Log("Cancelled routine");
		punchChainsawsRoutine = null;
		foreach (Chainsaw punchedChainsaw in punchedChainsaws)
		{
			if (!(punchedChainsaw == null))
			{
				punchedChainsaw.beingPunched = false;
			}
		}
	}

	private void Update()
	{
		if (MonoSingleton<OptionsManager>.Instance.paused)
		{
			return;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Punch.WasPerformedThisFrame && ready && !shopping && fc.fistCooldown <= 0f && fc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			heldAction = MonoSingleton<InputManager>.Instance.InputSource.Punch.Action;
			PunchStart();
		}
		if (holdingInput && heldAction.WasReleasedThisFrame())
		{
			holdingInput = false;
		}
		float layerWeight = anim.GetLayerWeight(1);
		if (shopping && layerWeight < 1f)
		{
			anim.SetLayerWeight(1, Mathf.MoveTowards(layerWeight, 1f, Time.deltaTime / 10f + 5f * Time.deltaTime * (1f - layerWeight)));
		}
		else if (!shopping && layerWeight > 0f)
		{
			anim.SetLayerWeight(1, Mathf.MoveTowards(layerWeight, 0f, Time.deltaTime / 10f + 5f * Time.deltaTime * layerWeight));
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && shopping)
		{
			anim.SetTrigger("ShopTap");
		}
		if (returnToOrigRot)
		{
			base.transform.parent.localRotation = Quaternion.RotateTowards(base.transform.parent.localRotation, Quaternion.identity, (Quaternion.Angle(base.transform.parent.localRotation, Quaternion.identity) * 5f + 5f) * Time.deltaTime * 5f);
			if (base.transform.parent.localRotation == Quaternion.identity)
			{
				returnToOrigRot = false;
			}
		}
		if (fc.shopping && !shopping)
		{
			ShopMode();
		}
		else if (!fc.shopping && shopping)
		{
			StopShop();
		}
		if (holding)
		{
			if (heldItem.Equals(null))
			{
				MonoSingleton<FistControl>.Instance.currentPunch.ResetHeldState();
			}
			else if (!heldItem.noHoldingAnimation && fc.forceNoHold <= 0)
			{
				anim.SetBool("SemiHolding", value: false);
				anim.SetBool("Holding", value: true);
			}
			else
			{
				anim.SetBool("SemiHolding", value: true);
			}
		}
	}

	public void PunchStart()
	{
		fc.weightCooldown += cooldownCost * 0.25f + fc.weightCooldown * cooldownCost * 0.1f;
		fc.fistCooldown += fc.weightCooldown;
		holdingInput = true;
		if (ready)
		{
			ready = false;
			anim.SetFloat("PunchRandomizer", Random.Range(0f, 1f));
			anim.SetTrigger("Punch");
			hitSomething = false;
			parriedSomething = false;
			alreadyHitCoin = false;
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.Play();
			tr.widthMultiplier = 0.5f;
			MonoSingleton<HookArm>.Instance.Cancel();
			if (holding && (bool)heldItem)
			{
				heldItem.SendMessage("PunchWith", SendMessageOptions.DontRequireReceiver);
			}
			MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.Punch);
		}
	}

	private void ActiveStart()
	{
		if (ignoreDoublePunch)
		{
			ignoreDoublePunch = false;
			return;
		}
		returnToOrigRot = false;
		hitSomething = false;
		parriedSomething = false;
		activeFrames = (MonoSingleton<AssistController>.Instance ? MonoSingleton<AssistController>.Instance.punchAssistFrames : 6);
		bool num = holding;
		hasHeldItem = holding;
		ActiveFrame(firstFrame: true);
		if (num && holding && heldItem != null)
		{
			ForceThrow();
		}
	}

	private void FixedUpdate()
	{
		if (activeFrames > 0)
		{
			activeFrames--;
			ActiveFrame();
			if (activeFrames == 0)
			{
				hasHeldItem = false;
			}
		}
	}

	private void ActiveFrame(bool firstFrame = false)
	{
		if (type == FistType.Standard && !parriedSomething)
		{
			Collider[] array = Physics.OverlapSphere(cc.GetDefaultPos(), 0.01f, deflectionLayerMask, QueryTriggerInteraction.Collide);
			List<Transform> list = new List<Transform>();
			Collider[] array2 = array;
			foreach (Collider collider in array2)
			{
				list.Add(collider.transform);
				if (TryParryProjectile((collider.attachedRigidbody != null) ? collider.attachedRigidbody.transform : collider.transform, firstFrame))
				{
					break;
				}
			}
			bool flag = Physics.Raycast(cc.GetDefaultPos(), camObj.transform.forward, out hit, 4f, deflectionLayerMask);
			if (!flag)
			{
				flag = Physics.BoxCast(cc.GetDefaultPos(), Vector3.one * 0.3f, camObj.transform.forward, out hit, camObj.transform.rotation, 4f, deflectionLayerMask);
			}
			if (!flag || list.Contains(hit.transform) || !TryParryProjectile(hit.transform, firstFrame))
			{
				if (ppz == null)
				{
					ppz = base.transform.parent.GetComponentInChildren<ProjectileParryZone>();
				}
				if (ppz != null)
				{
					Projectile projectile = ppz.CheckParryZone();
					if (projectile != null)
					{
						bool flag2 = !alreadyBoostedProjectile && firstFrame;
						if (!list.Contains(projectile.transform) && !projectile.unparryable && !projectile.undeflectable && (flag2 || !projectile.playerBullet))
						{
							ParryProjectile(projectile);
							parriedSomething = true;
							hitSomething = true;
						}
					}
				}
			}
		}
		else if (type == FistType.Heavy && !hitSomething)
		{
			Transform transform = null;
			Collider[] array3 = Physics.OverlapSphere(cc.GetDefaultPos(), 0.1f, deflectionLayerMask);
			if (array3.Length != 0)
			{
				transform = array3[0].transform;
			}
			else if (Physics.Raycast(cc.GetDefaultPos(), camObj.transform.forward, out hit, 4f, deflectionLayerMask) || Physics.BoxCast(cc.GetDefaultPos(), Vector3.one * 0.3f, camObj.transform.forward, out hit, camObj.transform.rotation, 4f, deflectionLayerMask))
			{
				transform = hit.transform;
			}
			if (transform != null)
			{
				if (transform.TryGetComponent<MassSpear>(out var component) && component.hitPlayer)
				{
					Object.Instantiate(specialHit, base.transform.position, Quaternion.identity);
					MonoSingleton<TimeController>.Instance.HitStop(0.1f);
					cc.CameraShake(0.5f * screenShakeMultiplier);
					component.GetHurt(10f);
					hitSomething = true;
				}
				if (transform.TryGetComponent<Chainsaw>(out var component2))
				{
					fc.fistCooldown -= Mathf.Min(fc.fistCooldown, fc.weightCooldown);
					component2.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos();
					component2.transform.rotation = Quaternion.LookRotation(component2.transform.position - GetParryLookTarget());
					component2.transform.position -= component2.transform.forward;
					component2.rb.velocity = component2.transform.forward * -105f;
					component2.stopped = false;
					MonoSingleton<TimeController>.Instance.ParryFlash();
					component2.TurnIntoSawblade();
					hitSomething = true;
				}
			}
		}
		bool flag3 = Physics.Raycast(cc.GetDefaultPos(), camObj.transform.forward, out hit, 4f, ignoreEnemyTrigger, QueryTriggerInteraction.Collide);
		if (!flag3)
		{
			flag3 = Physics.SphereCast(cc.GetDefaultPos(), 1f, camObj.transform.forward, out hit, 4f, ignoreEnemyTrigger, QueryTriggerInteraction.Collide);
		}
		if (flag3)
		{
			if (!alreadyHitCoin && type == FistType.Standard && hit.collider.CompareTag("Coin"))
			{
				Coin component3 = hit.collider.GetComponent<Coin>();
				if ((bool)component3 && component3.doubled)
				{
					anim.Play("Hook", 0, 0.065f);
					component3.DelayedPunchflection();
					alreadyHitCoin = true;
				}
			}
			if (hitSomething)
			{
				return;
			}
			bool flag4 = false;
			if (Physics.Raycast(cc.GetDefaultPos(), hit.point - cc.GetDefaultPos(), out var hitInfo, 5f, environmentMask) && Vector3.Distance(cc.GetDefaultPos(), hit.point) > Vector3.Distance(cc.GetDefaultPos(), hitInfo.point))
			{
				flag4 = true;
			}
			if (!flag4)
			{
				PunchSuccess(hit.point, hit.transform);
				hitSomething = true;
			}
		}
		if (hitSomething)
		{
			return;
		}
		Collider[] array4 = Physics.OverlapSphere(cc.GetDefaultPos(), 0.1f, ignoreEnemyTrigger, QueryTriggerInteraction.Collide);
		if (array4 != null && array4.Length != 0)
		{
			Collider[] array2 = array4;
			foreach (Collider collider2 in array2)
			{
				PunchSuccess(cc.GetDefaultPos(), collider2.transform);
			}
			hitSomething = true;
		}
		if (type == FistType.Standard && !hitSomething && !parriedSomething)
		{
			Collider[] array5 = Physics.OverlapSphere(cc.GetDefaultPos() + camObj.transform.forward * 3f, 3f, deflectionLayerMask, QueryTriggerInteraction.Collide);
			bool flag5 = false;
			Collider[] array2 = array5;
			foreach (Collider collider3 in array2)
			{
				Nail nail = ((!collider3.attachedRigidbody) ? collider3.GetComponent<Nail>() : collider3.attachedRigidbody.GetComponent<Nail>());
				if (!(nail == null) && nail.sawblade && nail.punchable)
				{
					flag5 = true;
					if (nail.stopped)
					{
						nail.stopped = false;
						nail.rb.velocity = (GetParryLookTarget() - nail.transform.position).normalized * nail.originalVelocity.magnitude;
					}
					else
					{
						nail.rb.velocity = (GetParryLookTarget() - nail.transform.position).normalized * nail.rb.velocity.magnitude;
					}
					nail.punched = true;
					if (nail.magnets.Count > 0)
					{
						nail.punchDistance = Vector3.Distance(nail.transform.position, nail.GetTargetMagnet().transform.position);
					}
				}
			}
			if (!flag5)
			{
				array2 = Physics.OverlapSphere(cc.GetDefaultPos() + camObj.transform.forward, 1f, 1, QueryTriggerInteraction.Collide);
				foreach (Collider collider4 in array2)
				{
					float num = Vector3.Distance(cc.GetDefaultPos() + camObj.transform.forward, collider4.transform.position);
					if (num < 6f || num > 12f || Mathf.Abs((cc.GetDefaultPos() + camObj.transform.forward).y - collider4.transform.position.y) > 3f || !collider4.TryGetComponent<Magnet>(out var component4) || component4.sawblades.Count <= 0)
					{
						continue;
					}
					float num2 = float.PositiveInfinity;
					float num3 = 0f;
					int num4 = -1;
					for (int num5 = component4.sawblades.Count - 1; num5 >= 0; num5--)
					{
						if (component4.sawblades[num5] == null)
						{
							component4.sawblades.RemoveAt(num5);
							if (flag5)
							{
								num4--;
							}
						}
						else
						{
							num3 = Vector3.Distance(component4.sawblades[num5].transform.position, cc.GetDefaultPos());
							if (component4.sawblades[num5] != null && (num4 < 0 || num2 < num3))
							{
								num4 = num5;
								num2 = num3;
								flag5 = true;
							}
						}
					}
					if (!flag5 || !component4.sawblades[num4].TryGetComponent<Nail>(out var component5))
					{
						continue;
					}
					component5.transform.position = cc.GetDefaultPos() + cc.transform.forward;
					if (component5.stopped)
					{
						component5.stopped = false;
						component5.rb.velocity = (GetParryLookTarget() - component5.transform.position).normalized * component5.originalVelocity.magnitude;
					}
					else
					{
						component5.rb.velocity = (GetParryLookTarget() - component5.transform.position).normalized * component5.rb.velocity.magnitude;
					}
					component5.punched = true;
					if (component5.magnets.Count > 0)
					{
						Magnet targetMagnet = component5.GetTargetMagnet();
						if (Vector3.Distance(component5.transform.position + component5.rb.velocity.normalized, targetMagnet.transform.position) > Vector3.Distance(component5.transform.position, targetMagnet.transform.position))
						{
							component5.MagnetRelease(targetMagnet);
						}
						else
						{
							component5.punchDistance = Vector3.Distance(component5.transform.position, targetMagnet.transform.position);
						}
					}
					break;
				}
			}
			if (flag5)
			{
				Object.Instantiate(specialHit, base.transform.position, Quaternion.identity);
				MonoSingleton<TimeController>.Instance.HitStop(0.1f);
				anim.Play("Hook", -1, 0.065f);
				parriedSomething = true;
				hitSomething = true;
			}
		}
		if (Physics.CheckSphere(cc.GetDefaultPos(), 0.01f, environmentMask, QueryTriggerInteraction.Collide))
		{
			Collider[] array2 = Physics.OverlapSphere(cc.GetDefaultPos(), 0.01f, environmentMask);
			foreach (Collider collider5 in array2)
			{
				AltHit(collider5.transform);
			}
		}
		else
		{
			if (!Physics.Raycast(cc.GetDefaultPos(), camObj.transform.forward, out hit, 4f, environmentMask))
			{
				return;
			}
			AltHit(hit.transform);
			if (hit.transform.gameObject.layer != 8 && hit.transform.gameObject.layer != 24)
			{
				return;
			}
			hitSomething = true;
			base.transform.parent.localRotation = Quaternion.identity;
			cc.CameraShake(0.2f * screenShakeMultiplier);
			Object.Instantiate(normalHit, base.transform.position, Quaternion.identity);
			currentDustParticle = Object.Instantiate(dustParticle, hit.point, base.transform.rotation);
			currentDustParticle.transform.forward = hit.normal;
			Breakable component6 = hit.transform.gameObject.GetComponent<Breakable>();
			if (component6 != null && !component6.precisionOnly && (component6.weak || type == FistType.Heavy))
			{
				component6.Break();
			}
			if (hit.collider.gameObject.TryGetComponent<Bleeder>(out var component7))
			{
				if (type == FistType.Standard)
				{
					component7.GetHit(hit.point, GoreType.Body);
				}
				else
				{
					component7.GetHit(hit.point, GoreType.Head);
				}
			}
			if (type == FistType.Heavy)
			{
				Glass component8 = hit.collider.gameObject.GetComponent<Glass>();
				if (component8 != null && !component8.broken)
				{
					component8.Shatter();
				}
			}
			HitSurface(hit);
		}
	}

	private void HitSurface(RaycastHit hit)
	{
		if (holding)
		{
			heldItem.SendMessage("HitSurface", hit, SendMessageOptions.DontRequireReceiver);
		}
	}

	private bool TryParryProjectile(Transform target, bool canProjectileBoost = false)
	{
		if (target.TryGetComponent<ParryHelper>(out var component))
		{
			target = component.target;
		}
		if (target.TryGetComponent<Projectile>(out var component2) && !component2.unparryable && !component2.undeflectable && ((!alreadyBoostedProjectile && canProjectileBoost) || !component2.playerBullet))
		{
			ParryProjectile(component2);
			hitSomething = true;
			parriedSomething = true;
			return true;
		}
		if (target.TryGetComponent<Cannonball>(out var component3) && component3.launchable)
		{
			anim.Play("Hook", 0, 0.065f);
			if (!component3.parry)
			{
				MonoSingleton<TimeController>.Instance.ParryFlash();
			}
			else
			{
				Parry();
			}
			Vector3 parryLookTarget = GetParryLookTarget();
			if (Vector3.Distance(component3.transform.position, parryLookTarget) < 10f)
			{
				if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment)))
				{
					component3.transform.position = hitInfo.point;
				}
				else
				{
					component3.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + MonoSingleton<CameraController>.Instance.transform.forward * 5f;
				}
				component3.transform.forward = MonoSingleton<CameraController>.Instance.transform.forward;
			}
			else
			{
				component3.transform.LookAt(parryLookTarget);
			}
			component3.Launch();
			hitSomething = true;
			parriedSomething = true;
			return true;
		}
		if (target.TryGetComponent<ParryReceiver>(out var component4))
		{
			if (!component4.enabled)
			{
				return false;
			}
			anim.Play("Hook", 0, 0.065f);
			if (component4.parryHeal)
			{
				Parry();
			}
			else
			{
				MonoSingleton<TimeController>.Instance.ParryFlash();
			}
			component4.Parry();
			hitSomething = true;
			parriedSomething = true;
			return true;
		}
		if (target.TryGetComponent<ThrownSword>(out var component5) && !component5.friendly && component5.active)
		{
			component5.GetParried();
			anim.Play("Hook", -1, 0.065f);
			Parry(hook: false, component5.returnTransform.GetComponentInParent<EnemyIdentifier>());
			hitSomething = true;
			parriedSomething = true;
			return true;
		}
		if (target.TryGetComponent<MassSpear>(out var component6))
		{
			if (!component6.beenStopped || component6.hittingPlayer)
			{
				component6.Deflected();
				anim.Play("Hook", -1, 0.065f);
				Parry();
				hitSomething = true;
				parriedSomething = true;
			}
			else
			{
				if (!component6.hitPlayer || hitSomething)
				{
					return false;
				}
				Object.Instantiate(specialHit, base.transform.position, Quaternion.identity);
				MonoSingleton<TimeController>.Instance.HitStop(0.1f);
				cc.CameraShake(0.5f * screenShakeMultiplier);
				component6.GetHurt(5f);
				hitSomething = true;
			}
			return true;
		}
		if (target.TryGetComponent<Landmine>(out var component7))
		{
			anim.Play("Hook", 0, 0.065f);
			Parry();
			component7.transform.LookAt(GetParryLookTarget());
			component7.Parry();
			hitSomething = true;
			parriedSomething = true;
			return true;
		}
		if (target.TryGetComponent<Chainsaw>(out var component8))
		{
			anim.Play("Hook", 0, 0.065f);
			component8.beingPunched = true;
			fc.fistCooldown -= Mathf.Min(fc.fistCooldown, fc.weightCooldown);
			if (!punchedChainsaws.Contains(component8))
			{
				punchedChainsaws.Add(component8);
			}
			if (punchChainsawsRoutine == null)
			{
				punchChainsawsRoutine = StartCoroutine(ChainsawPunchRoutine());
			}
		}
		return false;
	}

	private IEnumerator ChainsawPunchRoutine()
	{
		while (punchedChainsaws.Count > 0)
		{
			punchedChainsaws.RemoveAll((Chainsaw x) => x == null);
			if (punchedChainsaws.Count == 0)
			{
				break;
			}
			Chainsaw chainsaw = punchedChainsaws[punchedChainsaws.Count - 1];
			chainsaw.GetPunched();
			if (chainsaw.stopped)
			{
				chainsaw.stopped = false;
			}
			chainsaw.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + MonoSingleton<CameraController>.Instance.transform.forward;
			chainsaw.rb.velocity = (GetParryLookTarget() - chainsaw.transform.position).normalized * 105f;
			Object.Instantiate(specialHit, base.transform.position, Quaternion.identity);
			MonoSingleton<TimeController>.Instance.HitStop(0.1f);
			parriedSomething = true;
			hitSomething = true;
			punchedChainsaws.RemoveAt(punchedChainsaws.Count - 1);
			yield return new WaitForSeconds(0.05f);
		}
		punchChainsawsRoutine = null;
	}

	public void CoinFlip()
	{
		if (ready && MonoSingleton<FistControl>.Instance.forceNoHold <= 0)
		{
			anim.SetTrigger("CoinFlip");
		}
	}

	private void ActiveEnd()
	{
		tr.widthMultiplier = 0f;
		ignoreDoublePunch = false;
		if (type == FistType.Standard)
		{
			ResetFistRotation();
		}
	}

	public void ResetFistRotation()
	{
		returnToOrigRot = true;
	}

	private void PunchEnd()
	{
	}

	private void ReadyToPunch()
	{
		returnToOrigRot = true;
		holdingInput = false;
		ready = true;
		alreadyBoostedProjectile = false;
		ignoreDoublePunch = false;
	}

	private void PunchSuccess(Vector3 point, Transform target)
	{
		base.transform.parent.LookAt(point);
		if (Quaternion.Angle(base.transform.parent.localRotation, Quaternion.identity) > 45f)
		{
			Quaternion localRotation = base.transform.parent.localRotation;
			float num = localRotation.eulerAngles.x;
			float num2 = localRotation.eulerAngles.y;
			float num3 = localRotation.eulerAngles.z;
			if (num > 180f)
			{
				num -= 360f;
			}
			if (num2 > 180f)
			{
				num2 -= 360f;
			}
			if (num3 > 180f)
			{
				num3 -= 360f;
			}
			localRotation.eulerAngles = new Vector3(Mathf.Clamp(num, -45f, 45f), Mathf.Clamp(num2, -45f, 45f), Mathf.Clamp(num3, -45f, 45f));
			base.transform.parent.localRotation = localRotation;
		}
		if (target.TryGetComponent<ParryHelper>(out var component))
		{
			target = component.target;
		}
		EnemyIdentifier component3;
		if (target.gameObject.CompareTag("Enemy") || target.gameObject.CompareTag("Armor") || target.gameObject.CompareTag("Head") || target.gameObject.CompareTag("Body") || target.gameObject.CompareTag("Limb") || target.gameObject.CompareTag("EndLimb"))
		{
			if (anim.GetFloat("PunchRandomizer") < 0.5f)
			{
				anim.Play("Jab", 0, 0.075f);
			}
			else
			{
				anim.Play("Jab2", 0, 0.075f);
			}
			Object.Instantiate(heavyHit, base.transform.position, Quaternion.identity);
			MonoSingleton<TimeController>.Instance.HitStop(0.1f);
			cc.CameraShake(0.5f * screenShakeMultiplier);
			EnemyIdentifier enemyIdentifier = null;
			if (target.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
			{
				enemyIdentifier = component2.eid;
			}
			if ((bool)enemyIdentifier)
			{
				if (enemyIdentifier.drillers.Count > 0 && type != FistType.Heavy)
				{
					anim.Play("Hook", 0, 0.065f);
					MonoSingleton<TimeController>.Instance.ParryFlash();
					Harpoon harpoon = enemyIdentifier.drillers[enemyIdentifier.drillers.Count - 1];
					harpoon.transform.forward = cc.transform.forward;
					harpoon.transform.position = cc.GetDefaultPos();
					harpoon.Punched();
				}
				enemyIdentifier.hitter = hitter;
				enemyIdentifier.DeliverDamage(target.gameObject, camObj.transform.forward * force * 1000f, point, damage, tryForExplode);
			}
			if (holding)
			{
				heldItem.SendMessage("HitWith", target.gameObject, SendMessageOptions.DontRequireReceiver);
			}
		}
		else if (target.TryGetComponent<EnemyIdentifier>(out component3) && component3.enemyType == EnemyType.Idol)
		{
			component3.hitter = hitter;
			component3.DeliverDamage(target.gameObject, camObj.transform.forward * force * 1000f, point, damage, tryForExplode);
		}
	}

	public void Parry(bool hook = false, EnemyIdentifier eid = null, string customParryText = "")
	{
		parriedSomething = true;
		hitSomething = true;
		activeFrames = 0;
		if (hook)
		{
			anim.Play("Hook", 0, 0.065f);
		}
		aud.pitch = Random.Range(0.7f, 0.8f);
		MonoSingleton<NewMovement>.Instance.Parry(eid, customParryText);
	}

	private void ParryProjectile(Projectile proj)
	{
		proj.hittingPlayer = false;
		proj.friendly = true;
		proj.parried = true;
		proj.speed *= 2f;
		proj.homingType = HomingType.None;
		proj.explosionEffect = parriedProjectileHitObject;
		proj.precheckForCollisions = true;
		Rigidbody component = proj.GetComponent<Rigidbody>();
		if (proj.playerBullet)
		{
			alreadyBoostedProjectile = true;
			proj.boosted = true;
			proj.GetComponent<SphereCollider>().radius *= 4f;
			proj.damage = 0f;
			if ((bool)component)
			{
				component.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			}
			Color color = new Color(1f, 0.35f, 0f);
			if (proj.TryGetComponent<MeshRenderer>(out var component2) && (bool)component2.material && component2.material.HasProperty("_Color"))
			{
				component2.material.SetColor("_Color", color);
			}
			if (proj.TryGetComponent<TrailRenderer>(out var component3))
			{
				Gradient gradient = new Gradient();
				gradient.SetKeys(new GradientColorKey[2]
				{
					new GradientColorKey(color, 0f),
					new GradientColorKey(color, 1f)
				}, new GradientAlphaKey[2]
				{
					new GradientAlphaKey(1f, 0f),
					new GradientAlphaKey(0f, 1f)
				});
				component3.colorGradient = gradient;
			}
			if (proj.TryGetComponent<Light>(out var component4))
			{
				component4.color = color;
			}
		}
		if ((bool)component)
		{
			component.constraints = RigidbodyConstraints.FreezeRotation;
		}
		anim.Play("Hook", 0, 0.065f);
		if (!proj.playerBullet)
		{
			Parry();
		}
		else
		{
			MonoSingleton<TimeController>.Instance.ParryFlash();
		}
		if (proj.explosive)
		{
			proj.explosive = false;
		}
		Rigidbody component5 = proj.GetComponent<Rigidbody>();
		if ((bool)component5 && component5.useGravity)
		{
			component5.useGravity = false;
		}
		Vector3 parryLookTarget = GetParryLookTarget();
		proj.transform.LookAt(parryLookTarget);
		if (proj.speed == 0f)
		{
			component5.velocity = (parryLookTarget - base.transform.position).normalized * 250f;
		}
		else if (proj.speed < 100f)
		{
			proj.speed = 100f;
		}
		if (proj.spreaded)
		{
			ProjectileSpread componentInParent = proj.GetComponentInParent<ProjectileSpread>();
			if (componentInParent != null)
			{
				componentInParent.ParriedProjectile();
			}
		}
		proj.transform.SetParent(null, worldPositionStays: true);
	}

	public void BlastCheck()
	{
		if (heldAction.IsPressed())
		{
			holdingInput = false;
			anim.SetTrigger("PunchBlast");
			Vector3 position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + MonoSingleton<CameraController>.Instance.transform.forward * 2f;
			if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward, out var hitInfo, 2f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				position = hitInfo.point - camObj.transform.forward * 0.1f;
			}
			Object.Instantiate(blastWave, position, MonoSingleton<CameraController>.Instance.transform.rotation);
		}
	}

	public void Eject()
	{
		if (ejectorAud == null)
		{
			ejectorAud = shellEjector.GetComponent<AudioSource>();
		}
		ejectorAud.Play();
		for (int i = 0; i < 2; i++)
		{
			GameObject gameObject = Object.Instantiate(shell, shellEjector.position + shellEjector.right * 0.075f, shellEjector.rotation);
			if (i == 1)
			{
				gameObject.transform.position = gameObject.transform.position - shellEjector.right * 0.15f;
			}
			gameObject.transform.Rotate(Vector3.forward, Random.Range(-45, 45), Space.Self);
			gameObject.GetComponent<Rigidbody>().AddForce((shellEjector.forward / 1.75f + shellEjector.up / 2f + Vector3.up / 1.75f) * Random.Range(8, 12), ForceMode.VelocityChange);
		}
	}

	public void Hide()
	{
	}

	public void ShopMode()
	{
		shopping = true;
		holdingInput = false;
		shopRequests++;
	}

	public void StopShop()
	{
		shopRequests--;
		if (shopRequests <= 0)
		{
			shopping = false;
		}
	}

	public void EquipAnimation()
	{
		if (anim == null)
		{
			anim = GetComponent<Animator>();
		}
		anim.SetTrigger("Equip");
	}

	private void AltHit(Transform target)
	{
		if (target.gameObject.layer == 22)
		{
			ItemIdentifier itemIdentifier = target.GetComponent<ItemIdentifier>();
			if ((bool)itemIdentifier && hasHeldItem)
			{
				return;
			}
			ItemPlaceZone[] components = target.GetComponents<ItemPlaceZone>();
			if ((bool)itemIdentifier && itemIdentifier.infiniteSource)
			{
				itemIdentifier = itemIdentifier.CreateCopy();
			}
			if (holding && components != null && components.Length != 0)
			{
				PlaceHeldObject(components, target);
				hitSomething = true;
			}
			else if (!holding && itemIdentifier != null)
			{
				ForceHold(itemIdentifier);
				hitSomething = true;
			}
		}
		if (holding)
		{
			heldItem.SendMessage("HitWith", target.gameObject, SendMessageOptions.DontRequireReceiver);
		}
	}

	public void CancelAttack()
	{
		anim.Rebind();
		anim.Update(0f);
		ActiveEnd();
		ReadyToPunch();
	}

	public static Vector3 GetParryLookTarget()
	{
		Vector3 vector = MonoSingleton<CameraController>.Instance.transform.forward;
		if ((bool)MonoSingleton<CameraFrustumTargeter>.Instance && (bool)MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget && MonoSingleton<CameraFrustumTargeter>.Instance.IsAutoAimed)
		{
			vector = MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.transform.position;
		}
		if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), vector, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Enemies), QueryTriggerInteraction.Ignore))
		{
			return hitInfo.point;
		}
		return MonoSingleton<CameraController>.Instance.GetDefaultPos() + vector * 1000f;
	}
}



public class PunchZone : MonoBehaviour
{
	public bool active;

	private AudioSource aud;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	private void OnTriggerStay(Collider other)
	{
		if (active)
		{
			if (other.gameObject.layer == 8)
			{
				aud.Play();
				active = false;
			}
			else if (other.gameObject.CompareTag("Enemy"))
			{
				active = false;
				other.gameObject.GetComponent<EnemyIdentifierIdentifier>().eid.DeliverDamage(other.gameObject, (base.transform.position - other.transform.position).normalized * 10000f, other.transform.position, 1f, tryForExplode: false, 1f);
			}
		}
	}
}



public class Puppet : MonoBehaviour
{
	private NavMeshAgent nma;

	[SerializeField]
	private SwingCheck2 sc;

	private Animator anim;

	private EnemyIdentifier eid;

	private Machine mach;

	private Rigidbody rb;

	private bool inAction;

	private bool moving;

	private void Start()
	{
		nma = GetComponent<NavMeshAgent>();
		anim = GetComponent<Animator>();
		eid = GetComponent<EnemyIdentifier>();
		mach = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		SlowUpdate();
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.25f);
		if (eid.target != null && !inAction && nma.enabled && nma.isOnNavMesh && Physics.Raycast(eid.target.position, Vector3.down, out var hitInfo, 120f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			nma.SetDestination(hitInfo.point);
		}
	}

	private void Update()
	{
		Vector3 b = ((eid.target == null) ? (base.transform.position + base.transform.forward) : new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		if (!inAction && eid.target != null)
		{
			if (Vector3.Distance(base.transform.position, b) < 5f)
			{
				Swing();
			}
		}
		else if (moving)
		{
			rb.MovePosition(base.transform.position + base.transform.forward * Time.deltaTime * 15f);
		}
		anim.SetBool("Walking", !inAction && nma.velocity.magnitude > 1.5f);
	}

	private void Swing()
	{
		inAction = true;
		nma.enabled = false;
		anim.Play("Swing", -1, 0f);
		if (eid.target != null)
		{
			base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		}
	}

	private void DamageStart()
	{
		sc.DamageStart();
		moving = true;
	}

	private void DamageStop()
	{
		sc.DamageStop();
		moving = false;
	}

	private void StopAction()
	{
		inAction = false;
		if (mach.gc.onGround)
		{
			nma.enabled = true;
		}
	}
}



public class PuzzleController : MonoBehaviour
{
	private bool backOnBlack = true;

	private Image img;

	private PuzzlePanel[] panels;

	public List<PuzzlePanel> activatedPanels = new List<PuzzlePanel>();

	public List<TileColor> activatedColors = new List<TileColor>();

	public bool puzzleInProgress;

	public bool solved;

	public GameObject[] toActivate;

	public ObjectActivator activationZone;

	private TileColor currentColor;

	private int starts;

	private int ends;

	public GameObject puzzleCorrect;

	public GameObject puzzleWrong;

	public GameObject puzzleClick;

	private float checkForHold;

	private Punch punch;

	private void Start()
	{
		panels = GetComponentsInChildren<PuzzlePanel>();
		img = GetComponent<Image>();
	}

	private void OnDisable()
	{
		if (!solved)
		{
			ResetPuzzle();
		}
	}

	private void Update()
	{
		if (!backOnBlack)
		{
			img.color = Color.Lerp(img.color, Color.black, Time.deltaTime);
			if (img.color == Color.black)
			{
				backOnBlack = true;
			}
		}
		if (checkForHold > 0f)
		{
			checkForHold = Mathf.MoveTowards(checkForHold, 0f, Time.deltaTime);
		}
	}

	public void Clicked(PuzzlePanel other)
	{
		if (other.tileType == TileType.White)
		{
			if (!puzzleInProgress && !activatedPanels.Contains(other))
			{
				if (solved)
				{
					solved = false;
					backOnBlack = false;
					ResetPuzzle();
					activationZone.disableOnExit = true;
				}
				checkForHold = 0.3f;
				Object.Instantiate(puzzleClick, other.transform.position, Quaternion.identity);
				starts++;
				puzzleInProgress = true;
				currentColor = other.tileColor;
				other.Activate(currentColor);
				activatedPanels.Add(other);
				activatedColors.Add(currentColor);
			}
			else
			{
				ResetPuzzle();
			}
		}
		else if (other.tileType == TileType.WhiteEnd && puzzleInProgress && activatedPanels[activatedPanels.Count - 1] == other)
		{
			if (currentColor == other.tileColor || other.tileColor == TileColor.None)
			{
				CheckSolution();
			}
			else
			{
				Failure();
			}
		}
		else if (puzzleInProgress)
		{
			ResetPuzzle();
			Object.Instantiate(puzzleClick, other.transform.position, Quaternion.identity).GetComponent<AudioSource>().pitch -= 0.5f;
		}
	}

	public void Unclicked()
	{
		if (puzzleInProgress && checkForHold == 0f)
		{
			Clicked(activatedPanels[activatedPanels.Count - 1]);
			if (punch == null)
			{
				punch = MonoSingleton<FistControl>.Instance.currentPunch;
			}
			punch.anim.SetTrigger("ShopTap");
		}
	}

	public void Hovered(PuzzlePanel other)
	{
		if (!puzzleInProgress)
		{
			return;
		}
		if (!activatedPanels.Contains(other))
		{
			if (Vector3.Distance(other.transform.localPosition, activatedPanels[activatedPanels.Count - 1].transform.localPosition) < (float)(other.pl.length - 3))
			{
				other.pl.DrawLine(other.transform.localPosition, activatedPanels[activatedPanels.Count - 1].transform.localPosition, currentColor);
				other.Activate(currentColor);
				activatedPanels.Add(other);
				activatedColors.Add(currentColor);
			}
		}
		else if (activatedPanels.IndexOf(other) == activatedPanels.Count - 2)
		{
			activatedPanels[activatedPanels.Count - 1].DeActivate();
			activatedPanels[activatedPanels.Count - 1].pl.Hide();
			activatedPanels.Remove(activatedPanels[activatedPanels.Count - 1]);
			activatedColors.Remove(activatedColors[activatedColors.Count - 1]);
		}
	}

	public void Success()
	{
		img.color = Color.green;
		puzzleInProgress = false;
		solved = true;
		backOnBlack = true;
		activationZone.disableOnExit = false;
		if (toActivate.Length != 0)
		{
			Invoke("ActivateNow", 0.5f);
		}
		Object.Instantiate(puzzleCorrect, base.transform.position, Quaternion.identity);
	}

	public void Failure()
	{
		img.color = Color.red;
		backOnBlack = false;
		ResetPuzzle();
		Object.Instantiate(puzzleWrong, base.transform.position, Quaternion.identity);
	}

	public void ResetPuzzle()
	{
		starts = 0;
		ends = 0;
		puzzleInProgress = false;
		activatedPanels.Clear();
		activatedColors.Clear();
		PuzzlePanel[] array = panels;
		foreach (PuzzlePanel obj in array)
		{
			obj.DeActivate();
			obj.pl.Hide();
		}
	}

	private void CheckSolution()
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		ends = 0;
		for (int i = 0; i < panels.Length; i++)
		{
			if (panels[i].tileType == TileType.WhiteEnd)
			{
				if (!activatedPanels.Contains(panels[i]))
				{
					flag2 = true;
				}
				else
				{
					ends++;
					if (panels[i].tileColor != activatedColors[activatedPanels.IndexOf(panels[i])] && panels[i].tileColor != 0)
					{
						flag = true;
					}
				}
			}
			else if (panels[i].tileType == TileType.WhiteFill)
			{
				if (!activatedPanels.Contains(panels[i]) && panels[i].tileColor == currentColor)
				{
					flag = true;
				}
				else if (!activatedPanels.Contains(panels[i]) && panels[i].tileColor == TileColor.None)
				{
					flag3 = true;
				}
				else if (activatedPanels.Contains(panels[i]) && panels[i].tileColor != activatedColors[activatedPanels.IndexOf(panels[i])] && panels[i].tileColor != 0)
				{
					flag = true;
				}
			}
			else if (panels[i].tileType == TileType.WhitePit && puzzleInProgress && activatedPanels.Contains(panels[i]) && (panels[i].tileColor == activatedColors[activatedPanels.IndexOf(panels[i])] || panels[i].tileColor == TileColor.None))
			{
				flag = true;
			}
			if (flag)
			{
				break;
			}
		}
		if (starts != ends)
		{
			Failure();
		}
		else if (!flag && !flag3 && !flag2)
		{
			Success();
		}
		else if (flag || (flag3 && !flag2))
		{
			Failure();
		}
		else if (flag2)
		{
			WhiteFlash();
		}
	}

	private void WhiteFlash()
	{
		puzzleInProgress = false;
		backOnBlack = false;
		img.color = Color.white;
		Object.Instantiate(puzzleClick, base.transform.position, Quaternion.identity);
	}

	private void ActivateNow()
	{
		GameObject[] array = toActivate;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}
}



public class PuzzleLine : MonoBehaviour
{
	private RectTransform imageRectTransform;

	private Image img;

	public int length;

	public void DrawLine(Vector3 pointA, Vector3 pointB, TileColor color)
	{
		if (imageRectTransform == null)
		{
			imageRectTransform = GetComponent<RectTransform>();
		}
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		Vector3 vector = pointB - pointA;
		imageRectTransform.sizeDelta = new Vector2(length, 8f);
		imageRectTransform.pivot = new Vector2(0f, 0.5f);
		float z = Mathf.Atan2(vector.y, vector.x) * 57.29578f;
		imageRectTransform.localRotation = Quaternion.Euler(0f, 0f, z);
		img.color = TranslateColor(color);
		img.enabled = true;
	}

	public void Hide()
	{
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		img.enabled = false;
	}

	public Color TranslateColor(TileColor color)
	{
		Color result = Color.white;
		switch (color)
		{
		case TileColor.None:
			result = Color.white;
			break;
		case TileColor.Red:
			result = Color.red;
			break;
		case TileColor.Green:
			result = Color.green;
			break;
		case TileColor.Blue:
			result = new Color(0f, 0.25f, 1f);
			break;
		}
		return result;
	}
}



public class PuzzlePanel : MonoBehaviour
{
	[HideInInspector]
	public TileType tileType;

	[HideInInspector]
	public TileColor tileColor;

	[HideInInspector]
	public GameObject currentPanel;

	[HideInInspector]
	public GameObject whiteSquare;

	[HideInInspector]
	public GameObject blackSquare;

	[HideInInspector]
	public GameObject fillSquare;

	public GameObject pitSquare;

	private Image img;

	private bool activated;

	private PuzzleController pc;

	[HideInInspector]
	public PuzzleLine pl;

	private ControllerPointer pointer;

	private void Start()
	{
		img = GetComponent<Image>();
		pc = GetComponentInParent<PuzzleController>();
		pl = base.transform.GetChild(0).GetComponent<PuzzleLine>();
		if (pl != null)
		{
			pl.transform.SetParent(base.transform.parent, worldPositionStays: true);
		}
		if (!TryGetComponent<ControllerPointer>(out pointer))
		{
			pointer = base.gameObject.AddComponent<ControllerPointer>();
		}
		pointer.OnEnter.AddListener(delegate
		{
			pc.Hovered(this);
		});
		pointer.OnPressed.AddListener(delegate
		{
			pc.Clicked(this);
		});
		pointer.OnReleased.AddListener(pc.Unclicked);
	}

	public void Activate(TileColor color)
	{
		if (tileType == TileType.WhiteEnd)
		{
			base.transform.GetChild(0).GetComponent<Image>().fillCenter = true;
		}
		activated = true;
		Color color2 = pl.TranslateColor(color);
		img.color = new Color(color2.r, color2.g, color2.b, 0.85f);
	}

	public void DeActivate()
	{
		if (tileType == TileType.WhiteEnd)
		{
			base.transform.GetChild(0).GetComponent<Image>().fillCenter = false;
		}
		activated = false;
		img.color = new Color(1f, 1f, 1f, 0.5f);
	}
}



public class RaceRingTracker : MonoBehaviour
{
	public int raceRingAmount;

	private int currentRaceRings;

	private bool complete;

	private float time;

	private HudMessage hm;

	public UltrakillEvent onVictory;

	public bool infiniteRocketRide;

	private void Start()
	{
		hm = base.gameObject.AddComponent<HudMessage>();
		hm.timed = true;
		hm.message = "RACE START";
		if (infiniteRocketRide)
		{
			MonoSingleton<WeaponCharges>.Instance.infiniteRocketRide = true;
		}
	}

	private void Update()
	{
		if (!complete)
		{
			time += Time.deltaTime;
		}
	}

	public void AddScore()
	{
		currentRaceRings++;
		if (!complete && currentRaceRings == raceRingAmount)
		{
			Victory();
		}
	}

	public void Victory()
	{
		complete = true;
		hm = base.gameObject.AddComponent<HudMessage>();
		hm.timed = true;
		hm.message = "TIME: <color=#00ff00ff>" + time.ToString("F3") + "</color>";
		if (infiniteRocketRide)
		{
			MonoSingleton<WeaponCharges>.Instance.infiniteRocketRide = false;
		}
		onVictory?.Invoke();
	}
}



public class Radio : MonoBehaviour
{
	public AudioClip[] songs;

	private AudioSource aud;

	private int currentSong;

	public bool dontStartFromMiddle;

	public bool randomizeOrder;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if (randomizeOrder)
		{
			for (int num = songs.Length - 1; num >= 0; num--)
			{
				int num2 = Random.Range(0, songs.Length);
				AudioClip audioClip = songs[num];
				songs[num] = songs[num2];
				songs[num2] = audioClip;
			}
		}
		currentSong = Random.Range(0, songs.Length);
		aud.clip = songs[currentSong];
		aud.Play();
		if (!dontStartFromMiddle)
		{
			aud.time = Random.Range(0f, aud.clip.length);
		}
	}

	private void Update()
	{
		if (aud.time >= aud.clip.length - 0.01f || !aud.isPlaying)
		{
			NextSong();
		}
	}

	public void NextSong()
	{
		currentSong++;
		if (currentSong >= songs.Length)
		{
			currentSong = 0;
		}
		aud.clip = songs[currentSong];
		aud.time = 0f;
		aud.Play();
	}
}



public class Railcannon : MonoBehaviour
{
	public int variation;

	public GameObject beam;

	public Transform shootPoint;

	public GameObject fullCharge;

	public GameObject fireSound;

	private AudioSource fullAud;

	private bool pitchRise;

	private InputManager inman;

	public WeaponIdentifier wid;

	private float gotWidDelay;

	private AudioSource aud;

	private CameraController cc;

	private Camera cam;

	private GunControl gc;

	private Animator anim;

	private SkinnedMeshRenderer smr;

	private WeaponCharges wc;

	private WeaponPos wpos;

	private bool zooming;

	private bool gotStuff;

	private CameraFrustumTargeter targeter;

	private float altCharge;

	[SerializeField]
	private Light fullChargeLight;

	[SerializeField]
	private ParticleSystem fullChargeParticles;

	private void Awake()
	{
		if (!gotStuff)
		{
			wid = GetComponent<WeaponIdentifier>();
		}
	}

	private void Start()
	{
		if (!gotStuff)
		{
			gotStuff = true;
			GetStuff();
		}
	}

	private void OnEnable()
	{
		if (!gotStuff)
		{
			gotStuff = true;
			GetStuff();
		}
		if (wc.raicharge != 5f)
		{
			fullCharge.SetActive(value: false);
			base.transform.localPosition = wpos.currentDefault;
		}
		else if (variation == 2)
		{
			if (fullAud == null)
			{
				fullAud = fullCharge.GetComponent<AudioSource>();
			}
			pitchRise = true;
			fullAud.pitch = 0f;
		}
	}

	private void OnDisable()
	{
		if (wc == null)
		{
			wc = GetComponentInParent<WeaponCharges>();
		}
		if (wpos != null)
		{
			base.transform.localPosition = wpos.currentDefault;
		}
		if (zooming)
		{
			zooming = false;
			cc.StopZoom();
		}
	}

	private void Update()
	{
		if (wid.delay > 0f && altCharge < wc.raicharge)
		{
			altCharge = wc.raicharge;
		}
		float raicharge = wc.raicharge;
		if (wid.delay > 0f)
		{
			raicharge = altCharge;
		}
		if (raicharge < 5f && !NoWeaponCooldown.NoCooldown)
		{
			smr.material.SetFloat("_EmissiveIntensity", raicharge / 5f);
		}
		else
		{
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.RailcannonIdle, fullCharge);
			if (!fullCharge.activeSelf)
			{
				fullCharge.SetActive(value: true);
				if (variation == 2)
				{
					pitchRise = true;
					fullAud.pitch = 0f;
				}
			}
			if (!wc.railChargePlayed)
			{
				wc.PlayRailCharge();
			}
			base.transform.localPosition = new Vector3(wpos.currentDefault.x + Random.Range(-0.005f, 0.005f), wpos.currentDefault.y + Random.Range(-0.005f, 0.005f), wpos.currentDefault.z + Random.Range(-0.005f, 0.005f));
			smr.material.SetFloat("_EmissiveIntensity", 1f);
			Color color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation];
			fullChargeLight.color = color;
			ParticleSystem.MainModule main = fullChargeParticles.main;
			main.startColor = color;
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
			{
				fullCharge.SetActive(value: false);
				base.transform.localPosition = wpos.currentDefault;
				wc.raicharge = 0f;
				wc.railChargePlayed = false;
				altCharge = 0f;
				if (!wid || wid.delay == 0f)
				{
					Shoot();
				}
				else
				{
					Invoke("Shoot", wid.delay);
				}
			}
		}
		if (!wid || wid.delay == 0f)
		{
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
			{
				zooming = true;
				cc.Zoom(cc.defaultFov / 2f);
			}
			else if (zooming)
			{
				zooming = false;
				cc.StopZoom();
			}
		}
		if (wid.delay != gotWidDelay)
		{
			gotWidDelay = wid.delay;
			if ((bool)wid && wid.delay != 0f)
			{
				fullAud.volume -= wid.delay * 2f;
				if (fullAud.volume < 0f)
				{
					fullAud.volume = 0f;
				}
			}
		}
		if (pitchRise)
		{
			fullAud.pitch = Mathf.MoveTowards(fullAud.pitch, 2f, Time.deltaTime * 4f);
			if (fullAud.pitch == 2f)
			{
				pitchRise = false;
			}
		}
		smr.material.SetFloat("_EmissivePosition", wc.raicharge);
		smr.material.SetColor("_EmissiveColor", MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation]);
	}

	private void Shoot()
	{
		GameObject gameObject = Object.Instantiate(beam, cc.GetDefaultPos(), cc.transform.rotation);
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		if (variation != 1)
		{
			if (gameObject.TryGetComponent<RevolverBeam>(out var component))
			{
				component.sourceWeapon = gc.currentWeapon;
				component.alternateStartPoint = shootPoint.position;
			}
		}
		else
		{
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 250f, ForceMode.VelocityChange);
			if (gameObject.TryGetComponent<Harpoon>(out var component2))
			{
				component2.sourceWeapon = base.gameObject;
			}
		}
		Object.Instantiate(fireSound);
		anim.SetTrigger("Shoot");
		cc.CameraShake(2f);
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.GunFireStrong);
	}

	private void GetStuff()
	{
		targeter = Camera.main.GetComponent<CameraFrustumTargeter>();
		inman = MonoSingleton<InputManager>.Instance;
		wid = GetComponent<WeaponIdentifier>();
		aud = GetComponent<AudioSource>();
		cc = MonoSingleton<CameraController>.Instance;
		cam = cc.GetComponent<Camera>();
		smr = GetComponentInChildren<SkinnedMeshRenderer>();
		gc = GetComponentInParent<GunControl>();
		anim = GetComponentInChildren<Animator>();
		wpos = GetComponent<WeaponPos>();
		fullAud = fullCharge.GetComponent<AudioSource>();
		wc = MonoSingleton<WeaponCharges>.Instance;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class RailcannonMeter : MonoSingleton<RailcannonMeter>
{
	public Image meterBackground;

	public Image[] meters;

	private Image[] trueMeters;

	public Image colorlessMeter;

	private Image self;

	public GameObject[] altHudPanels;

	private float flashAmount;

	public GameObject miniVersion;

	private bool hasFlashed;

	private void Start()
	{
		CheckStatus();
	}

	private new void OnEnable()
	{
		CheckStatus();
	}

	private void Update()
	{
		if (self.enabled || miniVersion.activeSelf)
		{
			for (int i = 0; i < trueMeters.Length; i++)
			{
				if (self.enabled || i != 0)
				{
					trueMeters[i].enabled = true;
				}
				else
				{
					trueMeters[i].enabled = false;
				}
			}
			if (MonoSingleton<WeaponCharges>.Instance.raicharge > 4f)
			{
				if (!hasFlashed && Time.timeScale > 0f)
				{
					flashAmount = 1f;
				}
				hasFlashed = true;
				if (!MonoSingleton<ColorBlindSettings>.Instance)
				{
					return;
				}
				Color color = MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(HudColorType.railcannonFull);
				if (flashAmount > 0f)
				{
					color = Color.Lerp(color, Color.white, flashAmount);
					flashAmount = Mathf.MoveTowards(flashAmount, 0f, Time.deltaTime);
				}
				Image[] array = trueMeters;
				foreach (Image image in array)
				{
					image.fillAmount = 1f;
					if (image != colorlessMeter)
					{
						image.color = color;
					}
					else
					{
						image.color = Color.white;
					}
				}
			}
			else
			{
				flashAmount = 0f;
				hasFlashed = false;
				Image[] array = trueMeters;
				foreach (Image obj in array)
				{
					obj.color = MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(HudColorType.railcannonCharging);
					obj.fillAmount = MonoSingleton<WeaponCharges>.Instance.raicharge / 4f;
				}
			}
			if (MonoSingleton<WeaponCharges>.Instance.raicharge > 4f || !self.enabled)
			{
				meterBackground.enabled = false;
			}
			else
			{
				meterBackground.enabled = true;
			}
		}
		else
		{
			flashAmount = 0f;
			meterBackground.enabled = false;
			hasFlashed = false;
			Image[] array = trueMeters;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].enabled = false;
			}
		}
	}

	public void CheckStatus()
	{
		if (trueMeters == null || trueMeters.Length == 0)
		{
			trueMeters = new Image[meters.Length + 1];
			for (int i = 0; i < trueMeters.Length; i++)
			{
				if (i < meters.Length)
				{
					trueMeters[i] = meters[i];
				}
				else
				{
					trueMeters[i] = colorlessMeter;
				}
			}
		}
		if (!self)
		{
			self = GetComponent<Image>();
		}
		if (!MonoSingleton<HUDOptions>.Instance || !MonoSingleton<HUDOptions>.Instance.railcannonMeter)
		{
			return;
		}
		if (MonoSingleton<HUDOptions>.Instance.railcannonMeter.isOn && RailcannonStatus())
		{
			if (MonoSingleton<HUDOptions>.Instance.weaponIcon.isOn)
			{
				self.enabled = true;
				miniVersion.SetActive(value: false);
			}
			else
			{
				self.enabled = false;
				miniVersion.SetActive(value: true);
			}
			GameObject[] array = altHudPanels;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: true);
			}
		}
		else
		{
			self.enabled = false;
			miniVersion.SetActive(value: false);
			GameObject[] array = altHudPanels;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(value: false);
			}
		}
	}

	private bool RailcannonStatus()
	{
		for (int i = 0; i < 4; i++)
		{
			string text = "rai" + i;
			if (GameProgressSaver.CheckGear(text) == 1 && MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + text, 1) == 1 && !MonoSingleton<GunControl>.Instance.noWeapons)
			{
				return true;
			}
		}
		return false;
	}
}



public class RailCannonPip : MonoBehaviour
{
	private Vector3 origPos;

	private Vector3 targetPos;

	private Vector3 tempPos;

	public Vector3 pushAmount;

	public float chargeLevel;

	private Railcannon rc;

	private Quaternion origRot;

	private Quaternion tempRot;

	private AudioSource[] auds;

	private bool playIdle;

	private bool playClick;

	private void Start()
	{
		rc = GetComponentInParent<Railcannon>();
		auds = GetComponents<AudioSource>();
		origPos = base.transform.localPosition;
		tempPos = origPos;
		targetPos = origPos + pushAmount;
		origRot = base.transform.localRotation;
		tempRot = origRot;
		if (auds != null && (bool)rc.wid && rc.wid.delay != 0f)
		{
			AudioSource[] array = auds;
			foreach (AudioSource audioSource in array)
			{
				audioSource.volume -= rc.wid.delay * 2f;
				if (audioSource.volume < 0f)
				{
					audioSource.volume = 0f;
				}
			}
		}
		CheckSounds();
	}

	private void OnEnable()
	{
		CheckSounds();
	}

	private void LateUpdate()
	{
		if (MonoSingleton<WeaponCharges>.Instance.raicharge >= chargeLevel)
		{
			base.transform.localPosition = tempPos;
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, origPos, Vector3.Distance(base.transform.localPosition, origPos) * 50f * Time.deltaTime);
			tempPos = base.transform.localPosition;
			base.transform.localRotation = tempRot;
			base.transform.Rotate(Vector3.up, Time.deltaTime * -2400f, Space.Self);
			tempRot = base.transform.localRotation;
			if (!playClick && !playIdle)
			{
				return;
			}
			if (auds != null)
			{
				AudioSource[] array = auds;
				foreach (AudioSource audioSource in array)
				{
					if ((audioSource.loop && playIdle) || (!audioSource.loop && playClick))
					{
						audioSource.Play();
					}
				}
			}
			playClick = false;
			playIdle = false;
			return;
		}
		base.transform.localPosition = tempPos;
		base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Vector3.Distance(base.transform.localPosition, targetPos) * 50f * Time.deltaTime);
		tempPos = base.transform.localPosition;
		base.transform.localRotation = origRot;
		tempRot = origRot;
		if (playClick && playIdle)
		{
			return;
		}
		playClick = true;
		playIdle = true;
		if (auds != null)
		{
			AudioSource[] array = auds;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Stop();
			}
		}
	}

	private void CheckSounds()
	{
		if (rc == null)
		{
			rc = GetComponentInParent<Railcannon>();
		}
		if (auds == null)
		{
			auds = GetComponents<AudioSource>();
		}
		if (MonoSingleton<WeaponCharges>.Instance.raicharge > chargeLevel)
		{
			playClick = false;
		}
		else
		{
			playClick = true;
		}
		playIdle = true;
	}
}



public class RandomBase<T> : MonoBehaviour where T : RandomEntry, new()
{
	public bool randomizeOnEnable = true;

	public int toBeEnabledCount = 1;

	public T[] entries;

	private bool firstDeserialization = true;

	private int arrayLength;

	private void OnEnable()
	{
		if (randomizeOnEnable)
		{
			Randomize();
		}
	}

	public virtual void Randomize()
	{
		RandomizeWithCount(toBeEnabledCount);
	}

	private List<SimulatedRandomEntry> RebuildVirtualPool(T[] pool)
	{
		int num = 0;
		List<SimulatedRandomEntry> list = new List<SimulatedRandomEntry>();
		foreach (T val in pool)
		{
			SimulatedRandomEntry simulatedRandomEntry = new SimulatedRandomEntry
			{
				firstIndex = num,
				target = val
			};
			num = (simulatedRandomEntry.lastIndex = num + val.weight);
			list.Add(simulatedRandomEntry);
		}
		return list;
	}

	public virtual void RandomizeWithCount(int count)
	{
		List<T> list = new List<T>();
		list.AddRange(entries);
		List<SimulatedRandomEntry> list2 = RebuildVirtualPool(list.ToArray());
		for (int i = 0; i < count; i++)
		{
			if (list2.Count <= 0)
			{
				break;
			}
			int num = Random.Range(0, list2.Last().lastIndex);
			RandomEntry entry = null;
			int index = -1;
			for (int j = 0; j < list2.Count; j++)
			{
				SimulatedRandomEntry simulatedRandomEntry = list2[j];
				if (simulatedRandomEntry.firstIndex <= num && simulatedRandomEntry.lastIndex > num)
				{
					entry = simulatedRandomEntry.target;
					index = j;
					break;
				}
			}
			PerformTheAction(entry);
			list2.RemoveAt(index);
			list.RemoveAt(index);
			list2 = RebuildVirtualPool(list.ToArray());
		}
	}

	public virtual void PerformTheAction(RandomEntry entry)
	{
	}

	private void OnValidate()
	{
		if (firstDeserialization)
		{
			arrayLength = entries.Length;
			firstDeserialization = false;
		}
		else
		{
			if (entries.Length == arrayLength)
			{
				return;
			}
			if (entries.Length > arrayLength)
			{
				for (int i = arrayLength; i < entries.Length; i++)
				{
					entries[i] = new T();
				}
			}
			arrayLength = entries.Length;
		}
	}
}



[Serializable]
public class RandomEntry
{
	[Min(0f)]
	[Tooltip("The bigger the weight, the bigger the chance.")]
	public int weight = 1;
}



public class RandomForce : MonoBehaviour
{
	public float force;

	public bool onEnable = true;

	public bool oneTime = true;

	private bool applied;

	private void OnEnable()
	{
		if (onEnable && (!oneTime || !applied))
		{
			ApplyForce(force);
		}
	}

	public void ApplyForce()
	{
		ApplyForce(force);
	}

	public void ApplyForce(float tempForce)
	{
		applied = true;
		GetComponent<Rigidbody>().AddForce(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tempForce, ForceMode.VelocityChange);
	}
}



[Serializable]
public class RandomGameObjectEntry : RandomEntry
{
	public GameObject targetObject;
}



public class RandomInstantiate : RandomBase<RandomGameObjectEntry>
{
	public bool removePreviousOnRandomize = true;

	[SerializeField]
	private InstantiateObjectMode mode;

	public bool reParent = true;

	public bool useOwnPosition = true;

	public bool useOwnRotation = true;

	private List<GameObject> createdObjects = new List<GameObject>();

	public override void PerformTheAction(RandomEntry entry)
	{
		GameObject gameObject = Object.Instantiate(((RandomGameObjectEntry)entry).targetObject);
		if (useOwnPosition)
		{
			gameObject.transform.position = base.transform.position;
		}
		if (useOwnRotation)
		{
			gameObject.transform.rotation = base.transform.rotation;
		}
		if (reParent)
		{
			gameObject.transform.SetParent(base.transform);
			if (useOwnPosition)
			{
				gameObject.transform.localPosition = Vector3.zero;
			}
			if (useOwnRotation)
			{
				gameObject.transform.localRotation = Quaternion.identity;
			}
		}
		createdObjects.Add(gameObject);
		switch (mode)
		{
		case InstantiateObjectMode.ForceDisable:
			gameObject.SetActive(value: false);
			break;
		case InstantiateObjectMode.ForceEnable:
			gameObject.SetActive(value: true);
			break;
		}
	}

	public override void RandomizeWithCount(int count)
	{
		if (removePreviousOnRandomize)
		{
			foreach (GameObject createdObject in createdObjects)
			{
				Object.Destroy(createdObject);
			}
			createdObjects.Clear();
		}
		base.RandomizeWithCount(count);
	}
}



public class RandomizeWind : MonoBehaviour
{
	public Vector3 randomizeDirectionStrength = Vector3.one;

	private float initialStrength;

	private Vector3 initialDirection;

	private JiggleRigBuilder rig;

	private float waitTime;

	private float elapsedTime;

	private void Start()
	{
		rig = GetComponent<JiggleRigBuilder>();
		initialDirection = rig.wind.normalized;
		initialStrength = rig.wind.magnitude;
	}

	private void Update()
	{
		elapsedTime += Time.deltaTime;
		if (elapsedTime >= waitTime)
		{
			Randomize();
		}
	}

	private void Randomize()
	{
		elapsedTime = 0f;
		waitTime = Random.Range(1f, 5f);
		Vector3 normalized = (Random.rotation.eulerAngles - new Vector3(180f, 180f, 180f)).normalized;
		MonoBehaviour.print(normalized);
		normalized = initialDirection + Vector3.Scale(normalized, randomizeDirectionStrength) * initialStrength;
		rig.wind = normalized;
	}
}



public class RandomPitch : MonoBehaviour
{
	public float defaultPitch = 1f;

	public float pitchVariation = 0.1f;

	public bool oneTime = true;

	public bool playOnEnable = true;

	public bool nailgunOverheatFix;

	private bool beenPlayed;

	public AudioSource aud;

	private void Start()
	{
		if (nailgunOverheatFix)
		{
			Activate();
		}
	}

	private void OnEnable()
	{
		if (!nailgunOverheatFix)
		{
			Activate();
		}
	}

	private void Activate()
	{
		if (oneTime && beenPlayed)
		{
			return;
		}
		beenPlayed = true;
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
		}
		if (aud != null)
		{
			if (pitchVariation == 0f)
			{
				aud.pitch = Random.Range(0.8f, 1.2f);
			}
			else
			{
				aud.pitch = Random.Range(defaultPitch - pitchVariation, defaultPitch + pitchVariation);
			}
			if (playOnEnable)
			{
				aud.Play();
			}
		}
	}
}



public class RandomRotation : MonoBehaviour
{
	public Material[] materials;

	private MeshRenderer mr;

	private void Awake()
	{
		if (materials.Length != 0)
		{
			mr = GetComponent<MeshRenderer>();
			mr.material = materials[Random.Range(0, materials.Length - 1)];
		}
		base.transform.Rotate(Vector3.forward * Random.Range(0, 359), Space.Self);
	}

	private void Update()
	{
	}
}


public class RandomSetActive : RandomBase<RandomGameObjectEntry>
{
	public bool resetStatesOnRandomize = true;

	public override void PerformTheAction(RandomEntry entry)
	{
		((RandomGameObjectEntry)entry)?.targetObject.SetActive(value: true);
	}

	public override void RandomizeWithCount(int count)
	{
		if (resetStatesOnRandomize)
		{
			RandomGameObjectEntry[] array = entries;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].targetObject.SetActive(value: false);
			}
		}
		base.RandomizeWithCount(count);
	}
}



public class RandomSoundPlayer : MonoBehaviour
{
	public AudioClip[] sounds;

	private AudioSource aud;

	private float volume;

	public bool playing;

	private float fade;

	private float targetPitch;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (playing && fade < volume - 0.1f)
		{
			fade += Time.deltaTime / 10f;
		}
		else if (playing && fade > volume + 0.1f)
		{
			fade -= Time.deltaTime / 10f;
		}
		else if (!playing && fade > 0f)
		{
			fade -= Time.deltaTime / 10f;
		}
		else if (!playing && fade < 0f)
		{
			fade = 0f;
		}
		aud.volume = fade;
		if (playing && aud.pitch > targetPitch + 0.1f)
		{
			aud.pitch -= Time.deltaTime / 10f;
		}
		else if (playing && aud.pitch < targetPitch - 0.1f)
		{
			aud.pitch += Time.deltaTime / 10f;
		}
	}

	public void RollForPlay()
	{
		if (Random.Range(0f, 1f) >= 0.5f && !playing)
		{
			PlayRandomSound();
		}
		else if (playing)
		{
			if (Random.Range(0f, 1f) >= 0.7f)
			{
				PlayRandomSound();
			}
			if (Random.Range(0f, 1f) >= 0.7f)
			{
				targetPitch = Random.Range(0.2f, 3f);
			}
			if (Random.Range(0f, 1f) >= 0.7f)
			{
				volume = Random.Range(0.1f, 0.7f);
			}
		}
	}

	private void PlayRandomSound()
	{
		if (!playing)
		{
			playing = true;
			aud.clip = sounds[Random.Range(0, sounds.Length)];
			volume = Random.Range(0.1f, 0.5f);
			aud.pitch = Random.Range(0.2f, 3f);
			targetPitch = aud.pitch;
			aud.Play();
		}
		else
		{
			playing = false;
		}
	}
}



public class RandomSpawnInsideCollider : MonoBehaviour
{
	public GameObject spawnedObject;

	private BoxCollider boxCollider;

	public float delay;

	private float cooldown;

	public bool oneTime;

	private bool activated;

	private void Start()
	{
		boxCollider = GetComponent<BoxCollider>();
	}

	private void Update()
	{
		cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		if (cooldown <= 0f)
		{
			Spawn();
		}
	}

	private void Spawn()
	{
		if (activated)
		{
			if (oneTime)
			{
				base.enabled = false;
				return;
			}
		}
		else
		{
			activated = true;
		}
		Vector3 vector = boxCollider.size / 2f;
		Vector3 position = new Vector3(Random.Range(0f - vector.x, vector.x), Random.Range(0f - vector.y, vector.y), Random.Range(0f - vector.z, vector.z)) + boxCollider.center;
		Object.Instantiate(spawnedObject, boxCollider.transform.TransformPoint(position), Random.rotation);
		cooldown = delay;
		if (oneTime)
		{
			base.enabled = false;
		}
	}
}



public class RandomTextString : MonoBehaviour
{
	[SerializeField]
	private string[] strings;

	private void Start()
	{
		Text component = GetComponent<Text>();
		if ((bool)component)
		{
			component.text = strings[Random.Range(0, strings.Length)];
		}
	}
}



[Serializable]
public class RankData
{
	public int[] ranks;

	public int secretsAmount;

	public bool[] secretsFound;

	public bool challenge;

	public int levelNumber;

	public bool[] majorAssists;

	public RankScoreData[] stats;

	public RankData(StatsManager sman)
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		levelNumber = sman.levelNumber;
		RankData rank = GameProgressSaver.GetRank(returnNull: true);
		if (rank != null)
		{
			ranks = rank.ranks;
			if (rank.majorAssists != null)
			{
				majorAssists = rank.majorAssists;
			}
			else
			{
				majorAssists = new bool[6];
			}
			if (rank.stats != null)
			{
				stats = rank.stats;
			}
			else
			{
				stats = new RankScoreData[6];
			}
			if ((sman.rankScore >= rank.ranks[@int] && (rank.majorAssists == null || (!sman.majorUsed && rank.majorAssists[@int]))) || sman.rankScore > rank.ranks[@int] || rank.levelNumber != levelNumber)
			{
				majorAssists[@int] = sman.majorUsed;
				ranks[@int] = sman.rankScore;
				if (stats[@int] == null)
				{
					stats[@int] = new RankScoreData();
				}
				stats[@int].kills = sman.kills;
				stats[@int].style = sman.stylePoints;
				stats[@int].time = sman.seconds;
			}
			secretsAmount = sman.secretObjects.Length;
			secretsFound = new bool[secretsAmount];
			for (int i = 0; i < secretsAmount && i < rank.secretsFound.Length; i++)
			{
				if (sman.secretObjects[i] == null || rank.secretsFound[i])
				{
					secretsFound[i] = true;
				}
			}
			challenge = rank.challenge;
			return;
		}
		ranks = new int[6];
		stats = new RankScoreData[6];
		if (stats[@int] == null)
		{
			stats[@int] = new RankScoreData();
		}
		majorAssists = new bool[6];
		for (int j = 0; j < ranks.Length; j++)
		{
			ranks[j] = -1;
		}
		ranks[@int] = sman.rankScore;
		majorAssists[@int] = sman.majorUsed;
		stats[@int].kills = sman.kills;
		stats[@int].style = sman.stylePoints;
		stats[@int].time = sman.seconds;
		secretsAmount = sman.secretObjects.Length;
		secretsFound = new bool[secretsAmount];
		for (int k = 0; k < secretsAmount; k++)
		{
			if (sman.secretObjects[k] == null)
			{
				secretsFound[k] = true;
			}
		}
	}
}



public static class RankHelper
{
	public static string GetRankLetter(int rank)
	{
		if (rank < 0)
		{
			return "";
		}
		switch (rank)
		{
		case 12:
			return "P";
		case 1:
			return "C";
		case 2:
			return "B";
		case 3:
			return "A";
		case 4:
		case 5:
		case 6:
			return "S";
		default:
			return "D";
		}
	}

	public static Color GetRankBackgroundColor(int rank)
	{
		if (rank != 12)
		{
			return Color.white;
		}
		return new Color(1f, 0.686f, 0f, 1f);
	}

	public static string GetRankForegroundColor(int rank)
	{
		if (rank >= 0)
		{
			switch (rank)
			{
			case 12:
				break;
			case 1:
				return "#4CFF00";
			case 2:
				return "#FFD800";
			case 3:
				return "#FF6A00";
			case 4:
			case 5:
			case 6:
				return "#FF0000";
			default:
				return "#0094FF";
			}
		}
		return "#FFFFFF";
	}
}



public class RankIcon : MonoBehaviour
{
	[SerializeField]
	private bool useDefaultRank;

	[SerializeField]
	[Range(0f, 12f)]
	private int defaultRank;

	[SerializeField]
	private TMP_Text mainRankLetter;

	[SerializeField]
	private Image mainRankBackground;

	private void Start()
	{
		if (useDefaultRank)
		{
			SetRank(defaultRank);
		}
	}

	public void SetRank(int rank)
	{
		base.gameObject.SetActive(value: true);
		mainRankLetter.text = "<color=" + RankHelper.GetRankForegroundColor(rank) + ">" + RankHelper.GetRankLetter(rank) + "</color>";
		mainRankBackground.fillCenter = rank == 12;
		mainRankBackground.color = RankHelper.GetRankBackgroundColor(rank);
	}

	public void SetEmpty()
	{
		base.gameObject.SetActive(value: true);
		mainRankLetter.text = string.Empty;
		mainRankBackground.fillCenter = false;
		mainRankBackground.color = Color.white;
	}
}



[Serializable]
public class RankScoreData
{
	public float time;

	public int kills;

	public int style;
}



public class RaycastHelper
{
	private const float Duration = 15f;

	public static bool RaycastAndDebugDraw(Vector3 origin, Vector3 direction, float maxDistance, int layerMask)
	{
		RaycastHit hitInfo;
		bool flag = Physics.Raycast(origin, direction, out hitInfo, maxDistance, layerMask);
		if (Application.isEditor)
		{
			if (flag)
			{
				Debug.DrawRay(origin, direction.normalized * hitInfo.distance, Color.green, 15f);
				Debug.DrawRay(origin + direction.normalized * hitInfo.distance, direction.normalized * (maxDistance - hitInfo.distance), Color.red, 15f);
			}
			else
			{
				Debug.DrawRay(origin, direction.normalized * maxDistance, Color.green, 15f);
			}
		}
		return flag;
	}
}



public class Readable : MonoBehaviour
{
	[SerializeField]
	[TextArea(3, 12)]
	private string content;

	[SerializeField]
	private bool instantScan;

	private bool pickedUp;

	private int gameObjectInstanceId;

	private void Awake()
	{
		gameObjectInstanceId = base.gameObject.GetInstanceID();
	}

	public void PickUp()
	{
		pickedUp = true;
		MonoSingleton<ScanningStuff>.Instance.oldWeaponState = !MonoSingleton<GunControl>.Instance.noWeapons;
		Invoke("StartScan", 0.5f);
	}

	public void PutDown()
	{
		pickedUp = false;
		CancelInvoke("StartScan");
		MonoSingleton<ScanningStuff>.Instance.ResetState();
	}

	private void StartScan()
	{
		MonoSingleton<ScanningStuff>.Instance.ScanBook(content, instantScan, base.gameObject.GetInstanceID());
	}

	private void OnDestroy()
	{
		if ((bool)MonoSingleton<ScanningStuff>.Instance)
		{
			MonoSingleton<ScanningStuff>.Instance.ReleaseScroll(gameObjectInstanceId);
		}
	}
}



public sealed class RefCountedEvent : MonoBehaviour
{
	private int m_RefCount;

	[SerializeField]
	private UnityEvent m_Activate;

	[SerializeField]
	private UnityEvent m_Deactivate;

	public void AddRef()
	{
		if (m_RefCount == 0)
		{
			m_Activate?.Invoke();
		}
		m_RefCount++;
	}

	public void Release()
	{
		if (m_RefCount == 0)
		{
			throw new InvalidOperationException();
		}
		if (m_RefCount == 1)
		{
			m_Deactivate?.Invoke();
		}
		m_RefCount--;
	}
}



public class RemoveOnImpact : MonoBehaviour
{
	public string otherTag;

	public float timeUntilRemove;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag(otherTag))
		{
			Invoke("RemoveSelf", timeUntilRemove);
		}
	}

	private void RemoveSelf()
	{
		Object.Destroy(base.gameObject);
	}
}



public class RemoveOnParentScale : MonoBehaviour
{
	private void Update()
	{
		if (base.transform.parent.localScale == Vector3.zero)
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class RemoveOnTime : MonoBehaviour
{
	public bool useAudioLength;

	public float time;

	public float randomizer;

	public bool affectedByNoCooldowns;

	private void Start()
	{
		if (useAudioLength)
		{
			AudioSource component = GetComponent<AudioSource>();
			if (!component)
			{
				Debug.LogError("useAudioLength is enabled, but an AudioSource was not found");
				Object.Destroy(this);
			}
			else if (!component.clip)
			{
				Debug.LogError("useAudioLength is enabled without a clip");
				Object.Destroy(this);
			}
			else
			{
				Invoke("Remove", component.clip.length * component.pitch);
			}
		}
		else
		{
			Invoke("Remove", time + Random.Range(0f - randomizer, randomizer));
		}
	}

	private void Remove()
	{
		if (affectedByNoCooldowns && NoWeaponCooldown.NoCooldown)
		{
			Invoke("Remove", time / 2f + Random.Range(0f - randomizer, randomizer));
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class RenderCubemap : MonoBehaviour
{
	public bool manualRender;

	public Camera cam;

	public Cubemap cubemap;

	private void Update()
	{
		if (manualRender)
		{
			manualRender = false;
			if (cam != null && cubemap != null)
			{
				cam.RenderToCubemap(cubemap);
			}
			else
			{
				Debug.LogError("Camera and/or Cubemap not assigned.");
			}
		}
	}
}



public class ResetPosition : MonoBehaviour
{
	[HideInInspector]
	public bool valueSet;

	[HideInInspector]
	public Vector3 originalPosition;

	[HideInInspector]
	public Quaternion originalRotation;

	private void Awake()
	{
		if (!valueSet)
		{
			valueSet = true;
			ChangeOriginalPositionAndRotation();
		}
	}

	public void Activate()
	{
		Debug.Log("Activating");
		base.transform.localPosition = originalPosition;
		base.transform.localRotation = originalRotation;
	}

	public void ChangeOriginalPositionAndRotation()
	{
		ChangeOriginalPosition(base.transform.localPosition);
		ChangeOriginalRotation(base.transform.localRotation);
	}

	public void ChangeOriginalPosition(Vector3 target)
	{
		originalPosition = target;
	}

	public void ChangeOriginalRotation(Quaternion target)
	{
		originalRotation = target;
	}

	public void ChangeOriginalRotation(Vector3 target)
	{
		ChangeOriginalRotation(Quaternion.Euler(target));
	}
}



public sealed class RestrictedSerializationBinder : SerializationBinder
{
	public HashSet<Type> AllowedTypes { get; } = new HashSet<Type>();


	public override Type BindToType(string assemblyName, string typeName)
	{
		string text = Assembly.CreateQualifiedName(assemblyName, typeName);
		foreach (Type allowedType in AllowedTypes)
		{
			if (allowedType.AssemblyQualifiedName == text)
			{
				return allowedType;
			}
		}
		throw new SerializationException("Attempted to serialize restricted type: " + text);
	}
}



public class Revolver : MonoBehaviour
{
	private InputManager inman;

	private WeaponIdentifier wid;

	public int gunVariation;

	public bool altVersion;

	private AudioSource gunAud;

	public AudioClip[] gunShots;

	private int currentGunShot;

	public GameObject gunBarrel;

	private bool gunReady;

	private bool shootReady = true;

	private bool pierceReady = true;

	public float shootCharge;

	public float pierceCharge;

	private bool chargingPierce;

	public float pierceShotCharge;

	public Vector3 shotHitPoint;

	public GameObject revolverBeam;

	public GameObject revolverBeamSuper;

	public AudioSource superGunSound;

	public RaycastHit hit;

	public RaycastHit[] allHits;

	private int currentHit;

	private int currentHitMultiplier;

	public float recoilFOV;

	public GameObject chargeEffect;

	private AudioSource ceaud;

	private Light celight;

	private GameObject camObj;

	private Camera cam;

	private CameraController cc;

	private Vector3 tempCamPos;

	public Vector3 beamReflectPos;

	private GameObject beamDirectionSetter;

	public MeshRenderer screenMR;

	private MaterialPropertyBlock screenProps;

	public Material batteryMat;

	public Texture2D batteryFull;

	public Texture2D batteryMid;

	public Texture2D batteryLow;

	public Texture2D[] batteryCharges;

	private AudioSource screenAud;

	public AudioClip chargedSound;

	public AudioClip chargingSound;

	public Transform twirlBone;

	private float latestTwirlRotation;

	private float twirlLevel;

	public bool twirlRecovery;

	public SpriteRenderer twirlSprite;

	public GameObject twirlShotSound;

	private GameObject currentDrip;

	public GameObject coin;

	public GameObject quickTwirlEffect;

	[HideInInspector]
	public RevolverCylinder cylinder;

	private SwitchMaterial rimLight;

	public GunControl gc;

	private Animator anim;

	private Punch punch;

	private NewMovement nmov;

	private WeaponPos wpos;

	public Image[] coinPanels;

	public bool[] coinPanelsCharged;

	private WeaponCharges wc;

	private CameraFrustumTargeter targeter;

	private float coinCharge = 400f;

	private void Start()
	{
		targeter = MonoSingleton<CameraFrustumTargeter>.Instance;
		inman = MonoSingleton<InputManager>.Instance;
		wid = GetComponent<WeaponIdentifier>();
		gunReady = false;
		cam = MonoSingleton<CameraController>.Instance.GetComponent<Camera>();
		camObj = cam.gameObject;
		cc = MonoSingleton<CameraController>.Instance;
		nmov = MonoSingleton<NewMovement>.Instance;
		shootCharge = 0f;
		pierceShotCharge = 0f;
		pierceCharge = 100f;
		pierceReady = false;
		gunAud = GetComponent<AudioSource>();
		if (gunVariation == 0)
		{
			screenAud = screenMR.gameObject.GetComponent<AudioSource>();
		}
		else
		{
			screenAud = GetComponentInChildren<Canvas>().GetComponent<AudioSource>();
		}
		if ((bool)chargeEffect)
		{
			ceaud = chargeEffect.GetComponent<AudioSource>();
			celight = chargeEffect.GetComponent<Light>();
		}
		if (gunVariation == 0)
		{
			screenAud.clip = chargingSound;
			screenAud.loop = true;
			screenAud.pitch = 1f;
			screenAud.volume = 0.25f;
			screenAud.Play();
		}
		cylinder = GetComponentInChildren<RevolverCylinder>();
		gc = GetComponentInParent<GunControl>();
		beamDirectionSetter = new GameObject();
		anim = GetComponentInChildren<Animator>();
		wc = MonoSingleton<WeaponCharges>.Instance;
		wpos = GetComponent<WeaponPos>();
		if (wid.delay != 0f && gunVariation == 0)
		{
			pierceCharge = wc.rev0charge;
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			if (wc == null)
			{
				wc = MonoSingleton<WeaponCharges>.Instance;
			}
			if (gunVariation == 0)
			{
				wc.rev0alt = altVersion;
				wc.rev0charge = pierceCharge;
			}
			pierceShotCharge = 0f;
			gunReady = false;
		}
	}

	private void OnEnable()
	{
		if (wc == null)
		{
			wc = MonoSingleton<WeaponCharges>.Instance;
		}
		shootCharge = 100f;
		if (gunVariation == 0)
		{
			pierceCharge = wc.rev0charge;
		}
		else
		{
			pierceCharge = 100f;
			pierceReady = true;
			CheckCoinCharges();
		}
		if (gunVariation == 2)
		{
			wc.rev2alt = altVersion;
		}
		if (altVersion)
		{
			if (!anim)
			{
				anim = GetComponentInChildren<Animator>();
			}
			if (wc.revaltpickupcharges[gunVariation] > 0f)
			{
				anim.SetBool("SlowPickup", value: true);
			}
			else
			{
				anim.SetBool("SlowPickup", value: false);
			}
		}
		if (screenProps == null)
		{
			screenProps = new MaterialPropertyBlock();
		}
		if ((bool)screenMR)
		{
			screenMR.GetPropertyBlock(screenProps);
		}
		gunReady = false;
	}

	private void Update()
	{
		if (!shootReady)
		{
			if (shootCharge + 200f * Time.deltaTime < 100f)
			{
				shootCharge += 200f * Time.deltaTime;
			}
			else
			{
				shootCharge = 100f;
				shootReady = true;
			}
		}
		if (!pierceReady)
		{
			if (gunVariation == 0)
			{
				if (NoWeaponCooldown.NoCooldown)
				{
					pierceCharge = 100f;
				}
				float num = 1f;
				if (altVersion)
				{
					num = 0.5f;
				}
				if (pierceCharge + 40f * Time.deltaTime < 100f)
				{
					pierceCharge += 40f * Time.deltaTime * num;
				}
				else
				{
					pierceCharge = 100f;
					pierceReady = true;
					screenAud.clip = chargedSound;
					screenAud.loop = false;
					screenAud.volume = 0.35f;
					screenAud.pitch = Random.Range(1f, 1.1f);
					screenAud.Play();
				}
				if (cylinder.spinSpeed > 0f)
				{
					cylinder.spinSpeed = Mathf.MoveTowards(cylinder.spinSpeed, 0f, Time.deltaTime * 50f);
				}
				if (pierceCharge < 50f)
				{
					screenProps.SetTexture("_MainTex", batteryLow);
					screenProps.SetColor("_Color", Color.red);
				}
				else if (pierceCharge < 100f)
				{
					screenProps.SetTexture("_MainTex", batteryMid);
					screenProps.SetColor("_Color", Color.yellow);
				}
				else
				{
					screenProps.SetTexture("_MainTex", batteryFull);
				}
			}
			else if (pierceCharge + 480f * Time.deltaTime < 100f)
			{
				pierceCharge += 480f * Time.deltaTime;
			}
			else
			{
				pierceCharge = 100f;
				pierceReady = true;
			}
		}
		else if (gunVariation == 0)
		{
			if (pierceShotCharge != 0f)
			{
				if (pierceShotCharge < 50f)
				{
					screenProps.SetTexture("_MainTex", batteryCharges[0]);
				}
				else if (pierceShotCharge < 100f)
				{
					screenProps.SetTexture("_MainTex", batteryCharges[1]);
				}
				else
				{
					screenProps.SetTexture("_MainTex", batteryCharges[2]);
				}
				base.transform.localPosition = new Vector3(wpos.currentDefault.x + pierceShotCharge / 250f * Random.Range(-0.05f, 0.05f), wpos.currentDefault.y + pierceShotCharge / 250f * Random.Range(-0.05f, 0.05f), wpos.currentDefault.z + pierceShotCharge / 250f * Random.Range(-0.05f, 0.05f));
				cylinder.spinSpeed = pierceShotCharge;
			}
			else
			{
				screenProps.SetTexture("_MainTex", batteryFull);
				if (cylinder.spinSpeed != 0f)
				{
					cylinder.spinSpeed = 0f;
				}
			}
		}
		if (gc.activated)
		{
			if (gunVariation != 1 && gunReady)
			{
				float num2 = ((gunVariation == 0) ? 175 : (altVersion ? 750 : 75));
				if ((inman.InputSource.Fire2.WasCanceledThisFrame || (!inman.PerformingCheatMenuCombo() && !GameStateManager.Instance.PlayerInputLocked && inman.InputSource.Fire1.IsPressed)) && shootReady && ((gunVariation == 0) ? (pierceShotCharge == 100f) : (pierceShotCharge >= 25f)))
				{
					if (!wid || wid.delay == 0f)
					{
						Shoot(2);
					}
					else
					{
						shootReady = false;
						shootCharge = 0f;
						Invoke("DelayedShoot2", wid.delay);
					}
				}
				else if (!inman.PerformingCheatMenuCombo() && inman.InputSource.Fire1.IsPressed && shootReady && !chargingPierce)
				{
					if (!wid || wid.delay == 0f)
					{
						Shoot();
					}
					else
					{
						shootReady = false;
						shootCharge = 0f;
						Invoke("DelayedShoot", wid.delay);
					}
				}
				else if (inman.InputSource.Fire2.IsPressed && (gunVariation == 2 || shootReady) && ((gunVariation == 0) ? pierceReady : (coinCharge >= (float)(altVersion ? 300 : 100))))
				{
					if (!chargingPierce && !twirlRecovery)
					{
						latestTwirlRotation = 0f;
					}
					chargingPierce = true;
					if (pierceShotCharge + num2 * Time.deltaTime < 100f)
					{
						pierceShotCharge += num2 * Time.deltaTime;
					}
					else
					{
						pierceShotCharge = 100f;
					}
				}
				else
				{
					if (chargingPierce)
					{
						twirlRecovery = true;
					}
					chargingPierce = false;
					if (pierceShotCharge - num2 * Time.deltaTime > 0f)
					{
						pierceShotCharge -= num2 * Time.deltaTime;
					}
					else
					{
						pierceShotCharge = 0f;
					}
				}
			}
			else if (gunVariation == 1)
			{
				if (inman.InputSource.Fire2.WasPerformedThisFrame && pierceReady && coinCharge >= 100f)
				{
					cc.StopShake();
					if (!wid || wid.delay == 0f)
					{
						wc.rev1charge -= 100f;
					}
					if (!wid || wid.delay == 0f)
					{
						ThrowCoin();
					}
					else
					{
						Invoke("ThrowCoin", wid.delay);
						pierceReady = false;
						pierceCharge = 0f;
					}
				}
				else if (gunReady && !inman.PerformingCheatMenuCombo() && inman.InputSource.Fire1.IsPressed && shootReady)
				{
					if (!wid || wid.delay == 0f)
					{
						Shoot();
					}
					else
					{
						shootReady = false;
						shootCharge = 0f;
						Invoke("DelayedShoot", wid.delay);
					}
					if ((bool)ceaud && ceaud.volume != 0f)
					{
						ceaud.volume = 0f;
					}
				}
			}
		}
		if ((bool)celight)
		{
			if (pierceShotCharge == 0f && celight.enabled)
			{
				celight.enabled = false;
			}
			else if (pierceShotCharge != 0f)
			{
				celight.enabled = true;
				celight.range = pierceShotCharge * 0.01f;
			}
		}
		if (gunVariation != 1)
		{
			if (gunVariation == 0)
			{
				chargeEffect.transform.localScale = Vector3.one * pierceShotCharge * 0.02f;
				ceaud.pitch = pierceShotCharge * 0.005f;
			}
			ceaud.volume = 0.25f + pierceShotCharge * 0.005f;
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.RevolverCharge, ceaud.gameObject).intensityMultiplier = pierceShotCharge / 250f;
		}
		if (gunVariation != 0)
		{
			CheckCoinCharges();
		}
		else if (pierceCharge == 100f && (bool)MonoSingleton<ColorBlindSettings>.Instance)
		{
			screenProps.SetColor("_Color", MonoSingleton<ColorBlindSettings>.Instance.variationColors[gunVariation]);
		}
		if (gunVariation == 0)
		{
			screenMR.SetPropertyBlock(screenProps);
		}
	}

	private void LateUpdate()
	{
		if (gunVariation != 2)
		{
			return;
		}
		if (chargingPierce || twirlRecovery)
		{
			anim.SetBool("Spinning", value: true);
			bool flag = latestTwirlRotation < 0f;
			if (chargingPierce)
			{
				twirlLevel = Mathf.Min(3f, Mathf.Floor(pierceShotCharge / 25f)) + 1f;
			}
			else
			{
				twirlLevel = Mathf.MoveTowards(twirlLevel, 0.1f, Time.deltaTime * 100f * twirlLevel);
			}
			latestTwirlRotation += 1200f * (twirlLevel / 3f + 0.5f) * Time.deltaTime;
			if ((bool)twirlSprite)
			{
				twirlSprite.color = new Color(1f, 1f, 1f, Mathf.Min(2f, Mathf.Floor(pierceShotCharge / 25f)) / 3f);
			}
			if (!ceaud.isPlaying)
			{
				ceaud.Play();
			}
			ceaud.pitch = 0.5f + twirlLevel / 2f;
			if (twirlRecovery && flag && latestTwirlRotation >= 0f)
			{
				latestTwirlRotation = 0f;
				twirlRecovery = false;
				if ((bool)twirlSprite)
				{
					twirlSprite.color = new Color(1f, 1f, 1f, 0f);
				}
			}
			else
			{
				while (latestTwirlRotation > 180f)
				{
					latestTwirlRotation -= 360f;
				}
				twirlBone.localRotation = Quaternion.Euler(twirlBone.localRotation.eulerAngles + (altVersion ? Vector3.left : Vector3.forward) * latestTwirlRotation);
			}
			anim.SetFloat("TwirlSpeed", twirlLevel / 3f);
			if ((bool)wid && wid.delay != 0f && !MonoSingleton<NewMovement>.Instance.gc.onGround)
			{
				MonoSingleton<NewMovement>.Instance.rb.AddForce(MonoSingleton<CameraController>.Instance.transform.up * 400f * twirlLevel * Time.deltaTime, ForceMode.Acceleration);
			}
		}
		else
		{
			anim.SetBool("Spinning", value: false);
			if ((bool)twirlSprite)
			{
				twirlSprite.color = new Color(1f, 1f, 1f, 0f);
			}
			ceaud.Stop();
		}
	}

	private void Shoot(int shotType = 1)
	{
		cc.StopShake();
		shootReady = false;
		shootCharge = 0f;
		if (altVersion)
		{
			MonoSingleton<WeaponCharges>.Instance.revaltpickupcharges[gunVariation] = 2f;
		}
		switch (shotType)
		{
		case 1:
		{
			GameObject gameObject2 = Object.Instantiate(revolverBeam, cc.transform.position, cc.transform.rotation);
			if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
			{
				gameObject2.transform.LookAt(targeter.CurrentTarget.bounds.center);
			}
			RevolverBeam component2 = gameObject2.GetComponent<RevolverBeam>();
			component2.sourceWeapon = gc.currentWeapon;
			component2.alternateStartPoint = gunBarrel.transform.position;
			component2.gunVariation = gunVariation;
			if (anim.GetCurrentAnimatorStateInfo(0).IsName("PickUp"))
			{
				component2.quickDraw = true;
			}
			currentGunShot = Random.Range(0, gunShots.Length);
			gunAud.clip = gunShots[currentGunShot];
			gunAud.volume = 0.55f;
			gunAud.pitch = Random.Range(0.9f, 1.1f);
			gunAud.Play();
			cam.fieldOfView += cc.defaultFov / 40f;
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.GunFire, base.gameObject);
			break;
		}
		case 2:
		{
			GameObject gameObject = Object.Instantiate(revolverBeamSuper, cc.transform.position, cc.transform.rotation);
			if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
			{
				gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
			}
			RevolverBeam component = gameObject.GetComponent<RevolverBeam>();
			component.sourceWeapon = gc.currentWeapon;
			component.alternateStartPoint = gunBarrel.transform.position;
			component.gunVariation = gunVariation;
			if (gunVariation == 2)
			{
				component.ricochetAmount = Mathf.Min(3, Mathf.FloorToInt(pierceShotCharge / 25f));
			}
			pierceShotCharge = 0f;
			if (anim.GetCurrentAnimatorStateInfo(0).IsName("PickUp"))
			{
				component.quickDraw = true;
			}
			pierceReady = false;
			pierceCharge = 0f;
			if (gunVariation == 0)
			{
				screenAud.clip = chargingSound;
				screenAud.loop = true;
				if (altVersion)
				{
					screenAud.pitch = 0.5f;
				}
				else
				{
					screenAud.pitch = 1f;
				}
				screenAud.volume = 0.55f;
				screenAud.Play();
			}
			else if (!wid || wid.delay == 0f)
			{
				wc.rev2charge -= (altVersion ? 300 : 100);
			}
			if ((bool)superGunSound)
			{
				Object.Instantiate(superGunSound);
			}
			if (gunVariation == 2 && (bool)twirlShotSound)
			{
				Object.Instantiate(twirlShotSound, base.transform.position, Quaternion.identity);
			}
			cam.fieldOfView += cc.defaultFov / 20f;
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.GunFireStrong, base.gameObject);
			break;
		}
		}
		if (!altVersion)
		{
			cylinder.DoTurn();
		}
		anim.SetFloat("RandomChance", Random.Range(0f, 1f));
		if (shotType == 1)
		{
			anim.SetTrigger("Shoot");
		}
		else
		{
			anim.SetTrigger("ChargeShoot");
		}
		gunReady = false;
	}

	private void ThrowCoin()
	{
		if (punch == null || !punch.gameObject.activeInHierarchy)
		{
			punch = MonoSingleton<FistControl>.Instance.currentPunch;
		}
		if ((bool)punch)
		{
			punch.CoinFlip();
		}
		GameObject obj = Object.Instantiate(coin, camObj.transform.position + camObj.transform.up * -0.5f, camObj.transform.rotation);
		obj.GetComponent<Coin>().sourceWeapon = gc.currentWeapon;
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.CoinToss);
		Vector3 zero = Vector3.zero;
		obj.GetComponent<Rigidbody>().AddForce(camObj.transform.forward * 20f + Vector3.up * 15f + (MonoSingleton<NewMovement>.Instance.ridingRocket ? MonoSingleton<NewMovement>.Instance.ridingRocket.rb.velocity : MonoSingleton<NewMovement>.Instance.rb.velocity) + zero, ForceMode.VelocityChange);
		pierceCharge = 0f;
		pierceReady = false;
	}

	private void ReadyToShoot()
	{
		shootReady = true;
	}

	public void Punch()
	{
		gunReady = false;
		anim.SetTrigger("ChargeShoot");
	}

	public void ReadyGun()
	{
		gunReady = true;
	}

	public void Click()
	{
		if (altVersion)
		{
			MonoSingleton<WeaponCharges>.Instance.revaltpickupcharges[gunVariation] = 0f;
		}
		if (gunVariation == 2)
		{
			chargingPierce = false;
			twirlRecovery = false;
		}
	}

	public void InstaClick()
	{
		if (altVersion)
		{
			for (int i = 0; i < MonoSingleton<WeaponCharges>.Instance.revaltpickupcharges.Length; i++)
			{
				MonoSingleton<WeaponCharges>.Instance.revaltpickupcharges[i] = 0f;
			}
			Object.Instantiate(quickTwirlEffect, cylinder.transform.position, base.transform.rotation).transform.SetParent(cylinder.transform);
			anim.Rebind();
			anim.Play("ShootTwirl", -1, 0f);
		}
	}

	public void MaxCharge()
	{
		if (gunVariation == 0)
		{
			pierceCharge = 100f;
		}
		else
		{
			CheckCoinCharges();
		}
	}

	private void DelayedShoot()
	{
		Shoot();
	}

	private void DelayedShoot2()
	{
		Shoot(2);
	}

	private void CheckCoinCharges()
	{
		if (coinPanelsCharged == null || coinPanelsCharged.Length == 0)
		{
			coinPanelsCharged = new bool[coinPanels.Length];
		}
		coinCharge = ((gunVariation == 1) ? wc.rev1charge : wc.rev2charge);
		for (int i = 0; i < coinPanels.Length; i++)
		{
			if (altVersion && gunVariation == 2)
			{
				coinPanels[i].fillAmount = coinCharge / 300f;
			}
			else
			{
				coinPanels[i].fillAmount = coinCharge / 100f - (float)i;
			}
			if (coinPanels[i].fillAmount < 1f)
			{
				coinPanels[i].color = ((gunVariation == 1) ? Color.red : Color.gray);
				coinPanelsCharged[i] = false;
				continue;
			}
			if ((bool)MonoSingleton<ColorBlindSettings>.Instance && coinPanels[i].color != MonoSingleton<ColorBlindSettings>.Instance.variationColors[gunVariation])
			{
				coinPanels[i].color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[gunVariation];
			}
			if (!coinPanelsCharged[i] && (!wid || wid.delay == 0f))
			{
				if (!screenAud)
				{
					screenAud = GetComponentInChildren<Canvas>().GetComponent<AudioSource>();
				}
				screenAud.pitch = 1f + (float)i / 2f;
				screenAud.Play();
				coinPanelsCharged[i] = true;
			}
		}
	}
}



public class RevolverAnimationReceiver : MonoBehaviour
{
	private Revolver rev;

	public GameObject click;

	private void Start()
	{
		rev = GetComponentInParent<Revolver>();
	}

	public void ReadyGun()
	{
		rev.ReadyGun();
	}

	public void Click()
	{
		if ((bool)click)
		{
			Object.Instantiate(click);
		}
		rev.cylinder.DoTurn();
		rev.Click();
	}
}



public class RevolverBeam : MonoBehaviour
{
	private const float ForceBulletPropMulti = 0.005f;

	public EnemyTarget target;

	public BeamType beamType;

	public HitterAttribute[] attributes;

	private LineRenderer lr;

	private AudioSource aud;

	private Light muzzleLight;

	public Vector3 alternateStartPoint;

	public GameObject sourceWeapon;

	[HideInInspector]
	public int bodiesPierced;

	private int enemiesPierced;

	private RaycastHit[] allHits;

	[HideInInspector]
	public List<RaycastResult> hitList = new List<RaycastResult>();

	private GunControl gc;

	private RaycastHit hit;

	private Vector3 shotHitPoint;

	public CameraController cc;

	private bool maliciousIgnorePlayer;

	public GameObject hitParticle;

	public int bulletForce;

	public bool quickDraw;

	public int gunVariation;

	public float damage;

	[HideInInspector]
	public float addedDamage;

	public float enemyDamageOverride;

	public float critDamageOverride;

	public float screenshakeMultiplier = 1f;

	public int hitAmount;

	public int maxHitsPerTarget;

	private int currentHits;

	public bool noMuzzleflash;

	private bool fadeOut;

	private bool didntHit;

	private LayerMask ignoreEnemyTrigger;

	private LayerMask enemyLayerMask;

	private LayerMask pierceLayerMask;

	public int ricochetAmount;

	[HideInInspector]
	public bool hasBeenRicocheter;

	public GameObject ricochetSound;

	public GameObject enemyHitSound;

	public bool fake;

	public EnemyType ignoreEnemyType;

	public bool deflected;

	private bool chargeBacked;

	public bool strongAlt;

	public bool ultraRicocheter = true;

	public bool canHitProjectiles;

	private bool hasHitProjectile;

	[HideInInspector]
	public List<EnemyIdentifier> hitEids = new List<EnemyIdentifier>();

	[HideInInspector]
	public Transform previouslyHitTransform;

	[HideInInspector]
	public bool aimAssist;

	[HideInInspector]
	public bool intentionalRicochet;

	private void Start()
	{
		if (aimAssist)
		{
			RicochetAimAssist(base.gameObject, intentionalRicochet);
		}
		if (ricochetAmount > 0)
		{
			hasBeenRicocheter = true;
		}
		muzzleLight = GetComponent<Light>();
		lr = GetComponent<LineRenderer>();
		cc = MonoSingleton<CameraController>.Instance;
		gc = cc.GetComponentInChildren<GunControl>();
		if (beamType == BeamType.Enemy)
		{
			enemyLayerMask = (int)enemyLayerMask | 4;
		}
		enemyLayerMask = (int)enemyLayerMask | 0x400;
		enemyLayerMask = (int)enemyLayerMask | 0x800;
		if (canHitProjectiles)
		{
			enemyLayerMask = (int)enemyLayerMask | 0x4000;
		}
		pierceLayerMask = (int)pierceLayerMask | 0x100;
		pierceLayerMask = (int)pierceLayerMask | 0x1000000;
		pierceLayerMask = (int)pierceLayerMask | 0x4000000;
		ignoreEnemyTrigger = (int)enemyLayerMask | (int)pierceLayerMask;
		if (!fake)
		{
			Shoot();
		}
		else
		{
			fadeOut = true;
		}
		if (maxHitsPerTarget == 0)
		{
			maxHitsPerTarget = 99;
		}
	}

	private void Update()
	{
		if (fadeOut)
		{
			lr.widthMultiplier -= Time.deltaTime * 1.5f;
			if (muzzleLight != null)
			{
				muzzleLight.intensity -= Time.deltaTime * 100f;
			}
			if (lr.widthMultiplier <= 0f)
			{
				Object.Destroy(base.gameObject);
			}
		}
	}

	public void FakeShoot(Vector3 target)
	{
		Vector3 position = base.transform.position;
		if (alternateStartPoint != Vector3.zero)
		{
			position = alternateStartPoint;
		}
		lr.SetPosition(0, position);
		lr.SetPosition(1, target);
		Transform child = base.transform.GetChild(0);
		if (!noMuzzleflash)
		{
			child.SetPositionAndRotation(position, base.transform.rotation);
		}
		else
		{
			child.gameObject.SetActive(value: false);
		}
	}

	private void Shoot()
	{
		if (hitAmount == 1)
		{
			fadeOut = true;
			if (beamType != BeamType.Enemy)
			{
				if (beamType == BeamType.Railgun)
				{
					cc.CameraShake(2f * screenshakeMultiplier);
				}
				else if (strongAlt)
				{
					cc.CameraShake(0.25f * screenshakeMultiplier);
				}
			}
			bool flag = Physics.Raycast(base.transform.position, base.transform.forward, out hit, float.PositiveInfinity, ignoreEnemyTrigger);
			CheckWater(hit.distance);
			bool flag2 = false;
			RaycastHit hitInfo = default(RaycastHit);
			if (flag && (hit.transform.gameObject.layer == 8 || hit.transform.gameObject.layer == 24))
			{
				flag2 = Physics.SphereCast(base.transform.position, (beamType == BeamType.Enemy) ? 0.1f : 0.4f, base.transform.forward, out hitInfo, Vector3.Distance(base.transform.position, hit.point) - ((beamType == BeamType.Enemy) ? 0.1f : 0.4f), enemyLayerMask);
			}
			if (flag2)
			{
				HitSomething(hitInfo);
			}
			else if (flag)
			{
				HitSomething(hit);
			}
			else
			{
				shotHitPoint = base.transform.position + base.transform.forward * 1000f;
			}
		}
		else
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out hit, float.PositiveInfinity, pierceLayerMask))
			{
				shotHitPoint = hit.point;
			}
			else
			{
				shotHitPoint = base.transform.position + base.transform.forward * 999f;
				didntHit = true;
			}
			CheckWater(Vector3.Distance(base.transform.position, shotHitPoint));
			float radius = 0.6f;
			if (beamType == BeamType.Railgun)
			{
				radius = 1.2f;
			}
			else if (beamType == BeamType.Enemy)
			{
				radius = 0.3f;
			}
			allHits = Physics.SphereCastAll(base.transform.position, radius, base.transform.forward, Vector3.Distance(base.transform.position, shotHitPoint), enemyLayerMask, QueryTriggerInteraction.Collide);
		}
		Vector3 position = base.transform.position;
		if (alternateStartPoint != Vector3.zero)
		{
			position = alternateStartPoint;
		}
		lr.SetPosition(0, position);
		lr.SetPosition(1, shotHitPoint);
		if (hitAmount != 1)
		{
			PiercingShotOrder();
		}
		Transform child = base.transform.GetChild(0);
		if (!noMuzzleflash)
		{
			child.SetPositionAndRotation(position, base.transform.rotation);
		}
		else
		{
			child.gameObject.SetActive(value: false);
		}
	}

	private void CheckWater(float distance)
	{
		if (attributes.Length == 0)
		{
			return;
		}
		bool flag = false;
		HitterAttribute[] array = attributes;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == HitterAttribute.Electricity)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		Water component = null;
		List<Water> list = new List<Water>();
		List<GameObject> alreadyHitObjects = new List<GameObject>();
		Collider[] array2 = Physics.OverlapSphere(base.transform.position, 0.01f, 16, QueryTriggerInteraction.Collide);
		if (array2.Length != 0)
		{
			for (int j = 0; j < array2.Length; j++)
			{
				if ((!array2[j].attachedRigidbody && !array2[j].TryGetComponent<Water>(out component)) || ((bool)array2[j].attachedRigidbody && !array2[j].attachedRigidbody.TryGetComponent<Water>(out component)) || list.Contains(component))
				{
					return;
				}
				list.Add(component);
				EnemyIdentifier.Zap(base.transform.position, 2f, alreadyHitObjects, sourceWeapon, null, component, waterOnly: true);
			}
		}
		RaycastHit[] array3 = Physics.RaycastAll(base.transform.position, base.transform.forward, distance, 16, QueryTriggerInteraction.Collide);
		if (array3.Length == 0)
		{
			return;
		}
		for (int k = 0; k < array3.Length && array3[k].transform.TryGetComponent<Water>(out component); k++)
		{
			if (list.Contains(component))
			{
				break;
			}
			list.Add(component);
			EnemyIdentifier.Zap(array3[k].point, 2f, alreadyHitObjects, sourceWeapon, null, component, waterOnly: true);
		}
	}

	private void HitSomething(RaycastHit hit)
	{
		bool flag = false;
		if (hit.transform.gameObject.layer == 8 || hit.transform.gameObject.layer == 24)
		{
			ExecuteHits(hit);
		}
		else if (beamType != 0 && hit.transform.gameObject.CompareTag("Coin"))
		{
			flag = true;
			lr.SetPosition(1, hit.transform.position);
			GameObject gameObject = Object.Instantiate(base.gameObject, hit.point, base.transform.rotation);
			gameObject.SetActive(value: false);
			RevolverBeam component = gameObject.GetComponent<RevolverBeam>();
			component.bodiesPierced = 0;
			component.noMuzzleflash = true;
			component.alternateStartPoint = Vector3.zero;
			if (beamType == BeamType.MaliciousFace || beamType == BeamType.Enemy)
			{
				component.deflected = true;
			}
			Coin component2 = hit.transform.gameObject.GetComponent<Coin>();
			if (component2 != null)
			{
				if (component.deflected)
				{
					component2.ignoreBlessedEnemies = true;
				}
				sourceWeapon = component2.sourceWeapon ?? sourceWeapon;
				component2.DelayedReflectRevolver(hit.point, gameObject);
			}
			fadeOut = true;
		}
		else
		{
			ExecuteHits(hit);
		}
		shotHitPoint = hit.point;
		if (hit.transform.gameObject.CompareTag("Armor") || flag || !(hitParticle != null))
		{
			return;
		}
		GameObject obj = Object.Instantiate(hitParticle, shotHitPoint, base.transform.rotation);
		obj.transform.forward = hit.normal;
		Explosion[] componentsInChildren = obj.GetComponentsInChildren<Explosion>();
		Explosion[] array = componentsInChildren;
		foreach (Explosion explosion in array)
		{
			explosion.sourceWeapon = sourceWeapon ?? explosion.sourceWeapon;
			if (explosion.damage > 0 && addedDamage > 0f)
			{
				explosion.playerDamageOverride = explosion.damage;
				explosion.damage += Mathf.RoundToInt(addedDamage * 20f);
			}
		}
		if ((beamType != BeamType.MaliciousFace && (beamType != BeamType.Railgun || !maliciousIgnorePlayer)) || componentsInChildren.Length == 0)
		{
			return;
		}
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		if (beamType == BeamType.MaliciousFace)
		{
			array = componentsInChildren;
			foreach (Explosion explosion2 in array)
			{
				if (deflected || maliciousIgnorePlayer)
				{
					explosion2.unblockable = true;
					explosion2.canHit = AffectedSubjects.EnemiesOnly;
				}
				else
				{
					explosion2.enemy = true;
				}
				if (@int < 2)
				{
					explosion2.maxSize *= 0.65f;
					explosion2.speed *= 0.65f;
				}
			}
		}
		else
		{
			array = componentsInChildren;
			foreach (Explosion explosion3 in array)
			{
				explosion3.sourceWeapon = sourceWeapon ?? explosion3.sourceWeapon;
				explosion3.canHit = AffectedSubjects.EnemiesOnly;
			}
		}
	}

	private void PiercingShotOrder()
	{
		hitList.Clear();
		RaycastHit[] array = allHits;
		for (int i = 0; i < array.Length; i++)
		{
			RaycastHit raycastHit = array[i];
			if (raycastHit.transform != previouslyHitTransform)
			{
				hitList.Add(new RaycastResult(raycastHit));
			}
		}
		bool flag = true;
		Transform transform = hit.transform;
		if (!didntHit)
		{
			GameObject gameObject = transform.gameObject;
			if (gameObject.layer == 8 || gameObject.layer == 24)
			{
				if (gameObject.TryGetComponent<SandboxProp>(out var _) && hit.rigidbody != null)
				{
					hit.rigidbody.AddForceAtPosition(base.transform.forward * bulletForce * 0.005f, hit.point, ForceMode.VelocityChange);
				}
				AttributeChecker component4;
				if (transform.TryGetComponent<Breakable>(out var _) || gameObject.TryGetComponent<Bleeder>(out var _))
				{
					flag = true;
				}
				else if (transform.TryGetComponent<AttributeChecker>(out component4))
				{
					flag = true;
				}
			}
			if (flag || gameObject.CompareTag("Glass") || gameObject.CompareTag("GlassFloor") || gameObject.CompareTag("Armor"))
			{
				hitList.Add(new RaycastResult(hit));
			}
		}
		hitList.Sort();
		PiercingShotCheck();
	}

	private void PiercingShotCheck()
	{
		if (enemiesPierced < hitList.Count)
		{
			RaycastResult raycastResult = hitList[enemiesPierced];
			RaycastHit rrhit = raycastResult.rrhit;
			Transform transform = raycastResult.transform;
			if (transform == null)
			{
				enemiesPierced++;
				PiercingShotCheck();
				return;
			}
			GameObject gameObject = transform.gameObject;
			if (gameObject.CompareTag("Armor") || (ricochetAmount > 0 && (gameObject.layer == 8 || gameObject.layer == 24 || gameObject.layer == 0)))
			{
				bool flag = !gameObject.CompareTag("Armor");
				GameObject gameObject2 = Object.Instantiate(base.gameObject, rrhit.point, base.transform.rotation);
				gameObject2.transform.forward = Vector3.Reflect(base.transform.forward, rrhit.normal);
				lr.SetPosition(1, rrhit.point);
				RevolverBeam component = gameObject2.GetComponent<RevolverBeam>();
				component.noMuzzleflash = true;
				component.alternateStartPoint = Vector3.zero;
				component.bodiesPierced = bodiesPierced;
				component.previouslyHitTransform = transform;
				component.aimAssist = true;
				component.intentionalRicochet = flag;
				if (flag)
				{
					ricochetAmount--;
					if (beamType != 0 || component.maxHitsPerTarget < 3 || (strongAlt && component.maxHitsPerTarget < 4))
					{
						component.maxHitsPerTarget++;
					}
					component.hitEids.Clear();
				}
				component.ricochetAmount = ricochetAmount;
				GameObject gameObject3 = Object.Instantiate(ricochetSound, rrhit.point, Quaternion.identity);
				gameObject3.SetActive(value: false);
				gameObject2.SetActive(value: false);
				MonoSingleton<DelayedActivationManager>.Instance.Add(gameObject2, 0.1f);
				MonoSingleton<DelayedActivationManager>.Instance.Add(gameObject3, 0.1f);
				if (gameObject.TryGetComponent<Glass>(out var component2) && !component2.broken)
				{
					component2.Shatter();
				}
				if (gameObject.TryGetComponent<Breakable>(out var component3) && (strongAlt || component3.weak || beamType == BeamType.Railgun))
				{
					component3.Break();
				}
				fadeOut = true;
				enemiesPierced = hitList.Count;
				return;
			}
			if (gameObject.CompareTag("Coin") && bodiesPierced < hitAmount)
			{
				if (!gameObject.TryGetComponent<Coin>(out var component4))
				{
					enemiesPierced++;
					PiercingShotCheck();
					return;
				}
				lr.SetPosition(1, transform.position);
				GameObject gameObject4 = Object.Instantiate(base.gameObject, rrhit.point, base.transform.rotation);
				gameObject4.SetActive(value: false);
				RevolverBeam component5 = gameObject4.GetComponent<RevolverBeam>();
				component5.bodiesPierced = 0;
				component5.noMuzzleflash = true;
				component5.alternateStartPoint = Vector3.zero;
				component5.hitEids.Clear();
				Revolver component6;
				if (beamType == BeamType.Enemy)
				{
					component4.ignoreBlessedEnemies = true;
					component5.deflected = true;
				}
				else if (beamType == BeamType.Revolver && strongAlt && component4.hitTimes > 1 && (bool)sourceWeapon && sourceWeapon.TryGetComponent<Revolver>(out component6) && component6.altVersion)
				{
					component6.InstaClick();
				}
				component4.DelayedReflectRevolver(rrhit.point, gameObject4);
				fadeOut = true;
				return;
			}
			if ((gameObject.layer == 10 || gameObject.layer == 11) && bodiesPierced < hitAmount && !gameObject.CompareTag("Breakable"))
			{
				EnemyIdentifierIdentifier componentInParent = gameObject.GetComponentInParent<EnemyIdentifierIdentifier>();
				if (!componentInParent)
				{
					if (attributes.Length != 0 && transform.TryGetComponent<AttributeChecker>(out var component7))
					{
						HitterAttribute[] array = attributes;
						for (int i = 0; i < array.Length; i++)
						{
							if (array[i] == component7.targetAttribute)
							{
								component7.DelayedActivate();
								break;
							}
						}
					}
					enemiesPierced++;
					currentHits = 0;
					PiercingShotCheck();
					return;
				}
				EnemyIdentifier eid = componentInParent.eid;
				if (eid != null)
				{
					if ((!hitEids.Contains(eid) || (eid.dead && beamType == BeamType.Revolver && enemiesPierced == hitList.Count - 1)) && ((beamType != BeamType.Enemy && beamType != BeamType.MaliciousFace) || deflected || (eid.enemyType != ignoreEnemyType && !eid.immuneToFriendlyFire && !EnemyIdentifier.CheckHurtException(ignoreEnemyType, eid.enemyType, target))))
					{
						bool dead = eid.dead;
						ExecuteHits(rrhit);
						if (!dead || gameObject.layer == 11 || (beamType == BeamType.Revolver && enemiesPierced == hitList.Count - 1))
						{
							currentHits++;
							bodiesPierced++;
							Object.Instantiate(hitParticle, rrhit.point, base.transform.rotation);
							MonoSingleton<TimeController>.Instance.HitStop(0.05f);
						}
						else
						{
							if (beamType == BeamType.Revolver)
							{
								hitEids.Add(eid);
							}
							enemiesPierced++;
							currentHits = 0;
						}
						if (currentHits >= maxHitsPerTarget)
						{
							hitEids.Add(eid);
							currentHits = 0;
							enemiesPierced++;
						}
						if (beamType == BeamType.Revolver && !dead)
						{
							Invoke("PiercingShotCheck", 0.05f);
						}
						else if (beamType == BeamType.Revolver)
						{
							PiercingShotCheck();
						}
						else if (!dead)
						{
							Invoke("PiercingShotCheck", 0.025f);
						}
						else
						{
							Invoke("PiercingShotCheck", 0.01f);
						}
					}
					else
					{
						enemiesPierced++;
						currentHits = 0;
						PiercingShotCheck();
					}
				}
				else
				{
					ExecuteHits(rrhit);
					enemiesPierced++;
					PiercingShotCheck();
				}
				return;
			}
			if (canHitProjectiles && gameObject.layer == 14)
			{
				if (!hasHitProjectile)
				{
					Invoke("PiercingShotCheck", 0.01f);
				}
				else
				{
					MonoSingleton<TimeController>.Instance.HitStop(0.05f);
					Invoke("PiercingShotCheck", 0.05f);
				}
				ExecuteHits(rrhit);
				enemiesPierced++;
				return;
			}
			if (gameObject.CompareTag("Glass") || gameObject.CompareTag("GlassFloor"))
			{
				gameObject.TryGetComponent<Glass>(out var component8);
				if (!component8.broken)
				{
					component8.Shatter();
				}
				enemiesPierced++;
				PiercingShotCheck();
				return;
			}
			if (beamType == BeamType.Enemy && bodiesPierced < hitAmount && !rrhit.collider.isTrigger && gameObject.CompareTag("Player"))
			{
				ExecuteHits(rrhit);
				bodiesPierced++;
				enemiesPierced++;
				PiercingShotCheck();
				return;
			}
			if (transform.TryGetComponent<Breakable>(out var component9) && (beamType == BeamType.Railgun || component9.weak))
			{
				if (component9.interrupt)
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.interruption", sourceWeapon);
					MonoSingleton<TimeController>.Instance.ParryFlash();
					if (canHitProjectiles)
					{
						component9.breakParticle = MonoSingleton<DefaultReferenceManager>.Instance.superExplosion;
					}
					if ((bool)component9.interruptEnemy && !component9.interruptEnemy.blessed)
					{
						component9.interruptEnemy.Explode(fromExplosion: true);
					}
				}
				component9.Break();
			}
			else if (bodiesPierced < hitAmount)
			{
				ExecuteHits(rrhit);
			}
			Object.Instantiate(hitParticle, rrhit.point, Quaternion.LookRotation(rrhit.normal));
			enemiesPierced++;
			PiercingShotCheck();
		}
		else
		{
			enemiesPierced = 0;
			fadeOut = true;
		}
	}

	public void ExecuteHits(RaycastHit currentHit)
	{
		Transform transform = currentHit.transform;
		if (!(transform != null))
		{
			return;
		}
		GameObject gameObject = transform.gameObject;
		if (transform.TryGetComponent<Breakable>(out var component) && (strongAlt || beamType == BeamType.Railgun || component.weak))
		{
			if (component.interrupt)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(100, "ultrakill.interruption", sourceWeapon);
				MonoSingleton<TimeController>.Instance.ParryFlash();
				if (canHitProjectiles)
				{
					component.breakParticle = MonoSingleton<DefaultReferenceManager>.Instance.superExplosion;
				}
				if ((bool)component.interruptEnemy && !component.interruptEnemy.blessed)
				{
					component.interruptEnemy.Explode(fromExplosion: true);
				}
			}
			component.Break();
		}
		if (gameObject.TryGetComponent<Glass>(out var component2) && !component2.broken && beamType == BeamType.Enemy)
		{
			component2.Shatter();
		}
		if (canHitProjectiles && gameObject.layer == 14 && gameObject.TryGetComponent<Projectile>(out var component3) && (component3.speed != 0f || component3.turnSpeed != 0f || component3.decorative))
		{
			Object.Instantiate((!hasHitProjectile) ? MonoSingleton<DefaultReferenceManager>.Instance.superExplosion : component3.explosionEffect, component3.transform.position, Quaternion.identity);
			Object.Destroy(component3.gameObject);
			if (!hasHitProjectile)
			{
				MonoSingleton<TimeController>.Instance.ParryFlash();
			}
			hasHitProjectile = true;
		}
		if (gameObject.TryGetComponent<Bleeder>(out var component4))
		{
			if (beamType == BeamType.Railgun || strongAlt)
			{
				component4.GetHit(currentHit.point, GoreType.Head);
			}
			else
			{
				component4.GetHit(currentHit.point, GoreType.Body);
			}
		}
		if (gameObject.TryGetComponent<SandboxProp>(out var _) && currentHit.rigidbody != null)
		{
			currentHit.rigidbody.AddForceAtPosition(base.transform.forward * bulletForce * 0.005f, hit.point, ForceMode.VelocityChange);
		}
		if (transform.TryGetComponent<Coin>(out var component6) && beamType == BeamType.Revolver)
		{
			if (quickDraw)
			{
				component6.quickDraw = true;
			}
			component6.DelayedReflectRevolver(currentHit.point);
		}
		if (gameObject.CompareTag("Enemy") || gameObject.CompareTag("Body") || gameObject.CompareTag("Limb") || gameObject.CompareTag("EndLimb") || gameObject.CompareTag("Head"))
		{
			EnemyIdentifier eid = transform.GetComponentInParent<EnemyIdentifierIdentifier>().eid;
			if ((bool)eid && !deflected && (beamType == BeamType.MaliciousFace || beamType == BeamType.Enemy) && (eid.enemyType == ignoreEnemyType || eid.immuneToFriendlyFire || EnemyIdentifier.CheckHurtException(ignoreEnemyType, eid.enemyType, target)))
			{
				enemiesPierced++;
				return;
			}
			if (beamType != BeamType.Enemy)
			{
				if (hitAmount > 1)
				{
					cc.CameraShake(1f * screenshakeMultiplier);
				}
				else
				{
					cc.CameraShake(0.5f * screenshakeMultiplier);
				}
			}
			if ((bool)eid && !eid.dead && quickDraw && !eid.blessed && !eid.puppet)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.quickdraw", sourceWeapon, eid);
				quickDraw = false;
			}
			string text = "";
			if (beamType == BeamType.Revolver)
			{
				text = "revolver";
			}
			else if (beamType == BeamType.Railgun)
			{
				text = "railcannon";
			}
			else if (beamType == BeamType.MaliciousFace || beamType == BeamType.Enemy)
			{
				text = "enemy";
			}
			if ((bool)eid)
			{
				eid.hitter = text;
				if (attributes != null && attributes.Length != 0)
				{
					HitterAttribute[] array = attributes;
					foreach (HitterAttribute item in array)
					{
						eid.hitterAttributes.Add(item);
					}
				}
				if (!eid.hitterWeapons.Contains(text + gunVariation))
				{
					eid.hitterWeapons.Add(text + gunVariation);
				}
			}
			float critMultiplier = 1f;
			if (beamType != 0)
			{
				critMultiplier = 0f;
			}
			if (critDamageOverride != 0f || strongAlt)
			{
				critMultiplier = critDamageOverride;
			}
			float num = ((enemyDamageOverride != 0f) ? enemyDamageOverride : damage);
			if ((bool)eid && deflected)
			{
				if (beamType == BeamType.MaliciousFace && eid.enemyType == EnemyType.MaliciousFace)
				{
					num = 999f;
				}
				else if (beamType == BeamType.Enemy)
				{
					num *= 2.5f;
				}
				if (!chargeBacked)
				{
					chargeBacked = true;
					if (!eid.blessed)
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(400, "ultrakill.chargeback", sourceWeapon, eid);
					}
				}
			}
			bool tryForExplode = false;
			if (strongAlt)
			{
				tryForExplode = true;
			}
			if ((bool)eid)
			{
				eid.DeliverDamage(gameObject, (transform.position - base.transform.position).normalized * bulletForce, currentHit.point, num, tryForExplode, critMultiplier, sourceWeapon);
			}
			if (beamType != BeamType.MaliciousFace && beamType != BeamType.Enemy)
			{
				if ((bool)eid && !eid.dead && beamType == BeamType.Revolver && !eid.blessed && gameObject.CompareTag("Head"))
				{
					gc.headshots++;
					gc.headShotComboTime = 3f;
				}
				else if (beamType == BeamType.Railgun || !gameObject.CompareTag("Head"))
				{
					gc.headshots = 0;
					gc.headShotComboTime = 0f;
				}
				if (gc.headshots > 1 && (bool)eid && !eid.blessed)
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(gc.headshots * 20, "ultrakill.headshotcombo", count: gc.headshots, sourceWeapon: sourceWeapon, eid: eid);
				}
			}
			if ((bool)enemyHitSound)
			{
				Object.Instantiate(enemyHitSound, currentHit.point, Quaternion.identity);
			}
		}
		else if (gameObject.layer == 10)
		{
			Grenade componentInParent = transform.GetComponentInParent<Grenade>();
			if (componentInParent != null)
			{
				if (beamType != BeamType.Enemy || !componentInParent.enemy || componentInParent.playerRiding)
				{
					MonoSingleton<TimeController>.Instance.ParryFlash();
				}
				if ((beamType == BeamType.Railgun && hitAmount == 1) || beamType == BeamType.MaliciousFace)
				{
					maliciousIgnorePlayer = true;
					componentInParent.Explode(componentInParent.rocket, harmless: false, !componentInParent.rocket, 2f, ultrabooster: true, sourceWeapon);
				}
				else
				{
					componentInParent.Explode(componentInParent.rocket, harmless: false, !componentInParent.rocket, 1f, ultrabooster: false, sourceWeapon);
				}
			}
			else
			{
				Cannonball componentInParent2 = transform.GetComponentInParent<Cannonball>();
				if ((bool)componentInParent2)
				{
					MonoSingleton<TimeController>.Instance.ParryFlash();
					componentInParent2.Explode();
				}
			}
		}
		else if (beamType == BeamType.Enemy && !currentHit.collider.isTrigger && gameObject.CompareTag("Player"))
		{
			if ((bool)enemyHitSound)
			{
				Object.Instantiate(enemyHitSound, currentHit.point, Quaternion.identity);
			}
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(damage * 10f), invincible: true);
			}
			else
			{
				MonoSingleton<PlatformerMovement>.Instance.Explode();
			}
		}
		else
		{
			if ((bool)gc)
			{
				gc.headshots = 0;
				gc.headShotComboTime = 0f;
			}
			if (gameObject.CompareTag("Armor"))
			{
				GameObject gameObject2 = Object.Instantiate(base.gameObject, currentHit.point, base.transform.rotation);
				gameObject2.transform.forward = Vector3.Reflect(base.transform.forward, currentHit.normal);
				RevolverBeam component7 = gameObject2.GetComponent<RevolverBeam>();
				component7.noMuzzleflash = true;
				component7.alternateStartPoint = Vector3.zero;
				component7.aimAssist = true;
				GameObject gameObject3 = Object.Instantiate(ricochetSound, currentHit.point, Quaternion.identity);
				gameObject3.SetActive(value: false);
				gameObject2.SetActive(value: false);
				MonoSingleton<DelayedActivationManager>.Instance.Add(gameObject2, 0.1f);
				MonoSingleton<DelayedActivationManager>.Instance.Add(gameObject3, 0.1f);
			}
		}
	}

	private void RicochetAimAssist(GameObject beam, bool aimAtHead = false)
	{
		RaycastHit[] array = Physics.SphereCastAll(beam.transform.position, 5f, beam.transform.forward, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Enemies));
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 worldPosition = beam.transform.forward * 1000f;
		float num = float.PositiveInfinity;
		GameObject gameObject = null;
		bool flag = false;
		for (int i = 0; i < array.Length; i++)
		{
			Coin component;
			bool flag2 = MonoSingleton<CoinList>.Instance.revolverCoinsList.Count > 0 && array[i].transform.TryGetComponent<Coin>(out component) && (!component.shot || component.shotByEnemy);
			if ((!flag || flag2) && (!(array[i].distance > num) || (!flag && flag2)) && (!(array[i].distance < 0.1f) || flag2) && !Physics.Raycast(beam.transform.position, array[i].point - beam.transform.position, array[i].distance, LayerMaskDefaults.Get(LMD.Environment)) && (flag2 || (array[i].transform.TryGetComponent<EnemyIdentifierIdentifier>(out var component2) && (bool)component2.eid && !component2.eid.dead)))
			{
				if (flag2)
				{
					flag = true;
				}
				worldPosition = (flag2 ? array[i].transform.position : array[i].point);
				num = array[i].distance;
				gameObject = array[i].transform.gameObject;
			}
		}
		if ((bool)gameObject)
		{
			if (aimAtHead && !flag && (critDamageOverride != 0f || (beamType == BeamType.Revolver && !strongAlt)) && gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component3) && (bool)component3.eid && (bool)component3.eid.weakPoint && !Physics.Raycast(beam.transform.position, component3.eid.weakPoint.transform.position - beam.transform.position, Vector3.Distance(component3.eid.weakPoint.transform.position, beam.transform.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				worldPosition = component3.eid.weakPoint.transform.position;
			}
			beam.transform.LookAt(worldPosition);
		}
	}
}



public class RevolverBeamParticle : MonoBehaviour
{
	public int type;

	private Revolver rev;

	private SecondaryRevolver secRev;

	private void Awake()
	{
		if (type == 0)
		{
			rev = MonoSingleton<CameraController>.Instance.GetComponentInChildren<Revolver>();
		}
		else if (type == 1)
		{
			secRev = MonoSingleton<CameraController>.Instance.GetComponentInChildren<SecondaryRevolver>();
		}
		if (rev != null)
		{
			base.transform.forward = rev.hit.normal;
		}
		else if (secRev != null)
		{
			base.transform.forward = secRev.hit.normal;
		}
		Invoke("Destroy", 2f);
	}

	private void Destroy()
	{
		Object.Destroy(base.gameObject);
	}
}



public class RevolverCylinder : MonoBehaviour
{
	public int bulletAmount = 6;

	public Vector3 rotationAxis;

	public float speed;

	private AudioSource aud;

	private int target;

	private Quaternion currentRotation;

	private Quaternion[] allRotations;

	private bool freeSpinning;

	[HideInInspector]
	public float spinSpeed;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		currentRotation = base.transform.localRotation;
		allRotations = new Quaternion[bulletAmount];
		for (int i = 0; i < bulletAmount; i++)
		{
			allRotations[i] = base.transform.localRotation * Quaternion.Euler(rotationAxis * (360 / bulletAmount) * i);
		}
	}

	private void LateUpdate()
	{
		if (spinSpeed * 10f > speed)
		{
			freeSpinning = true;
			currentRotation *= Quaternion.Euler(rotationAxis * Time.deltaTime * spinSpeed * 10f);
		}
		else if (freeSpinning)
		{
			freeSpinning = false;
			target = GetClosestTarget();
		}
		if (!freeSpinning && Quaternion.Angle(currentRotation, allRotations[target]) > 0.1f)
		{
			currentRotation = Quaternion.RotateTowards(currentRotation, allRotations[target], Time.deltaTime * speed);
			if (Quaternion.Angle(currentRotation, allRotations[target]) <= 0.1f)
			{
				currentRotation = allRotations[target];
				aud?.Play();
			}
		}
		base.transform.localRotation = currentRotation;
	}

	public void DoTurn()
	{
		target++;
		if (target >= allRotations.Length)
		{
			target = 0;
		}
	}

	private int GetClosestTarget()
	{
		int result = 0;
		float num = Quaternion.Angle(currentRotation, allRotations[0]);
		for (int i = 1; i < bulletAmount; i++)
		{
			float num2 = Quaternion.Angle(currentRotation, allRotations[i]);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}
}



public class RocketLauncher : MonoBehaviour
{
	public int variation;

	public GameObject rocket;

	public GameObject clunkSound;

	public float rateOfFire;

	private float cooldown = 0.25f;

	private bool lookingForValue;

	private AudioSource aud;

	private Animator anim;

	private WeaponIdentifier wid;

	public Transform shootPoint;

	public GameObject muzzleFlash;

	[SerializeField]
	private Image timerMeter;

	[SerializeField]
	private RectTransform timerArm;

	[SerializeField]
	private Image[] variationColorables;

	private float[] colorablesTransparencies;

	private WeaponPos wpos;

	[Header("Freeze variation")]
	[SerializeField]
	private AudioSource timerFreezeSound;

	[SerializeField]
	private AudioSource timerUnfreezeSound;

	[SerializeField]
	private AudioSource timerTickSound;

	[HideInInspector]
	public AudioSource currentTimerTickSound;

	[SerializeField]
	private AudioSource timerWindupSound;

	private float lastKnownTimerAmount;

	[Header("Cannonball variation")]
	public Rigidbody cannonBall;

	[SerializeField]
	private AudioSource chargeSound;

	private float cbCharge;

	private bool firingCannonball;

	[Header("Napalm variation")]
	[SerializeField]
	private Rigidbody napalmProjectile;

	private float napalmProjectileCooldown;

	[SerializeField]
	private Transform napalmMuzzleFlashTransform;

	[SerializeField]
	private ParticleSystem napalmMuzzleFlashParticles;

	[SerializeField]
	private AudioSource[] napalmMuzzleFlashSounds;

	[SerializeField]
	private AudioSource napalmStopSound;

	[SerializeField]
	private AudioSource napalmNoAmmoSound;

	private bool firingNapalm;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		wid = GetComponent<WeaponIdentifier>();
		anim = GetComponent<Animator>();
		wpos = GetComponent<WeaponPos>();
		colorablesTransparencies = new float[variationColorables.Length];
		for (int i = 0; i < variationColorables.Length; i++)
		{
			colorablesTransparencies[i] = variationColorables[i].color.a;
		}
		if (variation == 0 && (!wid || wid.delay == 0f))
		{
			MonoSingleton<WeaponCharges>.Instance.rocketLauncher = this;
		}
	}

	private void OnEnable()
	{
		if (MonoSingleton<WeaponCharges>.Instance.rocketset)
		{
			MonoSingleton<WeaponCharges>.Instance.rocketset = false;
			if (MonoSingleton<WeaponCharges>.Instance.rocketcharge < 0.25f)
			{
				cooldown = 0.25f;
			}
			else
			{
				cooldown = MonoSingleton<WeaponCharges>.Instance.rocketcharge;
			}
		}
		else
		{
			lookingForValue = true;
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<WeaponCharges>.Instance.rocketcharge = cooldown;
			MonoSingleton<WeaponCharges>.Instance.rocketset = true;
			cbCharge = 0f;
			firingCannonball = false;
		}
	}

	private void OnDestroy()
	{
		if ((bool)currentTimerTickSound)
		{
			Object.Destroy(currentTimerTickSound.gameObject);
		}
	}

	private void Update()
	{
		if (!MonoSingleton<ColorBlindSettings>.Instance)
		{
			return;
		}
		Color color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation];
		float num = 1f;
		if (MonoSingleton<WeaponCharges>.Instance.rocketset && lookingForValue)
		{
			MonoSingleton<WeaponCharges>.Instance.rocketset = false;
			lookingForValue = false;
			if (MonoSingleton<WeaponCharges>.Instance.rocketcharge < 0.25f)
			{
				cooldown = 0.25f;
			}
			else
			{
				cooldown = MonoSingleton<WeaponCharges>.Instance.rocketcharge;
			}
		}
		if (variation == 1)
		{
			if (MonoSingleton<GunControl>.Instance.activated && !GameStateManager.Instance.PlayerInputLocked)
			{
				if ((bool)timerArm)
				{
					timerArm.localRotation = Quaternion.Euler(0f, 0f, Mathf.Lerp(360f, 0f, MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge));
				}
				if ((bool)timerMeter)
				{
					timerMeter.fillAmount = MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge;
				}
				if (lastKnownTimerAmount != MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge && (!wid || wid.delay == 0f))
				{
					for (float num2 = 4f; num2 > 0f; num2 -= 1f)
					{
						if (MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge >= num2 / 4f && lastKnownTimerAmount < num2 / 4f)
						{
							AudioSource audioSource = Object.Instantiate(timerWindupSound);
							audioSource.pitch = 1.6f + num2 * 0.1f;
							if (MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge < 1f)
							{
								audioSource.volume /= 2f;
							}
							break;
						}
					}
					lastKnownTimerAmount = MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge;
				}
				if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && !MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge >= 1f)
				{
					if (!wid || wid.delay == 0f)
					{
						if (!chargeSound.isPlaying)
						{
							chargeSound.Play();
						}
						chargeSound.pitch = cbCharge + 0.5f;
					}
					cbCharge = Mathf.MoveTowards(cbCharge, 1f, Time.deltaTime);
					base.transform.localPosition = new Vector3(wpos.currentDefault.x + Random.Range(cbCharge / 100f * -1f, cbCharge / 100f), wpos.currentDefault.y + Random.Range(cbCharge / 100f * -1f, cbCharge / 100f), wpos.currentDefault.z + Random.Range(cbCharge / 100f * -1f, cbCharge / 100f));
					if ((bool)timerArm)
					{
						timerArm.localRotation = Quaternion.Euler(0f, 0f, Mathf.Lerp(360f, 0f, cbCharge));
					}
					if ((bool)timerMeter)
					{
						timerMeter.fillAmount = cbCharge;
					}
				}
				else if (cbCharge > 0f && !firingCannonball)
				{
					chargeSound.Stop();
					if (!wid || wid.delay == 0f)
					{
						ShootCannonball();
					}
					else
					{
						Invoke("ShootCannonball", wid.delay);
						firingCannonball = true;
					}
					MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge = 0f;
				}
			}
			if (cbCharge > 0f)
			{
				color = Color.Lerp(MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation], Color.red, cbCharge);
			}
			else if (MonoSingleton<WeaponCharges>.Instance.rocketCannonballCharge < 1f)
			{
				num = 0.5f;
			}
		}
		else if (variation == 0)
		{
			if (MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime > 0f && MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && !GameStateManager.Instance.PlayerInputLocked && (!wid || !wid.duplicate))
			{
				if (MonoSingleton<WeaponCharges>.Instance.rocketFrozen)
				{
					UnfreezeRockets();
				}
				else
				{
					FreezeRockets();
				}
			}
			if ((bool)timerArm)
			{
				timerArm.localRotation = Quaternion.Euler(0f, 0f, Mathf.Lerp(360f, 0f, MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime / 5f));
			}
			if ((bool)timerMeter)
			{
				timerMeter.fillAmount = MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime / 5f;
			}
			if (lastKnownTimerAmount != MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime && (!wid || wid.delay == 0f))
			{
				for (float num3 = 4f; num3 > 0f; num3 -= 1f)
				{
					if (MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime / 5f >= num3 / 4f && lastKnownTimerAmount / 5f < num3 / 4f)
					{
						Object.Instantiate(timerWindupSound).pitch = 0.6f + num3 * 0.1f;
						break;
					}
				}
				lastKnownTimerAmount = MonoSingleton<WeaponCharges>.Instance.rocketFreezeTime;
			}
		}
		else if (variation == 2)
		{
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && !GameStateManager.Instance.PlayerInputLocked && MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && !MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel > 0f && (firingNapalm || MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel >= 0.25f))
			{
				if (cooldown < 0.5f)
				{
					if (!firingNapalm)
					{
						napalmMuzzleFlashTransform.localScale = Vector3.one * 3f;
						napalmMuzzleFlashParticles.Play();
						AudioSource[] array = napalmMuzzleFlashSounds;
						foreach (AudioSource obj in array)
						{
							obj.pitch = Random.Range(0.9f, 1.1f);
							obj.Play();
						}
					}
					firingNapalm = true;
				}
			}
			else if (firingNapalm)
			{
				firingNapalm = false;
				napalmMuzzleFlashParticles.Stop();
				AudioSource[] array = napalmMuzzleFlashSounds;
				foreach (AudioSource audioSource2 in array)
				{
					if (audioSource2.loop)
					{
						audioSource2.Stop();
					}
				}
				napalmStopSound.pitch = Random.Range(0.9f, 1.1f);
				napalmStopSound.Play();
			}
			else if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel < 0.25f)
			{
				napalmNoAmmoSound.Play();
			}
			if (!firingNapalm && napalmMuzzleFlashTransform.localScale != Vector3.zero)
			{
				napalmMuzzleFlashTransform.localScale = Vector3.MoveTowards(napalmMuzzleFlashTransform.localScale, Vector3.zero, Time.deltaTime * 9f);
			}
			if ((bool)timerArm)
			{
				timerArm.localRotation = Quaternion.Euler(0f, 0f, Mathf.Lerp(360f, 0f, MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel));
			}
			if ((bool)timerMeter)
			{
				timerMeter.fillAmount = MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel;
			}
			if (lastKnownTimerAmount != MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel && (!wid || wid.delay == 0f))
			{
				if (MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel >= 0.25f && lastKnownTimerAmount < 0.25f)
				{
					Object.Instantiate(timerWindupSound);
				}
				lastKnownTimerAmount = MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel;
			}
			if (!firingNapalm && MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel < 0.25f)
			{
				color = Color.grey;
			}
		}
		if (cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime);
		}
		else if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && MonoSingleton<GunControl>.Instance.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (!wid || wid.delay == 0f)
			{
				Shoot();
			}
			else
			{
				Invoke("Shoot", wid.delay);
				cooldown = 1f;
			}
		}
		for (int j = 0; j < variationColorables.Length; j++)
		{
			variationColorables[j].color = new Color(color.r, color.g, color.b, colorablesTransparencies[j] * num);
		}
	}

	private void FixedUpdate()
	{
		if (napalmProjectileCooldown > 0f)
		{
			napalmProjectileCooldown = Mathf.MoveTowards(napalmProjectileCooldown, 0f, Time.fixedDeltaTime);
		}
		if (firingNapalm && napalmProjectileCooldown == 0f)
		{
			ShootNapalm();
		}
	}

	public void Shoot()
	{
		if ((bool)aud)
		{
			aud.pitch = Random.Range(0.9f, 1.1f);
			aud.Play();
		}
		if (variation == 1 && cbCharge > 0f)
		{
			chargeSound.Stop();
			cbCharge = 0f;
		}
		Object.Instantiate(muzzleFlash, shootPoint.position, MonoSingleton<CameraController>.Instance.transform.rotation);
		anim.SetTrigger("Fire");
		cooldown = rateOfFire;
		GameObject gameObject = Object.Instantiate(rocket, MonoSingleton<CameraController>.Instance.transform.position, MonoSingleton<CameraController>.Instance.transform.rotation);
		if ((bool)MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget && MonoSingleton<CameraFrustumTargeter>.Instance.IsAutoAimed)
		{
			gameObject.transform.LookAt(MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget.bounds.center);
		}
		Grenade component = gameObject.GetComponent<Grenade>();
		if ((bool)component)
		{
			component.sourceWeapon = MonoSingleton<GunControl>.Instance.currentWeapon;
		}
		MonoSingleton<CameraController>.Instance.CameraShake(0.75f);
		MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.GunFire, base.gameObject);
	}

	public void ShootCannonball()
	{
		if ((bool)aud)
		{
			aud.pitch = Random.Range(0.6f, 0.8f);
			aud.Play();
		}
		base.transform.localPosition = wpos.currentDefault;
		Object.Instantiate(muzzleFlash, shootPoint.position, MonoSingleton<CameraController>.Instance.transform.rotation);
		anim.SetTrigger("Fire");
		cooldown = rateOfFire;
		Rigidbody rigidbody = Object.Instantiate(cannonBall, MonoSingleton<CameraController>.Instance.transform.position + MonoSingleton<CameraController>.Instance.transform.forward, MonoSingleton<CameraController>.Instance.transform.rotation);
		if ((bool)MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget && MonoSingleton<CameraFrustumTargeter>.Instance.IsAutoAimed)
		{
			rigidbody.transform.LookAt(MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget.bounds.center);
		}
		rigidbody.velocity = rigidbody.transform.forward * Mathf.Max(15f, cbCharge * 150f);
		if (rigidbody.TryGetComponent<Cannonball>(out var component))
		{
			component.sourceWeapon = MonoSingleton<GunControl>.Instance.currentWeapon;
		}
		MonoSingleton<CameraController>.Instance.CameraShake(0.75f);
		cbCharge = 0f;
		firingCannonball = false;
	}

	public void ShootNapalm()
	{
		anim.SetTrigger("Spray");
		napalmProjectileCooldown = 0.02f;
		MonoSingleton<WeaponCharges>.Instance.rocketNapalmFuel -= 0.015f;
		Rigidbody rigidbody = Object.Instantiate(napalmProjectile, MonoSingleton<CameraController>.Instance.transform.position + MonoSingleton<CameraController>.Instance.transform.forward, MonoSingleton<CameraController>.Instance.transform.rotation);
		if ((bool)MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget && MonoSingleton<CameraFrustumTargeter>.Instance.IsAutoAimed)
		{
			rigidbody.transform.LookAt(MonoSingleton<CameraFrustumTargeter>.Instance.CurrentTarget.bounds.center);
		}
		rigidbody.transform.Rotate(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)));
		rigidbody.velocity = rigidbody.transform.forward * 150f;
		MonoSingleton<CameraController>.Instance.CameraShake(0.15f);
	}

	public void FreezeRockets()
	{
		MonoSingleton<WeaponCharges>.Instance.rocketFrozen = true;
		if (!wid || wid.delay == 0f)
		{
			MonoSingleton<WeaponCharges>.Instance.timeSinceIdleFrozen = 0f;
			Object.Instantiate(timerFreezeSound);
			if (!currentTimerTickSound)
			{
				currentTimerTickSound = Object.Instantiate(timerTickSound);
			}
		}
	}

	public void UnfreezeRockets()
	{
		MonoSingleton<WeaponCharges>.Instance.rocketFrozen = false;
		if (!wid || wid.delay == 0f)
		{
			MonoSingleton<WeaponCharges>.Instance.canAutoUnfreeze = false;
			Object.Instantiate(timerUnfreezeSound);
			if ((bool)currentTimerTickSound)
			{
				Object.Destroy(currentTimerTickSound.gameObject);
			}
		}
	}

	public void Clunk(float pitch)
	{
		GameObject obj = Object.Instantiate(clunkSound, base.transform.position, Quaternion.identity);
		MonoSingleton<CameraController>.Instance.CameraShake(0.25f);
		if (obj.TryGetComponent<AudioSource>(out var component))
		{
			component.pitch = Random.Range(pitch - 0.1f, pitch + 0.1f);
		}
	}
}



public class RoomArea : MonoBehaviour
{
	public State roomType;

	private RoomManager rm;

	private string roomName;

	private void Awake()
	{
		rm = GameObject.FindWithTag("RoomManager").GetComponent<RoomManager>();
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			ChangeLevel();
		}
	}

	private void ChangeLevel()
	{
		if (roomType == State.Hallway)
		{
			rm.SwitchRooms("Hallway");
		}
		else if (roomType == State.Room)
		{
			rm.SwitchRooms("Room");
		}
	}
}



public class RoomManager : MonoBehaviour
{
	public List<int> visitedRooms = new List<int>();

	private int nextRoom;

	private int newRoomChance;

	private int newRoomMinChance = 4;

	public int totalLevels;

	public int rooms;

	public int clearedHallways;

	public int clearedRooms;

	public bool allClear;

	private Text roomAmount;

	private RandomSoundPlayer rsp;

	private bool fadeToFin;

	private void Awake()
	{
		roomAmount = GetComponentInChildren<Text>();
		rsp = GetComponentInChildren<RandomSoundPlayer>();
	}

	private void Update()
	{
		if (fadeToFin)
		{
			AudioSource component = GameObject.FindWithTag("EndingSong").GetComponent<AudioSource>();
			AudioSource component2 = GameObject.FindWithTag("EndingSongReverb").GetComponent<AudioSource>();
			Time.timeScale = 0.1f;
			Time.fixedDeltaTime = 0.002f;
			if (component.volume < 1f)
			{
				component.volume += 10f * Time.deltaTime;
			}
			component2.volume -= 10f * Time.deltaTime;
		}
	}

	public void SwitchRooms(string roomType)
	{
		if (roomType == "Hallway")
		{
			newRoomChance = Random.Range(0, newRoomMinChance);
			if (clearedRooms < rooms && totalLevels >= 4 && newRoomChance == 0)
			{
				int num = 0;
				while (num == 0)
				{
					nextRoom = Random.Range(1, rooms + 1);
					num++;
					foreach (int visitedRoom in visitedRooms)
					{
						if (nextRoom == visitedRoom)
						{
							num = 0;
						}
					}
				}
			}
		}
		else if (roomType == "Room")
		{
			newRoomChance = Random.Range(0, newRoomMinChance);
			if (clearedHallways < rooms && totalLevels >= 4 && newRoomChance == 0)
			{
				int num2 = 0;
				while (num2 == 0)
				{
					nextRoom = Random.Range(rooms + 1, rooms * 2 + 1);
					num2++;
					foreach (int visitedRoom2 in visitedRooms)
					{
						if (nextRoom == visitedRoom2)
						{
							num2 = 0;
						}
					}
				}
			}
		}
		if (clearedRooms == rooms && clearedHallways == rooms && !allClear)
		{
			Application.LoadLevel(rooms * 2 + 1);
			allClear = true;
			rsp.playing = false;
			return;
		}
		if (allClear)
		{
			fadeToFin = true;
			Invoke("EndingStart", 0.1f);
			return;
		}
		if ((newRoomChance > 0 || totalLevels < 4 || clearedRooms == rooms) && roomType == "Hallway")
		{
			Application.LoadLevel(1);
			Invoke("RoomSwitched", 0.1f);
			if (newRoomChance > 0)
			{
				newRoomMinChance--;
			}
			return;
		}
		if ((newRoomChance > 0 || totalLevels < 4 || clearedHallways == rooms) && roomType == "Room")
		{
			Application.LoadLevel(rooms + 1);
			Invoke("RoomSwitched", 0.1f);
			if (newRoomChance > 0)
			{
				newRoomMinChance--;
			}
			return;
		}
		if (roomType == "Hallway")
		{
			clearedRooms++;
		}
		else if (roomType == "Room")
		{
			clearedHallways++;
		}
		visitedRooms.Add(nextRoom);
		Application.LoadLevel(nextRoom);
		Invoke("RoomSwitched", 0.1f);
		newRoomMinChance = Random.Range(3, 6);
	}

	private void RoomSwitched()
	{
		totalLevels++;
		if (totalLevels < 10)
		{
			roomAmount.text = "00" + totalLevels;
		}
		else if (totalLevels < 100)
		{
			roomAmount.text = "0" + totalLevels;
		}
		else if (totalLevels < 1000)
		{
			roomAmount.text = string.Concat(totalLevels);
		}
		else
		{
			roomAmount.text = "???";
		}
		rsp.RollForPlay();
	}

	private void EndingStart()
	{
		Application.LoadLevel(rooms * 2 + 2);
		Object.Destroy(base.gameObject);
	}
}



internal class RotateToFaceFrustumTarget : MonoBehaviour
{
	[SerializeField]
	private CameraFrustumTargeter targeter;

	[SerializeField]
	private float maxDegreesDelta;

	private void Update()
	{
		Quaternion to = (base.transform.parent ? base.transform.parent.rotation : Quaternion.identity);
		if ((bool)targeter && targeter.isActiveAndEnabled && CameraFrustumTargeter.IsEnabled && (bool)targeter.CurrentTarget)
		{
			to = Quaternion.LookRotation(targeter.CurrentTarget.bounds.center - base.transform.position);
		}
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * maxDegreesDelta);
	}
}



public class RotateToTarget : MonoBehaviour
{
	public Vector3 target;

	public bool onEnable;

	public bool oneTime;

	private bool beenActivated;

	private bool rotating;

	public float speed;

	public bool easeTowards;

	public UltrakillEvent onComplete;

	private void OnEnable()
	{
		if (onEnable && (!oneTime || !beenActivated))
		{
			Rotate();
		}
	}

	public void Rotate()
	{
		if (!beenActivated || !oneTime)
		{
			beenActivated = true;
			rotating = true;
		}
	}

	private void Update()
	{
		if (rotating)
		{
			base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, Quaternion.Euler(target), speed * Time.deltaTime * (easeTowards ? (Mathf.Min(Quaternion.Angle(base.transform.localRotation, Quaternion.Euler(target)) + speed / 10f, speed) / speed) : 1f));
			if (Quaternion.Angle(base.transform.localRotation, Quaternion.Euler(target)) < 0.1f)
			{
				base.transform.localRotation = Quaternion.Euler(target);
				rotating = false;
				onComplete?.Invoke();
			}
		}
	}
}



public class Rotator : MonoBehaviour
{
	public Vector3 rotation;

	public float rotationTime = 1f;

	private Quaternion initialRotation;

	private float rotationProgress;

	public AnimationCurve customCurve;

	public EasingFunction.Ease easingFunction;

	private EasingFunction.Function selectedEasingFunction;

	public UltrakillEvent doAThing;

	public void StartRotate()
	{
		StartCoroutine(Rotate());
	}

	private IEnumerator Rotate()
	{
		rotationProgress = 0f;
		initialRotation = base.transform.rotation;
		selectedEasingFunction = EasingFunction.GetEasingFunction(easingFunction);
		while (rotationProgress < 1f)
		{
			rotationProgress += Time.deltaTime / rotationTime;
			float a = ((customCurve != null) ? customCurve.Evaluate(rotationProgress) : selectedEasingFunction(0f, 1f, rotationProgress));
			a = Mathf.Min(a, 1f);
			base.transform.rotation = Quaternion.LerpUnclamped(initialRotation, initialRotation * Quaternion.Euler(rotation), a);
			yield return null;
		}
		doAThing.Invoke();
	}
}


public class RumbleKey
{
	public string name { get; private set; }

	public int hashKey { get; private set; }

	public RumbleKey(string name)
	{
		this.name = name;
		hashKey = name.GetHashCode();
	}

	public override string ToString()
	{
		return name;
	}

	public override bool Equals(object obj)
	{
		if (obj is RumbleKey rumbleKey)
		{
			return rumbleKey.hashKey == hashKey;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return hashKey;
	}
}



public class RumbleKeyOptionEntry : MonoBehaviour
{
	public RumbleKey key;

	public TMP_Text keyName;

	public Slider intensitySlider;

	public Slider durationSlider;

	public Button intensityWrapper;

	public Button durationWrapper;

	public GameObject durationContainer;

	public void ResetIntensity()
	{
		intensitySlider.SetValueWithoutNotify(MonoSingleton<RumbleManager>.Instance.ResolveDefaultIntensity(key));
		MonoSingleton<PrefsManager>.Instance.DeleteKey(string.Format("{0}{1}", key, ".intensity"));
	}

	public void ResetDuration()
	{
		durationSlider.SetValueWithoutNotify(MonoSingleton<RumbleManager>.Instance.ResolveDefaultDuration(key));
		MonoSingleton<PrefsManager>.Instance.DeleteKey(string.Format("{0}{1}", key, ".duration"));
	}

	public void SetIntensity(float value)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat(string.Format("{0}{1}", key, ".intensity"), value);
	}

	public void SetDuration(float value)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat(string.Format("{0}{1}", key, ".duration"), value);
	}
}



[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class RumbleManager : MonoSingleton<RumbleManager>
{
	public readonly Dictionary<RumbleKey, PendingVibration> pendingVibrations = new Dictionary<RumbleKey, PendingVibration>();

	private List<RumbleKey> discardedKeys = new List<RumbleKey>();

	private static readonly Dictionary<RumbleKey, float> rumbleDurations = new Dictionary<RumbleKey, float>
	{
		{
			RumbleProperties.Slide,
			float.PositiveInfinity
		},
		{
			RumbleProperties.WhiplashThrow,
			float.PositiveInfinity
		},
		{
			RumbleProperties.WhiplashPull,
			float.PositiveInfinity
		},
		{
			RumbleProperties.RailcannonIdle,
			float.PositiveInfinity
		},
		{
			RumbleProperties.ShotgunCharge,
			float.PositiveInfinity
		},
		{
			RumbleProperties.NailgunFire,
			float.PositiveInfinity
		},
		{
			RumbleProperties.RevolverCharge,
			float.PositiveInfinity
		},
		{
			RumbleProperties.FallImpact,
			0.5f
		},
		{
			RumbleProperties.FallImpactHeavy,
			0.5f
		},
		{
			RumbleProperties.Jump,
			0.2f
		},
		{
			RumbleProperties.Dash,
			0.2f
		},
		{
			RumbleProperties.Punch,
			0.2f
		},
		{
			RumbleProperties.Sawblade,
			0.2f
		},
		{
			RumbleProperties.GunFire,
			0.4f
		},
		{
			RumbleProperties.SuperSaw,
			0.7f
		},
		{
			RumbleProperties.GunFireStrong,
			0.7f
		},
		{
			RumbleProperties.GunFireProjectiles,
			0.8f
		},
		{
			RumbleProperties.ParryFlash,
			0.1f
		},
		{
			RumbleProperties.CoinToss,
			0.1f
		},
		{
			RumbleProperties.Magnet,
			0.1f
		},
		{
			RumbleProperties.WeaponWheelTick,
			0.025f
		}
	};

	public static readonly Dictionary<RumbleKey, float> rumbleIntensities = new Dictionary<RumbleKey, float>
	{
		{
			RumbleProperties.Slide,
			0.1f
		},
		{
			RumbleProperties.Dash,
			0.2f
		},
		{
			RumbleProperties.FallImpact,
			0.2f
		},
		{
			RumbleProperties.Jump,
			0.1f
		},
		{
			RumbleProperties.FallImpactHeavy,
			0.5f
		},
		{
			RumbleProperties.WhiplashThrow,
			0.2f
		},
		{
			RumbleProperties.WhiplashPull,
			0.35f
		},
		{
			RumbleProperties.GunFire,
			0.8f
		},
		{
			RumbleProperties.GunFireStrong,
			1f
		},
		{
			RumbleProperties.GunFireProjectiles,
			0.7f
		},
		{
			RumbleProperties.RailcannonIdle,
			0.2f
		},
		{
			RumbleProperties.NailgunFire,
			0.2f
		},
		{
			RumbleProperties.SuperSaw,
			0.7f
		},
		{
			RumbleProperties.ShotgunCharge,
			0.7f
		},
		{
			RumbleProperties.Sawblade,
			0.5f
		},
		{
			RumbleProperties.RevolverCharge,
			0.5f
		},
		{
			RumbleProperties.Punch,
			0.2f
		},
		{
			RumbleProperties.ParryFlash,
			0.2f
		},
		{
			RumbleProperties.Magnet,
			0.2f
		},
		{
			RumbleProperties.CoinToss,
			0.1f
		},
		{
			RumbleProperties.WeaponWheelTick,
			0.05f
		}
	};

	public static readonly Dictionary<RumbleKey, string> fullNames = new Dictionary<RumbleKey, string>
	{
		{
			RumbleProperties.Slide,
			"Sliding"
		},
		{
			RumbleProperties.Dash,
			"Dashing"
		},
		{
			RumbleProperties.FallImpact,
			"Fall Impact"
		},
		{
			RumbleProperties.Jump,
			"Jumping"
		},
		{
			RumbleProperties.FallImpactHeavy,
			"Heavy Fall Impact"
		},
		{
			RumbleProperties.WhiplashThrow,
			"Whiplash Throw"
		},
		{
			RumbleProperties.WhiplashPull,
			"Whiplash Pull"
		},
		{
			RumbleProperties.GunFire,
			"Gun Fire"
		},
		{
			RumbleProperties.GunFireStrong,
			"Stronger Gun Fire"
		},
		{
			RumbleProperties.GunFireProjectiles,
			"Gun Fire (projectiles)"
		},
		{
			RumbleProperties.RailcannonIdle,
			"Railcannon Idle"
		},
		{
			RumbleProperties.NailgunFire,
			"Nailgun Fire"
		},
		{
			RumbleProperties.Sawblade,
			"Sawblade"
		},
		{
			RumbleProperties.SuperSaw,
			"Super Saw"
		},
		{
			RumbleProperties.Magnet,
			"Magnet"
		},
		{
			RumbleProperties.ShotgunCharge,
			"Shotgun Charge"
		},
		{
			RumbleProperties.RevolverCharge,
			"Revolver Charge"
		},
		{
			RumbleProperties.ParryFlash,
			"Parry Flash"
		},
		{
			RumbleProperties.CoinToss,
			"Coin Toss"
		},
		{
			RumbleProperties.Punch,
			"Punching"
		},
		{
			RumbleProperties.WeaponWheelTick,
			"Weapon Wheel Tick"
		}
	};

	public float currentIntensity { get; private set; }

	public PendingVibration SetVibration(RumbleKey key)
	{
		if (pendingVibrations.TryGetValue(key, out var value))
		{
			value.timeSinceStart = 0f;
			if (value.isTracking)
			{
				value.isTracking = false;
			}
			return value;
		}
		PendingVibration pendingVibration = new PendingVibration
		{
			key = key,
			timeSinceStart = 0f,
			isTracking = false
		};
		pendingVibrations.Add(key, pendingVibration);
		return pendingVibration;
	}

	public PendingVibration SetVibrationTracked(RumbleKey key, GameObject tracked)
	{
		if (pendingVibrations.TryGetValue(key, out var value))
		{
			value.timeSinceStart = 0f;
			value.isTracking = true;
			value.trackedObject = tracked;
			return value;
		}
		PendingVibration pendingVibration = new PendingVibration
		{
			key = key,
			timeSinceStart = 0f,
			isTracking = true,
			trackedObject = tracked
		};
		pendingVibrations.Add(key, pendingVibration);
		return pendingVibration;
	}

	public void StopVibration(RumbleKey key)
	{
		if (pendingVibrations.ContainsKey(key))
		{
			pendingVibrations.Remove(key);
		}
	}

	public void StopAllVibrations()
	{
		pendingVibrations.Clear();
	}

	private void Update()
	{
		discardedKeys.Clear();
		foreach (KeyValuePair<RumbleKey, PendingVibration> pendingVibration in pendingVibrations)
		{
			if (pendingVibration.Value.isTracking && (pendingVibration.Value.trackedObject == null || !pendingVibration.Value.trackedObject.activeInHierarchy))
			{
				discardedKeys.Add(pendingVibration.Key);
			}
			else if (pendingVibration.Value.IsFinished)
			{
				discardedKeys.Add(pendingVibration.Key);
			}
		}
		foreach (RumbleKey discardedKey in discardedKeys)
		{
			pendingVibrations.Remove(discardedKey);
		}
		float num = 0f;
		foreach (KeyValuePair<RumbleKey, PendingVibration> pendingVibration2 in pendingVibrations)
		{
			if (pendingVibration2.Value.Intensity > num)
			{
				num = pendingVibration2.Value.Intensity;
			}
		}
		num *= MonoSingleton<PrefsManager>.Instance.GetFloat("totalRumbleIntensity");
		if ((bool)MonoSingleton<OptionsManager>.Instance && MonoSingleton<OptionsManager>.Instance.paused)
		{
			num = 0f;
		}
		currentIntensity = num;
		if (Gamepad.current != null)
		{
			Gamepad.current.SetMotorSpeeds(num, num);
		}
	}

	private void OnDisable()
	{
		if (Gamepad.current != null)
		{
			Gamepad.current.SetMotorSpeeds(0f, 0f);
		}
	}

	public float ResolveDuration(RumbleKey key)
	{
		string key2 = key.name + ".duration";
		if (MonoSingleton<PrefsManager>.Instance.HasKey(key2))
		{
			return MonoSingleton<PrefsManager>.Instance.GetFloat(key2);
		}
		return ResolveDefaultDuration(key);
	}

	public float ResolveDefaultDuration(RumbleKey key)
	{
		if (rumbleDurations.TryGetValue(key, out var value))
		{
			return value;
		}
		Debug.LogError("No duration found for key: " + key);
		return 0.5f;
	}

	public float ResolveIntensity(RumbleKey key)
	{
		if (MonoSingleton<PrefsManager>.Instance.HasKey(key.name + ".intensity"))
		{
			return MonoSingleton<PrefsManager>.Instance.GetFloat(key.name + ".intensity");
		}
		return ResolveDefaultIntensity(key);
	}

	public float ResolveDefaultIntensity(RumbleKey key)
	{
		if (rumbleIntensities.TryGetValue(key, out var value))
		{
			return value;
		}
		Debug.LogError("No intensity found for key: " + key);
		return 0.5f;
	}

	public static string ResolveFullName(RumbleKey key)
	{
		if (fullNames.ContainsKey(key))
		{
			return fullNames[key];
		}
		return key.ToString();
	}
}


public static class RumbleProperties
{
	public static readonly RumbleKey Slide = new RumbleKey("rumble.slide");

	public static readonly RumbleKey Jump = new RumbleKey("rumble.jump");

	public static readonly RumbleKey FallImpact = new RumbleKey("rumble.fall_impact");

	public static readonly RumbleKey FallImpactHeavy = new RumbleKey("rumble.fall_impact_heave");

	public static readonly RumbleKey Dash = new RumbleKey("rumble.dash");

	public static readonly RumbleKey WhiplashThrow = new RumbleKey("rumble.whiplash.throw");

	public static readonly RumbleKey WhiplashPull = new RumbleKey("rumble.whiplash.pull");

	public static readonly RumbleKey GunFire = new RumbleKey("rumble.gun.fire");

	public static readonly RumbleKey GunFireStrong = new RumbleKey("rumble.gun.fire_strong");

	public static readonly RumbleKey GunFireProjectiles = new RumbleKey("rumble.gun.fire_projectiles");

	public static readonly RumbleKey RailcannonIdle = new RumbleKey("rumble.gun.railcannon_idle");

	public static readonly RumbleKey ShotgunCharge = new RumbleKey("rumble.gun.shotgun_charge");

	public static readonly RumbleKey RevolverCharge = new RumbleKey("rumble.gun.revolver_charge");

	public static readonly RumbleKey NailgunFire = new RumbleKey("rumble.gun.nailgun_fire");

	public static readonly RumbleKey Sawblade = new RumbleKey("rumble.gun.sawblade");

	public static readonly RumbleKey SuperSaw = new RumbleKey("rumble.gun.super_saw");

	public static readonly RumbleKey Magnet = new RumbleKey("rumble.magnet_released");

	public static readonly RumbleKey ParryFlash = new RumbleKey("rumble.parry_flash");

	public static readonly RumbleKey CoinToss = new RumbleKey("rumble.coin_toss");

	public static readonly RumbleKey Punch = new RumbleKey("rumble.punch");

	public static readonly RumbleKey WeaponWheelTick = new RumbleKey("rumble.weapon_wheel_tick");

	public static readonly RumbleKey[] All = new RumbleKey[21]
	{
		Slide, Jump, FallImpact, FallImpactHeavy, Dash, WhiplashThrow, WhiplashPull, GunFire, GunFireStrong, GunFireProjectiles,
		RailcannonIdle, ShotgunCharge, RevolverCharge, NailgunFire, Sawblade, SuperSaw, Magnet, ParryFlash, CoinToss, Punch,
		WeaponWheelTick
	};
}



public class RumbleSettingsMenu : MonoBehaviour
{
	[SerializeField]
	private RumbleKeyOptionEntry optionTemplate;

	[SerializeField]
	private Transform container;

	[SerializeField]
	private Button totalWrapper;

	[SerializeField]
	private Button quitButton;

	[SerializeField]
	private Slider totalSlider;

	private void Start()
	{
		optionTemplate.gameObject.SetActive(value: false);
		Button button = totalWrapper;
		RumbleKey[] all = RumbleProperties.All;
		foreach (RumbleKey key in all)
		{
			RumbleKeyOptionEntry option = Object.Instantiate(optionTemplate, container);
			option.gameObject.SetActive(value: true);
			option.key = key;
			option.keyName.text = RumbleManager.ResolveFullName(key);
			float num = MonoSingleton<RumbleManager>.Instance.ResolveDuration(key);
			if (num >= float.PositiveInfinity)
			{
				option.durationContainer.gameObject.SetActive(value: false);
			}
			else
			{
				option.durationSlider.SetValueWithoutNotify(num);
				option.durationSlider.onValueChanged.AddListener(delegate(float value)
				{
					option.SetDuration(value);
				});
			}
			option.intensitySlider.SetValueWithoutNotify(MonoSingleton<RumbleManager>.Instance.ResolveIntensity(key));
			option.intensitySlider.onValueChanged.AddListener(delegate(float value)
			{
				option.SetIntensity(value);
			});
			Navigation navigation = option.intensityWrapper.navigation;
			navigation.selectOnUp = button;
			option.intensityWrapper.navigation = navigation;
			navigation = button.navigation;
			navigation.selectOnDown = option.intensityWrapper;
			button.navigation = navigation;
			button = (option.durationContainer.gameObject.activeSelf ? option.durationWrapper : option.intensityWrapper);
			if (button == null)
			{
				Debug.LogError("Previous button is null");
			}
		}
		Navigation navigation2 = button.navigation;
		navigation2.selectOnDown = quitButton;
		button.navigation = navigation2;
		Navigation navigation3 = quitButton.navigation;
		navigation3.selectOnUp = button;
		quitButton.navigation = navigation3;
		totalSlider.SetValueWithoutNotify(MonoSingleton<PrefsManager>.Instance.GetFloat("totalRumbleIntensity"));
	}

	public void ChangeMasterMulti(float value)
	{
		MonoSingleton<PrefsManager>.Instance.SetFloat("totalRumbleIntensity", value);
	}

	public void Show()
	{
		base.gameObject.SetActive(value: true);
	}
}



public class SandboxAltar : MonoBehaviour, IAlter, IAlterOptions<bool>, IAlterOptions<int>
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxAltar");

	public AltarType altarType;

	private AssetReference[] altarPrefabs;

	[SerializeField]
	private GameObject skullPrefab;

	[SerializeField]
	private Transform defaultLocation;

	[SerializeField]
	private Collider altarTrigger;

	[SerializeField]
	private Altars altars;

	private bool hasSkull;

	private GameObject skull;

	public string alterKey => "ultrakill.sandbox.altar";

	public string alterCategoryName => "Sandbox";

	AlterOption<bool>[] IAlterOptions<bool>.options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			name = "Has Skull",
			key = "hasSkull",
			value = hasSkull,
			callback = SetSkullActive
		}
	};

	AlterOption<int>[] IAlterOptions<int>.options => new AlterOption<int>[1]
	{
		new AlterOption<int>
		{
			name = "Altar Type",
			key = "altarType",
			value = (int)altarType,
			type = typeof(AltarType),
			callback = delegate(int value)
			{
				if (value != (int)altarType)
				{
					altarType = (AltarType)value;
					Log.Info($"Changing altar type to {altarType}");
					GameObject gameObject = Object.Instantiate(altars.altarPrefabs[value].ToAsset(), base.transform.position, base.transform.rotation, base.transform.parent);
					SandboxAltar component = gameObject.GetComponent<SandboxAltar>();
					component.altarType = altarType;
					component.SetSkullActive(hasSkull);
					MonoSingleton<SandboxAlterMenu>.Instance.alterInstance.OpenProp(gameObject.GetComponent<SandboxSpawnableInstance>());
					Object.Destroy(base.gameObject);
				}
			}
		}
	};

	private void Awake()
	{
		skullPrefab.SetActive(value: false);
	}

	public void CreateSkull()
	{
		if (!hasSkull && !skull)
		{
			GameObject gameObject = Object.Instantiate(skullPrefab, defaultLocation.position, defaultLocation.rotation, defaultLocation.parent);
			gameObject.transform.localScale = skullPrefab.transform.localScale;
			skullPrefab.SetActive(value: false);
			gameObject.SetActive(value: true);
			skull = gameObject;
			hasSkull = true;
			if (altarTrigger != null)
			{
				altarTrigger.enabled = false;
			}
		}
	}

	public void SetSkullActive(bool active)
	{
		Log.Info("Setting skull to " + active);
		skullPrefab.SetActive(value: false);
		if (active)
		{
			CreateSkull();
		}
		else
		{
			RemoveSkull();
		}
	}

	public void RemoveSkull()
	{
		if (hasSkull)
		{
			Log.Info("Deleting skull");
			Object.Destroy(skull);
			hasSkull = false;
			if (altarTrigger != null)
			{
				altarTrigger.enabled = true;
			}
		}
	}
}



public class SandboxGhostEffect : MonoBehaviour
{
	public Collider targetCollider;

	private const float scaleMulti = 1.3f;

	private const float duration = 0.2f;

	private Vector3 originalScale;

	private TimeSince timeSinceStart;

	private void Awake()
	{
		originalScale = base.transform.localScale;
		base.transform.localScale *= 1.3f;
		timeSinceStart = 0f;
	}

	private void Update()
	{
		base.transform.localScale = Vector3.Lerp(originalScale * 1.3f, originalScale, (float)timeSinceStart / 0.2f);
		if ((float)timeSinceStart >= 0.2f)
		{
			Object.Destroy(base.gameObject);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxHud : MonoSingleton<SandboxHud>
{
	[Header("Nav")]
	[SerializeField]
	private CanvasGroup navmeshNoticeGroup;

	[Space]
	[SerializeField]
	private GameObject sandboxSavesWindow;

	[SerializeField]
	private SandboxSaveItem sandboxSaveTemplate;

	[SerializeField]
	private Transform savesContainer;

	[Space]
	[SerializeField]
	private InputField newSaveName;

	[SerializeField]
	private Button newSaveButton;

	public static bool SavesMenuOpen
	{
		get
		{
			if ((bool)MonoSingleton<SandboxHud>.Instance)
			{
				return MonoSingleton<SandboxHud>.Instance.sandboxSavesWindow.activeSelf;
			}
			return false;
		}
	}

	private void Start()
	{
		navmeshNoticeGroup.alpha = 0f;
		UpdateNewSaveInput();
	}

	private void ResetSavesMenu()
	{
		sandboxSaveTemplate.gameObject.SetActive(value: false);
		for (int i = 1; i < savesContainer.childCount; i++)
		{
			Object.Destroy(savesContainer.GetChild(i).gameObject);
		}
	}

	private void BuildSavesMenu()
	{
		ResetSavesMenu();
		string[] array = MonoSingleton<SandboxSaver>.Instance.ListSaves();
		foreach (string save in array)
		{
			SandboxSaveItem sandboxSaveItem = Object.Instantiate(sandboxSaveTemplate);
			sandboxSaveItem.transform.SetParent(savesContainer, worldPositionStays: false);
			sandboxSaveItem.gameObject.SetActive(value: true);
			sandboxSaveItem.saveName.text = save + "<color=#7A7A7A>.pitr</color>";
			sandboxSaveItem.deleteButton.onClick.AddListener(delegate
			{
				MonoSingleton<SandboxSaver>.Instance.Delete(save);
				BuildSavesMenu();
			});
			sandboxSaveItem.loadButton.onClick.AddListener(delegate
			{
				MonoSingleton<SandboxSaver>.Instance.Load(save);
				HideSavesMenu();
				MonoSingleton<CheatsManager>.Instance.HideMenu();
				if (MonoSingleton<OptionsManager>.Instance.paused)
				{
					MonoSingleton<OptionsManager>.Instance.UnPause();
				}
			});
			sandboxSaveItem.saveButton.onClick.AddListener(delegate
			{
				MonoSingleton<SandboxSaver>.Instance.Save(save);
				BuildSavesMenu();
			});
		}
	}

	public void OpenDirectory()
	{
		Application.OpenURL("file://" + SandboxSaver.SavePath);
	}

	public void UpdateNewSaveInput()
	{
		if (string.IsNullOrEmpty(newSaveName.text))
		{
			newSaveButton.interactable = false;
		}
		else
		{
			newSaveButton.interactable = !Path.GetInvalidFileNameChars().Any(((IEnumerable<char>)newSaveName.text).Contains<char>);
		}
	}

	public void NewSave()
	{
		MonoSingleton<SandboxSaver>.Instance.Save(newSaveName.text);
		newSaveName.text = string.Empty;
		UpdateNewSaveInput();
		BuildSavesMenu();
	}

	public void HideSavesMenu()
	{
		sandboxSavesWindow.SetActive(value: false);
	}

	public void ShowSavesMenu()
	{
		BuildSavesMenu();
		UpdateNewSaveInput();
		sandboxSavesWindow.SetActive(value: true);
	}

	public void NavmeshDirty()
	{
		navmeshNoticeGroup.alpha = 1f;
		StopAllCoroutines();
		CancelInvoke("NavmeshStartFadeOut");
		Invoke("NavmeshStartFadeOut", 3f);
	}

	private void NavmeshStartFadeOut()
	{
		StopAllCoroutines();
		StartCoroutine(FadeOutNotice());
	}

	private IEnumerator FadeOutNotice()
	{
		navmeshNoticeGroup.alpha = 1f;
		yield return null;
		while (navmeshNoticeGroup.alpha > 0f)
		{
			navmeshNoticeGroup.alpha -= Time.deltaTime;
			yield return null;
		}
		HideNavmeshNotice();
	}

	public void HideNavmeshNotice()
	{
		navmeshNoticeGroup.alpha = 0f;
	}
}



public class SandboxIconSwitcher : MonoBehaviour
{
	public int iconPack;

	public void SwitchIconPack()
	{
		MonoSingleton<IconManager>.Instance.SetIconPack(iconPack);
		MonoSingleton<IconManager>.Instance.Reload();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxNavmesh : MonoSingleton<SandboxNavmesh>
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxNavmesh");

	[SerializeField]
	private NavMeshSurface surface;

	public bool isDirty;

	public UnityAction navmeshBuilt;

	private Vector3 defaultCenter;

	private Vector3 defaultSize;

	protected override void Awake()
	{
		base.Awake();
		defaultCenter = surface.center;
		defaultSize = surface.size;
	}

	public void MarkAsDirty(SandboxSpawnableInstance instance)
	{
		if (!isDirty && (!instance || (instance.frozen && (!(instance.sourceObject != null) || (!instance.sourceObject.isWater && !instance.sourceObject.triggerOnly && instance.sourceObject.spawnableObjectType != SpawnableObject.SpawnableObjectDataType.Enemy)))))
		{
			MonoSingleton<SandboxHud>.Instance.NavmeshDirty();
			isDirty = true;
			MonoSingleton<CheatsManager>.Instance.RenderCheatsInfo();
		}
	}

	public void Rebake()
	{
		surface.BuildNavMesh();
		Log.Info("Navmesh built");
		isDirty = false;
		MonoSingleton<SandboxHud>.Instance.HideNavmeshNotice();
		if (navmeshBuilt != null)
		{
			navmeshBuilt();
		}
		MonoSingleton<CheatsManager>.Instance.RenderCheatsInfo();
	}

	private void OnDrawGizmos()
	{
		if (!(surface == null))
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawWireCube(surface.center + base.transform.position, surface.size);
		}
	}

	public void ResetSizeToDefault()
	{
		surface.center = defaultCenter;
		surface.size = defaultSize;
	}

	public void EnsurePositionWithinBounds(Vector3 worldPosition)
	{
		Vector3 vector = surface.center + base.transform.position;
		float num = 1f;
		if (worldPosition.x < vector.x - surface.size.x / 2f)
		{
			float num2 = vector.x - surface.size.x / 2f - worldPosition.x + num;
			surface.center = new Vector3(surface.center.x - num2 / 2f, surface.center.y, surface.center.z);
			surface.size = new Vector3(surface.size.x + num2, surface.size.y, surface.size.z);
		}
		else if (worldPosition.x > vector.x + surface.size.x / 2f)
		{
			float num3 = worldPosition.x - (vector.x + surface.size.x / 2f) + num;
			surface.center = new Vector3(surface.center.x + num3 / 2f, surface.center.y, surface.center.z);
			surface.size = new Vector3(surface.size.x + num3, surface.size.y, surface.size.z);
		}
		if (worldPosition.y < vector.y - surface.size.y / 2f)
		{
			float num4 = vector.y - surface.size.y / 2f - worldPosition.y + num;
			surface.center = new Vector3(surface.center.x, surface.center.y - num4 / 2f, surface.center.z);
			surface.size = new Vector3(surface.size.x, surface.size.y + num4, surface.size.z);
		}
		else if (worldPosition.y > vector.y + surface.size.y / 2f)
		{
			float num5 = worldPosition.y - (vector.y + surface.size.y / 2f) + num;
			surface.center = new Vector3(surface.center.x, surface.center.y + num5 / 2f, surface.center.z);
			surface.size = new Vector3(surface.size.x, surface.size.y + num5, surface.size.z);
		}
		if (worldPosition.z < vector.z - surface.size.z / 2f)
		{
			float num6 = vector.z - surface.size.z / 2f - worldPosition.z + num;
			surface.center = new Vector3(surface.center.x, surface.center.y, surface.center.z - num6 / 2f);
			surface.size = new Vector3(surface.size.x, surface.size.y, surface.size.z + num6);
		}
		else if (worldPosition.z > vector.z + surface.size.z / 2f)
		{
			float num7 = worldPosition.z - (vector.z + surface.size.z / 2f) + num;
			surface.center = new Vector3(surface.center.x, surface.center.y, surface.center.z + num7 / 2f);
			surface.size = new Vector3(surface.size.x, surface.size.y, surface.size.z + num7);
		}
	}
}



public class SandboxPropPart : MonoBehaviour
{
	public SandboxSpawnableInstance parent;

	private void Awake()
	{
		if (parent == null)
		{
			parent = GetComponentInParent<SandboxSpawnableInstance>();
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxSaveConfirmation : MonoSingleton<SandboxSaveConfirmation>
{
	[SerializeField]
	private GameObject saveConfirmationDialog;

	[SerializeField]
	private GameObject blocker;

	public void ConfirmSave()
	{
		MonoSingleton<SandboxSaver>.Instance.QuickSave();
		saveConfirmationDialog.SetActive(value: false);
		blocker.SetActive(value: false);
	}

	public void DisplayDialog()
	{
		saveConfirmationDialog.SetActive(value: true);
		blocker.SetActive(value: true);
	}
}



[Serializable]
public class SandboxSaveData
{
	public string MapName;

	public string MapIdentifier;

	public int SaveVersion = 2;

	public string GameVersion = Application.version;

	public SavedBlock[] Blocks;

	public SavedProp[] Props;

	public SavedEnemy[] Enemies;
}



public class SandboxSaveItem : MonoBehaviour
{
	public TMP_Text saveName;

	public Button saveButton;

	public Button loadButton;

	public Button deleteButton;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxSaver : MonoSingleton<SandboxSaver>
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxSaver");

	public const string SaveExtension = ".pitr";

	[SerializeField]
	private SpawnableObjectsDatabase objects;

	private Dictionary<string, SpawnableObject> registeredObjects;

	public string activeSave;

	public static string SavePath => Path.Combine(GameProgressSaver.BaseSavePath, "Sandbox");

	private static void SetupDirs()
	{
		if (!Directory.Exists(SavePath))
		{
			Directory.CreateDirectory(SavePath);
		}
	}

	public string[] ListSaves()
	{
		SetupDirs();
		return (from f in new DirectoryInfo(SavePath).GetFileSystemInfos()
			orderby f.LastWriteTime descending
			select Path.GetFileNameWithoutExtension(f.Name)).ToArray();
	}

	public void QuickSave()
	{
		Save($"{DateTime.Now.Year}-{DateTime.Now.Month}-{DateTime.Now.Day} {DateTime.Now.Hour}-{DateTime.Now.Minute}-{DateTime.Now.Second}");
	}

	public void QuickLoad()
	{
		string[] array = ListSaves();
		if (array.Length != 0)
		{
			Load(array[0]);
		}
	}

	public void Delete(string name)
	{
		SetupDirs();
		string path = Path.Combine(SavePath, name + ".pitr");
		if (File.Exists(path))
		{
			File.Delete(path);
		}
	}

	public void Save(string name)
	{
		SetupDirs();
		activeSave = name;
		MonoSingleton<CheatsManager>.Instance.RefreshCheatStates();
		CreateSaveAndWrite(name);
	}

	public void Load(string name)
	{
		Log.Info("Loading save: " + name);
		SetupDirs();
		Clear();
		activeSave = name;
		MonoSingleton<CheatsManager>.Instance.RefreshCheatStates();
		RebuildObjectList();
		SandboxSaveData sandboxSaveData = JsonConvert.DeserializeObject<SandboxSaveData>(File.ReadAllText(Path.Combine(SavePath, name + ".pitr")));
		Log.Fine($"Loaded {sandboxSaveData.Blocks.Length} blocks\nLoaded {sandboxSaveData.Props.Length} props");
		Log.Fine("Save Version: " + sandboxSaveData.SaveVersion);
		Vector3? vector = null;
		Vector3 position = MonoSingleton<NewMovement>.Instance.transform.position;
		SavedProp[] props = sandboxSaveData.Props;
		foreach (SavedProp savedProp in props)
		{
			RecreateProp(savedProp, sandboxSaveData.SaveVersion > 1);
			if (!(savedProp.ObjectIdentifier != "ultrakill.spawn-point"))
			{
				if (!vector.HasValue)
				{
					vector = savedProp.Position.ToVector3();
				}
				else if (Vector3.Distance(position, savedProp.Position.ToVector3()) < Vector3.Distance(position, vector.Value))
				{
					vector = savedProp.Position.ToVector3();
				}
			}
		}
		if (vector.HasValue)
		{
			MonoSingleton<NewMovement>.Instance.transform.position = vector.Value;
			MonoSingleton<NewMovement>.Instance.rb.velocity = Vector3.zero;
		}
		SavedBlock[] blocks = sandboxSaveData.Blocks;
		foreach (SavedBlock block in blocks)
		{
			RecreateBlock(block);
		}
		MonoSingleton<SandboxNavmesh>.Instance.Rebake();
		List<SandboxEnemy> list = new List<SandboxEnemy>();
		SavedEnemy[] enemies = sandboxSaveData.Enemies;
		foreach (SavedEnemy genericObject in enemies)
		{
			SandboxEnemy sandboxEnemy = RecreateEnemy(genericObject, sandboxSaveData.SaveVersion > 1);
			sandboxEnemy.Pause(freeze: false);
			list.Add(sandboxEnemy);
		}
		StartCoroutine(PostLoadAndBake(list));
	}

	private IEnumerator PostLoadAndBake(List<SandboxEnemy> enemies)
	{
		yield return new WaitForEndOfFrame();
		List<SandboxEnemy> enemiesToFreezeBack = new List<SandboxEnemy>();
		foreach (SandboxEnemy enemy in enemies)
		{
			bool frozen = enemy.frozen;
			enemy.Resume();
			if (frozen)
			{
				enemiesToFreezeBack.Add(enemy);
			}
		}
		yield return new WaitForEndOfFrame();
		foreach (SandboxEnemy item in enemiesToFreezeBack)
		{
			item.Pause();
		}
	}

	public SandboxEnemy RecreateEnemy(SavedGeneric genericObject, bool newSizing)
	{
		if (!registeredObjects.TryGetValue(genericObject.ObjectIdentifier, out var value))
		{
			Log.Error(genericObject.ObjectIdentifier + " missing from registered objects");
			return null;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(value.gameObject);
		gameObject.transform.position = genericObject.Position.ToVector3();
		if (!newSizing)
		{
			gameObject.transform.localScale = genericObject.Scale.ToVector3();
		}
		if (gameObject.TryGetComponent<KeepInBounds>(out var component))
		{
			component.ForceApproveNewPosition();
		}
		SandboxEnemy sandboxEnemy = gameObject.AddComponent<SandboxEnemy>();
		sandboxEnemy.sourceObject = registeredObjects[genericObject.ObjectIdentifier];
		sandboxEnemy.enemyId.checkingSpawnStatus = false;
		sandboxEnemy.RestoreRadiance(((SavedEnemy)genericObject).Radiance);
		if (genericObject is SavedPhysical { Kinematic: not false })
		{
			sandboxEnemy.Pause();
		}
		if (newSizing)
		{
			sandboxEnemy.SetSize(genericObject.Scale.ToVector3());
		}
		sandboxEnemy.disallowManipulation = genericObject.DisallowManipulation;
		sandboxEnemy.disallowFreezing = genericObject.DisallowFreezing;
		ApplyData(gameObject, genericObject.Data);
		MonoSingleton<SandboxNavmesh>.Instance.EnsurePositionWithinBounds(gameObject.transform.position);
		return sandboxEnemy;
	}

	private void RecreateProp(SavedProp prop, bool newSizing)
	{
		if (!registeredObjects.TryGetValue(prop.ObjectIdentifier, out var value))
		{
			Log.Error(prop.ObjectIdentifier + " missing from registered objects");
			return;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(value.gameObject);
		gameObject.transform.SetPositionAndRotation(prop.Position.ToVector3(), prop.Rotation.ToQuaternion());
		if (!newSizing)
		{
			gameObject.transform.localScale = prop.Scale.ToVector3();
		}
		SandboxProp component = gameObject.GetComponent<SandboxProp>();
		component.sourceObject = registeredObjects[prop.ObjectIdentifier];
		if (newSizing)
		{
			component.SetSize(prop.Scale.ToVector3());
		}
		if (prop.Kinematic)
		{
			component.Pause();
		}
		else
		{
			component.Resume();
		}
		component.disallowManipulation = prop.DisallowManipulation;
		component.disallowFreezing = prop.DisallowFreezing;
		ApplyData(gameObject, prop.Data);
	}

	private void RecreateBlock(SavedBlock block)
	{
		if (!registeredObjects.TryGetValue(block.ObjectIdentifier, out var value))
		{
			Log.Error(block.ObjectIdentifier + " missing from registered objects");
			return;
		}
		GameObject gameObject = SandboxUtils.CreateFinalBlock(value, block.Position.ToVector3(), block.BlockSize.ToVector3(), value.isWater);
		gameObject.transform.rotation = block.Rotation.ToQuaternion();
		SandboxProp component = gameObject.GetComponent<SandboxProp>();
		component.sourceObject = registeredObjects[block.ObjectIdentifier];
		if (block.Kinematic)
		{
			component.Pause();
		}
		else
		{
			component.Resume();
		}
		component.disallowManipulation = block.DisallowManipulation;
		component.disallowFreezing = block.DisallowFreezing;
		ApplyData(gameObject, block.Data);
	}

	private void ApplyData(GameObject go, SavedAlterData[] data)
	{
		if (data == null)
		{
			return;
		}
		IAlter[] componentsInChildren = go.GetComponentsInChildren<IAlter>();
		foreach (IAlter alterComponent in componentsInChildren)
		{
			if (alterComponent.alterKey == null)
			{
				continue;
			}
			if (!data.Select((SavedAlterData d) => d.Key).Contains(alterComponent.alterKey))
			{
				Log.Warning("No data for " + alterComponent.alterKey + " on " + go.name);
				continue;
			}
			SavedAlterData savedAlterData = data.FirstOrDefault((SavedAlterData d) => d.Key == alterComponent.alterKey);
			if (savedAlterData == null)
			{
				continue;
			}
			SavedAlterOption[] options2 = savedAlterData.Options;
			foreach (SavedAlterOption options in options2)
			{
				if (options.BoolValue.HasValue && alterComponent is IAlterOptions<bool> alterOptions)
				{
					AlterOption<bool> alterOption = alterOptions.options.FirstOrDefault((AlterOption<bool> o) => o.key == options.Key);
					if (alterOption == null)
					{
						continue;
					}
					alterOption.callback?.Invoke(options.BoolValue.Value);
				}
				if (options.FloatValue.HasValue && alterComponent is IAlterOptions<float> alterOptions2)
				{
					AlterOption<float> alterOption2 = alterOptions2.options.FirstOrDefault((AlterOption<float> o) => o.key == options.Key);
					if (alterOption2 == null)
					{
						continue;
					}
					alterOption2.callback?.Invoke(options.FloatValue.Value);
				}
				if (options.IntValue.HasValue && alterComponent is IAlterOptions<int> alterOptions3)
				{
					alterOptions3.options.FirstOrDefault((AlterOption<int> o) => o.key == options.Key)?.callback?.Invoke(options.IntValue.Value);
				}
			}
		}
	}

	public void RebuildObjectList()
	{
		if (registeredObjects == null)
		{
			registeredObjects = new Dictionary<string, SpawnableObject>();
		}
		registeredObjects.Clear();
		RegisterObjects(objects.objects);
		RegisterObjects(objects.enemies);
		RegisterObjects(objects.sandboxTools);
		RegisterObjects(objects.sandboxObjects);
		RegisterObjects(objects.specialSandbox);
	}

	private void RegisterObjects(SpawnableObject[] objs)
	{
		foreach (SpawnableObject spawnableObject in objs)
		{
			if (!string.IsNullOrEmpty(spawnableObject.identifier) && !registeredObjects.ContainsKey(spawnableObject.identifier))
			{
				registeredObjects.Add(spawnableObject.identifier, spawnableObject);
			}
		}
	}

	public static void Clear()
	{
		DefaultSandboxCheckpoint defaultSandboxCheckpoint = MonoSingleton<DefaultSandboxCheckpoint>.Instance;
		if (defaultSandboxCheckpoint == null)
		{
			MonoSingleton<StatsManager>.Instance.currentCheckPoint = null;
		}
		else
		{
			MonoSingleton<StatsManager>.Instance.currentCheckPoint = defaultSandboxCheckpoint.checkpoint;
		}
		SandboxSpawnableInstance[] array = UnityEngine.Object.FindObjectsOfType<SandboxSpawnableInstance>();
		foreach (SandboxSpawnableInstance sandboxSpawnableInstance in array)
		{
			if (sandboxSpawnableInstance.enabled)
			{
				UnityEngine.Object.Destroy(sandboxSpawnableInstance.gameObject);
			}
		}
		Resources.UnloadUnusedAssets();
		MonoSingleton<SandboxNavmesh>.Instance.ResetSizeToDefault();
		MonoSingleton<SandboxSaver>.Instance.activeSave = null;
		MonoSingleton<CheatsManager>.Instance.RefreshCheatStates();
	}

	private static void CreateSaveAndWrite(string name)
	{
		Log.Info("Creating save");
		SandboxProp[] array = UnityEngine.Object.FindObjectsOfType<SandboxProp>();
		Log.Fine($"{array.Length} props found");
		BrushBlock[] array2 = UnityEngine.Object.FindObjectsOfType<BrushBlock>();
		Log.Fine($"{array2.Length} procedural blocks found");
		SandboxEnemy[] array3 = UnityEngine.Object.FindObjectsOfType<SandboxEnemy>();
		Log.Fine($"{array3.Length} sandbox enemies found");
		List<SavedBlock> list = new List<SavedBlock>();
		BrushBlock[] array4 = array2;
		foreach (BrushBlock brushBlock in array4)
		{
			if (brushBlock.enabled)
			{
				Log.Finer($"Position: {brushBlock.transform.position}\nRotation: {brushBlock.transform.rotation}\nSize: {brushBlock.DataSize}\nType: {brushBlock.Type}");
				list.Add(brushBlock.SaveBrushBlock());
			}
		}
		List<SavedProp> list2 = new List<SavedProp>();
		SandboxProp[] array5 = array;
		foreach (SandboxProp sandboxProp in array5)
		{
			if (!sandboxProp.GetComponent<BrushBlock>() && sandboxProp.enabled)
			{
				Log.Finer($"Position: {sandboxProp.transform.position}\nRotation: {sandboxProp.transform.rotation}");
				list2.Add(sandboxProp.SaveProp());
			}
		}
		List<SavedEnemy> list3 = new List<SavedEnemy>();
		SandboxEnemy[] array6 = array3;
		foreach (SandboxEnemy sandboxEnemy in array6)
		{
			if (sandboxEnemy.enabled)
			{
				SavedEnemy savedEnemy = sandboxEnemy.SaveEnemy();
				if (savedEnemy != null)
				{
					list3.Add(savedEnemy);
				}
			}
		}
		string contents = JsonConvert.SerializeObject(new SandboxSaveData
		{
			MapName = SceneManager.GetActiveScene().name,
			Blocks = list.ToArray(),
			Props = list2.ToArray(),
			Enemies = list3.ToArray()
		});
		File.WriteAllText(Path.Combine(SavePath, name + ".pitr"), contents);
	}
}



public static class SandboxUtils
{
	public const float SnapGrid = 0.5f;

	private const float MeshDensity = 0.25f;

	private const float UvScale = 1f;

	private const float PreviewBlockUvScale = 0.05f;

	public static void StripForPreview(Transform target, Material newMaterial = null, bool first = true)
	{
		Component[] components = target.GetComponents<Component>();
		if (first)
		{
			Canvas[] componentsInChildren = target.GetComponentsInChildren<Canvas>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				UnityEngine.Object.Destroy(componentsInChildren[i].gameObject);
			}
			List<Component> list = new List<Component>();
			list.AddRange(target.GetComponentsInChildren<Joint>(includeInactive: true));
			list.AddRange(target.GetComponentsInChildren<Sisyphus>(includeInactive: true));
			list.AddRange(target.GetComponentsInChildren<AudioDistortionFilter>(includeInactive: true));
			list.AddRange(target.GetComponentsInChildren<AudioHighPassFilter>(includeInactive: true));
			list.AddRange(target.GetComponentsInChildren<AudioLowPassFilter>(includeInactive: true));
			list.AddRange(target.GetComponentsInChildren<ProBuilderMesh>(includeInactive: true));
			foreach (Component item in list)
			{
				UnityEngine.Object.Destroy(item);
			}
		}
		if (!first && ((bool)target.GetComponent<RemoveOnTime>() || (bool)target.GetComponent<SpawnEffect>() || (target.TryGetComponent<BoxCollider>(out var component) && component.isTrigger)))
		{
			UnityEngine.Object.Destroy(target.gameObject);
			return;
		}
		Component[] array = components;
		foreach (Component component2 in array)
		{
			if ((bool)newMaterial && component2 is Renderer renderer)
			{
				renderer.materials = ToMaterialArray(newMaterial, renderer.materials.Length);
			}
			else if (!(component2 as Transform) && !(component2 as MeshFilter) && !(component2 as MeshRenderer) && !(component2 as SkinnedMeshRenderer))
			{
				UnityEngine.Object.Destroy(component2);
			}
		}
		foreach (Transform item2 in target.transform)
		{
			StripForPreview(item2, newMaterial, first: false);
		}
	}

	public static SandboxSpawnableInstance GetProp(GameObject from, bool ignoreManipulationBlock = false)
	{
		SandboxSpawnableInstance sandboxSpawnableInstance = from.GetComponent<SandboxSpawnableInstance>();
		if ((bool)sandboxSpawnableInstance && !sandboxSpawnableInstance.enabled)
		{
			return null;
		}
		if (!sandboxSpawnableInstance)
		{
			SandboxPropPart component = from.GetComponent<SandboxPropPart>();
			if ((bool)component && (bool)component.parent)
			{
				sandboxSpawnableInstance = component.parent;
			}
		}
		if (!sandboxSpawnableInstance)
		{
			EnemyIdentifierIdentifier component2 = from.GetComponent<EnemyIdentifierIdentifier>();
			if ((bool)component2 && (bool)component2.eid)
			{
				sandboxSpawnableInstance = component2.eid.GetComponent<SandboxSpawnableInstance>();
				if (sandboxSpawnableInstance == null)
				{
					sandboxSpawnableInstance = component2.eid.GetComponentInParent<SandboxSpawnableInstance>();
				}
			}
		}
		if (!sandboxSpawnableInstance)
		{
			EnemyIdentifier component3 = from.GetComponent<EnemyIdentifier>();
			if ((bool)component3)
			{
				sandboxSpawnableInstance = component3.GetComponentInParent<SandboxSpawnableInstance>();
			}
		}
		if (sandboxSpawnableInstance != null && sandboxSpawnableInstance.enabled && sandboxSpawnableInstance.collider != null && (!sandboxSpawnableInstance.disallowManipulation || ignoreManipulationBlock))
		{
			return sandboxSpawnableInstance;
		}
		return null;
	}

	public static void SetLayerDeep(Transform target, int layer)
	{
		target.gameObject.layer = layer;
		foreach (Transform item in target.transform)
		{
			SetLayerDeep(item, layer);
			if (item.TryGetComponent<OutdoorsChecker>(out var component))
			{
				component.CancelInvoke("SlowUpdate");
				component.enabled = false;
			}
		}
	}

	private static Material[] ToMaterialArray(Material material, int length)
	{
		return Enumerable.Repeat(material, length).ToArray();
	}

	public static Vector3 SnapPos(Vector3 pos)
	{
		return SnapPos(pos, Vector3.zero);
	}

	public static Vector3 SnapPos(Vector3 pos, Vector3 offset, float snapDensity = 0.5f)
	{
		Vector3 vector = pos;
		vector *= snapDensity;
		vector = new Vector3(Mathf.Round(vector.x), Mathf.Round(vector.y), Mathf.Round(vector.z));
		vector = new Vector3(Mathf.Round(vector.x), Mathf.Round(vector.y), Mathf.Round(vector.z));
		vector /= snapDensity;
		return vector + offset;
	}

	public static Vector3 SnapRotation(Vector3 rot)
	{
		float num = 45f;
		rot /= num;
		rot = new Vector3(Mathf.Round(rot.x), Mathf.Round(rot.y), Mathf.Round(rot.z));
		rot *= num;
		return rot;
	}

	public static Mesh GenerateProceduralMesh(Vector3 size, bool simple)
	{
		Vector3 zero = Vector3.zero;
		Vector3 vector = size;
		float num = 0.25f;
		float num2 = 1f;
		float num3 = size.x * size.y * size.z;
		if (num3 > 5000000f)
		{
			num *= 0.5f;
			num2 *= 2f;
		}
		if (num3 > 50000000f)
		{
			num *= 0.25f;
			num2 *= 4f;
		}
		if (num3 > 500000000f)
		{
			num *= 0.125f;
			num2 *= 8f;
		}
		Vector3 vector2 = size * num;
		List<Vector3> vertices = new List<Vector3>();
		List<int> tris = new List<int>();
		List<Vector2> uvs = new List<Vector2>();
		if (simple)
		{
			Vector3 vector3 = zero;
			Vector3 vector4 = new Vector3(vector.x, zero.y, zero.z);
			Vector3 vector5 = new Vector3(zero.x, vector.y, zero.z);
			Vector3 vector6 = new Vector3(vector.x, vector.y, zero.z);
			Vector3 vector7 = new Vector3(zero.x, zero.y, vector.z);
			Vector3 vector8 = new Vector3(vector.x, zero.y, vector.z);
			Vector3 vector9 = new Vector3(zero.x, vector.y, vector.z);
			Vector3 vector10 = vector;
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector4, vector3, vector5, vector6 }, repeatUVs: true, Vector2.zero, new Vector2(vector.x, vector.y), 0.05f);
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector8, vector4, vector6, vector10 }, repeatUVs: true, Vector2.zero, new Vector2(vector.z, vector.y), 0.05f);
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector3, vector7, vector9, vector5 }, repeatUVs: true, Vector2.zero, new Vector2(vector.z, vector.y), 0.05f);
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector7, vector8, vector10, vector9 }, repeatUVs: true, Vector2.zero, new Vector2(vector.x, vector.y), 0.05f);
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector6, vector5, vector9, vector10 }, repeatUVs: true, Vector2.zero, new Vector2(vector.x, vector.z), 0.05f);
			AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector8, vector7, vector3, vector4 }, repeatUVs: true, Vector2.zero, new Vector2(vector.x, vector.z), 0.05f);
		}
		else
		{
			float num4 = 1f / num;
			for (int i = 0; (float)i < vector2.x; i++)
			{
				for (int j = 0; (float)j < vector2.y; j++)
				{
					Vector3 vector11 = new Vector3(PolyClamp(zero.x, vector.x, i, num4), PolyClamp(zero.y, vector.y, j, num4), num4);
					Vector3 vector12 = zero + new Vector3(i, j, 0f) * num4;
					Vector3 vector13 = vector12 + new Vector3(vector11.x, 0f, 0f);
					Vector3 vector14 = vector12 + new Vector3(0f, vector11.y, 0f);
					Vector3 vector15 = vector12 + new Vector3(vector11.x, vector11.y, 0f);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector13, vector12, vector14, vector15 }, repeatUVs: true, new Vector2(i, j), new Vector2(vector11.x, vector11.y) / num4, num2);
					vector12 = new Vector3(zero.x, zero.y, vector.z) + new Vector3(i, j, 0f) * num4;
					vector13 = vector12 + new Vector3(vector11.x, 0f, 0f);
					vector14 = vector12 + new Vector3(0f, vector11.y, 0f);
					vector15 = vector12 + new Vector3(vector11.x, vector11.y, 0f);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector12, vector13, vector15, vector14 }, repeatUVs: true, new Vector2((float)i - vector11.x / num4, j), new Vector2(vector11.x, vector11.y) / num4, num2);
				}
				for (int k = 0; (float)k < vector2.z; k++)
				{
					Vector3 vector16 = new Vector3(PolyClamp(zero.x, vector.x, i, num4), num4, PolyClamp(zero.z, vector.z, k, num4));
					Vector3 vector17 = new Vector3(zero.x, vector.y, zero.z) + new Vector3(i, 0f, k) * num4;
					Vector3 vector18 = vector17 + new Vector3(vector16.x, 0f, 0f);
					Vector3 vector19 = vector17 + new Vector3(0f, 0f, vector16.z);
					Vector3 vector20 = vector17 + new Vector3(vector16.x, 0f, vector16.z);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector18, vector17, vector19, vector20 }, repeatUVs: true, new Vector2(i, k), new Vector2(vector16.x, vector16.z) / num4, num2);
					vector17 = zero + new Vector3(i, 0f, k) * num4;
					vector18 = vector17 + new Vector3(vector16.x, 0f, 0f);
					vector19 = vector17 + new Vector3(0f, 0f, vector16.z);
					vector20 = vector17 + new Vector3(vector16.x, 0f, vector16.z);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector17, vector18, vector20, vector19 }, repeatUVs: true, new Vector2((float)i - vector16.x / num4, k), new Vector2(vector16.x, vector16.z) / num4, num2);
				}
			}
			for (int l = 0; (float)l < vector2.z; l++)
			{
				for (int m = 0; (float)m < vector2.y; m++)
				{
					Vector3 vector21 = new Vector3(num4, PolyClamp(zero.y, vector.y, m, num4), PolyClamp(zero.z, vector.z, l, num4));
					Vector3 vector22 = zero + new Vector3(0f, m, l) * num4;
					Vector3 vector23 = vector22 + new Vector3(0f, 0f, vector21.z);
					Vector3 vector24 = vector22 + new Vector3(0f, vector21.y, 0f);
					Vector3 vector25 = vector22 + new Vector3(0f, vector21.y, vector21.z);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector22, vector23, vector25, vector24 }, repeatUVs: true, new Vector2((float)l - vector21.z / num4, m), new Vector2(vector21.z, vector21.y) / num4, num2);
					vector22 = new Vector3(vector.x, zero.y, zero.z) + new Vector3(0f, m, l) * num4;
					vector23 = vector22 + new Vector3(0f, 0f, vector21.z);
					vector24 = vector22 + new Vector3(0f, vector21.y, 0f);
					vector25 = vector22 + new Vector3(0f, vector21.y, vector21.z);
					AddFaceToMesh(ref vertices, ref tris, ref uvs, new Vector3[4] { vector23, vector22, vector24, vector25 }, repeatUVs: true, new Vector2(l, m), new Vector2(vector21.z, vector21.y) / num4, num2);
				}
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = vertices.ToArray();
		mesh.triangles = tris.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.Optimize();
		mesh.RecalculateNormals();
		mesh.RecalculateTangents();
		mesh.RecalculateBounds();
		return mesh;
	}

	public static void AddFaceToMesh(ref List<Vector3> vertices, ref List<int> tris, ref List<Vector2> uvs, Vector3[] quadPoints, bool repeatUVs = false, Vector2? uvCords = null, Vector2? uvSizeMod = null, float uvScaleOverride = 1f)
	{
		if (quadPoints.Length < 4)
		{
			throw new Exception("Missing quad points");
		}
		Vector2 vector = Vector2.zero;
		if (uvCords.HasValue)
		{
			vector = uvCords.Value;
		}
		Vector2 vector2 = Vector2.one;
		if (uvSizeMod.HasValue)
		{
			vector2 = uvSizeMod.Value;
		}
		int count = vertices.Count;
		vertices.AddRange(new Vector3[4]
		{
			quadPoints[0],
			quadPoints[1],
			quadPoints[2],
			quadPoints[3]
		});
		uvs.AddRange(new Vector2[4]
		{
			(vector + new Vector2(vector2.x, 0f)) * uvScaleOverride,
			vector * uvScaleOverride,
			(vector + new Vector2(0f, vector2.y)) * uvScaleOverride,
			(vector + vector2) * uvScaleOverride
		});
		tris.AddRange(new int[6]
		{
			count,
			count + 1,
			count + 2,
			count + 2,
			count + 3,
			count
		});
	}

	public static float PolyClamp(float a, float b, float i, float units)
	{
		float num = a + i * units;
		float num2 = num + units;
		if (num2 > b)
		{
			return num2 - num - (num2 - b);
		}
		return units;
	}

	public static void SmallerBigger(Vector3 a, Vector3 b, out Vector3 smaller, out Vector3 bigger)
	{
		smaller = new Vector3((a.x > b.x) ? b.x : a.x, (a.y > b.y) ? b.y : a.y, (a.z > b.z) ? b.z : a.z);
		bigger = new Vector3((a.x > b.x) ? a.x : b.x, (a.y > b.y) ? a.y : b.y, (a.z > b.z) ? a.z : b.z);
	}

	public static GameObject CreateFinalBlock(SpawnableObject proceduralTemplate, Vector3 position, Vector3 size, bool liquid = false)
	{
		Debug.Log($"Creating block {size}");
		GameObject gameObject = UnityEngine.Object.Instantiate(proceduralTemplate.gameObject);
		gameObject.transform.position = position;
		BrushBlock component = gameObject.GetComponent<BrushBlock>();
		component.sourceObject = proceduralTemplate;
		component.DataSize = size;
		Mesh mesh = GenerateProceduralMesh(size, liquid);
		SandboxProp component2 = gameObject.GetComponent<SandboxProp>();
		component2.sourceObject = proceduralTemplate;
		gameObject.GetComponent<MeshFilter>().mesh = mesh;
		BoxCollider boxCollider = (component.OverrideCollider ? component.OverrideCollider : gameObject.GetComponent<BoxCollider>());
		boxCollider.size = size;
		boxCollider.center = boxCollider.size / 2f;
		if (liquid)
		{
			GameObject gameObject2 = new GameObject("LiquidTrigger");
			gameObject2.layer = LayerMask.NameToLayer("SandboxGrabbable");
			gameObject2.transform.parent = gameObject.transform;
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localRotation = Quaternion.identity;
			gameObject2.transform.localScale = Vector3.one;
			BoxCollider boxCollider2 = gameObject2.AddComponent<BoxCollider>();
			boxCollider2.isTrigger = true;
			boxCollider2.size = size;
			boxCollider2.center = boxCollider.size / 2f;
			component.WaterTrigger = boxCollider2;
			gameObject2.AddComponent<SandboxPropPart>().parent = component2;
		}
		return gameObject;
	}
}



public class SandificationZone : MonoBehaviour
{
	private int difficulty;

	[HideInInspector]
	public bool buffHealth;

	[HideInInspector]
	public float healthBuff = 1f;

	[HideInInspector]
	public bool buffDamage;

	[HideInInspector]
	public float damageBuff = 1f;

	public bool buffSpeed;

	public float speedBuff = 1f;

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
	}

	private void Enter(Collider other)
	{
		if (other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			if (difficulty >= 3)
			{
				if (MonoSingleton<NewMovement>.Instance.hp > 10)
				{
					MonoSingleton<NewMovement>.Instance.ForceAntiHP(100 - MonoSingleton<NewMovement>.Instance.hp + 10);
				}
				else
				{
					MonoSingleton<NewMovement>.Instance.ForceAntiHP(99f);
				}
			}
			else if (difficulty == 2)
			{
				if (MonoSingleton<NewMovement>.Instance.hp > 10)
				{
					MonoSingleton<NewMovement>.Instance.ForceAntiHP(Mathf.RoundToInt(MonoSingleton<NewMovement>.Instance.antiHp) + 10);
				}
				else
				{
					MonoSingleton<NewMovement>.Instance.ForceAntiHP(99f);
				}
			}
		}
		else
		{
			if (other.gameObject.layer != 10 && other.gameObject.layer != 11)
			{
				return;
			}
			EnemyIdentifierIdentifier component = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
			if ((bool)component && (bool)component.eid && !component.eid.dead)
			{
				component.eid.Sandify();
				if (buffHealth)
				{
					component.eid.HealthBuff(healthBuff);
				}
				if (buffDamage)
				{
					component.eid.DamageBuff(damageBuff);
				}
				if (buffSpeed)
				{
					component.eid.SpeedBuff(speedBuff);
				}
				component.eid.UpdateBuffs();
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		Enter(other);
	}

	private void OnCollisionEnter(Collision collision)
	{
		Enter(collision.collider);
	}
}



[Serializable]
public class SavedAlterData
{
	public string Key;

	public SavedAlterOption[] Options;
}



[Serializable]
public class SavedAlterOption
{
	public string Key;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public float? FloatValue;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public bool? BoolValue;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public Vector3? VectorData;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public int? IntValue;
}



[Serializable]
public class SavedBlock : SavedPhysical
{
	public SavedVector3 BlockSize;

	public BlockType BlockType;
}



[Serializable]
public class SavedEnemy : SavedPhysical
{
	public EnemyRadianceConfig Radiance;
}



[Serializable]
public class SavedGeneric
{
	public string ObjectIdentifier;

	public SavedVector3 Position;

	public SavedQuaternion Rotation;

	public SavedVector3 Scale;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
	public SavedAlterData[] Data;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore, DefaultValueHandling = DefaultValueHandling.Ignore)]
	public bool DisallowManipulation;

	[JsonProperty(NullValueHandling = NullValueHandling.Ignore, DefaultValueHandling = DefaultValueHandling.Ignore)]
	public bool DisallowFreezing;
}



[Serializable]
public class SavedPhysical : SavedGeneric
{
	public bool Kinematic;
}



[Serializable]
public class SavedProp : SavedPhysical
{
}



[Serializable]
public class SavedQuaternion
{
	public float x;

	public float y;

	public float z;

	public float w;

	public SavedQuaternion(Quaternion quaternion)
	{
		x = quaternion.x;
		y = quaternion.y;
		z = quaternion.z;
		w = quaternion.w;
	}

	public Quaternion ToQuaternion()
	{
		return new Quaternion(x, y, z, w);
	}
}



[Serializable]
public class SavedVector3
{
	public float x;

	public float y;

	public float z;

	public static SavedVector3 Zero => new SavedVector3(Vector3.zero);

	public static SavedVector3 One => new SavedVector3(Vector3.one);

	public SavedVector3(Vector3 vector3)
	{
		x = vector3.x;
		y = vector3.y;
		z = vector3.z;
	}

	public Vector3 ToVector3()
	{
		return new Vector3(x, y, z);
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SaveLoadFailMessage : MonoSingleton<SaveLoadFailMessage>
{
	public enum SaveLoadError
	{
		Generic,
		TempValidation
	}

	[SerializeField]
	private GameObject saveMergeConsentPanel;

	[SerializeField]
	private Text rootMergeOptionBtnText;

	[SerializeField]
	private Text slotOneMergeOptionBtnText;

	[SerializeField]
	private GameObject errorGeneric;

	[SerializeField]
	private GameObject errorTempValidation;

	[SerializeField]
	private Text tempErrorCode;

	private SaveLoadError currentError;

	private bool beenActivated;

	private Action potentialSaveRedo;

	private static bool consentQueued;

	private static SaveSlotMenu.SlotData queuedRootSlot;

	private static SaveSlotMenu.SlotData queuedSlotOneData;

	public static void DisplayMergeConsent(SaveSlotMenu.SlotData rootSlot, SaveSlotMenu.SlotData slotOneData)
	{
		if (!MonoSingleton<SaveLoadFailMessage>.Instance)
		{
			queuedRootSlot = rootSlot;
			queuedSlotOneData = slotOneData;
			consentQueued = true;
		}
		else
		{
			MonoSingleton<SaveLoadFailMessage>.Instance.DisplayMergeConsentInstance(rootSlot, slotOneData);
		}
	}

	private void DisplayMergeConsentInstance(SaveSlotMenu.SlotData rootSlot, SaveSlotMenu.SlotData slotOneData)
	{
		rootMergeOptionBtnText.text = $"<b>Saves{Path.DirectorySeparatorChar}</b>\n{rootSlot}";
		slotOneMergeOptionBtnText.text = $"<b>Saves{Path.DirectorySeparatorChar}Slot1{Path.DirectorySeparatorChar}</b>\n{slotOneData}";
		saveMergeConsentPanel.SetActive(value: true);
	}

	private new void OnEnable()
	{
		if (consentQueued)
		{
			consentQueued = false;
			DisplayMergeConsentInstance(queuedRootSlot, queuedSlotOneData);
		}
	}

	public void ConfirmMergeRoot()
	{
		GameProgressSaver.MergeRootWithSlotOne(keepRoot: true);
		SceneHelper.LoadScene("Main Menu");
	}

	public void ConfirmMergeFirstSlot()
	{
		GameProgressSaver.MergeRootWithSlotOne(keepRoot: false);
		SceneHelper.LoadScene("Main Menu");
	}

	public void QuitGame()
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			Application.Quit();
		}
	}

	public void ShowError(SaveLoadError error, string errorCode, Action saveRedo)
	{
		currentError = error;
		switch (error)
		{
		case SaveLoadError.Generic:
			errorGeneric.SetActive(value: true);
			break;
		case SaveLoadError.TempValidation:
			potentialSaveRedo = saveRedo;
			errorTempValidation.SetActive(value: true);
			if (!string.IsNullOrEmpty(errorCode))
			{
				tempErrorCode.text = errorCode;
				tempErrorCode.gameObject.SetActive(value: true);
			}
			break;
		}
		beenActivated = true;
	}

	private void HideAll()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: false);
		}
		beenActivated = false;
	}

	private void Update()
	{
		if (!beenActivated)
		{
			return;
		}
		switch (currentError)
		{
		case SaveLoadError.Generic:
			if (Input.GetKeyDown(KeyCode.Y))
			{
				HideAll();
			}
			if (Input.GetKeyDown(KeyCode.N))
			{
				Application.Quit();
			}
			break;
		case SaveLoadError.TempValidation:
			if (Input.GetKeyDown(KeyCode.Y))
			{
				if (potentialSaveRedo == null)
				{
					break;
				}
				HideAll();
				potentialSaveRedo();
			}
			if (Input.GetKeyDown(KeyCode.N))
			{
				HideAll();
				MonoSingleton<ProgressChecker>.Instance.DisableSaving();
			}
			break;
		}
	}
}



public class SaveSlotMenu : MonoBehaviour
{
	public class SlotData
	{
		public bool exists;

		public int highestLvlNumber;

		public int highestDifficulty;

		public override string ToString()
		{
			if (!exists)
			{
				return "EMPTY";
			}
			return GetMissionName.GetMission(highestLvlNumber) + " " + ((highestLvlNumber <= 0) ? string.Empty : ("(" + MonoSingleton<PresenceController>.Instance.diffNames[highestDifficulty] + ")"));
		}
	}

	public const int Slots = 5;

	private static readonly Color ActiveColor = new Color(1f, 0.66f, 0f);

	[SerializeField]
	private SlotRowPanel templateRow;

	[SerializeField]
	private Button closeButton;

	[FormerlySerializedAs("consentWrapper")]
	[SerializeField]
	private GameObject reloadConsentWrapper;

	[SerializeField]
	private TMP_Text wipeConsentContent;

	[SerializeField]
	private GameObject wipeConsentWrapper;

	private int queuedSlot;

	private SlotRowPanel[] slots;

	private void OnEnable()
	{
		if (slots != null)
		{
			return;
		}
		List<SlotRowPanel> list = new List<SlotRowPanel>();
		SlotData[] array = GameProgressSaver.GetSlots();
		for (int i = 0; i < 5; i++)
		{
			SlotRowPanel newRow = Object.Instantiate(templateRow, templateRow.transform.parent);
			newRow.slotIndex = i;
			newRow.gameObject.SetActive(value: true);
			UpdateSlotState(newRow, array[i]);
			newRow.selectButton.onClick.AddListener(delegate
			{
				SelectSlot(newRow.slotIndex);
			});
			newRow.deleteButton.onClick.AddListener(delegate
			{
				ClearSlot(newRow.slotIndex);
			});
			list.Add(newRow);
		}
		for (int j = 0; j < 5; j++)
		{
			list[j].selectButton.navigation = new Navigation
			{
				mode = Navigation.Mode.Explicit,
				selectOnUp = ((j > 0) ? list[j - 1].selectButton : null),
				selectOnDown = ((j + 1 < 5) ? list[j + 1].selectButton : closeButton),
				selectOnLeft = list[j].deleteButton,
				selectOnRight = list[j].deleteButton
			};
			list[j].deleteButton.navigation = new Navigation
			{
				mode = Navigation.Mode.Explicit,
				selectOnUp = ((j > 0) ? list[j - 1].deleteButton : null),
				selectOnDown = ((j + 1 < 5) ? list[j + 1].deleteButton : closeButton),
				selectOnLeft = list[j].selectButton,
				selectOnRight = list[j].selectButton
			};
		}
		closeButton.navigation = new Navigation
		{
			mode = Navigation.Mode.Explicit,
			selectOnUp = list[4].selectButton,
			selectOnDown = list[0].selectButton
		};
		slots = list.ToArray();
		templateRow.gameObject.SetActive(value: false);
	}

	public void ReloadMenu()
	{
		if (slots != null)
		{
			SlotRowPanel[] array = slots;
			for (int i = 0; i < array.Length; i++)
			{
				Object.Destroy(array[i].gameObject);
			}
			slots = null;
		}
		wipeConsentWrapper.SetActive(value: false);
		reloadConsentWrapper.SetActive(value: false);
		OnEnable();
	}

	private void UpdateSlotState(SlotRowPanel targetPanel, SlotData data)
	{
		bool flag = GameProgressSaver.currentSlot == targetPanel.slotIndex;
		targetPanel.backgroundPanel.color = (flag ? ActiveColor : Color.black);
		targetPanel.slotNumberLabel.color = (flag ? Color.black : (data.exists ? Color.white : Color.red));
		targetPanel.stateLabel.color = (flag ? Color.black : (data.exists ? Color.white : Color.red));
		targetPanel.selectButton.interactable = !flag;
		targetPanel.selectButton.GetComponentInChildren<TMP_Text>().text = (flag ? "SELECTED" : "SELECT");
		targetPanel.deleteButton.interactable = data.exists;
		targetPanel.slotNumberLabel.text = $"Slot {targetPanel.slotIndex + 1}";
		targetPanel.stateLabel.text = data.ToString();
	}

	public void ConfirmReload()
	{
		GameProgressSaver.SetSlot(queuedSlot);
		SceneHelper.LoadScene("Main Menu");
	}

	public void ConfirmWipe()
	{
		int currentSlot = GameProgressSaver.currentSlot;
		GameProgressSaver.WipeSlot(queuedSlot);
		if (currentSlot == queuedSlot)
		{
			SceneHelper.LoadScene("Main Menu");
		}
		else
		{
			ReloadMenu();
		}
	}

	public void CancelConsent()
	{
		reloadConsentWrapper.SetActive(value: false);
		wipeConsentWrapper.SetActive(value: false);
	}

	private void SelectSlot(int slot)
	{
		queuedSlot = slot;
		reloadConsentWrapper.SetActive(value: true);
	}

	private void ClearSlot(int slot)
	{
		queuedSlot = slot;
		wipeConsentContent.text = $"Are you sure you want to <color=red>DELETE SLOT {slot + 1}</color>?";
		wipeConsentWrapper.SetActive(value: true);
	}
}



public class ScaleNFade : MonoBehaviour
{
	public bool scale;

	public bool fade;

	public FadeType ft;

	public float scaleSpeed;

	public float fadeSpeed;

	private SpriteRenderer sr;

	private LineRenderer lr;

	private Light lght;

	private Renderer rend;

	public bool dontDestroyOnZero;

	public bool lightUseIntensityInsteadOfRange;

	public bool fadeToBlack;

	private Vector3 scaleAmt = Vector3.one;

	private bool hasOpacScale;

	private bool hasTint;

	private bool hasColor;

	private void Start()
	{
		if (fade)
		{
			switch (ft)
			{
			case FadeType.Sprite:
				sr = GetComponent<SpriteRenderer>();
				break;
			case FadeType.Line:
				lr = GetComponent<LineRenderer>();
				break;
			case FadeType.Light:
				lght = GetComponent<Light>();
				break;
			case FadeType.Renderer:
				rend = GetComponent<Renderer>();
				if (rend == null)
				{
					rend = GetComponentInChildren<Renderer>();
				}
				break;
			}
		}
		if (rend != null)
		{
			hasOpacScale = rend.material.HasProperty("_OpacScale");
			hasTint = rend.material.HasProperty("_Tint");
			hasColor = rend.material.HasProperty("_Color");
		}
		scaleAmt = base.transform.localScale;
	}

	private void Update()
	{
		if (scale)
		{
			scaleAmt += Vector3.one * Time.deltaTime * scaleSpeed;
			base.transform.localScale = scaleAmt;
		}
		if (fade)
		{
			switch (ft)
			{
			case FadeType.Sprite:
				UpdateSpriteFade();
				break;
			case FadeType.Light:
				UpdateLightFade();
				break;
			case FadeType.Renderer:
				UpdateRendererFade();
				break;
			case FadeType.Line:
				break;
			}
		}
	}

	private void UpdateSpriteFade()
	{
		Color color = sr.color;
		if (color.a <= 0f)
		{
			if (!dontDestroyOnZero)
			{
				Object.Destroy(base.gameObject);
			}
		}
		else
		{
			color.a -= fadeSpeed * Time.deltaTime;
			sr.color = color;
		}
	}

	private void UpdateLightFade()
	{
		float num = (lightUseIntensityInsteadOfRange ? lght.intensity : lght.range);
		if (num <= 0f)
		{
			if (!dontDestroyOnZero)
			{
				Object.Destroy(base.gameObject);
			}
			return;
		}
		num -= fadeSpeed * Time.deltaTime;
		if (lightUseIntensityInsteadOfRange)
		{
			lght.intensity = num;
		}
		else
		{
			lght.range = num;
		}
	}

	private void UpdateRendererFade()
	{
		if (hasOpacScale)
		{
			UpdateOpacityScale();
		}
		else if (hasTint || hasColor)
		{
			UpdateColorFade();
		}
	}

	private void UpdateOpacityScale()
	{
		float @float = rend.material.GetFloat("_OpacScale");
		if (@float <= 0f && !dontDestroyOnZero)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		@float = Mathf.Max(@float - fadeSpeed * Time.deltaTime, 0f);
		rend.material.SetFloat("_OpacScale", @float);
	}

	private void UpdateColorFade()
	{
		string text = (hasTint ? "_Tint" : "_Color");
		Color color = rend.material.GetColor(text);
		if (fadeToBlack)
		{
			color = Color.Lerp(color, Color.black, fadeSpeed * Time.deltaTime);
		}
		else
		{
			color.a = Mathf.Max(color.a - fadeSpeed * Time.deltaTime, 0f);
		}
		if (color.a <= 0f && !dontDestroyOnZero)
		{
			Object.Destroy(base.gameObject);
		}
		else
		{
			rend.material.SetColor(text, color);
		}
	}

	private void FixedUpdate()
	{
		if (fade && ft == FadeType.Line)
		{
			Color startColor = lr.startColor;
			startColor.a -= fadeSpeed * Time.deltaTime;
			lr.startColor = startColor;
			startColor = lr.endColor;
			startColor.a -= fadeSpeed * Time.deltaTime;
			lr.endColor = startColor;
			if (lr.startColor.a <= 0f && lr.endColor.a <= 0f && !dontDestroyOnZero)
			{
				Object.Destroy(base.gameObject);
			}
		}
	}
}



public class ScaleTransform : MonoBehaviour
{
	public Vector3 target;

	public float speed;

	public UnityEvent onComplete;

	private void Update()
	{
		if (base.transform.localScale != target)
		{
			base.transform.localScale = Vector3.MoveTowards(base.transform.localScale, target, speed * Time.deltaTime);
			if (base.transform.localScale == target)
			{
				onComplete?.Invoke();
			}
		}
	}

	public void SetTransformX(float target)
	{
		base.transform.localScale = new Vector3(target, base.transform.localScale.y, base.transform.localScale.z);
	}

	public void SetTransformY(float target)
	{
		base.transform.localScale = new Vector3(base.transform.localScale.x, target, base.transform.localScale.z);
	}

	public void SetTransformZ(float target)
	{
		base.transform.localScale = new Vector3(base.transform.localScale.x, base.transform.localScale.y, target);
	}

	public void SetScaleToZero()
	{
		base.transform.localScale = Vector3.zero;
	}
}



public sealed class ScaleVector2DeltaTimeProcessor : InputProcessor<Vector2>
{
	static ScaleVector2DeltaTimeProcessor()
	{
		Initialize();
	}

	public override Vector2 Process(Vector2 value, InputControl control)
	{
		return value * Time.deltaTime;
	}

	[RuntimeInitializeOnLoadMethod]
	private static void Initialize()
	{
		InputSystem.RegisterProcessor<ScaleVector2DeltaTimeProcessor>();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class ScanningStuff : MonoSingleton<ScanningStuff>
{
	[SerializeField]
	private GameObject scanningPanel;

	[SerializeField]
	private GameObject readingPanel;

	[SerializeField]
	private TMP_Text readingText;

	[SerializeField]
	private ScrollRect scrollRect;

	public Image meter;

	private float loading;

	private bool scanning;

	private Dictionary<int, bool> scannedBooks = new Dictionary<int, bool>();

	private Dictionary<int, float> bookScrollStates = new Dictionary<int, float>();

	private int currentBookId;

	public bool oldWeaponState;

	public bool IsReading => readingPanel.activeInHierarchy;

	public void ReleaseScroll(int instanceId)
	{
		if (bookScrollStates.ContainsKey(instanceId))
		{
			bookScrollStates.Remove(instanceId);
		}
	}

	public void ScanBook(string text, bool noScan, int instanceId)
	{
		oldWeaponState = !MonoSingleton<GunControl>.Instance.noWeapons;
		MonoSingleton<GunControl>.Instance.NoWeapon();
		readingText.text = text;
		if (bookScrollStates.ContainsKey(instanceId))
		{
			scrollRect.verticalNormalizedPosition = bookScrollStates[instanceId];
		}
		else
		{
			scrollRect.verticalNormalizedPosition = 1f;
		}
		currentBookId = instanceId;
		if (noScan || (scannedBooks.ContainsKey(instanceId) && scannedBooks[instanceId]))
		{
			scanningPanel.SetActive(value: false);
			readingPanel.SetActive(value: true);
			scanning = false;
		}
		else
		{
			scanningPanel.SetActive(value: true);
			readingPanel.SetActive(value: false);
			scanning = true;
			loading = 0f;
			meter.fillAmount = 0f;
		}
	}

	public void ResetState()
	{
		if (bookScrollStates.ContainsKey(currentBookId))
		{
			bookScrollStates[currentBookId] = scrollRect.verticalNormalizedPosition;
		}
		else
		{
			bookScrollStates.Add(currentBookId, scrollRect.verticalNormalizedPosition);
		}
		scanning = false;
		loading = 0f;
		meter.fillAmount = 0f;
		scanningPanel.SetActive(value: false);
		readingPanel.SetActive(value: false);
		currentBookId = -1;
		scrollRect.verticalNormalizedPosition = 1f;
		if (oldWeaponState)
		{
			MonoSingleton<GunControl>.Instance.YesWeapon();
		}
		else
		{
			MonoSingleton<GunControl>.Instance.NoWeapon();
		}
	}

	private void Update()
	{
		if (scanning)
		{
			loading = Mathf.MoveTowards(loading, 1f, Time.deltaTime / 2f);
			meter.fillAmount = loading;
			if (loading == 1f)
			{
				scanning = false;
				scanningPanel.SetActive(value: false);
				readingPanel.SetActive(value: true);
				scannedBooks.Add(currentBookId, value: true);
			}
		}
	}
}



public class ScatterRigidbodies : MonoBehaviour
{
	private Rigidbody[] rbs;

	public Vector3 minForce;

	public Vector3 maxForce;

	public float rotationForce;

	private void Start()
	{
		rbs = GetComponentsInChildren<Rigidbody>();
		Rigidbody[] array = rbs;
		foreach (Rigidbody obj in array)
		{
			obj.AddForce(Random.Range(minForce.x, maxForce.x), Random.Range(minForce.y, maxForce.y), Random.Range(minForce.z, maxForce.z), ForceMode.VelocityChange);
			obj.AddTorque(Random.Range(0f - rotationForce, rotationForce), Random.Range(0f - rotationForce, rotationForce), Random.Range(0f - rotationForce, rotationForce), ForceMode.VelocityChange);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance | SingletonFlags.PersistAutoInstance | SingletonFlags.DestroyDuplicates)]
public class SceneHelper : MonoSingleton<SceneHelper>
{
	[SerializeField]
	private AssetReference finalRoomPit;

	[SerializeField]
	private GameObject loadingBlocker;

	[SerializeField]
	private TMP_Text loadingBar;

	[SerializeField]
	private GameObject preloadingBadge;

	[SerializeField]
	private GameObject eventSystem;

	[Space]
	[SerializeField]
	private AudioMixerGroup masterMixer;

	[SerializeField]
	private AudioMixerGroup musicMixer;

	[SerializeField]
	private AudioMixer allSound;

	[SerializeField]
	private AudioMixer goreSound;

	[SerializeField]
	private AudioMixer musicSound;

	[SerializeField]
	private AudioMixer doorSound;

	[SerializeField]
	private AudioMixer unfreezeableSound;

	[Space]
	[SerializeField]
	private EmbeddedSceneInfo embeddedSceneInfo;

	public static bool IsPlayingCustom => GameStateManager.Instance.currentCustomGame != null;

	public static bool IsSceneRankless => MonoSingleton<SceneHelper>.Instance.embeddedSceneInfo.ranklessScenes.Contains(CurrentScene);

	public static int CurrentLevelNumber
	{
		get
		{
			if (!IsPlayingCustom)
			{
				return MonoSingleton<StatsManager>.Instance.levelNumber;
			}
			return GameStateManager.Instance.currentCustomGame.levelNumber;
		}
	}

	public static string CurrentScene { get; private set; }

	public static string LastScene { get; private set; }

	public static string PendingScene { get; private set; }

	protected override void OnEnable()
	{
		base.OnEnable();
		Object.DontDestroyOnLoad(base.gameObject);
		SceneManager.sceneLoaded += OnSceneLoaded;
		OnSceneLoaded(SceneManager.GetActiveScene(), LoadSceneMode.Single);
		if (string.IsNullOrEmpty(CurrentScene))
		{
			CurrentScene = SceneManager.GetActiveScene().name;
		}
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= OnSceneLoaded;
	}

	public bool IsSceneSpecial(string sceneName)
	{
		sceneName = SanitizeLevelPath(sceneName);
		if (embeddedSceneInfo == null)
		{
			return false;
		}
		return embeddedSceneInfo.specialScenes.Contains(sceneName);
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		if (EventSystem.current != null)
		{
			Object.Destroy(EventSystem.current.gameObject);
		}
		Object.Instantiate(eventSystem);
		if (mode == LoadSceneMode.Single)
		{
			GameStateManager.Instance.ResetGravity();
		}
	}

	public static string SanitizeLevelPath(string scene)
	{
		if (scene.StartsWith("Assets/Scenes/"))
		{
			scene = scene.Substring("Assets/Scenes/".Length);
		}
		if (scene.EndsWith(".unity"))
		{
			scene = scene.Substring(0, scene.Length - ".unity".Length);
		}
		return scene;
	}

	public static void ShowLoadingBlocker()
	{
		MonoSingleton<SceneHelper>.Instance.loadingBlocker.SetActive(value: true);
	}

	public static void DismissBlockers()
	{
		MonoSingleton<SceneHelper>.Instance.loadingBlocker.SetActive(value: false);
		MonoSingleton<SceneHelper>.Instance.loadingBar.gameObject.SetActive(value: false);
	}

	public static void LoadScene(string sceneName, bool noBlocker = false)
	{
		MonoSingleton<SceneHelper>.Instance.StartCoroutine(MonoSingleton<SceneHelper>.Instance.LoadSceneAsync(sceneName, noBlocker));
	}

	private IEnumerator LoadSceneAsync(string sceneName, bool noSplash = false)
	{
		if (PendingScene == null)
		{
			PendingScene = sceneName;
			sceneName = SanitizeLevelPath(sceneName);
			switch (sceneName)
			{
			default:
				_ = sceneName == "Custom Content";
				break;
			case "Main Menu":
			case "Tutorial":
			case "Credits":
			case "Endless":
				break;
			}
			Debug.Log("(LoadSceneAsync) Loading scene " + sceneName);
			loadingBlocker.SetActive(!noSplash);
			yield return null;
			if (CurrentScene != sceneName)
			{
				LastScene = CurrentScene;
			}
			CurrentScene = sceneName;
			if (MonoSingleton<MapVarManager>.Instance != null)
			{
				MonoSingleton<MapVarManager>.Instance.ReloadMapVars();
			}
			yield return Addressables.LoadSceneAsync(sceneName);
			if ((bool)GameStateManager.Instance)
			{
				GameStateManager.Instance.currentCustomGame = null;
			}
			if ((bool)preloadingBadge)
			{
				preloadingBadge.SetActive(value: false);
			}
			if ((bool)loadingBlocker)
			{
				loadingBlocker.SetActive(value: false);
			}
			if ((bool)loadingBar)
			{
				loadingBar.gameObject.SetActive(value: false);
			}
			PendingScene = null;
		}
	}

	public static void RestartScene()
	{
		MonoBehaviour[] array = Object.FindObjectsOfType<MonoBehaviour>();
		foreach (MonoBehaviour monoBehaviour in array)
		{
			if (!(monoBehaviour == null) && !(monoBehaviour.gameObject.scene.name == "DontDestroyOnLoad"))
			{
				monoBehaviour.CancelInvoke();
				monoBehaviour.enabled = false;
			}
		}
		if (string.IsNullOrEmpty(CurrentScene))
		{
			CurrentScene = SceneManager.GetActiveScene().name;
		}
		Addressables.LoadSceneAsync(CurrentScene).WaitForCompletion();
		if (MonoSingleton<MapVarManager>.Instance != null)
		{
			MonoSingleton<MapVarManager>.Instance.ReloadMapVars();
		}
	}

	public static void LoadPreviousScene()
	{
		string text = LastScene;
		if (string.IsNullOrEmpty(text))
		{
			text = "Main Menu";
		}
		LoadScene(text);
	}

	public static void SpawnFinalPitAndFinish()
	{
		FinalRoom finalRoom = Object.FindObjectOfType<FinalRoom>();
		if (finalRoom != null)
		{
			if ((bool)finalRoom.doorOpener)
			{
				finalRoom.doorOpener.SetActive(value: true);
			}
			MonoSingleton<NewMovement>.Instance.transform.position = finalRoom.dropPoint.position;
		}
		else
		{
			GameObject obj = Object.Instantiate(AssetHelper.LoadPrefab(MonoSingleton<SceneHelper>.Instance.finalRoomPit));
			finalRoom = obj.GetComponent<FinalRoom>();
			obj.transform.position = new Vector3(50000f, -1000f, 50000f);
			MonoSingleton<NewMovement>.Instance.transform.position = finalRoom.dropPoint.position;
		}
	}

	public static void SetLoadingSubtext(string text)
	{
		if ((bool)MonoSingleton<SceneHelper>.Instance.loadingBlocker)
		{
			MonoSingleton<SceneHelper>.Instance.loadingBar.gameObject.SetActive(value: true);
			MonoSingleton<SceneHelper>.Instance.loadingBar.text = text;
		}
	}

	public int? GetLevelIndexAfterIntermission(string intermissionScene)
	{
		if (embeddedSceneInfo == null)
		{
			return null;
		}
		IntermissionRelation[] intermissions = embeddedSceneInfo.intermissions;
		for (int i = 0; i < intermissions.Length; i++)
		{
			IntermissionRelation intermissionRelation = intermissions[i];
			if (intermissionRelation.intermissionScene == intermissionScene)
			{
				return intermissionRelation.nextLevelIndex;
			}
		}
		return null;
	}
}



public class ScreenBlood : MonoBehaviour
{
	private Image img;

	private Color clr;

	private RectTransform rct;

	public Sprite[] sprites;

	private void Start()
	{
		rct = GetComponent<RectTransform>();
		rct.anchoredPosition = new Vector2(Random.Range(-400, 400), Random.Range(-250, 250));
		img = GetComponent<Image>();
		img.sprite = sprites[Random.Range(0, sprites.Length)];
		clr = img.color;
	}

	private void Update()
	{
		if (clr.a > 0f)
		{
			clr.a -= Time.deltaTime;
			img.color = clr;
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}
}



public class Screenshaker : MonoBehaviour
{
	public float amount;

	public bool oneTime;

	public bool continuous;

	private bool alreadyShaken;

	private bool colliderless;

	public float minDistance;

	public float maxDistance;

	private void Awake()
	{
		colliderless = GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null;
	}

	private void OnEnable()
	{
		if (colliderless)
		{
			Shake();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			Shake();
		}
	}

	private void Update()
	{
		if (continuous && base.gameObject.activeInHierarchy)
		{
			MonoSingleton<CameraController>.Instance.CameraShake((maxDistance == 0f) ? amount : GetDistanceValue());
		}
	}

	public void Shake()
	{
		if (!oneTime || !alreadyShaken)
		{
			float distanceValue = amount;
			if (maxDistance != 0f)
			{
				distanceValue = GetDistanceValue();
			}
			alreadyShaken = true;
			MonoSingleton<CameraController>.Instance.CameraShake(distanceValue);
			if (oneTime && !continuous)
			{
				Object.Destroy(this);
			}
		}
	}

	private float GetDistanceValue()
	{
		return Mathf.Lerp(amount, 0f, (Vector3.Distance(MonoSingleton<CameraController>.Instance.transform.position, base.transform.position) - minDistance) / (maxDistance - minDistance));
	}
}



public class ScreenZone : MonoBehaviour
{
	protected bool inZone;

	protected bool touchMode;

	private GunControl gc;

	private FistControl pun;

	[SerializeField]
	private AudioSource music;

	private float originalVolume;

	[SerializeField]
	private float angleLimit;

	[SerializeField]
	private Transform angleSourceOverride;

	[Space]
	[SerializeField]
	protected UnityEvent onEnterZone = new UnityEvent();

	[SerializeField]
	protected UnityEvent onExitZone = new UnityEvent();

	private GraphicRaycaster raycaster;

	private void Awake()
	{
		if ((bool)music)
		{
			originalVolume = music.volume;
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded && inZone)
		{
			UpdatePlayerState(active: false);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			if (gc == null)
			{
				gc = other.GetComponentInChildren<GunControl>();
			}
			if (pun == null)
			{
				pun = other.GetComponentInChildren<FistControl>();
			}
			inZone = true;
			if (raycaster == null)
			{
				raycaster = GetComponentInChildren<GraphicRaycaster>(includeInactive: true);
			}
			if (raycaster == null)
			{
				raycaster = base.transform.parent.GetComponentInChildren<GraphicRaycaster>(includeInactive: true);
			}
			ControllerPointer.raycaster = raycaster;
			onEnterZone?.Invoke();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			if (gc == null)
			{
				gc = other.GetComponentInChildren<GunControl>();
			}
			if ((bool)raycaster && ControllerPointer.raycaster == raycaster)
			{
				ControllerPointer.raycaster = null;
			}
			onExitZone?.Invoke();
			inZone = false;
			UpdatePlayerState(active: false);
		}
	}

	public virtual void UpdatePlayerState(bool active)
	{
		if (touchMode == active)
		{
			return;
		}
		if (active)
		{
			if (gc != null)
			{
				gc.NoWeapon();
			}
			if (pun != null)
			{
				pun.ShopMode();
			}
		}
		else
		{
			if (gc != null)
			{
				gc.YesWeapon();
			}
			if (pun != null)
			{
				pun.StopShop();
			}
		}
		touchMode = active;
	}

	protected virtual void Update()
	{
		if (music != null)
		{
			if (MonoSingleton<AudioMixerController>.Instance.optionsMusicVolume == 0f)
			{
				music.volume = 0f;
			}
			else
			{
				music.volume = originalVolume;
			}
			if (inZone)
			{
				if (music.pitch < 1f)
				{
					music.pitch = Mathf.MoveTowards(music.pitch, 1f, Time.deltaTime);
				}
			}
			else if (music.pitch > 0f)
			{
				music.pitch = Mathf.MoveTowards(music.pitch, 0f, Time.deltaTime);
			}
		}
		if (inZone)
		{
			float num = Vector3.Angle(MonoSingleton<CameraController>.Instance.transform.forward, (angleSourceOverride == null) ? base.transform.forward : angleSourceOverride.forward);
			UpdatePlayerState(angleLimit == 0f || !(num > angleLimit));
		}
	}
}



public class ScriptActivator : MonoBehaviour
{
	public Piston[] pistons;

	public LightPillar[] lightpillars;

	private void OnTriggerEnter(Collider other)
	{
		if (!other.gameObject.CompareTag("Player"))
		{
			return;
		}
		if (pistons.Length != 0)
		{
			Piston[] array = pistons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].off = false;
			}
		}
		if (lightpillars.Length != 0)
		{
			LightPillar[] array2 = lightpillars;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].ActivatePillar();
			}
		}
		Object.Destroy(this);
	}
}



public class ScrollingTexture : MonoBehaviour
{
	private static MaterialPropertyBlock _propertyBlock;

	public float scrollSpeedX;

	public float scrollSpeedY;

	private Dictionary<int, int[]> texturePropertyStNames;

	private Material[] sharedMaterials;

	private MeshRenderer mr;

	private Vector2 offset;

	public bool scrollAttachedObjects;

	public Vector3 force;

	public bool relativeDirection;

	public List<Transform> attachedObjects = new List<Transform>();

	[HideInInspector]
	public Bounds bounds;

	[HideInInspector]
	public bool valuesSet;

	[HideInInspector]
	public List<GameObject> cleanUp = new List<GameObject>();

	[HideInInspector]
	public List<WaterDryTracker> specialScrollers = new List<WaterDryTracker>();

	[HideInInspector]
	public List<Rigidbody> touchingRbs = new List<Rigidbody>();

	public BloodstainParent parent;

	private void Start()
	{
		if (scrollAttachedObjects)
		{
			GameObject gameObject = new GameObject("Scrolling Texture Parent");
			parent = gameObject.AddComponent<BloodstainParent>();
		}
		if (_propertyBlock == null)
		{
			_propertyBlock = new MaterialPropertyBlock();
		}
		mr = GetComponent<MeshRenderer>();
		texturePropertyStNames = new Dictionary<int, int[]>();
		sharedMaterials = mr.sharedMaterials;
		for (int i = 0; i < sharedMaterials.Length; i++)
		{
			Material material = sharedMaterials[i];
			List<string> list = material.GetTexturePropertyNames().ToList();
			for (int j = 0; j < list.Count; j++)
			{
				list[j] += "_ST";
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				if (!material.HasProperty(list[num]))
				{
					list.RemoveAt(num);
				}
			}
			int[] array = new int[list.Count];
			for (int k = 0; k < array.Length; k++)
			{
				array[k] = Shader.PropertyToID(list[k]);
			}
			texturePropertyStNames[i] = array;
		}
		if (!scrollAttachedObjects || valuesSet)
		{
			return;
		}
		valuesSet = true;
		MonoSingleton<ComponentsDatabase>.Instance.scrollers.Add(base.transform);
		Rigidbody component2;
		if (TryGetComponent<Collider>(out var component))
		{
			bounds = component.bounds;
		}
		else if (TryGetComponent<Rigidbody>(out component2))
		{
			Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
			bool flag = false;
			for (int l = 0; l < componentsInChildren.Length; l++)
			{
				if (componentsInChildren[l].attachedRigidbody == component2)
				{
					if (!flag)
					{
						bounds = componentsInChildren[l].bounds;
						flag = true;
					}
					else
					{
						bounds.Encapsulate(componentsInChildren[l].bounds);
					}
				}
			}
		}
		Invoke("SlowUpdate", 5f);
	}

	private void SlowUpdate()
	{
		foreach (GameObject item in cleanUp)
		{
			Object.Destroy(item);
		}
		cleanUp.Clear();
		Invoke("SlowUpdate", 5f);
	}

	private void OnDestroy()
	{
		if ((bool)parent)
		{
			Object.Destroy(parent.gameObject);
		}
		ComponentsDatabase instance = MonoSingleton<ComponentsDatabase>.Instance;
		if ((bool)instance)
		{
			instance.scrollers.Remove(base.transform);
		}
	}

	private void Update()
	{
		offset += new Vector2(scrollSpeedX * Time.deltaTime, scrollSpeedY * Time.deltaTime);
		for (int i = 0; i < sharedMaterials.Length; i++)
		{
			mr.GetPropertyBlock(_propertyBlock, i);
			int[] array = texturePropertyStNames[i];
			Material material = sharedMaterials[i];
			for (int j = 0; j < array.Length; j++)
			{
				Vector4 vector = material.GetVector(array[j]);
				vector.z = offset.x;
				vector.w = offset.y;
				_propertyBlock.SetVector(array[j], vector);
			}
			mr.SetPropertyBlock(_propertyBlock, i);
		}
		Vector3 vector2 = force;
		if (relativeDirection)
		{
			vector2 = new Vector3(force.x * base.transform.forward.x, force.y * base.transform.forward.y, force.z * base.transform.forward.z);
		}
		if ((bool)parent)
		{
			parent.transform.position += vector2 * Time.deltaTime;
		}
		if (!scrollAttachedObjects || attachedObjects.Count <= 0)
		{
			return;
		}
		for (int num = attachedObjects.Count - 1; num >= 0; num--)
		{
			if (attachedObjects[num] != null)
			{
				attachedObjects[num].position = attachedObjects[num].position + vector2 * Time.deltaTime;
				int num2 = -1;
				if (specialScrollers.Count != 0)
				{
					for (int num3 = specialScrollers.Count - 1; num3 >= 0; num3--)
					{
						if (specialScrollers[num3].transform == null)
						{
							specialScrollers.RemoveAt(num3);
						}
						else if (specialScrollers[num3].transform == attachedObjects[num])
						{
							num2 = num3;
							break;
						}
					}
				}
				if ((num2 < 0 && Vector3.Distance(attachedObjects[num].position, bounds.ClosestPoint(attachedObjects[num].position)) > 1f) || (num2 >= 0 && Vector3.Distance(attachedObjects[num].position + specialScrollers[num2].closestPosition, bounds.ClosestPoint(attachedObjects[num].position + specialScrollers[num2].closestPosition)) > 1f))
				{
					if (num2 >= 0)
					{
						specialScrollers.RemoveAt(num2);
					}
					cleanUp.Add(attachedObjects[num].gameObject);
					attachedObjects[num].gameObject.SetActive(value: false);
					attachedObjects.RemoveAt(num);
				}
			}
			else
			{
				attachedObjects.RemoveAt(num);
			}
		}
	}

	private void FixedUpdate()
	{
		if (touchingRbs.Count <= 0)
		{
			return;
		}
		Vector3 vector = force;
		if (relativeDirection)
		{
			vector = new Vector3(force.x * base.transform.forward.x, force.y * base.transform.forward.y, force.z * base.transform.forward.z);
		}
		for (int num = touchingRbs.Count - 1; num >= 0; num--)
		{
			if (touchingRbs[num] == null)
			{
				touchingRbs.RemoveAt(num);
			}
			else
			{
				touchingRbs[num].AddForce(vector * Time.fixedDeltaTime, ForceMode.VelocityChange);
			}
		}
	}
}



[RequireComponent(typeof(ScrollRect))]
public class ScrollRectMouseControl : MonoBehaviour
{
	private ScrollRect m_ScrollRect;

	private void OnEnable()
	{
		m_ScrollRect = GetComponent<ScrollRect>();
	}

	private void Update()
	{
		m_ScrollRect.verticalNormalizedPosition += Mouse.current.scroll.y.ReadValue() / m_ScrollRect.content.sizeDelta.y;
	}
}



public class SeasonalHats : MonoBehaviour
{
	private DateTime time;

	[SerializeField]
	private GameObject christmas;

	[SerializeField]
	private GameObject halloween;

	[SerializeField]
	private GameObject easter;

	private void Start()
	{
		if (!MonoSingleton<PrefsManager>.Instance.GetBool("seasonalEvents") || MonoSingleton<StatsManager>.Instance.firstPlayThrough)
		{
			return;
		}
		time = DateTime.Now;
		switch (time.Month)
		{
		case 12:
			if (time.Day >= 22 && time.Day <= 28)
			{
				christmas.SetActive(value: true);
			}
			return;
		case 10:
			if (time.Day >= 25 && time.Day <= 31)
			{
				halloween.SetActive(value: true);
			}
			return;
		}
		DateTime dateTime = GetEaster(time.Year);
		if (time.DayOfYear >= dateTime.DayOfYear - 2 && time.DayOfYear <= dateTime.DayOfYear)
		{
			easter.SetActive(value: true);
		}
	}

	private DateTime GetEaster(int year)
	{
		int num = year % 19;
		int num2 = year / 100;
		int num3 = (num2 - num2 / 4 - (8 * num2 + 13) / 25 + 19 * num + 15) % 30;
		int num4 = num3 - num3 / 28 * (1 - num3 / 28 * (29 / (num3 + 1)) * ((21 - num) / 11));
		int num5 = num4 - (year + year / 4 + num4 + 2 - num2 + num2 / 4) % 7;
		int num6 = 3 + (num5 + 40) / 44;
		int day = num5 + 28 - 31 * (num6 / 4);
		return new DateTime(year, num6, day);
	}
}



public class SecondaryRevolver : MonoBehaviour
{
	private int bulletForce;

	private GameObject camObj;

	private Camera cam;

	public RaycastHit hit;

	private bool gunReady;

	public Vector3 shotHitPoint;

	private bool shootReady;

	private float shootCharge;

	private int currentGunShot;

	private AudioSource gunAud;

	public Revolver rev;

	public GameObject secBeamPoint;

	public GameObject secHitParticle;

	private GameObject gunBarrel;

	private Vector3 defaultGunPos;

	private Quaternion defaultGunRot;

	private MeshRenderer screenMR;

	private CameraFrustumTargeter targeter;

	private void Awake()
	{
		defaultGunPos = base.transform.localPosition;
		defaultGunRot = base.transform.localRotation;
		Debug.Log("Started!");
	}

	private void Start()
	{
		targeter = Camera.main.GetComponent<CameraFrustumTargeter>();
		screenMR = base.transform.GetChild(1).GetComponent<MeshRenderer>();
		gunBarrel = base.transform.GetChild(0).gameObject;
		cam = MonoSingleton<CameraController>.Instance.GetComponent<Camera>();
		camObj = cam.gameObject;
		rev = camObj.GetComponentInChildren<Revolver>();
		gunAud = GetComponent<AudioSource>();
		PickUp();
		Debug.Log("Awake!");
	}

	private void OnDisable()
	{
		PickUp();
	}

	public void PickUp()
	{
		gunReady = false;
		shootCharge = 0f;
		shootReady = false;
	}

	private void Update()
	{
		if (gunReady && !MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame && shootReady)
		{
			Shoot();
		}
		if (base.transform.localPosition != defaultGunPos && base.transform.localRotation != defaultGunRot)
		{
			gunReady = false;
		}
		else
		{
			gunReady = true;
		}
		if (!shootReady)
		{
			if (shootCharge + 175f * Time.deltaTime < 100f)
			{
				shootCharge += 175f * Time.deltaTime;
			}
			else
			{
				shootCharge = 100f;
				shootReady = true;
			}
		}
		if (base.transform.localPosition != defaultGunPos)
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, defaultGunPos, Time.deltaTime * 3f);
		}
		if (base.transform.localRotation != defaultGunRot)
		{
			base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, defaultGunRot, Time.deltaTime * 160f);
		}
		if (shootCharge < 50f)
		{
			screenMR.material.SetTexture("_MainTex", rev.batteryLow);
		}
		else if (shootCharge < 100f)
		{
			screenMR.material.SetTexture("_MainTex", rev.batteryMid);
		}
		else
		{
			screenMR.material.SetTexture("_MainTex", rev.batteryFull);
		}
	}

	public void Shoot()
	{
		bulletForce = 5000;
		Vector3 direction = camObj.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			direction = targeter.CurrentTarget.bounds.center - camObj.transform.position;
		}
		Physics.Raycast(camObj.transform.position, direction, out hit, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment));
		shotHitPoint = hit.point;
		GameObject gameObject = Object.Instantiate(secBeamPoint, gunBarrel.transform.position, gunBarrel.transform.rotation);
		GameObject gameObject2 = Object.Instantiate(secHitParticle, hit.point, base.transform.rotation);
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
			gameObject2.transform.LookAt(targeter.CurrentTarget.bounds.center);
		}
		shootReady = false;
		shootCharge = 0f;
		currentGunShot = Random.Range(0, rev.gunShots.Length);
		gunAud.clip = rev.gunShots[currentGunShot];
		gunAud.volume = 0.5f;
		gunAud.pitch = Random.Range(0.95f, 1.05f);
		gunAud.Play();
		cam.fieldOfView = (rev.recoilFOV - cam.fieldOfView) / 2f + cam.fieldOfView;
	}

	private void ReadyToShoot()
	{
		shootReady = true;
	}
}



public class SecretMissionChecker : MonoBehaviour
{
	public bool requireCompletion = true;

	public bool primeMission;

	public int secretMission;

	public UltrakillEvent onMissionGet;

	private void Start()
	{
		if (primeMission && GameProgressSaver.GetPrime(MonoSingleton<PrefsManager>.Instance.GetInt("difficulty"), secretMission) == 2)
		{
			onMissionGet.Invoke();
		}
		else if (!primeMission)
		{
			int num = GameProgressSaver.GetSecretMission(secretMission);
			if (requireCompletion && num == 2)
			{
				onMissionGet.Invoke();
			}
			else if (!requireCompletion && num == 1)
			{
				onMissionGet.Invoke();
			}
		}
	}
}



public class SecretMissionPanel : MonoBehaviour
{
	public LayerSelect layerSelect;

	public int missionNumber;

	private void Start()
	{
		GotEnabled();
	}

	private void OnEnable()
	{
		GotEnabled();
	}

	public void GotEnabled()
	{
		int secretMission = GameProgressSaver.GetSecretMission(missionNumber);
		Debug.Log("Secret Mission Status: " + secretMission);
		switch (secretMission)
		{
		case 2:
			GetComponent<Image>().fillCenter = true;
			GetComponentInChildren<TMP_Text>().color = Color.black;
			GetComponent<Button>().interactable = true;
			layerSelect.SecretMissionDone();
			break;
		case 1:
			GetComponent<Image>().fillCenter = false;
			GetComponentInChildren<TMP_Text>().color = Color.white;
			GetComponent<Button>().interactable = true;
			break;
		default:
			GetComponent<Image>().fillCenter = false;
			GetComponentInChildren<TMP_Text>().color = new Color(0.5f, 0.5f, 0.5f);
			GetComponent<Button>().interactable = false;
			break;
		}
	}
}



public class SecretMissionPit : MonoBehaviour
{
	public int missionNumber;

	public bool halfUnlock;

	public bool primeMission;

	private bool done;

	private void OnTriggerEnter(Collider other)
	{
		if (done || !other.gameObject.CompareTag("Player"))
		{
			return;
		}
		done = true;
		if (primeMission)
		{
			if (halfUnlock)
			{
				GameProgressSaver.SetPrime(missionNumber, 1);
			}
			else
			{
				GameProgressSaver.SetPrime(missionNumber, 2);
			}
		}
		else if (halfUnlock)
		{
			GameProgressSaver.FoundSecretMission(missionNumber);
		}
		else
		{
			GameProgressSaver.SetSecretMission(missionNumber);
		}
	}
}



public class SelectableRectTools : MonoBehaviour
{
	[SerializeField]
	private Selectable target;

	[SerializeField]
	private bool autoSwitchForDown;

	[SerializeField]
	private bool autoSwitchForUp;

	[SerializeField]
	private Selectable[] prioritySwitch;

	private void Awake()
	{
		if (target == null)
		{
			target = GetComponent<Selectable>();
		}
	}

	private void OnEnable()
	{
		Selectable[] array;
		if (autoSwitchForDown)
		{
			array = prioritySwitch;
			foreach (Selectable selectable in array)
			{
				if (selectable.gameObject.activeSelf && selectable.IsInteractable() && selectable.enabled)
				{
					ChangeSelectOnDown(selectable);
					break;
				}
			}
		}
		if (!autoSwitchForUp)
		{
			return;
		}
		array = prioritySwitch;
		foreach (Selectable selectable2 in array)
		{
			if (selectable2.gameObject.activeSelf && selectable2.IsInteractable() && selectable2.enabled)
			{
				ChangeSelectOnUp(selectable2);
				break;
			}
		}
	}

	public void ChangeSelectOnUp(Selectable newElement)
	{
		Navigation navigation = target.navigation;
		navigation.selectOnUp = newElement;
		target.navigation = navigation;
	}

	public void ChangeSelectOnDown(Selectable newElement)
	{
		Navigation navigation = target.navigation;
		navigation.selectOnDown = newElement;
		target.navigation = navigation;
	}
}



public sealed class SelectionRedirector : Selectable
{
	public Selectable[] Selectables;

	public override void OnSelect(BaseEventData eventData)
	{
		base.OnSelect(eventData);
		if (Selectables == null)
		{
			return;
		}
		Selectable[] selectables = Selectables;
		foreach (Selectable selectable in selectables)
		{
			if (selectable != null && selectable.isActiveAndEnabled)
			{
				StartCoroutine(SelectAtEndOfFrame(selectable));
				break;
			}
		}
	}

	private IEnumerator SelectAtEndOfFrame(Selectable selectable)
	{
		yield return new WaitForEndOfFrame();
		selectable.Select();
	}
}



[Serializable]
public struct SerializedActivityAssets
{
	public string LargeImage;

	public string LargeText;

	public ActivityAssets Deserialize()
	{
		ActivityAssets result = default(ActivityAssets);
		result.LargeImage = LargeImage;
		result.LargeText = LargeText;
		return result;
	}
}



public class SetChildShaderPropertiesOnPref : MonoBehaviour
{
	private List<Renderer> renderers;

	public bool localPref;

	public string prefName;

	[Space]
	public ShaderProperty[] onTrue;

	public ShaderProperty[] onFalse;

	private void Awake()
	{
		renderers = new List<Renderer>();
		renderers.AddRange(GetComponentsInChildren<Renderer>(includeInactive: true));
	}

	private void OnEnable()
	{
		ShaderProperty[] array;
		if (localPref ? MonoSingleton<PrefsManager>.Instance.GetBoolLocal(prefName) : MonoSingleton<PrefsManager>.Instance.GetBool(prefName))
		{
			array = onTrue;
			foreach (ShaderProperty shaderProperty in array)
			{
				foreach (Renderer renderer in renderers)
				{
					shaderProperty.Set(renderer.material);
				}
			}
			return;
		}
		array = onFalse;
		foreach (ShaderProperty shaderProperty2 in array)
		{
			foreach (Renderer renderer2 in renderers)
			{
				shaderProperty2.Set(renderer2.material);
			}
		}
	}
}



public class SetFishZone : MonoBehaviour
{
	[SerializeField]
	private bool onEnter = true;

	[SerializeField]
	private bool restorePreviousOnExit = true;

	public float suggestedFishingDistance = 1f;

	private float previousFishingDistance;

	private float previousMinDistance;

	[SerializeField]
	private bool customMinDistance;

	[SerializeField]
	private float minDistance = 1f;

	private void OnTriggerEnter(Collider other)
	{
		if (onEnter && other.gameObject.CompareTag("Player"))
		{
			Set();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (restorePreviousOnExit && other.gameObject.CompareTag("Player"))
		{
			Restore();
		}
	}

	public void Set()
	{
		previousFishingDistance = FishingRodWeapon.suggestedDistanceMulti;
		if (customMinDistance)
		{
			previousMinDistance = FishingRodWeapon.minDistanceMulti;
		}
		FishingRodWeapon.suggestedDistanceMulti = suggestedFishingDistance;
		if (customMinDistance)
		{
			FishingRodWeapon.minDistanceMulti = minDistance;
		}
	}

	public void Restore()
	{
		FishingRodWeapon.suggestedDistanceMulti = previousFishingDistance;
		if (customMinDistance)
		{
			FishingRodWeapon.minDistanceMulti = previousMinDistance;
		}
	}
}



public class SetPlayerPref : MonoBehaviour
{
	public string playerPref;

	public int intValue;

	private void Start()
	{
		PlayerPrefs.SetInt(playerPref, intValue);
	}
}



public class SettingsRestoreDefaultButton : MonoBehaviour
{
	[SerializeField]
	private GameObject buttonContainer;

	public string settingKey;

	[Header("Float")]
	[SerializeField]
	private Slider slider;

	[SerializeField]
	private float valueToPrefMultiplier = 1f;

	[SerializeField]
	private float sliderTolerance = 0.01f;

	[SerializeField]
	private bool integerSlider;

	[Header("Integer")]
	[SerializeField]
	private TMP_Dropdown dropdown;

	[Header("Boolean")]
	[SerializeField]
	private Toggle toggle;

	[SerializeField]
	private UnityEvent customToggleEvent;

	private float? defaultFloat;

	private int? defaultInt;

	private bool? defaultBool;

	public void RestoreDefault()
	{
		customToggleEvent?.Invoke();
		if (defaultFloat.HasValue)
		{
			slider.value = defaultFloat.Value / valueToPrefMultiplier;
		}
		else if (defaultBool.HasValue)
		{
			toggle.isOn = defaultBool.Value;
		}
		else if (defaultInt.HasValue)
		{
			if (dropdown != null)
			{
				dropdown.value = defaultInt.Value;
			}
			if (integerSlider && slider != null)
			{
				slider.value = defaultInt.Value;
			}
		}
	}

	private void Start()
	{
		if (MonoSingleton<PrefsManager>.Instance.defaultValues.ContainsKey(settingKey))
		{
			object obj = MonoSingleton<PrefsManager>.Instance.defaultValues[settingKey];
			if (obj != null)
			{
				if (!(obj is float num))
				{
					if (!(obj is bool flag))
					{
						if (obj is int num2)
						{
							int value = num2;
							defaultInt = value;
						}
					}
					else
					{
						bool value2 = flag;
						defaultBool = value2;
					}
				}
				else
				{
					float value3 = num;
					defaultFloat = value3;
				}
			}
		}
		if (slider != null)
		{
			if (integerSlider)
			{
				if (!defaultInt.HasValue)
				{
					defaultInt = 0;
				}
			}
			else if (!defaultFloat.HasValue)
			{
				defaultFloat = 0f;
			}
			slider.onValueChanged.AddListener(delegate
			{
				UpdateSelf();
			});
		}
		if (toggle != null)
		{
			if (!defaultBool.HasValue)
			{
				defaultBool = false;
			}
			toggle.onValueChanged.AddListener(delegate
			{
				UpdateSelf();
			});
		}
		if (dropdown != null)
		{
			if (!defaultInt.HasValue)
			{
				defaultInt = 0;
			}
			dropdown.onValueChanged.AddListener(delegate
			{
				UpdateSelf();
			});
		}
		UpdateSelf();
	}

	private void UpdateSelf()
	{
		Debug.Log("UpdateSelf " + settingKey + " DefaultInt: " + defaultInt + " DefaultBool: " + defaultBool + " DefaultFloat: " + defaultFloat);
		if (!defaultInt.HasValue && !defaultBool.HasValue && !defaultFloat.HasValue)
		{
			buttonContainer.SetActive(value: false);
		}
		else if (defaultFloat.HasValue && slider != null)
		{
			if (Math.Abs(defaultFloat.Value - slider.value * valueToPrefMultiplier) < sliderTolerance)
			{
				buttonContainer.SetActive(value: false);
			}
			else
			{
				buttonContainer.SetActive(value: true);
			}
		}
		else if (defaultBool.HasValue && toggle != null)
		{
			if (defaultBool.Value == toggle.isOn)
			{
				buttonContainer.SetActive(value: false);
			}
			else
			{
				buttonContainer.SetActive(value: true);
			}
		}
		else if (defaultInt.HasValue && (dropdown != null || (integerSlider && slider != null)))
		{
			int? num = ReadCurrentInt();
			if (!num.HasValue || defaultInt.Value == num)
			{
				buttonContainer.SetActive(value: false);
			}
			else
			{
				buttonContainer.SetActive(value: true);
			}
		}
	}

	private int? ReadCurrentInt()
	{
		if (dropdown != null)
		{
			return dropdown.value;
		}
		if (slider != null && integerSlider)
		{
			return (int)slider.value;
		}
		return null;
	}
}



public class SetVideoFilePath : MonoBehaviour
{
	[SerializeField]
	private string videoName;

	private void OnEnable()
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			GetComponent<VideoPlayer>().url = "file://" + Path.Combine(Application.streamingAssetsPath, "Videos", videoName);
		}
	}
}



public static class ShaderProperties
{
	public static readonly int BaseMap = PrefixedPropertyToID("", "BaseMap");

	public static readonly int Color = PrefixedPropertyToID("", "Color");

	public static readonly int MainTex = PrefixedPropertyToID("", "MainTex");

	public static readonly int Cutoff = PrefixedPropertyToID("", "Cutoff");

	public static readonly int Glossiness = PrefixedPropertyToID("", "Glossiness");

	public static readonly int GlossMapScale = PrefixedPropertyToID("", "GlossMapScale");

	public static readonly int SmoothnessTextureChannel = PrefixedPropertyToID("", "SmoothnessTextureChannel");

	public static readonly int Metallic = PrefixedPropertyToID("", "Metallic");

	public static readonly int MetallicGlossMap = PrefixedPropertyToID("", "MetallicGlossMap");

	public static readonly int SpecularHighlights = PrefixedPropertyToID("", "SpecularHighlights");

	public static readonly int GlossyReflections = PrefixedPropertyToID("", "GlossyReflections");

	public static readonly int BumpScale = PrefixedPropertyToID("", "BumpScale");

	public static readonly int BumpMap = PrefixedPropertyToID("", "BumpMap");

	public static readonly int Parallax = PrefixedPropertyToID("", "Parallax");

	public static readonly int ParallaxMap = PrefixedPropertyToID("", "ParallaxMap");

	public static readonly int OcclusionStrength = PrefixedPropertyToID("", "OcclusionStrength");

	public static readonly int OcclusionMap = PrefixedPropertyToID("", "OcclusionMap");

	public static readonly int EmissionColor = PrefixedPropertyToID("", "EmissionColor");

	public static readonly int EmissionMap = PrefixedPropertyToID("", "EmissionMap");

	public static readonly int DetailMask = PrefixedPropertyToID("", "DetailMask");

	public static readonly int DetailAlbedoMap = PrefixedPropertyToID("", "DetailAlbedoMap");

	public static readonly int DetailNormalMapScale = PrefixedPropertyToID("", "DetailNormalMapScale");

	public static readonly int DetailNormalMap = PrefixedPropertyToID("", "DetailNormalMap");

	public static readonly int UVSec = PrefixedPropertyToID("", "UVSec");

	public static readonly int Mode = PrefixedPropertyToID("", "Mode");

	public static readonly int SrcBlend = PrefixedPropertyToID("", "SrcBlend");

	public static readonly int DstBlend = PrefixedPropertyToID("", "DstBlend");

	public static readonly int ZWrite = PrefixedPropertyToID("", "ZWrite");

	public static readonly int WorldSpaceCameraPos = PrefixedPropertyToID("", "WorldSpaceCameraPos");

	public static readonly int ProjectionParams = PrefixedPropertyToID("", "ProjectionParams");

	public static readonly int ScreenParams = PrefixedPropertyToID("", "ScreenParams");

	public static readonly int ZBufferParams = PrefixedPropertyToID("", "ZBufferParams");

	public static readonly int Time = PrefixedPropertyToID("", "Time");

	public static readonly int SinTime = PrefixedPropertyToID("", "SinTime");

	public static readonly int CosTime = PrefixedPropertyToID("", "CosTime");

	public static readonly int LightColor0 = PrefixedPropertyToID("", "LightColor0");

	public static readonly int WorldSpaceLightPos0 = PrefixedPropertyToID("", "WorldSpaceLightPos0");

	public static readonly int LightMatrix0 = PrefixedPropertyToID("", "LightMatrix0");

	public static readonly int TextureSampleAdd = PrefixedPropertyToID("", "TextureSampleAdd");

	public static readonly int OpacScale = PrefixedPropertyToID("", "OpacScale");

	public static int GetMainTexID(Material material)
	{
		if (!material.HasProperty(BaseMap))
		{
			return MainTex;
		}
		return BaseMap;
	}

	public static int PrefixedPropertyToID(string prefix = "", [CallerMemberName] string name = null)
	{
		if (!name.StartsWith("_"))
		{
			prefix += "_";
		}
		return Shader.PropertyToID(prefix + name);
	}
}



[Serializable]
public class ShaderProperty
{
	public string name;

	public bool setFloat = true;

	public float floatValue;

	public bool setInt = true;

	public int intValue;

	public bool setVector = true;

	public Vector4 vectorValue = Vector4.zero;

	public bool setColor = true;

	public Color colorValue = Color.black;

	public void Set(Material material)
	{
		if (setFloat)
		{
			material.SetFloat(name, floatValue);
		}
		if (setInt)
		{
			material.SetInt(name, intValue);
		}
		if (setVector)
		{
			material.SetVector(name, vectorValue);
		}
		if (setColor)
		{
			material.SetColor(name, colorValue);
		}
	}
}



public class ShadowCamera
{
	public static (Matrix4x4, Matrix4x4, RenderTexture) RenderShadowMap(Light light, Bounds groupBounds, LayerMask shadowCullingMask)
	{
		GameObject gameObject = new GameObject("Shadow Camera");
		Camera camera = gameObject.AddComponent<Camera>();
		camera.transform.SetPositionAndRotation(light.transform.position, light.transform.rotation);
		camera.nearClipPlane = 0.01f;
		camera.cullingMask = shadowCullingMask;
		camera.clearFlags = CameraClearFlags.Color;
		camera.backgroundColor = Color.black;
		RenderTexture renderTexture;
		if (light.type == LightType.Directional)
		{
			renderTexture = new RenderTexture(2048, 2048, 24, RenderTextureFormat.RFloat)
			{
				dimension = TextureDimension.Tex2D,
				wrapMode = TextureWrapMode.Clamp,
				filterMode = FilterMode.Point,
				useMipMap = false
			};
			var (position, vector) = CalculateCameraParams(light.transform, groupBounds);
			camera.transform.position = position;
			camera.orthographic = true;
			camera.orthographicSize = vector.x;
			camera.nearClipPlane = vector.y;
			camera.farClipPlane = vector.z;
			camera.targetTexture = renderTexture;
			camera.backgroundColor = new Color(-9999f, -9999f, -9999f);
			Shader shader = Shader.Find("ULTRAKILL/Shadowmap_Directional");
			camera.SetReplacementShader(shader, "");
			camera.Render();
		}
		else
		{
			renderTexture = new RenderTexture(2048, 2048, 24, RenderTextureFormat.RFloat)
			{
				dimension = TextureDimension.Cube,
				wrapMode = TextureWrapMode.Clamp,
				filterMode = FilterMode.Point,
				useMipMap = false
			};
			camera.farClipPlane = light.range * 2f;
			camera.backgroundColor = new Color(9999f, 9999f, 9999f);
			Shader shader2 = Shader.Find("ULTRAKILL/Shadowmap_PointSpot");
			camera.SetReplacementShader(shader2, "");
			Shader.SetGlobalVector("bakeLightPos", camera.transform.position);
			camera.RenderToCubemap(renderTexture);
		}
		Matrix4x4 worldToCameraMatrix = camera.worldToCameraMatrix;
		Matrix4x4 projectionMatrix = camera.projectionMatrix;
		camera.targetTexture = null;
		camera.ResetReplacementShader();
		Object.DestroyImmediate(gameObject);
		return (worldToCameraMatrix, projectionMatrix, renderTexture);
	}

	public static Bounds CalculateGroupBounds(Renderer[] rends)
	{
		Bounds result = default(Bounds);
		foreach (Renderer renderer in rends)
		{
			result.Encapsulate(renderer.bounds);
		}
		return result;
	}

	public static (Vector3, Vector3) CalculateCameraParams(Transform lightTransform, Bounds groupBounds)
	{
		Vector3[] boundsVertices = GetBoundsVertices(groupBounds);
		Bounds bounds = new Bounds(lightTransform.InverseTransformPoint(boundsVertices[0]), Vector3.zero);
		Vector3[] array = boundsVertices;
		foreach (Vector3 position in array)
		{
			Vector3 point = lightTransform.InverseTransformPoint(position);
			bounds.Encapsulate(point);
		}
		Vector3 item = lightTransform.TransformPoint(bounds.center);
		float x = Mathf.Max(bounds.extents.x, bounds.extents.y);
		float y = 0f - bounds.extents.z;
		float z = bounds.extents.z;
		Vector3 item2 = new Vector3(x, y, z);
		return (item, item2);
	}

	private static Vector3[] GetBoundsVertices(Bounds bounds)
	{
		return new Vector3[8]
		{
			bounds.min,
			new Vector3(bounds.min.x, bounds.min.y, bounds.max.z),
			new Vector3(bounds.min.x, bounds.max.y, bounds.min.z),
			new Vector3(bounds.min.x, bounds.max.y, bounds.max.z),
			new Vector3(bounds.max.x, bounds.min.y, bounds.min.z),
			new Vector3(bounds.max.x, bounds.min.y, bounds.max.z),
			new Vector3(bounds.max.x, bounds.max.y, bounds.min.z),
			bounds.max
		};
	}
}



public class Shockwave : MonoBehaviour
{
	public bool groundSlam;

	public float lifeTime;

	private void Start()
	{
		Invoke("TimeToDie", lifeTime);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Breakable"))
		{
			Breakable component = other.gameObject.GetComponent<Breakable>();
			if (component != null && ((component.weak && !component.precisionOnly) || (groundSlam && component.forceGroundSlammable)))
			{
				component.Break();
			}
		}
	}

	private void TimeToDie()
	{
		Object.Destroy(this);
	}
}



public class ShopButton : MonoBehaviour
{
	public bool deactivated;

	public bool failure;

	public GameObject clickSound;

	public GameObject failSound;

	public GameObject[] toActivate;

	public GameObject[] toDeactivate;

	public VariationInfo variationInfo;

	private ControllerPointer pointer;

	private void Awake()
	{
		if (!TryGetComponent<ControllerPointer>(out pointer))
		{
			pointer = base.gameObject.AddComponent<ControllerPointer>();
		}
		pointer.OnPressed.AddListener(OnPointerClick);
	}

	private void OnPointerClick()
	{
		if (deactivated)
		{
			return;
		}
		if (!failure)
		{
			GameObject[] array = toActivate;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			array = toDeactivate;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			if (variationInfo != null)
			{
				variationInfo.WeaponBought();
			}
			if (clickSound != null)
			{
				Object.Instantiate(clickSound);
			}
		}
		else if (failure && failSound != null)
		{
			Object.Instantiate(failSound);
		}
	}
}



public class ShopCategory : MonoBehaviour
{
	public string weaponName;

	public void CheckGear()
	{
		if (GameProgressSaver.CheckGear(weaponName) == 0)
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			base.gameObject.SetActive(value: true);
		}
	}
}



public class ShopGearChecker : MonoBehaviour
{
	private ShopCategory[] shopcats;

	private void OnEnable()
	{
		if (shopcats == null)
		{
			shopcats = GetComponentsInChildren<ShopCategory>();
		}
		ShopCategory[] array = shopcats;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckGear();
		}
	}
}



public class ShopMother : MonoBehaviour
{
	private ShopZone shop;

	public Text dailyTip;

	private Text origDailyTip;

	private GameObject menu;

	private CameraController cc;

	private void Start()
	{
		ShopZone[] array = Object.FindObjectsOfType<ShopZone>();
		foreach (ShopZone shopZone in array)
		{
			if (shopZone.gameObject != base.gameObject)
			{
				shop = shopZone;
			}
		}
		if (shop != null)
		{
			origDailyTip = shop.transform.GetChild(1).GetChild(4).GetChild(0)
				.GetChild(0)
				.GetChild(1)
				.GetComponent<Text>();
			dailyTip.text = origDailyTip.text;
		}
		menu = base.transform.GetChild(0).gameObject;
		cc = MonoSingleton<CameraController>.Instance;
	}

	private void Update()
	{
		if (MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame && menu.activeSelf)
		{
			TurnOff();
		}
	}

	public void TurnOn()
	{
		if (!menu.activeSelf)
		{
			menu.SetActive(value: true);
			cc.enabled = false;
			Cursor.lockState = CursorLockMode.None;
			Cursor.visible = true;
		}
	}

	public void TurnOff()
	{
		if (menu.activeSelf)
		{
			menu.SetActive(value: false);
			cc.enabled = true;
		}
	}
}



public class ShopZone : ScreenZone
{
	private bool inUse;

	private Canvas shopCanvas;

	public bool firstVariationBuy;

	private ShopMother shom;

	private ShopCategory[] shopcats;

	public bool muteMusic;

	private float originalMusicVolume;

	private float musicTarget = 1f;

	private bool fading;

	public bool forcedOff;

	private void Start()
	{
		shopCanvas = GetComponentInChildren<Canvas>(includeInactive: true);
		if (shopCanvas != null)
		{
			shopCanvas.gameObject.SetActive(value: false);
		}
		originalMusicVolume = MonoSingleton<AudioMixerController>.Instance.optionsMusicVolume;
		musicTarget = originalMusicVolume;
		MonoSingleton<CheckPointsController>.Instance.AddShop(this);
		onEnterZone.AddListener(TurnOn);
		onExitZone.AddListener(TurnOff);
	}

	protected override void Update()
	{
		base.Update();
		if (muteMusic && fading && MonoSingleton<AudioMixerController>.Instance.musicVolume != musicTarget)
		{
			MonoSingleton<AudioMixerController>.Instance.SetMusicVolume(Mathf.MoveTowards(MonoSingleton<AudioMixerController>.Instance.musicVolume, Mathf.Min(musicTarget, MonoSingleton<AudioMixerController>.Instance.optionsMusicVolume), originalMusicVolume * Time.deltaTime));
			if (MonoSingleton<AudioMixerController>.Instance.musicVolume == musicTarget)
			{
				fading = false;
			}
		}
	}

	public void TurnOn()
	{
		if (!inUse && !forcedOff)
		{
			inUse = true;
			if (shopCanvas != null)
			{
				shopCanvas.gameObject.SetActive(value: true);
			}
			if (shopcats == null)
			{
				shopcats = GetComponentsInChildren<ShopCategory>();
			}
			ShopCategory[] array = shopcats;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].CheckGear();
			}
			ControllerPointer.raycaster = shopCanvas.GetComponent<GraphicRaycaster>();
			if (muteMusic)
			{
				fading = true;
				musicTarget = 0f;
			}
		}
	}

	public void TurnOff()
	{
		if (inUse)
		{
			if (shopCanvas != null)
			{
				shopCanvas.gameObject.SetActive(value: false);
			}
			inUse = false;
			shopCanvas.gameObject.SetActive(value: false);
			if (firstVariationBuy)
			{
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Cycle through <color=orange>EQUIPPED</color> variations with '<color=orange>", "ChangeVariation", "</color>'.");
				firstVariationBuy = false;
				PlayerPrefs.SetInt("FirVar", 0);
			}
			if (muteMusic)
			{
				fading = true;
				musicTarget = originalMusicVolume;
			}
		}
	}

	public void ForceOff()
	{
		TurnOff();
		forcedOff = true;
	}

	public void StopForceOff()
	{
		forcedOff = false;
		if (inZone)
		{
			TurnOn();
		}
	}
}



public class Shotgun : MonoBehaviour
{
	private InputManager inman;

	private WeaponIdentifier wid;

	private AudioSource gunAud;

	public AudioClip shootSound;

	public AudioClip shootSound2;

	public AudioClip clickSound;

	public AudioClip clickChargeSound;

	public AudioClip smackSound;

	public AudioClip pump1sound;

	public AudioClip pump2sound;

	public int variation;

	public GameObject bullet;

	public GameObject grenade;

	public float spread;

	private bool smallSpread;

	private Animator anim;

	private GameObject cam;

	private CameraController cc;

	private GunControl gc;

	private bool gunReady;

	public Transform[] shootPoints;

	public GameObject muzzleFlash;

	public SkinnedMeshRenderer heatSinkSMR;

	private Color tempColor;

	private bool releasingHeat;

	[SerializeField]
	private ParticleSystem[] heatReleaseParticles;

	private AudioSource heatSinkAud;

	public LayerMask shotgunZoneLayerMask;

	private RaycastHit[] rhits;

	private bool charging;

	private float grenadeForce;

	private Vector3 grenadeVector;

	private Slider chargeSlider;

	public Image sliderFill;

	public GameObject grenadeSoundBubble;

	public GameObject chargeSoundBubble;

	private AudioSource tempChargeSound;

	[HideInInspector]
	public int primaryCharge;

	private bool cockedBack;

	public GameObject explosion;

	public GameObject pumpChargeSound;

	public GameObject warningBeep;

	private float timeToBeep;

	[SerializeField]
	private Chainsaw chainsaw;

	private List<Chainsaw> currentChainsaws = new List<Chainsaw>();

	[SerializeField]
	private Transform chainsawAttachPoint;

	[SerializeField]
	private ScrollingTexture chainsawBladeScroll;

	private MeshRenderer chainsawBladeRenderer;

	private Material chainsawBladeMaterial;

	[SerializeField]
	private Material chainsawBladeMotionMaterial;

	[SerializeField]
	private HurtZone sawZone;

	[SerializeField]
	private ParticleSystem environmentalSawSpark;

	[SerializeField]
	private AudioSource environmentalSawSound;

	private WeaponPos wpos;

	private CameraFrustumTargeter targeter;

	private bool meterOverride;

	private void Start()
	{
		targeter = Camera.main.GetComponent<CameraFrustumTargeter>();
		inman = MonoSingleton<InputManager>.Instance;
		wid = GetComponent<WeaponIdentifier>();
		gunAud = GetComponent<AudioSource>();
		anim = GetComponentInChildren<Animator>();
		cam = MonoSingleton<CameraController>.Instance.gameObject;
		cc = MonoSingleton<CameraController>.Instance;
		gc = GetComponentInParent<GunControl>();
		tempColor = heatSinkSMR.materials[3].GetColor("_TintColor");
		heatSinkAud = heatSinkSMR.GetComponent<AudioSource>();
		chargeSlider = GetComponentInChildren<Slider>();
		sliderFill = chargeSlider.GetComponentInChildren<Image>();
		if (variation == 0)
		{
			chargeSlider.value = chargeSlider.maxValue;
		}
		else if (variation == 1)
		{
			chargeSlider.value = 0f;
		}
		wpos = GetComponent<WeaponPos>();
		if ((bool)chainsawBladeScroll)
		{
			chainsawBladeRenderer = chainsawBladeScroll.GetComponent<MeshRenderer>();
			chainsawBladeMaterial = chainsawBladeRenderer.sharedMaterial;
		}
		if ((bool)sawZone)
		{
			sawZone.sourceWeapon = base.gameObject;
		}
	}

	private void OnEnable()
	{
		if (variation != 2)
		{
			return;
		}
		foreach (Chainsaw currentChainsaw in currentChainsaws)
		{
			currentChainsaw.lineStartTransform = chainsawAttachPoint;
		}
		chainsawAttachPoint.gameObject.SetActive(MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f);
	}

	private void OnDisable()
	{
		if (!base.gameObject.scene.isLoaded)
		{
			return;
		}
		if (anim == null)
		{
			anim = GetComponentInChildren<Animator>();
		}
		anim.StopPlayback();
		gunReady = false;
		if (sliderFill != null && (bool)MonoSingleton<ColorBlindSettings>.Instance)
		{
			sliderFill.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation];
		}
		if (chargeSlider == null)
		{
			chargeSlider = GetComponentInChildren<Slider>();
		}
		if (variation == 0)
		{
			chargeSlider.value = chargeSlider.maxValue;
		}
		else if (variation == 1)
		{
			chargeSlider.value = 0f;
		}
		if (sliderFill == null)
		{
			sliderFill = chargeSlider.GetComponentInChildren<Image>();
		}
		primaryCharge = 0;
		charging = false;
		grenadeForce = 0f;
		meterOverride = false;
		if (tempChargeSound != null)
		{
			Object.Destroy(tempChargeSound);
		}
		foreach (Chainsaw currentChainsaw in currentChainsaws)
		{
			currentChainsaw.lineStartTransform = MonoSingleton<NewMovement>.Instance.transform;
		}
		if ((bool)sawZone)
		{
			sawZone.enabled = false;
		}
		if ((bool)environmentalSawSound)
		{
			environmentalSawSound.Stop();
		}
		if ((bool)environmentalSawSpark)
		{
			environmentalSawSpark.Stop();
		}
	}

	private void Update()
	{
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked && !charging)
		{
			if (!wid || wid.delay == 0f)
			{
				Shoot();
			}
			else
			{
				gunReady = false;
				Invoke("Shoot", wid.delay);
			}
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && variation == 1 && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			gunReady = false;
			if (!wid || wid.delay == 0f)
			{
				Pump();
			}
			else
			{
				Invoke("Pump", wid.delay);
			}
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && variation != 1 && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked && (variation != 2 || MonoSingleton<WeaponCharges>.Instance.shoSawCharge >= 1f))
		{
			charging = true;
			if (grenadeForce < 60f)
			{
				grenadeForce = Mathf.MoveTowards(grenadeForce, 60f, Time.deltaTime * 60f);
			}
			grenadeVector = new Vector3(cam.transform.forward.x, cam.transform.forward.y, cam.transform.forward.z);
			if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
			{
				grenadeVector = Vector3.Normalize(targeter.CurrentTarget.bounds.center - cam.transform.position);
			}
			grenadeVector += new Vector3(0f, grenadeForce * 0.002f, 0f);
			float num = 3000f;
			if (variation == 2)
			{
				num = 12000f;
			}
			base.transform.localPosition = new Vector3(wpos.currentDefault.x + Random.Range(grenadeForce / num * -1f, grenadeForce / num), wpos.currentDefault.y + Random.Range(grenadeForce / num * -1f, grenadeForce / num), wpos.currentDefault.z + Random.Range(grenadeForce / num * -1f, grenadeForce / num));
			if (tempChargeSound == null)
			{
				GameObject gameObject = Object.Instantiate(chargeSoundBubble);
				tempChargeSound = gameObject.GetComponent<AudioSource>();
				if ((bool)wid && wid.delay > 0f)
				{
					tempChargeSound.volume -= wid.delay * 2f;
					if (tempChargeSound.volume < 0f)
					{
						tempChargeSound.volume = 0f;
					}
				}
			}
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.ShotgunCharge, tempChargeSound.gameObject).intensityMultiplier = grenadeForce / 60f;
			if (variation == 0)
			{
				tempChargeSound.pitch = grenadeForce / 60f;
			}
			else
			{
				tempChargeSound.pitch = (grenadeForce / 2f + 30f) / 60f;
			}
		}
		if ((MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasCanceledThisFrame || (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && !GameStateManager.Instance.PlayerInputLocked && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)) && variation != 1 && gunReady && gc.activated && charging)
		{
			charging = false;
			if (variation == 2)
			{
				MonoSingleton<WeaponCharges>.Instance.shoSawCharge = 0f;
			}
			if (!wid || wid.delay == 0f)
			{
				if (variation == 0)
				{
					ShootSinks();
				}
				else
				{
					ShootSaw();
				}
			}
			else
			{
				gunReady = false;
				Invoke((variation == 0) ? "ShootSinks" : "ShootSaw", wid.delay);
			}
			Object.Destroy(tempChargeSound.gameObject);
		}
		if (variation == 2)
		{
			if (charging && chainsawBladeScroll.scrollSpeedX == 0f)
			{
				chainsawBladeRenderer.material = chainsawBladeMotionMaterial;
			}
			else if (!charging && chainsawBladeScroll.scrollSpeedX > 0f)
			{
				chainsawBladeRenderer.material = chainsawBladeMaterial;
			}
			chainsawBladeScroll.scrollSpeedX = grenadeForce / 6f;
			anim.SetBool("Sawing", charging);
			sawZone.enabled = charging;
			if (charging && Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward, out var hitInfo, 3f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				environmentalSawSpark.transform.position = hitInfo.point;
				if (!environmentalSawSpark.isEmitting)
				{
					environmentalSawSpark.Play();
				}
				if (!environmentalSawSound.isPlaying)
				{
					environmentalSawSound.Play();
				}
				MonoSingleton<CameraController>.Instance.CameraShake(0.1f);
			}
			else
			{
				if (environmentalSawSpark.isEmitting)
				{
					environmentalSawSpark.Stop();
				}
				if (environmentalSawSound.isPlaying)
				{
					environmentalSawSound.Stop();
				}
			}
		}
		if (releasingHeat)
		{
			tempColor.a -= Time.deltaTime * 2.5f;
			heatSinkSMR.sharedMaterials[3].SetColor("_TintColor", tempColor);
		}
		UpdateMeter();
	}

	private void UpdateMeter()
	{
		if (variation == 1)
		{
			if (timeToBeep != 0f)
			{
				timeToBeep = Mathf.MoveTowards(timeToBeep, 0f, Time.deltaTime * 5f);
			}
			if (primaryCharge == 3)
			{
				chargeSlider.value = chargeSlider.maxValue;
				if (timeToBeep == 0f)
				{
					timeToBeep = 1f;
					Object.Instantiate(warningBeep);
					sliderFill.color = Color.red;
				}
				else if (timeToBeep < 0.5f)
				{
					sliderFill.color = Color.black;
				}
			}
			else
			{
				chargeSlider.value = primaryCharge * 20;
				sliderFill.color = Color.Lerp(MonoSingleton<ColorBlindSettings>.Instance.variationColors[1], new Color(1f, 0.25f, 0.25f), (float)primaryCharge / 2f);
			}
		}
		else if (!meterOverride)
		{
			if (variation == 2 && MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f && !chainsawAttachPoint.gameObject.activeSelf)
			{
				chainsawAttachPoint.gameObject.SetActive(value: true);
			}
			if (grenadeForce > 0f)
			{
				chargeSlider.value = grenadeForce;
				sliderFill.color = Color.Lerp(MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation], new Color(1f, 0.25f, 0.25f), grenadeForce / 60f);
			}
			else if (variation == 0)
			{
				chargeSlider.value = chargeSlider.maxValue;
				sliderFill.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[0];
			}
			else
			{
				chargeSlider.value = MonoSingleton<WeaponCharges>.Instance.shoSawCharge * chargeSlider.maxValue;
				sliderFill.color = ((MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f) ? MonoSingleton<ColorBlindSettings>.Instance.variationColors[2] : Color.gray);
			}
		}
	}

	private void Shoot()
	{
		gunReady = false;
		int num = 12;
		if (variation == 1)
		{
			switch (primaryCharge)
			{
			case 0:
				num = 10;
				gunAud.pitch = Random.Range(1.15f, 1.25f);
				break;
			case 1:
				num = 16;
				gunAud.pitch = Random.Range(0.95f, 1.05f);
				break;
			case 2:
				num = 24;
				gunAud.pitch = Random.Range(0.75f, 0.85f);
				break;
			case 3:
				num = 0;
				gunAud.pitch = Random.Range(0.75f, 0.85f);
				break;
			}
		}
		MonoSingleton<CameraController>.Instance.StopShake();
		Vector3 direction = cam.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			direction = (targeter.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized;
		}
		rhits = Physics.RaycastAll(cam.transform.position, direction, 4f, shotgunZoneLayerMask);
		if (rhits.Length != 0)
		{
			RaycastHit[] array = rhits;
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (!raycastHit.collider.gameObject.CompareTag("Body"))
				{
					continue;
				}
				EnemyIdentifierIdentifier componentInParent = raycastHit.collider.GetComponentInParent<EnemyIdentifierIdentifier>();
				if ((bool)componentInParent && (bool)componentInParent.eid)
				{
					EnemyIdentifier eid = componentInParent.eid;
					if (!eid.dead && !eid.blessed && anim.GetCurrentAnimatorStateInfo(0).IsName("Equip"))
					{
						MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.quickdraw", gc.currentWeapon, eid);
					}
					eid.hitter = "shotgunzone";
					if (!eid.hitterWeapons.Contains("shotgun" + variation))
					{
						eid.hitterWeapons.Add("shotgun" + variation);
					}
					eid.DeliverDamage(raycastHit.collider.gameObject, (eid.transform.position - base.transform.position).normalized * 10000f, raycastHit.point, 4f, tryForExplode: false, 0f, base.gameObject);
				}
			}
		}
		MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.GunFireProjectiles, base.gameObject);
		if (variation != 1 || primaryCharge != 3)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = Object.Instantiate(bullet, cam.transform.position, cam.transform.rotation);
				Projectile component = gameObject.GetComponent<Projectile>();
				component.weaponType = "shotgun" + variation;
				component.sourceWeapon = gc.currentWeapon;
				if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
				{
					gameObject.transform.LookAt(targeter.CurrentTarget.bounds.center);
				}
				if (variation == 1)
				{
					switch (primaryCharge)
					{
					case 0:
						gameObject.transform.Rotate(Random.Range((0f - spread) / 1.5f, spread / 1.5f), Random.Range((0f - spread) / 1.5f, spread / 1.5f), Random.Range((0f - spread) / 1.5f, spread / 1.5f));
						break;
					case 1:
						gameObject.transform.Rotate(Random.Range(0f - spread, spread), Random.Range(0f - spread, spread), Random.Range(0f - spread, spread));
						break;
					case 2:
						gameObject.transform.Rotate(Random.Range((0f - spread) * 2f, spread * 2f), Random.Range((0f - spread) * 2f, spread * 2f), Random.Range((0f - spread) * 2f, spread * 2f));
						break;
					}
				}
				else
				{
					gameObject.transform.Rotate(Random.Range(0f - spread, spread), Random.Range(0f - spread, spread), Random.Range(0f - spread, spread));
				}
			}
		}
		else
		{
			Vector3 position = cam.transform.position + cam.transform.forward;
			if (Physics.Raycast(cam.transform.position, cam.transform.forward, out var hitInfo, 1f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				position = hitInfo.point - cam.transform.forward * 0.1f;
			}
			GameObject gameObject2 = Object.Instantiate(explosion, position, cam.transform.rotation);
			if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
			{
				gameObject2.transform.LookAt(targeter.CurrentTarget.bounds.center);
			}
			Explosion[] componentsInChildren = gameObject2.GetComponentsInChildren<Explosion>();
			foreach (Explosion obj in componentsInChildren)
			{
				obj.sourceWeapon = gc.currentWeapon;
				obj.enemyDamageMultiplier = 1f;
				obj.maxSize *= 1.5f;
				obj.damage = 50;
			}
		}
		if (variation != 1)
		{
			gunAud.pitch = Random.Range(0.95f, 1.05f);
		}
		gunAud.clip = shootSound;
		gunAud.volume = 0.45f;
		gunAud.panStereo = 0f;
		gunAud.Play();
		cc.CameraShake(1f);
		if (variation == 1)
		{
			anim.SetTrigger("PumpFire");
		}
		else
		{
			anim.SetTrigger("Fire");
		}
		Transform[] array2 = shootPoints;
		foreach (Transform transform in array2)
		{
			Object.Instantiate(muzzleFlash, transform.transform.position, transform.transform.rotation);
		}
		releasingHeat = false;
		tempColor.a = 1f;
		heatSinkSMR.sharedMaterials[3].SetColor("_TintColor", tempColor);
		if (variation == 1)
		{
			primaryCharge = 0;
		}
	}

	private void ShootSinks()
	{
		gunReady = false;
		base.transform.localPosition = wpos.currentDefault;
		Transform[] array = shootPoints;
		for (int i = 0; i < array.Length; i++)
		{
			_ = array[i];
			GameObject obj = Object.Instantiate(grenade, cam.transform.position + cam.transform.forward * 0.5f, Random.rotation);
			obj.GetComponentInChildren<Grenade>().sourceWeapon = gc.currentWeapon;
			obj.GetComponent<Rigidbody>().AddForce(grenadeVector * (grenadeForce + 10f), ForceMode.VelocityChange);
		}
		Object.Instantiate(grenadeSoundBubble).GetComponent<AudioSource>().volume = 0.45f * Mathf.Sqrt(Mathf.Pow(1f, 2f) - Mathf.Pow(grenadeForce, 2f) / Mathf.Pow(60f, 2f));
		anim.SetTrigger("Secondary Fire");
		gunAud.clip = shootSound;
		gunAud.volume = 0.45f * (grenadeForce / 60f);
		gunAud.panStereo = 0f;
		gunAud.pitch = Random.Range(0.75f, 0.85f);
		gunAud.Play();
		cc.CameraShake(1f);
		meterOverride = true;
		chargeSlider.value = 0f;
		sliderFill.color = Color.black;
		array = shootPoints;
		foreach (Transform transform in array)
		{
			Object.Instantiate(muzzleFlash, transform.transform.position, transform.transform.rotation);
		}
		releasingHeat = false;
		tempColor.a = 0f;
		heatSinkSMR.sharedMaterials[3].SetColor("_TintColor", tempColor);
		grenadeForce = 0f;
	}

	private void ShootSaw()
	{
		gunReady = true;
		base.transform.localPosition = wpos.currentDefault;
		Vector3 vector = cam.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			vector = (targeter.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized;
		}
		Transform[] array = shootPoints;
		for (int i = 0; i < array.Length; i++)
		{
			_ = array[i];
			Vector3 position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + vector * 0.5f;
			if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), vector, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				position = hitInfo.point - vector * 5f;
			}
			Chainsaw chainsaw = Object.Instantiate(this.chainsaw, position, Random.rotation);
			chainsaw.weaponType = "shotgun" + variation;
			chainsaw.CheckMultipleRicochets(onStart: true);
			chainsaw.sourceWeapon = gc.currentWeapon;
			chainsaw.attachedTransform = MonoSingleton<PlayerTracker>.Instance.GetTarget();
			chainsaw.lineStartTransform = chainsawAttachPoint;
			chainsaw.GetComponent<Rigidbody>().AddForce(vector * (grenadeForce + 10f) * 1.5f, ForceMode.VelocityChange);
			currentChainsaws.Add(chainsaw);
		}
		chainsawBladeRenderer.material = chainsawBladeMaterial;
		chainsawBladeScroll.scrollSpeedX = 0f;
		chainsawAttachPoint.gameObject.SetActive(value: false);
		Object.Instantiate(grenadeSoundBubble).GetComponent<AudioSource>().volume = 0.45f * Mathf.Sqrt(Mathf.Pow(1f, 2f) - Mathf.Pow(grenadeForce, 2f) / Mathf.Pow(60f, 2f));
		anim.Play("FireNoReload");
		gunAud.clip = shootSound;
		gunAud.volume = 0.45f * Mathf.Max(0.5f, grenadeForce / 60f);
		gunAud.panStereo = 0f;
		gunAud.pitch = Random.Range(0.75f, 0.85f);
		gunAud.Play();
		cc.CameraShake(1f);
		releasingHeat = false;
		grenadeForce = 0f;
	}

	private void Pump()
	{
		anim.SetTrigger("Pump");
		if (primaryCharge < 3)
		{
			primaryCharge++;
		}
	}

	public void ReleaseHeat()
	{
		releasingHeat = true;
		ParticleSystem[] array = heatReleaseParticles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play();
		}
		heatSinkAud.Play();
	}

	public void ClickSound()
	{
		if (sliderFill.color != MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation])
		{
			gunAud.clip = clickChargeSound;
		}
		else
		{
			gunAud.clip = clickSound;
		}
		gunAud.volume = 0.5f;
		gunAud.pitch = Random.Range(0.95f, 1.05f);
		gunAud.panStereo = 0.1f;
		gunAud.Play();
	}

	public void ReadyGun()
	{
		gunReady = true;
		meterOverride = false;
	}

	public void Smack()
	{
		gunAud.clip = smackSound;
		gunAud.volume = 0.75f;
		gunAud.pitch = Random.Range(2f, 2.2f);
		gunAud.panStereo = 0.1f;
		gunAud.Play();
	}

	public void SkipShoot()
	{
		anim.ResetTrigger("Fire");
		anim.Play("FireWithReload", -1, 0.05f);
	}

	public void Pump1Sound()
	{
		AudioSource component = Object.Instantiate(grenadeSoundBubble).GetComponent<AudioSource>();
		component.pitch = Random.Range(0.95f, 1.05f);
		component.clip = pump1sound;
		component.volume = 1f;
		component.panStereo = 0.1f;
		component.Play();
		AudioSource component2 = Object.Instantiate(pumpChargeSound).GetComponent<AudioSource>();
		float num = primaryCharge;
		component2.pitch = 1f + num / 5f;
		component2.Play();
	}

	public void Pump2Sound()
	{
		AudioSource component = Object.Instantiate(grenadeSoundBubble).GetComponent<AudioSource>();
		component.pitch = Random.Range(0.95f, 1.05f);
		component.clip = pump2sound;
		component.volume = 1f;
		component.panStereo = 0.1f;
		component.Play();
	}
}



public class ShotgunAnimationReceiver : MonoBehaviour
{
	private Shotgun sgun;

	private void Start()
	{
		sgun = GetComponentInParent<Shotgun>();
	}

	public void ReleaseHeat()
	{
		sgun.ReleaseHeat();
	}

	public void ClickSound()
	{
		sgun.ClickSound();
	}

	public void ReadyGun()
	{
		sgun.ReadyGun();
	}

	public void Smack()
	{
		sgun.Smack();
	}

	public void Pump1Sound()
	{
		sgun.Pump1Sound();
	}

	public void Pump2Sound()
	{
		sgun.Pump2Sound();
	}
}



public class ShotgunHammer : MonoBehaviour
{
	private WeaponIdentifier wid;

	public int variation;

	private GunControl gc;

	private bool gunReady;

	private WeaponPos wpos;

	private CameraFrustumTargeter targeter;

	private Animator anim;

	[HideInInspector]
	public int primaryCharge;

	public GameObject pumpChargeSound;

	public GameObject warningBeep;

	private float timeToBeep;

	private bool chargingSwing;

	private float swingCharge;

	[SerializeField]
	private Transform modelTransform;

	[HideInInspector]
	public Vector3 defaultModelPosition;

	[SerializeField]
	private Transform hammerPullable;

	[SerializeField]
	private AudioSource hammerPullSound;

	[HideInInspector]
	public Vector3 hammerDefaultPosition;

	private TimeSince pulledOut;

	private bool fireHeldOnPullOut;

	private float hammerCooldown;

	[SerializeField]
	private Transform rotatingMotor;

	private Quaternion motorPreviousRotation;

	[SerializeField]
	private SpriteRenderer motorSprite;

	[SerializeField]
	private AudioSource motorSound;

	private bool overheated;

	[SerializeField]
	private ParticleSystem overheatParticle;

	[SerializeField]
	private AudioSource overheatAud;

	private float currentSpeed;

	[SerializeField]
	private Renderer meter;

	[SerializeField]
	private Texture[] meterEmissives;

	private int tier;

	private MaterialPropertyBlock block;

	[SerializeField]
	private Transform meterHand;

	private TimeSince tierDownTimer;

	[SerializeField]
	private Image secondaryMeter;

	private float secondaryMeterFill;

	[SerializeField]
	private AudioSource hitSound;

	[SerializeField]
	private GameObject[] hitImpactParticle;

	private Coroutine impactRoutine;

	private float storedSpeed;

	private TimeSince speedStorageTimer;

	[Header("Core Eject")]
	[SerializeField]
	private GameObject grenade;

	[SerializeField]
	private AudioSource nadeSpawnSound;

	[SerializeField]
	private AudioSource nadeReadySound;

	private bool nadeCharging;

	[Header("Pump Charge")]
	[SerializeField]
	private AudioSource pump1Sound;

	[SerializeField]
	private AudioSource pump2Sound;

	[SerializeField]
	private GameObject pumpExplosion;

	[SerializeField]
	private GameObject overPumpExplosion;

	private bool aboutToSecondary;

	[Header("Chainsaw")]
	public GameObject chargeSoundBubble;

	private AudioSource tempChargeSound;

	private bool charging;

	private float chargeForce;

	[SerializeField]
	private Chainsaw chainsaw;

	private List<Chainsaw> currentChainsaws = new List<Chainsaw>();

	[SerializeField]
	private Transform chainsawAttachPoint;

	[SerializeField]
	private ScrollingTexture chainsawBladeScroll;

	private MeshRenderer chainsawBladeRenderer;

	private Material chainsawBladeMaterial;

	[SerializeField]
	private Material chainsawBladeMotionMaterial;

	[SerializeField]
	private HurtZone sawZone;

	[SerializeField]
	private ParticleSystem environmentalSawSpark;

	[SerializeField]
	private AudioSource environmentalSawSound;

	private bool launchPlayer;

	private EnemyIdentifier hitEnemy;

	private Vector3 direction;

	private Transform target;

	private Vector3 hitPosition;

	private float damage;

	private bool forceWeakHit;

	private Grenade hitGrenade;

	private void Awake()
	{
		if (defaultModelPosition == Vector3.zero)
		{
			defaultModelPosition = modelTransform.localPosition;
		}
		if (hammerDefaultPosition == Vector3.zero)
		{
			hammerDefaultPosition = hammerPullable.localPosition;
		}
		targeter = Camera.main.GetComponent<CameraFrustumTargeter>();
		wid = GetComponent<WeaponIdentifier>();
		gc = GetComponentInParent<GunControl>();
		wpos = GetComponent<WeaponPos>();
		anim = GetComponent<Animator>();
		block = new MaterialPropertyBlock();
		if ((bool)chainsawBladeScroll)
		{
			chainsawBladeRenderer = chainsawBladeScroll.GetComponent<MeshRenderer>();
			chainsawBladeMaterial = chainsawBladeRenderer.sharedMaterial;
		}
		if ((bool)sawZone)
		{
			sawZone.sourceWeapon = base.gameObject;
		}
	}

	private void OnEnable()
	{
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			fireHeldOnPullOut = true;
		}
		impactRoutine = null;
		pulledOut = 0f;
		UpdateMeter(forceUpdateTexture: true);
		if (variation != 2)
		{
			return;
		}
		foreach (Chainsaw currentChainsaw in currentChainsaws)
		{
			currentChainsaw.lineStartTransform = chainsawAttachPoint;
		}
		chainsawAttachPoint.gameObject.SetActive(MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f);
	}

	private void OnDisable()
	{
		if (impactRoutine != null)
		{
			if (hitGrenade != null)
			{
				HitNade();
			}
			if (hitEnemy != null)
			{
				DeliverDamage();
			}
			ImpactEffects();
		}
		impactRoutine = null;
		gunReady = false;
		primaryCharge = 0;
		chargingSwing = false;
		charging = false;
		swingCharge = 0f;
		hammerPullable.localPosition = hammerDefaultPosition;
		tier = 0;
		hammerCooldown = 0f;
		chargeForce = 0f;
		if (tempChargeSound != null)
		{
			Object.Destroy(tempChargeSound);
		}
		foreach (Chainsaw currentChainsaw in currentChainsaws)
		{
			currentChainsaw.lineStartTransform = MonoSingleton<NewMovement>.Instance.transform;
		}
		if ((bool)sawZone)
		{
			sawZone.enabled = false;
		}
		if ((bool)environmentalSawSound)
		{
			environmentalSawSound.Stop();
		}
		if ((bool)environmentalSawSpark)
		{
			environmentalSawSpark.Stop();
		}
	}

	private void UpdateMeter(bool forceUpdateTexture = false)
	{
		int num = 0;
		if (currentSpeed > 0.66f)
		{
			num = 2;
		}
		else if (currentSpeed > 0.33f)
		{
			num = 1;
		}
		if (MonoSingleton<HookArm>.Instance.beingPulled && tier == 2)
		{
			num = 1;
		}
		else if (num < tier)
		{
			if ((float)tierDownTimer <= 0.5f)
			{
				num = tier;
			}
		}
		else
		{
			tierDownTimer = 0f;
		}
		meter.GetPropertyBlock(block, 1);
		if (tier != num || forceUpdateTexture)
		{
			block.SetTexture("_EmissiveTex", meterEmissives[num]);
			tier = num;
		}
		if (overheated)
		{
			block.SetFloat("_EmissiveIntensity", 0f);
		}
		else if ((float)tierDownTimer > 0f)
		{
			block.SetFloat("_EmissiveIntensity", ((float)tierDownTimer % 0.1f >= 0.05f) ? 1 : 0);
		}
		else
		{
			block.SetFloat("_EmissiveIntensity", 1f);
		}
		meter.SetPropertyBlock(block, 1);
		if (variation == 0)
		{
			secondaryMeterFill = MonoSingleton<WeaponCharges>.Instance.shoAltNadeCharge;
			if (secondaryMeterFill >= 1f)
			{
				secondaryMeter.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[0];
			}
			else
			{
				secondaryMeter.color = Color.white;
			}
		}
		else if (variation == 1)
		{
			if (timeToBeep != 0f)
			{
				timeToBeep = Mathf.MoveTowards(timeToBeep, 0f, Time.deltaTime * 5f);
			}
			secondaryMeterFill = (float)primaryCharge / 3f;
			if (primaryCharge == 3)
			{
				secondaryMeterFill = 1f;
				if (timeToBeep == 0f)
				{
					timeToBeep = 1f;
					Object.Instantiate(warningBeep);
					secondaryMeter.color = Color.red;
				}
				else if (timeToBeep < 0.5f)
				{
					secondaryMeter.color = Color.black;
				}
			}
			else if (primaryCharge == 1)
			{
				secondaryMeter.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[1];
			}
			else if (primaryCharge == 2)
			{
				secondaryMeter.color = Color.yellow;
			}
		}
		else if (variation == 2)
		{
			if (MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f && !chainsawAttachPoint.gameObject.activeSelf)
			{
				chainsawAttachPoint.gameObject.SetActive(value: true);
			}
			if (charging)
			{
				secondaryMeterFill = chargeForce / 60f;
				secondaryMeter.color = Color.Lerp(MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation], new Color(1f, 0.25f, 0.25f), chargeForce / 60f);
			}
			else
			{
				secondaryMeterFill = MonoSingleton<WeaponCharges>.Instance.shoSawCharge;
				secondaryMeter.color = ((MonoSingleton<WeaponCharges>.Instance.shoSawCharge == 1f) ? MonoSingleton<ColorBlindSettings>.Instance.variationColors[2] : Color.white);
			}
		}
	}

	private void Update()
	{
		overheated = MonoSingleton<WeaponCharges>.Instance.shoaltcooldowns[variation] > 0f;
		if (overheated && !overheatAud.isPlaying)
		{
			overheatAud.Play();
			overheatParticle.Play();
			anim.SetBool("Cooldown", value: true);
		}
		else if (!overheated && overheatAud.isPlaying)
		{
			overheatAud.Stop();
			overheatParticle.Stop();
			anim.SetBool("Cooldown", value: false);
		}
		float num = Mathf.Min(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude / 60f, 1f);
		currentSpeed = (overheated ? 0f : Mathf.MoveTowards(currentSpeed, num, Time.deltaTime * 2f));
		if (MonoSingleton<HookArm>.Instance.beingPulled)
		{
			currentSpeed = Mathf.Min(currentSpeed, 0.5f);
		}
		UpdateMeter();
		if ((float)pulledOut >= 0.5f)
		{
			gunReady = true;
		}
		if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && !chargingSwing && hammerCooldown <= 0f && !overheated && MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && (!fireHeldOnPullOut || (float)pulledOut >= 0.25f) && gc.activated)
		{
			fireHeldOnPullOut = false;
			chargingSwing = true;
		}
		else if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && !MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && swingCharge == 1f && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			chargingSwing = false;
			swingCharge = 0f;
			if (!wid || wid.delay == 0f)
			{
				Impact();
			}
			else
			{
				gunReady = false;
				Invoke("Impact", wid.delay);
			}
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && variation == 2 && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked && MonoSingleton<WeaponCharges>.Instance.shoSawCharge >= 1f)
		{
			charging = true;
			if (chargeForce < 60f)
			{
				chargeForce = Mathf.MoveTowards(chargeForce, 60f, Time.deltaTime * 60f);
			}
			float num2 = 12000f;
			base.transform.localPosition = new Vector3(wpos.currentDefault.x + Random.Range(chargeForce / num2 * -1f, chargeForce / num2), wpos.currentDefault.y + Random.Range(chargeForce / num2 * -1f, chargeForce / num2), wpos.currentDefault.z + Random.Range(chargeForce / num2 * -1f, chargeForce / num2));
			if (tempChargeSound == null)
			{
				GameObject gameObject = Object.Instantiate(chargeSoundBubble);
				tempChargeSound = gameObject.GetComponent<AudioSource>();
				if ((bool)wid && wid.delay > 0f)
				{
					tempChargeSound.volume -= wid.delay * 2f;
					if (tempChargeSound.volume < 0f)
					{
						tempChargeSound.volume = 0f;
					}
				}
			}
			MonoSingleton<RumbleManager>.Instance.SetVibrationTracked(RumbleProperties.ShotgunCharge, tempChargeSound.gameObject).intensityMultiplier = chargeForce / 60f;
			tempChargeSound.pitch = (chargeForce / 2f + 30f) / 60f;
		}
		if (!MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && variation == 2 && gunReady && gc.activated && charging)
		{
			charging = false;
			MonoSingleton<WeaponCharges>.Instance.shoSawCharge = 0f;
			if (!wid || wid.delay == 0f)
			{
				ShootSaw();
			}
			else
			{
				gunReady = false;
				Invoke("ShootSaw", wid.delay);
			}
			if ((bool)tempChargeSound)
			{
				Object.Destroy(tempChargeSound.gameObject);
			}
		}
		if (variation == 2)
		{
			if (charging && chainsawBladeScroll.scrollSpeedX == 0f)
			{
				chainsawBladeRenderer.material = chainsawBladeMotionMaterial;
			}
			else if (!charging && chainsawBladeScroll.scrollSpeedX > 0f)
			{
				chainsawBladeRenderer.material = chainsawBladeMaterial;
			}
			chainsawBladeScroll.scrollSpeedX = chargeForce / 6f;
			anim.SetBool("Sawing", charging);
			sawZone.enabled = charging;
			if (charging && Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), MonoSingleton<CameraController>.Instance.transform.forward, out var hitInfo, 3f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				environmentalSawSpark.transform.position = hitInfo.point;
				if (!environmentalSawSpark.isEmitting)
				{
					environmentalSawSpark.Play();
				}
				if (!environmentalSawSound.isPlaying)
				{
					environmentalSawSound.Play();
				}
				MonoSingleton<CameraController>.Instance.CameraShake(0.1f);
			}
			else
			{
				if (environmentalSawSpark.isEmitting)
				{
					environmentalSawSpark.Stop();
				}
				if (environmentalSawSound.isPlaying)
				{
					environmentalSawSound.Stop();
				}
			}
		}
		if (chargingSwing)
		{
			swingCharge = Mathf.MoveTowards(swingCharge, 1f, Time.deltaTime * 2f);
		}
		modelTransform.localPosition = new Vector3(defaultModelPosition.x + Random.Range((0f - swingCharge) / 30f, swingCharge / 30f), defaultModelPosition.y + Random.Range((0f - swingCharge) / 30f, swingCharge / 30f), defaultModelPosition.z + Random.Range((0f - swingCharge) / 30f, swingCharge / 30f));
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed && variation != 2 && (variation == 1 || MonoSingleton<WeaponCharges>.Instance.shoAltNadeCharge >= 1f) && !aboutToSecondary && gunReady && gc.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			gunReady = false;
			if (!wid || wid.delay == 0f)
			{
				if (variation == 0)
				{
					ThrowNade();
				}
				else
				{
					Pump();
				}
			}
			else
			{
				aboutToSecondary = true;
				Invoke((variation == 0) ? "ThrowNade" : "Pump", wid.delay);
			}
		}
		if (secondaryMeterFill >= 1f)
		{
			secondaryMeter.fillAmount = 1f;
		}
		else if (secondaryMeterFill <= 0f)
		{
			secondaryMeter.fillAmount = 0f;
		}
		else
		{
			secondaryMeter.fillAmount = Mathf.Lerp(0.275f, 0.625f, secondaryMeterFill);
		}
		if (hammerCooldown > 0f)
		{
			hammerCooldown = Mathf.MoveTowards(hammerCooldown, 0f, Time.deltaTime);
		}
		if (MonoSingleton<WeaponCharges>.Instance.shoAltNadeCharge < 1f)
		{
			nadeCharging = true;
		}
		else if (nadeCharging)
		{
			nadeCharging = false;
			Object.Instantiate(nadeReadySound);
		}
	}

	private void FixedUpdate()
	{
		float magnitude = MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude;
		if (magnitude >= storedSpeed - 5f || (float)speedStorageTimer > 0.5f)
		{
			storedSpeed = magnitude;
			speedStorageTimer = 0f;
		}
	}

	private void LateUpdate()
	{
		float num = Time.timeScale;
		if (impactRoutine != null)
		{
			num = 1f;
		}
		hammerPullable.localPosition = Vector3.Lerp(hammerDefaultPosition, hammerDefaultPosition + Vector3.up * -0.65f, swingCharge);
		hammerPullSound.volume = swingCharge * 0.6f;
		hammerPullSound.pitch = swingCharge + currentSpeed * 0.2f * num * Time.unscaledDeltaTime * 150f;
		if (overheated)
		{
			meterHand.localRotation = Quaternion.Euler(0f, 170f - MonoSingleton<WeaponCharges>.Instance.shoaltcooldowns[variation] / 7f * 200f, -90f);
		}
		else
		{
			meterHand.localRotation = Quaternion.Euler(0f, 170f - currentSpeed * 200f, -90f);
		}
		rotatingMotor.localRotation = motorPreviousRotation;
		rotatingMotor.Rotate(Vector3.up * currentSpeed * 10f * num * Time.unscaledDeltaTime * 150f, Space.Self);
		motorPreviousRotation = rotatingMotor.localRotation;
		motorSprite.color = new Color(1f, 1f, 1f, currentSpeed / 3f);
		motorSound.volume = currentSpeed / 2f;
		if (impactRoutine == null)
		{
			motorSound.pitch = currentSpeed * num;
		}
		else
		{
			motorSound.pitch = tier + 1;
		}
	}

	private void Impact()
	{
		impactRoutine = StartCoroutine(ImpactRoutine());
	}

	private IEnumerator ImpactRoutine()
	{
		hitEnemy = null;
		hitGrenade = null;
		target = null;
		hitPosition = Vector3.zero;
		hammerCooldown = 0.5f;
		Vector3 position = MonoSingleton<CameraController>.Instance.GetDefaultPos();
		direction = MonoSingleton<CameraController>.Instance.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			direction = (targeter.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized;
		}
		if (MonoSingleton<ObjectTracker>.Instance.grenadeList.Count > 0 || MonoSingleton<WeaponCharges>.Instance.shoSawAmount > 0 || MonoSingleton<ObjectTracker>.Instance.landmineList.Count > 0)
		{
			Collider[] cols = Physics.OverlapSphere(position, 0.01f);
			if (cols.Length != 0)
			{
				for (int i = 0; i < cols.Length; i++)
				{
					Transform transform = cols[i].transform;
					if (transform.TryGetComponent<ParryHelper>(out var component))
					{
						transform = component.target;
					}
					if (MonoSingleton<ObjectTracker>.Instance.grenadeList.Count > 0 && transform.gameObject.layer == 10)
					{
						Grenade componentInParent = transform.GetComponentInParent<Grenade>();
						if ((bool)componentInParent)
						{
							hitGrenade = componentInParent;
							cols[i].enabled = false;
							Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
							MonoSingleton<TimeController>.Instance.TrueStop(0.25f);
							yield return new WaitForSeconds(0.01f);
							HitNade();
						}
					}
					else if (MonoSingleton<WeaponCharges>.Instance.shoSawAmount > 0 || MonoSingleton<ObjectTracker>.Instance.landmineList.Count > 0)
					{
						Landmine component3;
						if (MonoSingleton<WeaponCharges>.Instance.shoSawAmount > 0 && transform.TryGetComponent<Chainsaw>(out var component2))
						{
							Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
							component2.GetPunched();
							component2.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + direction;
							component2.rb.velocity = (Punch.GetParryLookTarget() - component2.transform.position).normalized * 105f;
						}
						else if (MonoSingleton<ObjectTracker>.Instance.landmineList.Count > 0 && transform.TryGetComponent<Landmine>(out component3))
						{
							component3.transform.LookAt(Punch.GetParryLookTarget());
							component3.Parry();
							Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
							anim.Play("Fire", -1, 0f);
							MonoSingleton<TimeController>.Instance.TrueStop(0.25f);
							yield return new WaitForSeconds(0.01f);
						}
					}
				}
			}
		}
		if (MonoSingleton<WeaponCharges>.Instance.shoSawAmount > 0 || MonoSingleton<ObjectTracker>.Instance.landmineList.Count > 0)
		{
			RaycastHit[] rhits = Physics.RaycastAll(position, direction, 8f, 16384, QueryTriggerInteraction.Collide);
			for (int i = 0; i < rhits.Length; i++)
			{
				Transform transform2 = rhits[i].transform;
				if (transform2.TryGetComponent<ParryHelper>(out var component4))
				{
					transform2 = component4.target;
				}
				Landmine component6;
				if (transform2.TryGetComponent<Chainsaw>(out var component5))
				{
					Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
					component5.GetPunched();
					component5.transform.position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + direction;
					component5.rb.velocity = (Punch.GetParryLookTarget() - component5.transform.position).normalized * 105f;
				}
				else if (transform2.TryGetComponent<Landmine>(out component6))
				{
					component6.transform.LookAt(Punch.GetParryLookTarget());
					component6.Parry();
					Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
					anim.Play("Fire", -1, 0f);
					MonoSingleton<TimeController>.Instance.TrueStop(0.25f);
					yield return new WaitForSeconds(0.01f);
				}
			}
		}
		if (Physics.Raycast(position, direction, out var rhit, 8f, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment), QueryTriggerInteraction.Collide))
		{
			if (rhit.transform.gameObject.layer == 11 || rhit.transform.gameObject.layer == 10)
			{
				EnemyIdentifierIdentifier component10;
				if (rhit.transform.gameObject.TryGetComponent<ParryHelper>(out var component7))
				{
					EnemyIdentifier component9;
					if (component7.target.TryGetComponent<EnemyIdentifierIdentifier>(out var component8) && (bool)component8.eid && !component8.eid.dead)
					{
						hitEnemy = component8.eid;
					}
					else if (component7.target.TryGetComponent<EnemyIdentifier>(out component9) && !component9.dead)
					{
						hitEnemy = component9;
					}
				}
				else if (rhit.transform.TryGetComponent<EnemyIdentifierIdentifier>(out component10) && (bool)component10.eid && !component10.eid.dead)
				{
					hitEnemy = component10.eid;
				}
				else if (MonoSingleton<ObjectTracker>.Instance.grenadeList.Count > 0 && rhit.transform.gameObject.layer == 10)
				{
					Grenade componentInParent2 = rhit.transform.GetComponentInParent<Grenade>();
					if ((bool)componentInParent2)
					{
						hitGrenade = componentInParent2;
						rhit.collider.enabled = false;
						Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
						anim.Play("Fire", -1, 0f);
						MonoSingleton<TimeController>.Instance.TrueStop(0.25f);
						yield return new WaitForSeconds(0.01f);
						HitNade();
					}
				}
			}
			target = rhit.transform;
			hitPosition = rhit.point;
		}
		if (hitEnemy == null)
		{
			Vector3 vector = position + direction * 2.5f;
			Collider[] array = Physics.OverlapSphere(vector, 2.5f);
			if (array.Length != 0)
			{
				float num = 2.5f;
				for (int j = 0; j < array.Length; j++)
				{
					if (array[j].TryGetComponent<ParryHelper>(out var component11) && component11.target.TryGetComponent<Collider>(out var component12))
					{
						array[j] = component12;
					}
					if (array[j].gameObject.layer != 10 && array[j].gameObject.layer != 11)
					{
						continue;
					}
					Vector3 vector2 = array[j].ClosestPoint(vector);
					if (Physics.Raycast(position, vector2 - position, out rhit, Vector3.Distance(vector2, position), LayerMaskDefaults.Get(LMD.Environment)))
					{
						continue;
					}
					float num2 = Vector3.Distance(vector, vector2);
					if (num2 < num)
					{
						Transform transform3 = ((array[j].attachedRigidbody != null) ? array[j].attachedRigidbody.transform : array[j].transform);
						EnemyIdentifier component13 = null;
						if (transform3.TryGetComponent<EnemyIdentifierIdentifier>(out var component14))
						{
							component13 = component14.eid;
						}
						else
						{
							transform3.TryGetComponent<EnemyIdentifier>(out component13);
						}
						if ((bool)component13 && (!component13.dead || hitEnemy == null))
						{
							hitEnemy = component14.eid;
							num = num2;
							target = transform3;
							hitPosition = vector2;
						}
					}
				}
			}
			RaycastHit[] array2 = Physics.SphereCastAll(position + direction * 2.5f, 2.5f, direction, 3f, LayerMaskDefaults.Get(LMD.Enemies));
			if (array2.Length != 0)
			{
				float num3 = -1f;
				if (hitEnemy != null)
				{
					num3 = Vector3.Dot(direction, hitPosition - position);
				}
				for (int k = 0; k < array2.Length; k++)
				{
					if (Physics.Raycast(position, array2[k].point - position, out rhit, Vector3.Distance(array2[k].point, position), LayerMaskDefaults.Get(LMD.Environment)))
					{
						continue;
					}
					float num4 = Vector3.Dot(direction, array2[k].point - position);
					if (num4 > num3)
					{
						Transform transform4 = array2[k].transform;
						Vector3 point = array2[k].point;
						if (transform4.TryGetComponent<ParryHelper>(out var component15))
						{
							transform4 = component15.target.transform;
						}
						EnemyIdentifier component16 = null;
						if (transform4.TryGetComponent<EnemyIdentifierIdentifier>(out var component17))
						{
							component16 = component17.eid;
						}
						else
						{
							transform4.TryGetComponent<EnemyIdentifier>(out component16);
						}
						if ((bool)component16 && (!component16.dead || hitEnemy == null))
						{
							hitEnemy = component16;
							num3 = num4;
							target = transform4;
							hitPosition = point;
						}
					}
				}
			}
		}
		forceWeakHit = true;
		if (target != null)
		{
			Breakable component18;
			Glass component19;
			if (hitEnemy != null)
			{
				float num5 = 0.05f;
				damage = 3f;
				if (tier == 2)
				{
					num5 = 0.5f;
					damage = 10f;
				}
				else if (tier == 1)
				{
					num5 = 0.25f;
					damage = 6f;
				}
				if (hitEnemy.dead)
				{
					num5 = 0f;
				}
				if (num5 > 0f)
				{
					forceWeakHit = false;
					launchPlayer = true;
					Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
					MonoSingleton<TimeController>.Instance.TrueStop(num5);
					yield return new WaitForSeconds(0.01f);
				}
				else
				{
					launchPlayer = false;
				}
				DeliverDamage();
			}
			else if (target.TryGetComponent<Breakable>(out component18) && !component18.precisionOnly && !component18.unbreakable)
			{
				component18.Break();
			}
			else if (target.TryGetComponent<Glass>(out component19) && !component19.broken)
			{
				component19.Shatter();
			}
		}
		if (!hitGrenade && ((hitEnemy == null && target != null && (target.gameObject.layer == 8 || target.gameObject.layer == 24)) || ((bool)hitEnemy && hitEnemy.dead)))
		{
			MonoSingleton<NewMovement>.Instance.Launch(-direction * ((float)(100 * tier + 300) / ((float)(MonoSingleton<NewMovement>.Instance.hammerJumps + 3) / 3f)));
			MonoSingleton<NewMovement>.Instance.hammerJumps++;
		}
		ImpactEffects();
		hitEnemy = null;
		hitGrenade = null;
		impactRoutine = null;
	}

	private void DeliverDamage()
	{
		direction = MonoSingleton<CameraController>.Instance.transform.forward;
		if (launchPlayer)
		{
			MonoSingleton<NewMovement>.Instance.Launch(-direction * (300 * tier + 100));
			if (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude < storedSpeed)
			{
				MonoSingleton<NewMovement>.Instance.rb.velocity = -direction * storedSpeed;
			}
		}
		if (!hitEnemy.hitterWeapons.Contains("hammer" + variation))
		{
			hitEnemy.hitterWeapons.Add("hammer" + variation);
		}
		bool dead = hitEnemy.dead;
		if (target.gameObject.CompareTag("Body"))
		{
			hitEnemy.hitter = "hammerzone";
			hitEnemy.DeliverDamage(target.gameObject, direction * (50000 * tier + 50000), hitPosition, 4f, tryForExplode: true, 0f, base.gameObject);
		}
		hitEnemy.hitter = "hammer";
		hitEnemy.DeliverDamage(target.gameObject, direction * (50000 * tier + 50000), hitPosition, damage, tryForExplode: true, 0f, base.gameObject);
		if (!dead)
		{
			if (hitEnemy.dead)
			{
				if (tier == 2)
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(240, "ultrakill.hammerhitred", base.gameObject, hitEnemy);
				}
				else if (tier == 1)
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(120, "ultrakill.hammerhityellow", base.gameObject, hitEnemy);
				}
				else
				{
					MonoSingleton<StyleHUD>.Instance.AddPoints(80, "ultrakill.hammerhitgreen", base.gameObject, hitEnemy);
				}
			}
			else if (tier == 2)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(120, "ultrakill.hammerhitheavy", base.gameObject, hitEnemy);
			}
			else
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(40 * (tier + 1), "ultrakill.hammerhit", base.gameObject, hitEnemy);
			}
		}
		if (tier == 2 && !dead && hitEnemy.enemyType != EnemyType.Idol)
		{
			MonoSingleton<WeaponCharges>.Instance.shoaltcooldowns[variation] = 7f;
		}
	}

	private void HitNade()
	{
		direction = MonoSingleton<CameraController>.Instance.transform.forward;
		if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), direction, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment), QueryTriggerInteraction.Ignore))
		{
			hitGrenade.GrenadeBeam(hitInfo.point, base.gameObject);
		}
		else
		{
			hitGrenade.GrenadeBeam(MonoSingleton<CameraController>.Instance.GetDefaultPos() + direction * 1000f, base.gameObject);
		}
	}

	private void ImpactEffects()
	{
		Vector3 position = ((hitPosition != Vector3.zero) ? (hitPosition - (hitPosition - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized) : (MonoSingleton<CameraController>.Instance.GetDefaultPos() + direction * 2.5f));
		if (primaryCharge > 0)
		{
			GameObject gameObject = Object.Instantiate((primaryCharge == 3) ? overPumpExplosion : pumpExplosion, position, Quaternion.LookRotation(direction));
			Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
			foreach (Explosion explosion in componentsInChildren)
			{
				explosion.sourceWeapon = base.gameObject;
				explosion.hitterWeapon = "hammer";
				if (primaryCharge == 2)
				{
					explosion.maxSize *= 2f;
				}
			}
			if (primaryCharge == 2 && gameObject.TryGetComponent<AudioSource>(out var component))
			{
				component.volume = 1f;
				component.pitch -= 0.4f;
			}
			primaryCharge = 0;
		}
		if (forceWeakHit || tier == 0)
		{
			anim.Play("Fire", -1, 0f);
		}
		else if (tier == 1)
		{
			anim.Play("FireStrong", -1, 0f);
		}
		else
		{
			anim.Play("FireStrongest", -1, 0f);
		}
		Object.Instantiate(hitImpactParticle[(!forceWeakHit) ? tier : 0], position, MonoSingleton<CameraController>.Instance.transform.rotation);
	}

	private void ThrowNade()
	{
		MonoSingleton<WeaponCharges>.Instance.shoAltNadeCharge = 0f;
		pulledOut = 0.3f;
		gunReady = false;
		aboutToSecondary = false;
		Vector3 vector = MonoSingleton<CameraController>.Instance.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			vector = (targeter.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized;
		}
		GameObject obj = Object.Instantiate(grenade, MonoSingleton<CameraController>.Instance.GetDefaultPos() + vector * 2f - MonoSingleton<CameraController>.Instance.transform.up * 0.5f, Random.rotation);
		if (obj.TryGetComponent<Rigidbody>(out var component))
		{
			component.AddForce(MonoSingleton<CameraController>.Instance.transform.forward * 3f + Vector3.up * 7.5f + (MonoSingleton<NewMovement>.Instance.ridingRocket ? MonoSingleton<NewMovement>.Instance.ridingRocket.rb.velocity : MonoSingleton<NewMovement>.Instance.rb.velocity), ForceMode.VelocityChange);
		}
		if (obj.TryGetComponent<Grenade>(out var component2))
		{
			component2.sourceWeapon = base.gameObject;
		}
		anim.Play("NadeSpawn", -1, 0f);
		Object.Instantiate(nadeSpawnSound);
	}

	private void ShootSaw()
	{
		gunReady = true;
		base.transform.localPosition = wpos.currentDefault;
		Vector3 vector = MonoSingleton<CameraController>.Instance.transform.forward;
		if ((bool)targeter.CurrentTarget && targeter.IsAutoAimed)
		{
			vector = (targeter.CurrentTarget.bounds.center - MonoSingleton<CameraController>.Instance.GetDefaultPos()).normalized;
		}
		Vector3 position = MonoSingleton<CameraController>.Instance.GetDefaultPos() + vector * 0.5f;
		if (Physics.Raycast(MonoSingleton<CameraController>.Instance.GetDefaultPos(), vector, out var hitInfo, 5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
		{
			position = hitInfo.point - vector * 5f;
		}
		Chainsaw chainsaw = Object.Instantiate(this.chainsaw, position, Random.rotation);
		chainsaw.weaponType = "hammer" + variation;
		chainsaw.CheckMultipleRicochets(onStart: true);
		chainsaw.sourceWeapon = gc.currentWeapon;
		chainsaw.attachedTransform = MonoSingleton<PlayerTracker>.Instance.GetTarget();
		chainsaw.lineStartTransform = chainsawAttachPoint;
		chainsaw.GetComponent<Rigidbody>().AddForce(vector * (chargeForce + 10f) * 1.5f, ForceMode.VelocityChange);
		currentChainsaws.Add(chainsaw);
		chainsawBladeRenderer.material = chainsawBladeMaterial;
		chainsawBladeScroll.scrollSpeedX = 0f;
		chainsawAttachPoint.gameObject.SetActive(value: false);
		Object.Instantiate(nadeSpawnSound);
		anim.Play("SawingShot");
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
		chargeForce = 0f;
	}

	private void Pump()
	{
		if (primaryCharge < 3)
		{
			primaryCharge++;
		}
		pulledOut = 0f;
		gunReady = false;
		aboutToSecondary = false;
		AudioSource component = Object.Instantiate(pumpChargeSound, base.transform.position, Quaternion.identity).GetComponent<AudioSource>();
		float num = primaryCharge;
		component.pitch = 1f + num / 5f;
		component.Play();
		Object.Instantiate(pump1Sound);
		anim.Play("Pump", -1, 0f);
	}

	private void Pump2Sound()
	{
		Object.Instantiate(pump2Sound);
	}
}



public class ShotgunShell : MonoBehaviour
{
	private bool hitGround;

	private AudioSource aud;

	private Collider col;

	private void Start()
	{
		Invoke("TurnGib", 0.2f);
		Invoke("Remove", 2f);
	}

	private void TurnGib()
	{
		col = GetComponent<Collider>();
		col.enabled = true;
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.layer = 9;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((!hitGround && collision.gameObject.layer == 8) || collision.gameObject.layer == 24)
		{
			hitGround = true;
			if (!aud)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.pitch = Random.Range(0.85f, 1.15f);
			aud.Play();
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (collision.gameObject.layer == 8 || collision.gameObject.layer == 24)
		{
			hitGround = false;
		}
	}

	private void Remove()
	{
		if (!hitGround || base.transform.position.magnitude > 1000f)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		base.transform.SetParent(GoreZone.ResolveGoreZone(base.transform).gibZone, worldPositionStays: true);
		Object.Destroy(GetComponent<Rigidbody>());
		Object.Destroy(col);
	}
}



public class ShowIfLevelUnlocked : MonoBehaviour
{
	public int missionNumber;

	public GameObject[] objectsToHide;

	private void OnEnable()
	{
		RankData rank = GameProgressSaver.GetRank(missionNumber, returnNull: true);
		GameObject[] array = objectsToHide;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(rank != null);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SimpleMeshCombineManager : MonoSingleton<SimpleMeshCombineManager>
{
	public float waitTimeUntilProcess = 0.2f;

	private Queue<SimpleMeshCombiner> combinersQueue = new Queue<SimpleMeshCombiner>();

	private void Start()
	{
		SimpleMeshCombiner[] array = Resources.FindObjectsOfTypeAll<SimpleMeshCombiner>();
		foreach (SimpleMeshCombiner simpleMeshCombiner in array)
		{
			if (simpleMeshCombiner.gameObject.isStatic)
			{
				Debug.LogWarning("we can't process static meshes");
			}
			else
			{
				combinersQueue.Enqueue(simpleMeshCombiner);
			}
		}
		StartCoroutine(ProcessCombiners());
	}

	private IEnumerator ProcessCombiners()
	{
		WaitForSeconds waitTime = new WaitForSeconds(waitTimeUntilProcess);
		yield return waitTime;
		while (combinersQueue.Count > 0)
		{
			combinersQueue.Dequeue().CombineMeshes();
			yield return waitTime;
		}
	}
}



public class SimpleMeshCombiner : MonoBehaviour
{
	public bool removeAllChildren = true;

	public void CombineMeshes()
	{
		Transform parent = base.transform.parent;
		Vector3 position = base.transform.position;
		Quaternion rotation = base.transform.rotation;
		Vector3 localScale = base.transform.localScale;
		base.transform.parent = null;
		base.transform.position = Vector3.zero;
		base.transform.rotation = Quaternion.identity;
		base.transform.localScale = Vector3.one;
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>(includeInactive: true);
		Dictionary<Material, List<CombineInstance>> dictionary = new Dictionary<Material, List<CombineInstance>>();
		MeshFilter[] array = componentsInChildren;
		foreach (MeshFilter meshFilter in array)
		{
			if (meshFilter.sharedMesh == null)
			{
				continue;
			}
			if (meshFilter.gameObject.isStatic)
			{
				Debug.LogWarning("cannot process static mesh " + meshFilter.gameObject);
				continue;
			}
			MeshRenderer component = meshFilter.GetComponent<MeshRenderer>();
			if (component == null || component.sharedMaterials.Length == 0)
			{
				continue;
			}
			for (int j = 0; j < meshFilter.sharedMesh.subMeshCount; j++)
			{
				Material key = component.sharedMaterials[j];
				if (!dictionary.ContainsKey(key))
				{
					dictionary[key] = new List<CombineInstance>();
				}
				CombineInstance combineInstance = default(CombineInstance);
				combineInstance.mesh = meshFilter.sharedMesh;
				combineInstance.subMeshIndex = j;
				combineInstance.transform = meshFilter.transform.localToWorldMatrix;
				CombineInstance item = combineInstance;
				dictionary[key].Add(item);
			}
		}
		List<CombineInstance> list = new List<CombineInstance>();
		List<Material> list2 = new List<Material>();
		foreach (KeyValuePair<Material, List<CombineInstance>> item2 in dictionary)
		{
			List<CombineInstance> value = item2.Value;
			Mesh mesh = new Mesh();
			mesh.CombineMeshes(value.ToArray(), mergeSubMeshes: true, useMatrices: true);
			list.Add(new CombineInstance
			{
				mesh = mesh,
				subMeshIndex = 0,
				transform = Matrix4x4.identity
			});
			list2.Add(item2.Key);
		}
		Mesh mesh2 = new Mesh();
		mesh2.CombineMeshes(list.ToArray(), mergeSubMeshes: false, useMatrices: false);
		MeshFilter meshFilter2 = base.gameObject.AddComponent<MeshFilter>();
		MeshRenderer meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		meshFilter2.sharedMesh = mesh2;
		meshRenderer.materials = list2.ToArray();
		base.transform.SetParent(parent, worldPositionStays: false);
		base.transform.SetPositionAndRotation(position, rotation);
		base.transform.localScale = localScale;
		if (removeAllChildren)
		{
			for (int k = 0; k < base.transform.childCount; k++)
			{
				Object.Destroy(base.transform.GetChild(k).gameObject);
			}
		}
	}
}


internal class SimulatedRandomEntry
{
	public int firstIndex;

	public int lastIndex;

	public RandomEntry target;
}



[Flags]
public enum SingletonFlags
{
	None = 0,
	NoAutoInstance = 1,
	HideAutoInstance = 2,
	NoAwakeInstance = 4,
	PersistAutoInstance = 8,
	DestroyDuplicates = 0x10
}



[CreateAssetMenu(menuName = "ULTRAKILL/Attack Animation Details")]
public class SisyAttackAnimationDetails : ScriptableObject
{
	[Header("Boulder")]
	public float minBoulderSpeed = 0.01f;

	public float boulderDistanceDivide = 100f;

	public float maxBoulderSpeed = 1E+10f;

	[FormerlySerializedAs("durationMulti")]
	public float finalDurationMulti = 1f;

	[Header("Anim")]
	public float speedDistanceMulti = 1f;

	[FormerlySerializedAs("minSpeedCap")]
	public float minAnimSpeedCap = 0.1f;

	[FormerlySerializedAs("maxSpeedCap")]
	public float maxAnimSpeedCap = 1f;
}



[RequireComponent(typeof(Solver3D))]
public class Sisyphus : MonoBehaviour
{
	private enum AttackType
	{
		OverheadSlam,
		HorizontalSwing,
		Stab,
		AirStab
	}

	private static readonly int s_SwingAnimSpeed = Animator.StringToHash("SwingSpeed");

	private float swingArmSpeed;

	private static readonly int s_OverheadSlam = Animator.StringToHash("OverheadSlam");

	private static readonly int s_HorizontalSwing = Animator.StringToHash("HorizontalSwing");

	private static readonly int s_Stab = Animator.StringToHash("Stab");

	private static readonly int s_AirStab = Animator.StringToHash("AirStab");

	private static readonly int s_AirStabCancel = Animator.StringToHash("AirStabCancel");

	private static readonly int s_Stomp = Animator.StringToHash("Stomp");

	[SerializeField]
	private Solver3D m_Solver;

	[SerializeField]
	private Animator anim;

	[SerializeField]
	private Transform m_Boulder;

	[SerializeField]
	private Collider boulderCol;

	[SerializeField]
	private PhysicalShockwave m_ShockwavePrefab;

	[SerializeField]
	private GameObject explosion;

	private Pose m_StartPose;

	private AttackType m_AttackType;

	private float[] m_NormalizedDistances;

	private Transform[] m_Transforms;

	private bool didCollide;

	private bool airStabCancelled;

	private bool pullSelfRetract;

	private bool swinging;

	private bool inAction;

	private float stuckInActionTimer;

	private int attacksPerformed;

	private int previousAttack = -1;

	private bool previouslyJumped;

	private float cooldown;

	private NavMeshAgent nma;

	private SwingCheck2 sc;

	private float airStabOvershoot = 2f;

	private float stabOvershoot = 1.1f;

	private GroundCheckEnemy gce;

	private Rigidbody rb;

	private bool jumping;

	private Vector3 jumpTarget;

	private bool superJumping;

	private float trackingX;

	private float trackingY;

	private bool forceCorrectOrientation;

	private Collider col;

	[SerializeField]
	private GameObject rubble;

	[SerializeField]
	private TrailRenderer trail;

	[SerializeField]
	private ParticleSystem swingParticle;

	[SerializeField]
	private AudioSource swingAudio;

	public bool stationary;

	private AudioSource aud;

	[SerializeField]
	private AudioClip[] attackVoices;

	[SerializeField]
	private AudioClip stompVoice;

	[SerializeField]
	private AudioClip deathVoice;

	[SerializeField]
	private GameObject[] hurtSounds;

	private GameObject currentHurtSound;

	[SerializeField]
	private Transform[] legs;

	[SerializeField]
	private Transform armature;

	private int difficulty = -1;

	[SerializeField]
	private GameObject attackFlash;

	private float stuckChecker;

	private EnemyIdentifier eid;

	private GoreZone gz;

	private Machine mach;

	private Coroutine co;

	[SerializeField]
	private Cannonball boulderCb;

	private bool isParried;

	[SerializeField]
	private Transform originalBoulder;

	[HideInInspector]
	public bool knockedDownByCannonball;

	[SerializeField]
	private GameObject fallSound;

	private List<EnemyIdentifier> fallEnemiesHit = new List<EnemyIdentifier>();

	[Header("Animations")]
	[SerializeField]
	private SisyAttackAnimationDetails overheadSlamAnim;

	[SerializeField]
	private SisyAttackAnimationDetails horizontalSwingAnim;

	[SerializeField]
	private SisyAttackAnimationDetails groundStabAnim;

	[SerializeField]
	private SisyAttackAnimationDetails airStabAnim;

	[HideInInspector]
	public bool downed;

	public bool jumpOnSpawn;

	private bool dontFacePlayer;

	private float superKnockdownWindow;

	private SisyAttackAnimationDetails GetAnimationDetails(AttackType type)
	{
		return type switch
		{
			AttackType.OverheadSlam => overheadSlamAnim, 
			AttackType.HorizontalSwing => horizontalSwingAnim, 
			AttackType.Stab => groundStabAnim, 
			AttackType.AirStab => airStabAnim, 
			_ => null, 
		};
	}

	private void Awake()
	{
		nma = GetComponent<NavMeshAgent>();
		sc = GetComponentInChildren<SwingCheck2>();
		rb = GetComponent<Rigidbody>();
		gce = GetComponentInChildren<GroundCheckEnemy>();
		col = GetComponent<Collider>();
		aud = GetComponent<AudioSource>();
		mach = GetComponent<Machine>();
	}

	private void Start()
	{
		m_Solver.Initialize();
		IKChain3D chain = m_Solver.GetChain(0);
		m_Transforms = new Transform[chain.transformCount];
		m_Transforms[m_Transforms.Length - 1] = chain.effector;
		for (int num = m_Transforms.Length - 2; num >= 0; num--)
		{
			m_Transforms[num] = m_Transforms[num + 1].parent;
		}
		float num2 = 0f;
		m_NormalizedDistances = new float[m_Transforms.Length - 1];
		for (int i = 0; i < m_NormalizedDistances.Length; i++)
		{
			m_NormalizedDistances[i] = Vector3.Distance(m_Transforms[i].position, m_Transforms[i + 1].position);
			num2 += m_NormalizedDistances[i];
		}
		for (int j = 0; j < m_NormalizedDistances.Length; j++)
		{
			m_NormalizedDistances[j] /= num2;
		}
		m_StartPose = new Pose(m_Boulder.localPosition, m_Boulder.localRotation);
		if (difficulty < 4)
		{
			cooldown = 3f;
		}
		else
		{
			cooldown = 1f;
		}
		if ((bool)nma)
		{
			nma.enabled = true;
		}
		gz = GoreZone.ResolveGoreZone(base.transform);
		anim.SetFloat(s_SwingAnimSpeed, 1f * eid.totalSpeedModifier);
		Physics.IgnoreCollision(col, boulderCol);
		SetSpeed();
		boulderCb.sisy = this;
		if (jumpOnSpawn && eid.target != null)
		{
			Jump(eid.target.position);
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		anim.SetFloat("DownedSpeed", (difficulty < 4) ? 1 : 2);
		if (difficulty <= 1)
		{
			anim.SetFloat("StompSpeed", 0.75f * eid.totalSpeedModifier);
		}
		else if (difficulty == 2)
		{
			anim.SetFloat("StompSpeed", 0.875f * eid.totalSpeedModifier);
		}
		else
		{
			anim.SetFloat("StompSpeed", 1f * eid.totalSpeedModifier);
		}
	}

	private void OnDisable()
	{
		if (co != null)
		{
			StopCoroutine(co);
		}
		StopAction();
		ResetBoulderPose();
		SwingStop();
		if (eid.target != null)
		{
			swingArmSpeed = Mathf.Max(0.01f, Vector3.Distance(base.transform.position, eid.target.position) / 100f) * eid.totalSpeedModifier;
		}
		if ((bool)gce && !gce.onGround)
		{
			rb.isKinematic = false;
			rb.useGravity = true;
		}
	}

	private void OnEnable()
	{
		SetSpeed();
		anim.SetFloat(s_SwingAnimSpeed, 1f * eid.totalSpeedModifier);
	}

	private void LateUpdate()
	{
		ChangeArmLength(Vector3.Distance(m_Transforms[0].position, m_Boulder.position));
		m_Solver.UpdateIK(1f);
		m_Transforms[m_Transforms.Length - 1].position = m_Boulder.position;
		if (!isParried)
		{
			m_Boulder.rotation = originalBoulder.rotation;
			m_Boulder.Rotate(Vector3.right * -90f, Space.Self);
			m_Boulder.Rotate(Vector3.up * -5f, Space.Self);
		}
		else
		{
			originalBoulder.transform.up = m_Boulder.transform.forward;
		}
	}

	private void ChangeArmLength(float targetLength)
	{
		for (int i = 0; i < m_NormalizedDistances.Length; i++)
		{
			Vector3 vector = Vector3.Normalize(m_Transforms[i + 1].position - m_Transforms[i].position);
			float num = targetLength * m_NormalizedDistances[i];
			m_Transforms[i + 1].position = m_Transforms[i].position + vector * num;
		}
	}

	private void FixedUpdate()
	{
		if (eid.target != null)
		{
			if (inAction && (anim.GetCurrentAnimatorStateInfo(0).IsName("Walking") || anim.GetCurrentAnimatorStateInfo(0).IsName("Idle")))
			{
				stuckInActionTimer = Mathf.MoveTowards(stuckInActionTimer, 2f, Time.fixedDeltaTime);
				if (stuckInActionTimer == 2f)
				{
					inAction = false;
				}
			}
			else
			{
				stuckInActionTimer = 0f;
			}
		}
		else
		{
			anim.SetBool("Walking", value: false);
			if (nma.enabled && nma.isOnNavMesh)
			{
				nma.SetDestination(base.transform.position);
			}
		}
		if (gce.onGround && !nma.isOnNavMesh && !nma.isOnOffMeshLink && eid.target != null)
		{
			if (gce.onGround && !nma.isOnNavMesh && !nma.isOnOffMeshLink && !inAction)
			{
				stuckChecker = Mathf.MoveTowards(stuckChecker, 3f, Time.fixedDeltaTime);
				if (stuckChecker >= 3f && !jumping)
				{
					stuckChecker = 2f;
					superJumping = true;
					Jump(eid.target.position);
				}
			}
			else
			{
				stuckChecker = 0f;
			}
		}
		if (gce.onGround && !superJumping && !inAction && rb.useGravity && !rb.isKinematic)
		{
			nma.enabled = true;
			rb.isKinematic = true;
			rb.useGravity = false;
			jumping = false;
			inAction = true;
			if (superKnockdownWindow > 0f)
			{
				downed = true;
				Knockdown(base.transform.position + base.transform.forward);
				MonoSingleton<StyleHUD>.Instance.AddPoints(60, "ultrakill.insurrknockdown", null, eid);
				Invoke("Undown", 4f);
			}
			else
			{
				anim.Play("Landing");
				if (difficulty >= 1)
				{
					RaycastHit[] array = Physics.RaycastAll(base.transform.position + Vector3.up * 4f, Vector3.down, 6f, LayerMaskDefaults.Get(LMD.Environment));
					PhysicalShockwave physicalShockwave = null;
					if (array.Length != 0)
					{
						bool flag = false;
						RaycastHit[] array2 = array;
						for (int i = 0; i < array2.Length; i++)
						{
							RaycastHit raycastHit = array2[i];
							if (raycastHit.collider != boulderCol)
							{
								physicalShockwave = UnityEngine.Object.Instantiate(m_ShockwavePrefab, raycastHit.point, Quaternion.identity);
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							physicalShockwave = UnityEngine.Object.Instantiate(m_ShockwavePrefab, base.transform.position, Quaternion.identity);
						}
					}
					else
					{
						physicalShockwave = UnityEngine.Object.Instantiate(m_ShockwavePrefab, base.transform.position, Quaternion.identity);
					}
					if ((bool)physicalShockwave)
					{
						physicalShockwave.transform.SetParent(gz.transform);
						physicalShockwave.speed *= eid.totalSpeedModifier;
						physicalShockwave.damage = Mathf.RoundToInt((float)physicalShockwave.damage * eid.totalDamageModifier);
					}
				}
			}
			if (fallEnemiesHit.Count > 0)
			{
				foreach (EnemyIdentifier item in fallEnemiesHit)
				{
					if (item != null && !item.dead && item.TryGetComponent<Collider>(out var component))
					{
						Physics.IgnoreCollision(col, component, ignore: false);
					}
				}
				fallEnemiesHit.Clear();
			}
		}
		else if (!gce.onGround && rb.useGravity && !rb.isKinematic)
		{
			RaycastHit[] array2 = Physics.SphereCastAll(col.bounds.center, 2.5f, rb.velocity, rb.velocity.magnitude * Time.fixedDeltaTime + 6f, LayerMaskDefaults.Get(LMD.EnemiesAndEnvironment));
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit2 = array2[i];
				EnemyIdentifierIdentifier component4;
				if (raycastHit2.transform.gameObject.layer == 8 || raycastHit2.transform.gameObject.layer == 24)
				{
					Glass component3;
					if (raycastHit2.transform.TryGetComponent<Breakable>(out var component2) && !component2.playerOnly && !component2.precisionOnly)
					{
						component2.Break();
					}
					else if (raycastHit2.transform.TryGetComponent<Glass>(out component3))
					{
						component3.Shatter();
					}
				}
				else if (raycastHit2.transform.TryGetComponent<EnemyIdentifierIdentifier>(out component4) && (bool)component4.eid && component4.eid != eid && !fallEnemiesHit.Contains(component4.eid))
				{
					FallKillEnemy(component4.eid);
				}
			}
			array2 = Physics.SphereCastAll(col.bounds.center, 2.5f, rb.velocity, rb.velocity.magnitude * Time.fixedDeltaTime + 6f, 4096);
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit3 = array2[i];
				if (raycastHit3.transform != base.transform && raycastHit3.transform.TryGetComponent<EnemyIdentifier>(out var component5) && !fallEnemiesHit.Contains(component5))
				{
					FallKillEnemy(component5);
				}
			}
		}
		if (!inAction && gce.onGround && !jumping && eid.target != null)
		{
			if (cooldown > 0f)
			{
				forceCorrectOrientation = false;
				if (eid.target != null && Vector3.Distance(base.transform.position, eid.target.position) < 10f)
				{
					cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * 3f * eid.totalSpeedModifier);
				}
				else
				{
					cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
				}
				if (!stationary)
				{
					if (nma.enabled && nma.isOnNavMesh && Physics.Raycast(eid.target.position, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
					{
						if (NavMesh.SamplePosition(eid.target.position, out var hit, 1f, nma.areaMask))
						{
							nma.SetDestination(hit.position);
						}
						else
						{
							nma.SetDestination(hitInfo.point);
						}
					}
					else if (nma.enabled && nma.isOnNavMesh)
					{
						nma.SetDestination(eid.target.position);
					}
					if (nma.velocity.magnitude < 1f)
					{
						anim.SetBool("Walking", value: false);
					}
					else
					{
						anim.SetBool("Walking", value: true);
					}
				}
			}
			else if (Vector3.Distance(base.transform.position, eid.target.position) < 8f && difficulty != 0)
			{
				inAction = true;
				aud.pitch = UnityEngine.Random.Range(1.4f, 1.6f);
				aud.PlayOneShot(stompVoice);
				anim.SetTrigger(s_Stomp);
			}
			else
			{
				if ((attacksPerformed >= UnityEngine.Random.Range(2, 4) || Vector3.Distance(base.transform.position, eid.target.position) > 100f) && Physics.Raycast(eid.target.position, Vector3.down, 50f, LayerMaskDefaults.Get(LMD.Environment)))
				{
					Jump(eid.target.position);
					attacksPerformed = 0;
					return;
				}
				int num = UnityEngine.Random.Range(0, 4);
				bool flag2 = false;
				int num2 = 0;
				while ((num == previousAttack || (num == 3 && previouslyJumped)) && num2 < 10)
				{
					num2++;
					num = UnityEngine.Random.Range(0, 4);
					if (num2 == 10)
					{
						Debug.LogError("While method in Sisyphus' attack choosing function hit the failsafe", this);
					}
				}
				if (TestAttack(num))
				{
					flag2 = true;
				}
				else
				{
					int[] array3 = new int[4] { 0, 1, 2, 3 };
					int num3 = 4;
					if (previouslyJumped)
					{
						num3 = 3;
					}
					for (int j = 0; j < num3; j++)
					{
						int num4 = array3[j];
						int num5 = UnityEngine.Random.Range(j, num3);
						array3[j] = array3[num5];
						array3[num5] = num4;
					}
					for (int k = 0; k < 4; k++)
					{
						if (array3[k] != num && TestAttack(array3[k]))
						{
							flag2 = true;
							num = array3[k];
							break;
						}
					}
				}
				forceCorrectOrientation = false;
				if (flag2)
				{
					if (!stationary && nma.isOnNavMesh)
					{
						nma.SetDestination(base.transform.position);
					}
					inAction = true;
					cooldown = 3 - difficulty / 2;
					previousAttack = num;
					previouslyJumped = false;
					switch (num)
					{
					case 0:
						m_AttackType = AttackType.OverheadSlam;
						base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
						anim.SetTrigger(s_OverheadSlam);
						trackingX = 1f;
						trackingY = 0.15f;
						break;
					case 1:
						m_AttackType = AttackType.HorizontalSwing;
						anim.SetTrigger(s_HorizontalSwing);
						trackingX = 0f;
						trackingY = 1f;
						break;
					case 2:
						m_AttackType = AttackType.Stab;
						anim.SetTrigger(s_Stab);
						trackingX = 0.9f;
						trackingY = 0.5f;
						break;
					case 3:
						m_AttackType = AttackType.AirStab;
						StartCoroutine(AirStab());
						Jump(noEnd: true);
						trackingX = 0f;
						trackingY = 0.9f;
						break;
					}
					if (num < attackVoices.Length && num != 3)
					{
						if (num == 1)
						{
							aud.pitch = UnityEngine.Random.Range(1.4f, 1.6f);
						}
						else
						{
							aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
						}
						aud.PlayOneShot(attackVoices[num]);
					}
					if (num != 3)
					{
						UnityEngine.Object.Instantiate(attackFlash, m_Boulder);
					}
					attacksPerformed++;
				}
				else
				{
					Jump(eid.target.position);
				}
			}
		}
		else if (inAction)
		{
			if (!gce.onGround)
			{
				rb.useGravity = false;
			}
			if (!dontFacePlayer)
			{
				RotateTowardsTarget();
			}
		}
		else if (jumping)
		{
			RotateTowardsTarget();
		}
		if (jumping)
		{
			Vector3 vector = new Vector3(jumpTarget.x, base.transform.position.y, jumpTarget.z);
			if (!Physics.Raycast(col.bounds.center, vector - base.transform.position, Vector3.Distance(base.transform.position, vector) * Time.fixedDeltaTime * 2f + 2f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				base.transform.position = Vector3.MoveTowards(base.transform.position, vector, Vector3.Distance(base.transform.position, vector) * Time.fixedDeltaTime * 2f);
			}
			if (superJumping)
			{
				RaycastHit hitInfo2;
				bool num6 = Physics.SphereCast(base.transform.position, 3f, rb.velocity.normalized, out hitInfo2, rb.velocity.magnitude * Time.fixedDeltaTime, LayerMaskDefaults.Get(LMD.Environment));
				if (!num6 && didCollide && Physics.SphereCast(base.transform.position, 3f, -rb.velocity.normalized, out hitInfo2, rb.velocity.magnitude * Time.fixedDeltaTime, LayerMaskDefaults.Get(LMD.Environment)))
				{
					UnityEngine.Object.Instantiate(rubble, hitInfo2.point, Quaternion.LookRotation(hitInfo2.normal));
					didCollide = false;
				}
				if (num6 && !didCollide)
				{
					didCollide = true;
					if (Vector3.Distance(base.transform.position + rb.velocity * Time.fixedDeltaTime, jumpTarget) > 3f)
					{
						UnityEngine.Object.Instantiate(rubble, hitInfo2.point, Quaternion.LookRotation(hitInfo2.normal));
					}
				}
				if (rb.velocity.y >= 0f)
				{
					col.isTrigger = Vector3.Distance(base.transform.position, jumpTarget) > 1f;
				}
				else if (jumpTarget.y + 8f > base.transform.position.y + Mathf.Abs(rb.velocity.y) * Time.fixedDeltaTime)
				{
					col.isTrigger = false;
					superJumping = false;
					base.transform.position = vector;
				}
			}
		}
		if (!inAction && !gce.onGround)
		{
			rb.useGravity = true;
		}
		if (!rb.isKinematic && rb.useGravity)
		{
			rb.velocity -= Vector3.up * 200f * Time.fixedDeltaTime;
		}
		if (!jumping && !rb.isKinematic && !inAction)
		{
			anim.Play("Jump", -1, 0.95f);
		}
		else if (gce.onGround && !inAction && !superJumping)
		{
			superJumping = false;
			jumping = false;
		}
	}

	private void Update()
	{
		if (superKnockdownWindow > 0f)
		{
			superKnockdownWindow = Mathf.MoveTowards(superKnockdownWindow, 0f, Time.deltaTime);
		}
	}

	private bool TestAttack(int attack)
	{
		float num = Vector3.Distance(base.transform.position, eid.target.position);
		LayerMask layerMask = LayerMaskDefaults.Get(LMD.Environment);
		switch (attack)
		{
		case 0:
			if (!Physics.Raycast(base.transform.position, Vector3.up, num, layerMask) && !Physics.Raycast(base.transform.position + Vector3.up * num, eid.target.position - base.transform.position, num, layerMask) && !Physics.Raycast(eid.target.position, Vector3.up, num, layerMask))
			{
				return true;
			}
			return false;
		case 1:
		{
			Vector3 position = base.transform.position;
			float num2 = Vector3.Distance(eid.target.position, position);
			float num3 = eid.target.position.y - position.y;
			Vector3 vector2 = position + base.transform.up * 5f + base.transform.right * (0f - num2);
			Vector3 vector3 = position + base.transform.up * 5f + Vector3.up * num3 * 2f + base.transform.right * num2;
			if (!Physics.Raycast(base.transform.position + Vector3.up * 3f, -base.transform.right, num, layerMask) && !Physics.Raycast(vector2, eid.target.position - vector2, Vector3.Distance(vector2, eid.target.position), layerMask) && !Physics.Raycast(base.transform.position + Vector3.up * 3f, base.transform.right, num, layerMask) && !Physics.Raycast(vector3, eid.target.position - vector3, Vector3.Distance(vector3, eid.target.position), layerMask))
			{
				return true;
			}
			return false;
		}
		case 2:
		{
			Vector3 vector4 = eid.target.position + Vector3.up * 3f;
			RaycastHit hitInfo;
			return !Physics.SphereCast(base.transform.position + Vector3.up * 3f, 1.75f, Quaternion.LookRotation(vector4 - base.transform.position, Vector3.up).eulerAngles, out hitInfo, Vector3.Distance(base.transform.position, eid.target.position), layerMask);
		}
		case 3:
		{
			Vector3 vector = base.transform.position + Vector3.up * 73f;
			Vector3 direction = Vector3.Normalize(eid.target.position - vector);
			if (!Physics.Raycast(base.transform.position + Vector3.up * 3f, base.transform.up, 70f, layerMask))
			{
				return !Physics.Raycast(vector, direction, Vector3.Distance(vector, eid.target.position), layerMask);
			}
			return false;
		}
		default:
			return false;
		}
	}

	public bool CanFit(Vector3 point)
	{
		if (Physics.Raycast(point, Vector3.up, 11f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			return false;
		}
		return true;
	}

	private IEnumerator AirStab()
	{
		superJumping = false;
		yield return new WaitForSeconds(1f);
		UnityEngine.Object.Instantiate(attackFlash, m_Boulder).transform.localScale *= 5f;
		aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
		aud.PlayOneShot(attackVoices[3]);
		trackingX = 0.9f;
		trackingY = 0.9f;
		rb.isKinematic = true;
		anim.SetTrigger(s_AirStab);
	}

	private IEnumerator AirStabAttack(float time)
	{
		if (eid.target == null)
		{
			yield break;
		}
		airStabCancelled = true;
		rb.isKinematic = true;
		ResetBoulderPose();
		Vector3 start = m_Boulder.position;
		float t = 0f;
		time *= swingArmSpeed * GetAnimationDetails(AttackType.AirStab).finalDurationMulti;
		Vector3 attackTarget = base.transform.position + (base.transform.forward * Vector3.Distance(base.transform.position, eid.target.position) + base.transform.right * 3f) * airStabOvershoot;
		sc.DamageStart();
		while (swinging)
		{
			Vector3 vector = Vector3.LerpUnclamped(start, attackTarget, t / time);
			trail.transform.forward = vector - m_Boulder.position;
			m_Boulder.position = vector;
			yield return new WaitForEndOfFrame();
			t += Time.deltaTime;
			if (Physics.OverlapSphere(m_Boulder.position, 3.75f, LayerMaskDefaults.Get(LMD.Environment)).Length != 0)
			{
				SlamShockwave();
				SwingStop();
				swinging = false;
				trackingX = 0f;
				trackingY = 0f;
			}
		}
		trackingX = 0.75f;
		trackingY = 0f;
		SwingStop();
	}

	public void ExtendArm(float time)
	{
		SisyAttackAnimationDetails animationDetails = GetAnimationDetails(m_AttackType);
		boulderCol.enabled = false;
		trail.emitting = true;
		swingParticle.Play();
		swinging = true;
		swingAudio.Play();
		boulderCb.launchable = true;
		float num = Vector3.Distance(base.transform.position, GetActualTargetPos());
		if (num < 10f)
		{
			num = 10f;
		}
		num -= 10f;
		swingArmSpeed = Mathf.Clamp(num / animationDetails.boulderDistanceDivide, animationDetails.minBoulderSpeed, animationDetails.maxBoulderSpeed);
		if (m_AttackType == AttackType.AirStab)
		{
			num *= 0.35f;
			swingArmSpeed /= airStabOvershoot;
		}
		float num2 = 1f - num / animationDetails.boulderDistanceDivide;
		num2 *= animationDetails.speedDistanceMulti;
		num2 = Mathf.Clamp(num2, animationDetails.minAnimSpeedCap, animationDetails.maxAnimSpeedCap);
		_ = m_AttackType;
		_ = 2;
		float num3 = 1f;
		if (difficulty >= 4)
		{
			num3 = 1.5f;
		}
		else if (difficulty == 3)
		{
			num3 = 1.25f;
		}
		else if (difficulty == 1)
		{
			num3 = 0.75f;
		}
		else if (difficulty == 0)
		{
			num3 = 0.5f;
		}
		num3 *= eid.totalSpeedModifier;
		num2 *= num3;
		swingArmSpeed /= num3;
		anim.SetFloat(s_SwingAnimSpeed, num2);
		if (m_AttackType == AttackType.OverheadSlam)
		{
			co = StartCoroutine(OverheadSlamAttack(time));
		}
		else if (m_AttackType == AttackType.HorizontalSwing)
		{
			co = StartCoroutine(HorizontalSwingAttack(time));
		}
		else if (m_AttackType == AttackType.Stab)
		{
			co = StartCoroutine(StabAttack(time));
		}
		else if (m_AttackType == AttackType.AirStab)
		{
			co = StartCoroutine(AirStabAttack(time));
		}
	}

	public void RetractArm(float time)
	{
		inAction = false;
		anim.SetFloat(s_SwingAnimSpeed, 1f * eid.totalSpeedModifier);
		if (eid.target != null)
		{
			swingArmSpeed = Mathf.Max(0.01f, Vector3.Distance(base.transform.position, eid.target.position) / 100f);
		}
		TryToRetractArm(time);
	}

	private Vector3 GetActualTargetPos()
	{
		if (eid.target == null)
		{
			return base.transform.position;
		}
		switch (m_AttackType)
		{
		case AttackType.OverheadSlam:
		{
			Vector3 position = base.transform.position;
			position.y = eid.target.position.y;
			return position + base.transform.forward * (Vector3.Distance(position, eid.target.position) - 0.5f) - base.transform.forward;
		}
		case AttackType.HorizontalSwing:
		{
			Vector3 result = eid.target.position - base.transform.forward * 3f;
			result.y = eid.target.position.y;
			return result;
		}
		case AttackType.AirStab:
			return eid.target.position + base.transform.right * 10f;
		default:
			return eid.target.position;
		}
	}

	private bool SwingCheck(bool noExplosion = false)
	{
		if (Physics.OverlapSphere(m_Boulder.position, 0.75f, LayerMaskDefaults.Get(LMD.Environment)).Length != 0)
		{
			if (!noExplosion)
			{
				GameObject temp = UnityEngine.Object.Instantiate(explosion, m_Boulder.position + m_Boulder.forward, Quaternion.identity);
				SetupExplosion(temp);
			}
			SwingStop();
			return true;
		}
		return false;
	}

	private void SetupExplosion(GameObject temp)
	{
		if (temp.TryGetComponent<PhysicalShockwave>(out var component))
		{
			component.target = eid.target;
		}
		if (difficulty > 2 && eid.totalDamageModifier == 1f && eid.totalSpeedModifier == 1f)
		{
			return;
		}
		Explosion[] componentsInChildren = temp.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			if (difficulty <= 2)
			{
				explosion.maxSize *= 0.66f;
				explosion.speed /= 0.66f;
			}
			explosion.maxSize *= eid.totalDamageModifier;
			explosion.speed *= eid.totalDamageModifier;
			explosion.damage = Mathf.RoundToInt((float)explosion.damage * eid.totalDamageModifier);
		}
	}

	private IEnumerator HorizontalSwingAttack(float time)
	{
		ResetBoulderPose();
		float t = 0f;
		time *= swingArmSpeed * GetAnimationDetails(AttackType.HorizontalSwing).finalDurationMulti;
		Vector3 actualTarget = GetActualTargetPos();
		sc.DamageStart();
		while (t < time / 3f && swinging)
		{
			float num = Vector3.Distance(actualTarget, base.transform.position);
			Vector3 vector = base.transform.position + base.transform.up * 5f + base.transform.right * (0f - num);
			Vector3 a = m_Boulder.parent.TransformPoint(m_StartPose.position);
			Debug.DrawLine(base.transform.position, vector, Color.red, 8f);
			Vector3 vector2 = Vector3.Lerp(a, vector, t / (time / 2f));
			trail.transform.forward = vector2 - m_Boulder.position;
			m_Boulder.transform.position = vector2;
			yield return new WaitForEndOfFrame();
			t += Time.deltaTime;
			if (SwingCheck(noExplosion: true))
			{
				yield return new WaitForSeconds(0.5f);
				RetractArm(0.5f);
				yield break;
			}
		}
		t = 0f;
		float progressEnd = time / 1.5f;
		float yPos = actualTarget.y;
		while (t < progressEnd && swinging)
		{
			float num2 = t / progressEnd;
			if (num2 <= 0.5f)
			{
				actualTarget = GetActualTargetPos();
				_ = 0.12f;
				actualTarget.y = yPos + 2f;
			}
			Vector3 position = base.transform.position;
			float num3 = Vector3.Distance(actualTarget, position);
			float num4 = actualTarget.y - position.y;
			Vector3 vector3 = position + base.transform.up * 5f + base.transform.right * (0f - num3);
			Vector3 vector4 = position + base.transform.up * 5f + Vector3.up * num4 * 2f + base.transform.right * num3;
			trackingY = 1f;
			Quaternion a2 = Quaternion.LookRotation(vector3 - position, Vector3.up);
			Quaternion b = Quaternion.LookRotation(vector4 - position, Vector3.up);
			Quaternion quaternion = Quaternion.LookRotation(actualTarget - position, Vector3.up);
			Quaternion quaternion2 = ((num2 > 0.5f) ? Quaternion.Lerp(quaternion, b, (num2 - 0.5f) * 2f) : Quaternion.Lerp(a2, quaternion, num2 * 2f));
			Vector3 vector5 = position + quaternion2 * Vector3.forward * num3;
			trail.transform.forward = vector5 - m_Boulder.position;
			m_Boulder.position = vector5;
			yield return new WaitForEndOfFrame();
			t += Time.deltaTime;
			if (SwingCheck())
			{
				yield return new WaitForSeconds(0.5f);
				RetractArm(0.5f);
				yield break;
			}
		}
		SwingStop();
		TryToRetractArm(2f);
	}

	private IEnumerator OverheadSlamAttack(float time)
	{
		ResetBoulderPose();
		Vector3 start = m_Boulder.position;
		float t = 0f;
		time *= swingArmSpeed * GetAnimationDetails(AttackType.OverheadSlam).finalDurationMulti;
		sc.DamageStart();
		Vector3 actualTargetPos = GetActualTargetPos();
		while (t < time)
		{
			Vector3 vector = Vector3.Lerp(start, actualTargetPos, t / time);
			vector.y += Vector3.Distance(start, actualTargetPos) * Mathf.Sin(Mathf.Clamp01(t / time) * (float)Math.PI);
			trail.transform.forward = vector - m_Boulder.position;
			m_Boulder.position = vector;
			yield return new WaitForEndOfFrame();
			t += Time.deltaTime;
			actualTargetPos = GetActualTargetPos();
		}
		if (swinging)
		{
			if (Physics.OverlapSphere(m_Boulder.position, 5f, LayerMaskDefaults.Get(LMD.Environment)).Length != 0)
			{
				SlamShockwave();
				SwingStop();
			}
			else
			{
				bool hit = false;
				t = 0f;
				while (!hit)
				{
					Vector3 position = m_Boulder.position;
					position.y -= Time.deltaTime * swingArmSpeed * 400f;
					trail.transform.forward = position - m_Boulder.position;
					m_Boulder.position = position;
					if (Physics.OverlapSphere(m_Boulder.position, 5f, LayerMaskDefaults.Get(LMD.Environment)).Length != 0)
					{
						SlamShockwave();
						SwingStop();
						hit = true;
					}
					yield return new WaitForEndOfFrame();
					if (t > 1.5f)
					{
						hit = true;
					}
					t += Time.deltaTime;
				}
			}
		}
		trackingY = 0f;
		sc.DamageStop();
		yield return new WaitForSeconds(1f);
		TryToRetractArm(2f);
	}

	private void SlamShockwave()
	{
		Collider[] array = Physics.OverlapSphere(m_Boulder.position, 3.5f, LayerMaskDefaults.Get(LMD.Environment));
		if (array.Length != 0)
		{
			float num = 5f;
			Vector3 vector = m_Boulder.position;
			for (int i = 0; i < array.Length; i++)
			{
				Vector3 vector2 = array[i].ClosestPoint(m_Boulder.position);
				if (Vector3.Distance(m_Boulder.position, vector2) < num)
				{
					vector = vector2;
					num = Vector3.Distance(m_Boulder.position, vector2);
				}
			}
			GameObject temp = UnityEngine.Object.Instantiate(explosion, vector + Vector3.up * 0.1f, Quaternion.identity);
			m_Boulder.position = vector;
			SetupExplosion(temp);
		}
		else
		{
			GameObject temp2 = UnityEngine.Object.Instantiate(explosion, m_Boulder.position, Quaternion.identity);
			m_Boulder.position -= Vector3.up * 2f;
			SetupExplosion(temp2);
		}
	}

	private IEnumerator StabAttack(float time)
	{
		if (eid.target == null)
		{
			yield break;
		}
		ResetBoulderPose();
		Vector3 start = m_Boulder.position;
		float t = 0f;
		time *= swingArmSpeed * GetAnimationDetails(AttackType.Stab).finalDurationMulti;
		Vector3 b = eid.target.position + Vector3.up * 3f;
		Vector3 attackTarget = base.transform.position + base.transform.forward * Vector3.Distance(base.transform.position, b);
		attackTarget.y = b.y;
		trackingX = 0f;
		trackingY = 0f;
		sc.DamageStart();
		bool canCancel = false;
		while (swinging)
		{
			Vector3 vector = Vector3.LerpUnclamped(start, attackTarget, t / time);
			if (!canCancel && Vector3.Distance(start, vector) >= 20f)
			{
				canCancel = true;
			}
			trail.transform.forward = vector - m_Boulder.position;
			m_Boulder.position = vector;
			yield return new WaitForEndOfFrame();
			t += Time.deltaTime;
			if (canCancel && Physics.OverlapSphere(m_Boulder.position, 2f, LayerMaskDefaults.Get(LMD.Environment)).Length != 0)
			{
				GameObject temp = UnityEngine.Object.Instantiate(explosion, m_Boulder.position + m_Boulder.forward, Quaternion.identity);
				SetupExplosion(temp);
				anim.Play(s_Stab, -1, 0.73f);
				SwingStop();
				yield return new WaitForSeconds(0.5f);
				RetractArm(0.5f);
			}
		}
		sc.DamageStop();
	}

	public void TryToRetractArm(float time)
	{
		if (swinging)
		{
			swinging = false;
			boulderCol.enabled = true;
			boulderCb.Unlaunch(relaunchable: false);
			SwingStop();
			co = StartCoroutine(RetractArmAsync(time));
			isParried = false;
		}
	}

	public void SwingStop()
	{
		trail.emitting = false;
		swingParticle?.Stop();
		sc?.DamageStop();
		swingAudio?.Stop();
		boulderCb?.Unlaunch(relaunchable: false);
		isParried = false;
	}

	private IEnumerator RetractArmAsync(float time)
	{
		float t = 0f;
		Vector3 boulderStart = m_Boulder.position;
		Transform oldBoulderParent = m_Boulder.parent;
		Vector3 bossStart = base.transform.position;
		if (pullSelfRetract)
		{
			m_Boulder.SetParent(base.transform.parent ? base.transform.parent : null);
		}
		for (; t < time; t += Time.deltaTime)
		{
			Vector3 b = ((!pullSelfRetract) ? m_Boulder.parent.TransformPoint(m_StartPose.position) : m_Boulder.transform.position);
			(pullSelfRetract ? base.transform : m_Boulder).position = Vector3.Lerp(pullSelfRetract ? bossStart : boulderStart, b, t / time);
			_ = pullSelfRetract;
			yield return new WaitForEndOfFrame();
		}
		if (pullSelfRetract)
		{
			m_Boulder.SetParent(oldBoulderParent);
			rb.isKinematic = false;
			rb.useGravity = true;
			base.transform.rotation = Quaternion.identity;
			rb.AddForce(Vector3.down * 300f, ForceMode.VelocityChange);
			pullSelfRetract = false;
			ResetBoulderPose();
			StopAction();
		}
	}

	private void Jump(bool noEnd = false)
	{
		Jump(base.transform.position, noEnd);
	}

	private void Jump(Vector3 target, bool noEnd = false)
	{
		if (jumping || stationary)
		{
			return;
		}
		previouslyJumped = true;
		if (RaycastHelper.RaycastAndDebugDraw(target, Vector3.up, 50f, LayerMaskDefaults.Get(LMD.Environment)) || RaycastHelper.RaycastAndDebugDraw(col.bounds.center, Vector3.up, 25f, LayerMaskDefaults.Get(LMD.Environment)) || RaycastHelper.RaycastAndDebugDraw(col.bounds.center, target - col.bounds.center, Vector3.Distance(col.bounds.center, target), LayerMaskDefaults.Get(LMD.Environment)))
		{
			superJumping = true;
		}
		didCollide = false;
		jumpTarget = target;
		if (superJumping)
		{
			RaycastHit hitInfo;
			if (NavMesh.SamplePosition(target, out var hit, 2f, nma.areaMask))
			{
				jumpTarget = hit.position;
			}
			else if (Physics.Raycast(target, -Vector3.up, out hitInfo, 3f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				jumpTarget = hitInfo.point;
			}
			if (!CanFit(jumpTarget))
			{
				int num = 60;
				float num2 = UnityEngine.Random.Range(0f, 360f);
				int num3 = 0;
				while (num3 < 360)
				{
					Vector3 vector = jumpTarget + Quaternion.Euler(0f, (float)num3 + num2, 0f) * Vector3.forward * 12f;
					vector += Vector3.up * 2f;
					if (!Physics.Linecast(jumpTarget + Vector3.up * 2f, vector, LayerMaskDefaults.Get(LMD.Environment)))
					{
						Debug.DrawRay(vector, Vector3.down * 50f, Color.yellow, 50f);
						if (Physics.Raycast(vector, Vector3.down, out var hitInfo2, 50f, LayerMaskDefaults.Get(LMD.Environment)))
						{
							if (!CanFit(hitInfo2.point))
							{
								num3 += num;
								continue;
							}
							jumpTarget = hitInfo2.point;
							break;
						}
					}
					num3 += num;
				}
			}
		}
		jumping = true;
		anim.Play("Jump");
		rb.isKinematic = false;
		rb.useGravity = true;
		if (superJumping)
		{
			col.isTrigger = true;
		}
		nma.enabled = false;
		UnityEngine.Object.Instantiate(rubble, base.transform.position, base.transform.rotation);
		rb.velocity = Vector3.zero;
		rb.AddForce(Vector3.up * Mathf.Max(50f, 100f + Vector3.Distance(base.transform.position, target)), ForceMode.VelocityChange);
		trackingX = 0f;
		trackingY = 1f;
		inAction = true;
		if (!noEnd)
		{
			Invoke("StopAction", 0.5f);
		}
	}

	private void FlyToArm()
	{
		if (!airStabCancelled)
		{
			inAction = false;
			pullSelfRetract = true;
			forceCorrectOrientation = true;
			trackingX = 0.3f;
			aud.pitch = UnityEngine.Random.Range(1.4f, 1.6f);
			aud.PlayOneShot(attackVoices[3]);
			anim.SetFloat(s_SwingAnimSpeed, 1f);
			swinging = true;
			TryToRetractArm(0.4f);
		}
	}

	private void CancelAirStab()
	{
		Vector3 position = base.transform.position;
		if (eid.target != null)
		{
			position.y = eid.target.position.y;
		}
		if (eid.target != null && Vector3.Distance(position, eid.target.position) > Vector3.Distance(m_Boulder.position, eid.target.position) && !swinging)
		{
			airStabCancelled = false;
			return;
		}
		inAction = false;
		airStabCancelled = true;
		pullSelfRetract = false;
		swinging = true;
		RetractArm(1f);
		anim.SetTrigger(s_AirStabCancel);
		rb.isKinematic = false;
		rb.useGravity = true;
		nma.enabled = false;
		rb.velocity = Vector3.zero;
		forceCorrectOrientation = true;
		trackingX = 0.3f;
		trackingY = 1f;
	}

	public void Death()
	{
		aud.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
		aud.PlayOneShot(deathVoice);
		GoreZone componentInParent = GetComponentInParent<GoreZone>();
		Transform[] array = legs;
		foreach (Transform obj in array)
		{
			obj.parent = componentInParent.gibZone;
			Rigidbody[] componentsInChildren = obj.GetComponentsInChildren<Rigidbody>();
			foreach (Rigidbody obj2 in componentsInChildren)
			{
				obj2.isKinematic = false;
				obj2.useGravity = true;
			}
		}
		EnemyIdentifierIdentifier[] componentsInChildren2 = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		if (OptionsMenuToManager.bloodEnabled)
		{
			EnemyIdentifierIdentifier[] array2 = componentsInChildren2;
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in array2)
			{
				GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Head, enemyIdentifierIdentifier.eid);
				if ((bool)gore)
				{
					gore.transform.position = enemyIdentifierIdentifier.transform.position;
					gore.transform.SetParent(componentInParent.goreZone, worldPositionStays: true);
					gore.SetActive(value: true);
				}
				for (int k = 0; k < 3; k++)
				{
					GameObject gib = MonoSingleton<BloodsplatterManager>.Instance.GetGib(BSType.gib);
					if ((bool)gib)
					{
						gib.transform.SetPositionAndRotation(enemyIdentifierIdentifier.transform.position, UnityEngine.Random.rotation);
						gib.transform.SetParent(componentInParent.gibZone, worldPositionStays: true);
						gib.transform.localScale *= 4f;
					}
				}
			}
		}
		armature.localScale = Vector3.zero;
		Collider[] componentsInChildren3 = GetComponentsInChildren<Collider>();
		for (int num = componentsInChildren3.Length - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(componentsInChildren3[num]);
		}
		UnityEngine.Object.Destroy(m_Boulder.gameObject);
		UnityEngine.Object.Destroy(anim);
		UnityEngine.Object.Destroy(this);
	}

	private void StopAction()
	{
		inAction = false;
		dontFacePlayer = false;
		knockedDownByCannonball = false;
	}

	private void ResetBoulderPose()
	{
		m_Boulder.localPosition = m_StartPose.position;
		m_Boulder.localRotation = m_StartPose.rotation;
		boulderCb.Unlaunch();
		isParried = false;
	}

	private void RotateTowardsTarget()
	{
		if (eid.target != null)
		{
			Vector3 vector = eid.target.position;
			if (gce.onGround || forceCorrectOrientation)
			{
				vector = new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z);
			}
			Quaternion b = Quaternion.LookRotation(vector - base.transform.position);
			float num = (Quaternion.Angle(base.transform.rotation, b) * 10f + 30f) * Time.fixedDeltaTime;
			float num2 = base.transform.rotation.eulerAngles.x;
			float num3 = base.transform.rotation.eulerAngles.y;
			while (num2 - b.eulerAngles.x > 180f)
			{
				num2 -= 360f;
			}
			for (; num2 - b.eulerAngles.x < -180f; num2 += 360f)
			{
			}
			while (num3 - b.eulerAngles.y > 180f)
			{
				num3 -= 360f;
			}
			for (; num3 - b.eulerAngles.y < -180f; num3 += 360f)
			{
			}
			float num4 = 1f;
			if (difficulty == 1)
			{
				num4 = 0.75f;
			}
			else if (difficulty == 0)
			{
				num4 = 0.5f;
			}
			base.transform.rotation = Quaternion.Euler(Mathf.MoveTowards(num2, b.eulerAngles.x, num * trackingX * num4), Mathf.MoveTowards(num3, b.eulerAngles.y, num * trackingY * num4), Mathf.MoveTowards(base.transform.rotation.eulerAngles.z, b.eulerAngles.z, num));
		}
	}

	public void StompExplosion()
	{
		Vector3 vector = base.transform.position + Vector3.up;
		if (Physics.Raycast(vector, eid.target.position - vector, Vector3.Distance(eid.target.position, vector), LayerMaskDefaults.Get(LMD.Environment)))
		{
			vector = base.transform.position + Vector3.up * 5f;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(this.explosion, vector, Quaternion.identity);
		if (difficulty > 2 && eid.totalDamageModifier == 1f && eid.totalSpeedModifier == 1f)
		{
			return;
		}
		Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			if (difficulty >= 3)
			{
				explosion.maxSize *= 1.5f;
				explosion.speed *= 1.5f;
			}
			explosion.maxSize *= eid.totalDamageModifier;
			explosion.speed *= eid.totalDamageModifier;
			explosion.damage = Mathf.RoundToInt((float)explosion.damage * eid.totalDamageModifier);
		}
	}

	public void PlayHurtSound(int type = 0)
	{
		if ((bool)currentHurtSound)
		{
			if (type == 0)
			{
				return;
			}
			UnityEngine.Object.Destroy(currentHurtSound);
		}
		currentHurtSound = UnityEngine.Object.Instantiate(hurtSounds[type], base.transform.position, Quaternion.identity);
	}

	public void GotParried()
	{
		isParried = true;
		if (co != null)
		{
			StopCoroutine(co);
		}
	}

	public void Knockdown(Vector3 boulderPos)
	{
		if (!pullSelfRetract)
		{
			if (co != null)
			{
				StopCoroutine(co);
			}
			if (!knockedDownByCannonball)
			{
				base.transform.LookAt(new Vector3(boulderPos.x, base.transform.position.y, boulderPos.z));
			}
			if (!inAction && gce.onGround)
			{
				inAction = true;
				if (!stationary && nma.isOnNavMesh)
				{
					nma.SetDestination(base.transform.position);
				}
			}
		}
		if (!gce.onGround)
		{
			superKnockdownWindow = 0.25f;
		}
		dontFacePlayer = true;
		if (gce.onGround && !knockedDownByCannonball)
		{
			knockedDownByCannonball = true;
			anim.Play("Knockdown");
		}
		PlayHurtSound(2);
		trackingX = 0f;
		trackingY = 0f;
		if (knockedDownByCannonball)
		{
			Invoke("CheckLoop", 0.85f);
		}
		GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Splatter, eid);
		if ((bool)gore)
		{
			gore.transform.position = boulderPos;
			gore.transform.up = base.transform.forward;
			gore.transform.SetParent(GetComponentInParent<GoreZone>().goreZone, worldPositionStays: true);
			gore.SetActive(value: true);
			if (gore.TryGetComponent<Bloodsplatter>(out var component))
			{
				component.GetReady();
			}
		}
		if (!pullSelfRetract)
		{
			ResetBoulderPose();
			SwingStop();
		}
	}

	public void FallSound()
	{
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
		UnityEngine.Object.Instantiate(fallSound, base.transform.position, Quaternion.identity);
	}

	private void FallKillEnemy(EnemyIdentifier eid)
	{
		eid.hitter = "enemy";
		fallEnemiesHit.Add(eid);
		if (eid.TryGetComponent<Collider>(out var component))
		{
			Physics.IgnoreCollision(col, component, ignore: true);
		}
		EnemyIdentifier.FallOnEnemy(eid);
	}

	public void CheckLoop()
	{
		if (downed)
		{
			anim.SetFloat("DownedSpeed", 0f);
			Invoke("CheckLoop", 0.1f);
		}
		else
		{
			anim.SetFloat("DownedSpeed", (difficulty < 4) ? 1 : 2);
		}
	}

	private void Undown()
	{
		downed = false;
	}
}



public class SisyphusPrime : MonoBehaviour, IHitTargetCallback
{
	private NavMeshAgent nma;

	private Animator anim;

	private Machine mach;

	private EnemyIdentifier eid;

	private GroundCheckEnemy gce;

	private Rigidbody rb;

	private Collider col;

	private AudioSource aud;

	private float originalHp;

	private bool inAction;

	private float cooldown = 2f;

	private SPAttack lastPrimaryAttack;

	private SPAttack lastSecondaryAttack;

	private int secondariesSinceLastPrimary;

	private int attacksSinceLastExplosion;

	private Vector3 heightAdjustedTargetPos;

	private bool tracking;

	private bool fullTracking;

	private bool aiming;

	private bool jumping;

	public GameObject explosion;

	public GameObject explosionChargeEffect;

	private GameObject currentExplosionChargeEffect;

	public GameObject rubble;

	public GameObject bigRubble;

	public GameObject groundWave;

	public GameObject swoosh;

	public Transform aimingBone;

	private Transform head;

	public GameObject projectileCharge;

	private GameObject currentProjectileCharge;

	public GameObject sparkleExplosion;

	private bool hasProjectiled;

	public GameObject warningFlash;

	public GameObject parryableFlash;

	private bool gravityInAction;

	public GameObject attackTrail;

	public GameObject swingSnake;

	private List<GameObject> currentSwingSnakes = new List<GameObject>();

	private bool uppercutting;

	private bool hitSuccessful;

	private bool gotParried;

	private Vector3 teleportToGroundFailsafe;

	public Transform[] swingLimbs;

	private bool swinging;

	private bool boxing;

	private SwingCheck2 sc;

	private GoreZone gz;

	private int attackAmount;

	private bool enraged;

	public GameObject passiveEffect;

	private GameObject currentPassiveEffect;

	public GameObject flameEffect;

	public GameObject phaseChangeEffect;

	private int difficulty = -1;

	private SPAttack previousCombo = SPAttack.Explosion;

	private bool activated = true;

	private bool ascending;

	private bool vibrating;

	private Vector3 origPos;

	public GameObject lightShaft;

	public GameObject outroExplosion;

	public UltrakillEvent onPhaseChange;

	public UltrakillEvent onOutroEnd;

	private Vector3 spawnPoint;

	[Header("Voice clips")]
	public AudioClip[] uppercutComboVoice;

	public AudioClip[] stompComboVoice;

	public AudioClip phaseChangeVoice;

	public AudioClip[] hurtVoice;

	public AudioClip[] explosionVoice;

	public AudioClip[] tauntVoice;

	public AudioClip[] clapVoice;

	private bool bossVersion;

	private bool taunting;

	private bool tauntCheck;

	private int attacksSinceTaunt;

	private float defaultMoveSpeed;

	private EnemyTarget target => eid.target;

	private void Awake()
	{
		nma = GetComponent<NavMeshAgent>();
		mach = GetComponent<Machine>();
		gce = GetComponentInChildren<GroundCheckEnemy>();
		rb = GetComponent<Rigidbody>();
		sc = GetComponentInChildren<SwingCheck2>();
		col = GetComponent<Collider>();
		aud = GetComponent<AudioSource>();
		eid = GetComponent<EnemyIdentifier>();
		sc.OverrideEnemyIdentifier(eid);
	}

	private void Start()
	{
		defaultMoveSpeed = nma.speed;
		SetSpeed();
		head = eid.weakPoint.transform;
		originalHp = mach.health;
		gz = GoreZone.ResolveGoreZone(base.transform);
		spawnPoint = base.transform.position;
		bossVersion = TryGetComponent<BossHealthBar>(out var _);
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty == 1)
		{
			anim.speed = 0.9f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.8f;
		}
		else if (difficulty == 5)
		{
			anim.speed = 1.25f;
		}
		else if (difficulty == 4)
		{
			anim.speed = 1.125f;
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
	}

	private void OnDisable()
	{
		if ((bool)mach)
		{
			CancelInvoke();
			StopAction();
			DamageStop();
			uppercutting = false;
			ascending = false;
			tracking = false;
			fullTracking = false;
			aiming = false;
			jumping = false;
		}
	}

	private void OnEnable()
	{
		if (!activated)
		{
			OutroEnd();
		}
	}

	private void Update()
	{
		if (activated && target != null)
		{
			heightAdjustedTargetPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
			if (!inAction || taunting)
			{
				cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (!enraged && mach.health < originalHp / 2f)
			{
				enraged = true;
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("YES! That's it!");
				aud.clip = phaseChangeVoice;
				aud.pitch = 1f;
				aud.Play();
				currentPassiveEffect = Object.Instantiate(passiveEffect, base.transform.position + Vector3.up * 3.5f, Quaternion.identity);
				currentPassiveEffect.transform.SetParent(base.transform);
				EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
				foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
				{
					Object.Instantiate(flameEffect, enemyIdentifierIdentifier.transform);
				}
				Object.Instantiate(phaseChangeEffect, mach.chest.transform.position, Quaternion.identity);
				onPhaseChange?.Invoke();
			}
		}
		else if (ascending)
		{
			rb.velocity = Vector3.MoveTowards(rb.velocity, Vector3.up * 3f, Time.deltaTime);
			MonoSingleton<CameraController>.Instance.CameraShake(0.1f);
		}
		else if (vibrating)
		{
			float num = 0.1f;
			if (activated)
			{
				num = 0.25f;
			}
			base.transform.position = new Vector3(origPos.x + Random.Range(0f - num, num), origPos.y + Random.Range(0f - num, num), origPos.z + Random.Range(0f - num, num));
		}
	}

	private void FixedUpdate()
	{
		if (!activated)
		{
			return;
		}
		CustomPhysics();
		if (eid.target == null)
		{
			return;
		}
		if (!inAction && gce.onGround && (bool)nma && nma.enabled && nma.isOnNavMesh)
		{
			if (Vector3.Distance(base.transform.position, heightAdjustedTargetPos) > 10f)
			{
				nma.isStopped = false;
				if ((bool)MonoSingleton<NewMovement>.Instance.gc && !MonoSingleton<NewMovement>.Instance.gc.onGround)
				{
					if (Physics.Raycast(target.position, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
					{
						nma.SetDestination(hitInfo.point);
					}
					else
					{
						nma.SetDestination(target.position);
					}
				}
				else
				{
					nma.SetDestination(target.position);
				}
			}
			else if (cooldown > 0f)
			{
				if (!tauntCheck)
				{
					tauntCheck = true;
					if (attacksSinceTaunt >= (enraged ? 15 : 10) && mach.health > 20f)
					{
						Taunt();
					}
					else
					{
						LookAtTarget();
					}
				}
				else
				{
					LookAtTarget();
				}
			}
		}
		else if (inAction)
		{
			if ((bool)nma)
			{
				nma.enabled = false;
			}
			anim.SetBool("Walking", value: false);
		}
		if (tracking || fullTracking)
		{
			if (!fullTracking)
			{
				base.transform.LookAt(heightAdjustedTargetPos);
			}
			else
			{
				base.transform.rotation = Quaternion.LookRotation(target.position - new Vector3(base.transform.position.x, aimingBone.position.y, base.transform.position.z));
			}
		}
		if ((bool)nma && nma.enabled && nma.isOnNavMesh && !inAction)
		{
			bool flag = cooldown > 0f && Vector3.Distance(base.transform.position, heightAdjustedTargetPos) < 20f;
			nma.speed = (flag ? (defaultMoveSpeed / 2f) : defaultMoveSpeed);
			anim.SetBool("Cooldown", flag);
			anim.SetBool("Walking", nma.velocity.magnitude > 2f);
		}
	}

	private void LateUpdate()
	{
		if (aiming && inAction && activated)
		{
			aimingBone.LookAt(target.position);
			aimingBone.Rotate(Vector3.up * -90f, Space.Self);
		}
	}

	private void CustomPhysics()
	{
		if ((difficulty == 3 && ((!enraged && attackAmount >= 8) || attackAmount >= 16)) || (difficulty <= 2 && (((difficulty <= 1 || !enraged) && attackAmount >= 6) || attackAmount >= 10)))
		{
			attackAmount = 0;
			if (difficulty == 1)
			{
				cooldown = 3f;
			}
			else if (difficulty == 0)
			{
				cooldown = 4f;
			}
			else
			{
				cooldown = 2f;
			}
			tauntCheck = false;
		}
		if (!inAction)
		{
			gravityInAction = false;
			if (gce.onGround && !jumping)
			{
				nma.enabled = true;
				rb.isKinematic = true;
				hasProjectiled = false;
				if (cooldown <= 0f && !anim.IsInTransition(0) && target != null && activated)
				{
					if (!Physics.Raycast(target.position, Vector3.down, (MonoSingleton<NewMovement>.Instance.rb.velocity.y > 0f) ? 11 : 15, LayerMaskDefaults.Get(LMD.Environment)))
					{
						attacksSinceTaunt++;
						secondariesSinceLastPrimary++;
						PickSecondaryAttack();
					}
					else
					{
						PickAnyAttack();
					}
				}
			}
			else
			{
				nma.enabled = false;
				rb.isKinematic = false;
				if (cooldown <= 0f && !anim.IsInTransition(0) && eid.target != null && activated)
				{
					if (secondariesSinceLastPrimary <= (enraged ? 3 : 2))
					{
						attacksSinceTaunt++;
						secondariesSinceLastPrimary++;
						PickSecondaryAttack();
					}
					else if (enraged)
					{
						TeleportOnGround();
					}
				}
			}
		}
		else
		{
			nma.enabled = false;
			if (gravityInAction)
			{
				rb.isKinematic = false;
			}
			else
			{
				rb.isKinematic = true;
			}
			if (swinging && !Physics.Raycast(base.transform.position, base.transform.forward, 1f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				if (MonoSingleton<NewMovement>.Instance.sliding)
				{
					rb.MovePosition(base.transform.position + base.transform.forward * 125f * Time.fixedDeltaTime * eid.totalSpeedModifier);
				}
				else
				{
					rb.MovePosition(base.transform.position + base.transform.forward * 75f * Time.fixedDeltaTime * eid.totalSpeedModifier);
				}
			}
		}
		if (!rb.isKinematic && rb.useGravity)
		{
			rb.velocity -= Vector3.up * 100f * Time.fixedDeltaTime;
		}
		if (!jumping)
		{
			if (!rb.isKinematic)
			{
				anim.SetBool("Falling", value: true);
			}
			else
			{
				anim.SetBool("Falling", value: false);
			}
		}
		else
		{
			if (inAction || !(rb.velocity.y < 0f))
			{
				return;
			}
			jumping = false;
			if (uppercutting)
			{
				uppercutting = false;
				DamageStop();
				if (hitSuccessful && target.position.y > base.transform.position.y && activated && target != null)
				{
					hitSuccessful = false;
				}
			}
		}
	}

	private void PickAnyAttack()
	{
		if (secondariesSinceLastPrimary != 0 && (secondariesSinceLastPrimary > ((!enraged) ? 1 : 2) || Random.Range(0f, 1f) > 0.5f))
		{
			attacksSinceTaunt++;
			secondariesSinceLastPrimary = 0;
			PickPrimaryAttack();
		}
		else
		{
			attacksSinceTaunt++;
			secondariesSinceLastPrimary++;
			PickSecondaryAttack();
		}
	}

	private void PickPrimaryAttack(int type = -1)
	{
		if (type == -1)
		{
			type = Random.Range(0, 3);
		}
		switch (type)
		{
		case 0:
			if (lastPrimaryAttack != 0)
			{
				attacksSinceLastExplosion++;
				UppercutCombo();
				lastPrimaryAttack = SPAttack.UppercutCombo;
			}
			else
			{
				PickPrimaryAttack(type + 1);
			}
			break;
		case 1:
			if (lastPrimaryAttack != SPAttack.StompCombo)
			{
				attacksSinceLastExplosion++;
				StompCombo();
				lastPrimaryAttack = SPAttack.StompCombo;
			}
			else
			{
				PickPrimaryAttack(type + 1);
			}
			break;
		case 2:
			if (attacksSinceLastExplosion >= 2)
			{
				lastSecondaryAttack = SPAttack.Explosion;
				attacksSinceLastExplosion = 0;
				TeleportAnywhere();
				ExplodeAttack();
			}
			else
			{
				PickPrimaryAttack(Random.Range(0, 2));
			}
			break;
		}
	}

	private void PickSecondaryAttack(int type = -1)
	{
		if (type == -1)
		{
			type = Random.Range(0, 4);
		}
		switch (type)
		{
		case 0:
			if (lastSecondaryAttack != SPAttack.Chop)
			{
				lastSecondaryAttack = SPAttack.Chop;
				TeleportSide(Random.Range(0, 2), inAir: true);
				Chop();
			}
			else
			{
				PickSecondaryAttack(type + 1);
			}
			break;
		case 1:
			if (lastSecondaryAttack != SPAttack.Clap)
			{
				lastSecondaryAttack = SPAttack.Clap;
				TeleportAnywhere();
				Clap();
			}
			else
			{
				PickSecondaryAttack(type + 1);
			}
			break;
		case 2:
			if (lastSecondaryAttack != SPAttack.AirStomp)
			{
				lastSecondaryAttack = SPAttack.AirStomp;
				TeleportAbove();
				AirStomp();
			}
			else
			{
				PickSecondaryAttack(type + 1);
			}
			break;
		case 3:
			if (lastSecondaryAttack != SPAttack.AirKick)
			{
				lastSecondaryAttack = SPAttack.AirKick;
				TeleportAnywhere(predictive: true);
				AirKick();
			}
			else
			{
				PickSecondaryAttack(0);
			}
			break;
		}
	}

	public void CancelIntoSecondary()
	{
		if (enraged)
		{
			secondariesSinceLastPrimary++;
			int type = Random.Range(0, 3);
			PickSecondaryAttack(type);
		}
	}

	public void Taunt()
	{
		attacksSinceTaunt = 0;
		inAction = true;
		base.transform.LookAt(heightAdjustedTargetPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("Taunt", 0, 0f);
		aiming = false;
		taunting = true;
		attackAmount += 2;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("Nice try!");
		PlayVoice(tauntVoice);
	}

	public void UppercutCombo()
	{
		previousCombo = SPAttack.UppercutCombo;
		inAction = true;
		base.transform.LookAt(heightAdjustedTargetPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("UppercutCombo", 0, 0f);
		sc.knockBackForce = 50f;
		aiming = false;
		attackAmount += 3;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("DESTROY!");
		PlayVoice(uppercutComboVoice);
	}

	public void StompCombo()
	{
		previousCombo = SPAttack.StompCombo;
		inAction = true;
		base.transform.LookAt(heightAdjustedTargetPos);
		tracking = true;
		fullTracking = false;
		gravityInAction = false;
		anim.Play("StompCombo", 0, 0f);
		sc.knockBackForce = 50f;
		aiming = false;
		attackAmount += 3;
		teleportToGroundFailsafe = base.transform.position;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("You can't escape!");
		PlayVoice(stompComboVoice);
	}

	private void Chop()
	{
		tracking = true;
		fullTracking = true;
		inAction = true;
		base.transform.LookAt(target.position);
		gravityInAction = false;
		anim.SetTrigger("Chop");
		Unparryable();
		sc.knockBackForce = 50f;
		sc.knockBackDirectionOverride = true;
		sc.knockBackDirection = Vector3.down;
		aiming = false;
		attackAmount++;
	}

	private void Clap()
	{
		tracking = true;
		fullTracking = true;
		inAction = true;
		base.transform.LookAt(target.position);
		gravityInAction = false;
		anim.SetTrigger("Clap");
		Parryable();
		sc.knockBackForce = 100f;
		aiming = false;
		attackAmount++;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("BE GONE!");
		PlayVoice(clapVoice);
	}

	private void AirStomp()
	{
		tracking = true;
		fullTracking = false;
		inAction = true;
		base.transform.LookAt(target.position);
		gravityInAction = false;
		anim.SetTrigger("AirStomp");
		Unparryable();
		aiming = false;
		attackAmount++;
	}

	private void AirKick()
	{
		tracking = false;
		fullTracking = false;
		inAction = true;
		gravityInAction = false;
		anim.SetTrigger("AirKick");
		Parryable();
		sc.knockBackForce = 100f;
		sc.ignoreSlidingPlayer = true;
		aiming = false;
		attackAmount++;
	}

	private void ExplodeAttack()
	{
		tracking = true;
		fullTracking = true;
		inAction = true;
		base.transform.LookAt(target.position);
		gravityInAction = false;
		anim.SetTrigger("Explosion");
		aiming = false;
		attackAmount++;
		MonoSingleton<SubtitleController>.Instance.DisplaySubtitle("This will hurt.");
		PlayVoice(explosionVoice);
	}

	public void ClapStart()
	{
		SnakeSwingStart(0);
		SnakeSwingStart(1);
	}

	public void ClapShockwave()
	{
		DamageStop();
		if (gotParried && difficulty <= 2 && !enraged)
		{
			gotParried = false;
		}
		else if (difficulty >= 2)
		{
			PhysicalShockwave physicalShockwave = CreateShockwave(Vector3.Lerp(swingLimbs[0].position, swingLimbs[1].position, 0.5f));
			physicalShockwave.target = target;
			physicalShockwave.transform.rotation = base.transform.rotation;
			physicalShockwave.transform.Rotate(Vector3.forward * 90f, Space.Self);
			physicalShockwave.speed *= 2f;
			if (difficulty >= 4 && enraged)
			{
				DelayedExplosion(Vector3.Lerp(swingLimbs[0].position, swingLimbs[1].position, 0.5f));
			}
		}
	}

	public void StompShockwave()
	{
		DamageStop();
		if (gotParried && difficulty <= 2 && !enraged)
		{
			gotParried = false;
			return;
		}
		if (difficulty >= 2)
		{
			CreateShockwave(new Vector3(swingLimbs[2].position.x, base.transform.position.y, swingLimbs[2].position.z));
		}
		if (difficulty >= 4 && enraged)
		{
			DelayedExplosion(new Vector3(swingLimbs[2].position.x, base.transform.position.y, swingLimbs[2].position.z));
		}
	}

	private PhysicalShockwave CreateShockwave(Vector3 position)
	{
		GameObject obj = Object.Instantiate(groundWave, position, Quaternion.identity);
		obj.transform.SetParent(gz.transform);
		if (obj.TryGetComponent<PhysicalShockwave>(out var component))
		{
			component.target = target;
			component.enemyType = EnemyType.SisyphusPrime;
			component.damage = Mathf.RoundToInt((float)component.damage * eid.totalDamageModifier);
			return component;
		}
		return null;
	}

	private void RiderKickActivate()
	{
		Physics.Raycast(aimingBone.position, base.transform.forward, out var hitInfo, 250f, LayerMaskDefaults.Get(LMD.Environment));
		LineRenderer component = Object.Instantiate(attackTrail, aimingBone.position, base.transform.rotation).GetComponent<LineRenderer>();
		component.SetPosition(0, aimingBone.position);
		RaycastHit[] array = Physics.SphereCastAll(aimingBone.position, 5f, base.transform.forward, Vector3.Distance(aimingBone.position, hitInfo.point), LayerMaskDefaults.Get(LMD.EnemiesAndPlayer));
		bool flag = false;
		new List<EnemyIdentifier>();
		RaycastHit[] array2 = array;
		foreach (RaycastHit raycastHit in array2)
		{
			if (!flag && raycastHit.collider.gameObject.CompareTag("Player"))
			{
				flag = true;
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(30f * eid.totalDamageModifier), invincible: true);
				MonoSingleton<NewMovement>.Instance.LaunchFromPoint(MonoSingleton<NewMovement>.Instance.transform.position + base.transform.forward * -1f, 100f, 100f);
			}
		}
		if (Vector3.Angle(Vector3.up, hitInfo.normal) < 35f)
		{
			ResetRotation();
			base.transform.position = hitInfo.point;
			anim.Play("DropRecovery", 0, 0f);
		}
		else if (Vector3.Angle(Vector3.up, hitInfo.normal) < 145f)
		{
			base.transform.position = hitInfo.point - base.transform.forward;
			ResetRotation();
			inAction = false;
			anim.Play("Falling", 0, 0f);
		}
		else
		{
			base.transform.position = hitInfo.point - Vector3.up * 6.5f;
			ResetRotation();
			inAction = false;
			anim.Play("Falling", 0, 0f);
		}
		ResolveStuckness();
		component.SetPosition(1, aimingBone.position);
		GameObject gameObject = Object.Instantiate(bigRubble, hitInfo.point, Quaternion.identity);
		if (Vector3.Angle(hitInfo.normal, Vector3.up) < 5f)
		{
			gameObject.transform.LookAt(new Vector3(gameObject.transform.position.x + base.transform.forward.x, gameObject.transform.position.y, gameObject.transform.position.z + base.transform.forward.z));
		}
		else
		{
			gameObject.transform.up = hitInfo.normal;
		}
		if (difficulty >= 2)
		{
			gameObject = Object.Instantiate(groundWave, hitInfo.point, Quaternion.identity);
			gameObject.transform.up = hitInfo.normal;
			gameObject.transform.SetParent(gz.transform);
			if (gameObject.TryGetComponent<PhysicalShockwave>(out var component2))
			{
				component2.enemyType = EnemyType.MinosPrime;
				component2.damage = Mathf.RoundToInt((float)component2.damage * eid.totalDamageModifier);
			}
		}
	}

	private void DropAttackActivate()
	{
		Physics.Raycast(aimingBone.position, Vector3.down, out var hitInfo, 250f, LayerMaskDefaults.Get(LMD.Environment));
		LineRenderer component = Object.Instantiate(attackTrail, aimingBone.position, base.transform.rotation).GetComponent<LineRenderer>();
		component.SetPosition(0, aimingBone.position);
		RaycastHit[] array = Physics.SphereCastAll(aimingBone.position, 5f, Vector3.down, Vector3.Distance(aimingBone.position, hitInfo.point), LayerMaskDefaults.Get(LMD.EnemiesAndPlayer));
		bool flag = false;
		new List<EnemyIdentifier>();
		RaycastHit[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RaycastHit raycastHit = array2[i];
			if (!flag && raycastHit.collider.gameObject.CompareTag("Player"))
			{
				flag = true;
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(30f * eid.totalDamageModifier), invincible: true);
				MonoSingleton<NewMovement>.Instance.LaunchFromPoint(MonoSingleton<NewMovement>.Instance.transform.position + (MonoSingleton<NewMovement>.Instance.transform.position - new Vector3(raycastHit.point.x, MonoSingleton<NewMovement>.Instance.transform.position.y, raycastHit.point.z)).normalized, 100f, 100f);
			}
		}
		base.transform.position = hitInfo.point;
		component.SetPosition(1, aimingBone.position);
		GameObject gameObject = Object.Instantiate(bigRubble, hitInfo.point, Quaternion.identity);
		if (Vector3.Angle(hitInfo.normal, Vector3.up) < 5f)
		{
			gameObject.transform.LookAt(new Vector3(gameObject.transform.position.x + base.transform.forward.x, gameObject.transform.position.y, gameObject.transform.position.z + base.transform.forward.z));
		}
		else
		{
			gameObject.transform.up = hitInfo.normal;
		}
		if (difficulty >= 2)
		{
			gameObject = Object.Instantiate(groundWave, hitInfo.point, Quaternion.identity);
			gameObject.transform.up = hitInfo.normal;
			gameObject.transform.SetParent(gz.transform);
			if (gameObject.TryGetComponent<PhysicalShockwave>(out var component2))
			{
				component2.enemyType = EnemyType.SisyphusPrime;
				component2.damage = Mathf.RoundToInt((float)component2.damage * eid.totalDamageModifier);
			}
		}
	}

	public void SnakeSwingStart(int limb)
	{
		if (eid.dead)
		{
			return;
		}
		Transform child = Object.Instantiate(swingSnake, aimingBone.position + base.transform.forward * 4f, Quaternion.identity).transform.GetChild(0);
		child.SetParent(base.transform, worldPositionStays: true);
		child.LookAt(heightAdjustedTargetPos);
		currentSwingSnakes.Add(child.gameObject);
		if (!boxing)
		{
			swinging = true;
		}
		SwingCheck2 componentInChildren = child.GetComponentInChildren<SwingCheck2>();
		if ((bool)componentInChildren)
		{
			componentInChildren.OverrideEnemyIdentifier(eid);
			componentInChildren.knockBackDirectionOverride = true;
			if (sc.knockBackDirectionOverride)
			{
				componentInChildren.knockBackDirection = sc.knockBackDirection;
			}
			else
			{
				componentInChildren.knockBackDirection = base.transform.forward;
			}
			componentInChildren.knockBackForce = sc.knockBackForce;
			componentInChildren.ignoreSlidingPlayer = sc.ignoreSlidingPlayer;
		}
		AttackTrail componentInChildren2 = child.GetComponentInChildren<AttackTrail>();
		if ((bool)componentInChildren2)
		{
			componentInChildren2.target = swingLimbs[limb];
			componentInChildren2.pivot = aimingBone;
		}
		DamageStart();
	}

	public void DamageStart()
	{
		sc.DamageStart();
	}

	public void DamageStop()
	{
		swinging = false;
		sc.DamageStop();
		sc.knockBackDirectionOverride = false;
		sc.ignoreSlidingPlayer = false;
		mach.parryable = false;
		if (currentSwingSnakes.Count <= 0)
		{
			return;
		}
		for (int num = currentSwingSnakes.Count - 1; num >= 0; num--)
		{
			if (currentSwingSnakes[num].TryGetComponent<SwingCheck2>(out var component))
			{
				component.DamageStop();
			}
			if (base.gameObject.activeInHierarchy && currentSwingSnakes[num].TryGetComponent<AttackTrail>(out var component2))
			{
				component2.DelayedDestroy(0.5f);
				currentSwingSnakes[num].transform.parent = null;
				component2.target = null;
				component2.pivot = null;
			}
			else
			{
				Object.Destroy(currentSwingSnakes[num]);
			}
		}
		currentSwingSnakes.Clear();
	}

	public void Explosion()
	{
		vibrating = false;
		if ((bool)currentExplosionChargeEffect)
		{
			Object.Destroy(currentExplosionChargeEffect);
		}
		if (gotParried)
		{
			gotParried = false;
			return;
		}
		GameObject gameObject = Object.Instantiate(this.explosion, aimingBone.position, Quaternion.identity);
		mach.parryable = false;
		if (difficulty > 1 && eid.totalDamageModifier == 1f)
		{
			return;
		}
		Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
		foreach (Explosion explosion in componentsInChildren)
		{
			if (difficulty == 1)
			{
				explosion.speed *= 0.6f;
				explosion.maxSize *= 0.75f;
			}
			else if (difficulty == 0)
			{
				explosion.speed *= 0.5f;
				explosion.maxSize *= 0.5f;
			}
			explosion.speed *= eid.totalDamageModifier;
			explosion.maxSize *= eid.totalDamageModifier;
			explosion.damage = Mathf.RoundToInt((float)explosion.damage * eid.totalDamageModifier);
		}
	}

	public void ProjectileCharge()
	{
		if ((bool)currentProjectileCharge)
		{
			Object.Destroy(currentProjectileCharge);
		}
		currentProjectileCharge = Object.Instantiate(projectileCharge, swingLimbs[1].position, swingLimbs[1].rotation);
		currentProjectileCharge.transform.SetParent(swingLimbs[1]);
	}

	public void ProjectileShoot()
	{
		if ((bool)currentProjectileCharge)
		{
			Object.Destroy(currentProjectileCharge);
		}
		if (target != null)
		{
			mach.parryable = false;
			Vector3 vector = target.PredictTargetPosition(0.5f);
			base.transform.LookAt(new Vector3(vector.x, base.transform.position.y, vector.z));
			DelayedExplosion(vector);
			aiming = false;
			tracking = false;
			fullTracking = false;
		}
	}

	public void DelayedExplosion(Vector3 target)
	{
		GameObject obj = Object.Instantiate(sparkleExplosion, target, Quaternion.identity);
		obj.transform.SetParent(gz.transform);
		ObjectActivator component = obj.GetComponent<ObjectActivator>();
		if ((bool)component)
		{
			component.delay /= eid.totalSpeedModifier;
		}
		LineRenderer componentInChildren = obj.GetComponentInChildren<LineRenderer>();
		if ((bool)componentInChildren)
		{
			componentInChildren.SetPosition(0, target);
			componentInChildren.SetPosition(1, swingLimbs[1].position);
		}
		Explosion[] componentsInChildren = obj.GetComponentsInChildren<Explosion>();
		foreach (Explosion obj2 in componentsInChildren)
		{
			obj2.damage = Mathf.RoundToInt((float)obj2.damage * eid.totalDamageModifier);
			obj2.maxSize *= eid.totalDamageModifier;
		}
	}

	public void TeleportOnGround(int forceNoPrediction = 0)
	{
		if (target != null)
		{
			ResetRotation();
			Vector3 point = teleportToGroundFailsafe;
			if (Physics.Raycast(base.transform.position + Vector3.up, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
			{
				point = hitInfo.point;
			}
			base.transform.position = point;
			heightAdjustedTargetPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
			Teleport(heightAdjustedTargetPos, base.transform.position);
			if (difficulty < 2 || forceNoPrediction == 1)
			{
				base.transform.LookAt(heightAdjustedTargetPos);
				return;
			}
			Vector3 vector = target.PredictTargetPosition(0.5f);
			base.transform.LookAt(new Vector3(vector.x, base.transform.position.y, vector.z));
		}
	}

	public void TeleportAnywhere()
	{
		TeleportAnywhere(predictive: false);
	}

	public void TeleportAnywhere(bool predictive = false)
	{
		if (target != null)
		{
			Teleport(predictive ? target.PredictTargetPosition(0.5f) : target.position, base.transform.position);
			if (difficulty < 2)
			{
				base.transform.LookAt(target.position);
			}
			else
			{
				base.transform.LookAt(target.PredictTargetPosition(0.5f));
			}
		}
	}

	public void TeleportAbove()
	{
		TeleportAbove(predictive: true);
	}

	public void TeleportAbove(bool predictive = true)
	{
		Vector3 vector = (predictive ? target.PredictTargetPosition(0.5f) : target.position);
		if (vector.y < target.position.y)
		{
			vector.y = target.position.y;
		}
		Teleport(vector + Vector3.up * 25f, vector);
	}

	public void TeleportSideRandom(int predictive)
	{
		TeleportSide(Random.Range(0, 2), inAir: false, predictive == 1);
	}

	public void TeleportSideRandomAir(int predictive)
	{
		TeleportSide(Random.Range(0, 2), inAir: true, predictive == 1);
	}

	public void TeleportSide(int side, bool inAir = false, bool predictive = false)
	{
		int num = 1;
		Vector3 vector = (predictive ? target.PredictTargetPosition(0.5f) : target.position);
		if (!inAir)
		{
			vector = new Vector3(vector.x, base.transform.position.y, vector.z);
		}
		if (side == 0)
		{
			num = -1;
		}
		if (Physics.Raycast(vector + Vector3.up, target.right * num + target.forward, out var hitInfo, 4f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
		{
			if (hitInfo.distance >= 2f)
			{
				Teleport(vector, vector + Vector3.ClampMagnitude(target.right * num + target.forward, 1f) * (hitInfo.distance - 1f));
			}
			else
			{
				Teleport(vector, base.transform.position);
			}
			base.transform.LookAt(vector);
		}
		else
		{
			Teleport(vector, vector + (target.right * num + target.forward) * 10f);
			base.transform.LookAt(vector);
		}
	}

	public void Teleport(Vector3 teleportTarget, Vector3 startPos)
	{
		float num = Vector3.Distance(teleportTarget, startPos);
		if (boxing && num > 4.5f)
		{
			num = 4.5f;
		}
		else if (num > 6f)
		{
			num = 6f;
		}
		LineRenderer component = Object.Instantiate(attackTrail, aimingBone.position, base.transform.rotation).GetComponent<LineRenderer>();
		component.SetPosition(0, aimingBone.position);
		Vector3 vector = teleportTarget + (startPos - teleportTarget).normalized * num;
		Collider[] array = Physics.OverlapCapsule(vector + base.transform.up * 0.75f, vector + base.transform.up * 5.25f, 0.75f, LayerMaskDefaults.Get(LMD.Environment));
		if (array != null && array.Length != 0)
		{
			for (int i = 0; i < 6; i++)
			{
				Collider collider = array[0];
				if (!Physics.ComputePenetration(col, vector + base.transform.up * 3f, base.transform.rotation, collider, collider.transform.position, collider.transform.rotation, out var direction, out var distance))
				{
					break;
				}
				_ = 0.5f;
				vector += direction * distance;
				array = Physics.OverlapCapsule(vector + base.transform.up * 0.75f, vector + base.transform.up * 5.25f, 0.75f, LayerMaskDefaults.Get(LMD.Environment));
				if (array == null || array.Length == 0)
				{
					break;
				}
				if (i == 5)
				{
					ResolveStuckness();
					break;
				}
			}
		}
		float num2 = Vector3.Distance(base.transform.position, vector);
		for (int j = 0; (float)j < num2; j += 3)
		{
			if (Physics.Raycast(Vector3.Lerp(base.transform.position, vector, (num2 - (float)j) / num2) + Vector3.up, Vector3.down, out var hitInfo, 3f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				Object.Instantiate(rubble, hitInfo.point, Quaternion.Euler(0f, Random.Range(0, 360), 0f));
			}
		}
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
		base.transform.position = vector;
		tracking = false;
		fullTracking = false;
		Object.Instantiate(swoosh, base.transform.position, Quaternion.identity);
		component.SetPosition(1, aimingBone.position);
	}

	public void LookAtTarget()
	{
		if (target != null)
		{
			heightAdjustedTargetPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
			base.transform.LookAt(heightAdjustedTargetPos);
		}
	}

	public void Death()
	{
		if ((bool)currentProjectileCharge)
		{
			Object.Destroy(currentProjectileCharge);
		}
		DamageStop();
		anim.Play("Outro");
		anim.SetBool("Dead", value: true);
		if (bossVersion)
		{
			anim.speed = 1f;
		}
		else
		{
			anim.speed = 5f;
		}
		activated = false;
		if ((bool)currentPassiveEffect)
		{
			Object.Destroy(currentPassiveEffect);
		}
		CancelInvoke();
		Object.Destroy(nma);
		DisableGravity();
		rb.useGravity = false;
		rb.isKinematic = true;
		MonoSingleton<TimeController>.Instance.SlowDown(0.0001f);
	}

	public void Ascend()
	{
		if (!bossVersion)
		{
			OutroEnd();
			return;
		}
		rb.isKinematic = false;
		rb.constraints = (RigidbodyConstraints)122;
		ascending = true;
		LightShaft();
		Invoke("LightShaft", 1.5f);
		Invoke("LightShaft", 3f);
		Invoke("LightShaft", 4f);
		Invoke("LightShaft", 5f);
		Invoke("LightShaft", 5.5f);
		Invoke("LightShaft", 6f);
		Invoke("LightShaft", 6.25f);
		Invoke("LightShaft", 6.5f);
		Invoke("LightShaft", 6.7f);
		Invoke("LightShaft", 6.8f);
		Invoke("LightShaft", 6.85f);
		Invoke("LightShaft", 6.9f);
		Invoke("LightShaft", 6.925f);
		Invoke("LightShaft", 6.95f);
		Invoke("LightShaft", 6.975f);
		Invoke("OutroEnd", 7f);
	}

	private void LightShaft()
	{
		if (base.gameObject.activeInHierarchy)
		{
			Object.Instantiate(lightShaft, mach.chest.transform.position, Random.rotation).transform.SetParent(base.transform, worldPositionStays: true);
			MonoSingleton<CameraController>.Instance.CameraShake(1f);
		}
	}

	public void OutroEnd()
	{
		if (base.gameObject.activeInHierarchy)
		{
			onOutroEnd.Invoke();
			Object.Instantiate(outroExplosion, mach.chest.transform.position, Quaternion.identity);
			base.gameObject.SetActive(value: false);
			MonoSingleton<TimeController>.Instance.SlowDown(0.001f);
		}
	}

	public void EnableGravity(int earlyCancel)
	{
		if (!gce.onGround)
		{
			anim.SetBool("Falling", value: true);
			gravityInAction = true;
			if (earlyCancel == 1)
			{
				inAction = false;
			}
		}
		ResetRotation();
	}

	public void Parryable()
	{
		gotParried = false;
		Object.Instantiate(parryableFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 30f;
		mach.ParryableCheck();
	}

	public void Unparryable()
	{
		Object.Instantiate(warningFlash, head.position, Quaternion.LookRotation(MonoSingleton<CameraController>.Instance.transform.position - head.position)).transform.localScale *= 15f;
	}

	public void GotParried()
	{
		PlayVoice(hurtVoice);
		attackAmount -= 5;
		gotParried = true;
		if ((bool)currentExplosionChargeEffect)
		{
			Object.Destroy(currentExplosionChargeEffect);
		}
	}

	public void Rubble()
	{
		Object.Instantiate(bigRubble, base.transform.position + base.transform.forward, base.transform.rotation);
	}

	public void ResetRotation()
	{
		base.transform.LookAt(new Vector3(base.transform.position.x + base.transform.forward.x, base.transform.position.y, base.transform.position.z + base.transform.forward.z));
		ResolveStuckness();
	}

	public void DisableGravity()
	{
		gravityInAction = false;
	}

	public void StartTracking()
	{
		tracking = true;
	}

	public void StopTracking()
	{
		tracking = false;
		fullTracking = false;
	}

	public void StopAction()
	{
		fullTracking = false;
		ResetRotation();
		gotParried = false;
		inAction = false;
		boxing = false;
		taunting = false;
		sc.knockBackDirectionOverride = false;
		if ((bool)mach)
		{
			mach.parryable = false;
		}
	}

	public void TargetBeenHit()
	{
		sc.DamageStop();
		hitSuccessful = true;
		mach.parryable = false;
		foreach (GameObject currentSwingSnake in currentSwingSnakes)
		{
			if ((bool)currentSwingSnake && currentSwingSnake.TryGetComponent<SwingCheck2>(out var component))
			{
				component.OverrideEnemyIdentifier(eid);
				component.DamageStop();
			}
		}
	}

	public void OutOfBounds()
	{
		base.transform.position = spawnPoint;
	}

	public void Vibrate()
	{
		if ((bool)currentExplosionChargeEffect)
		{
			Object.Destroy(currentExplosionChargeEffect);
		}
		if (activated)
		{
			currentExplosionChargeEffect = Object.Instantiate(explosionChargeEffect, aimingBone.position, Quaternion.identity);
		}
		origPos = base.transform.position;
		vibrating = true;
	}

	public void PlayVoice(AudioClip[] voice)
	{
		if (voice.Length != 0 && (!(aud.clip == phaseChangeVoice) || !aud.isPlaying))
		{
			aud.clip = voice[Random.Range(0, voice.Length)];
			aud.pitch = Random.Range(0.95f, 1f);
			aud.Play();
		}
	}

	public void ForceKnockbackDown()
	{
		sc.knockBackDirectionOverride = true;
		sc.knockBackDirection = Vector3.down;
	}

	public void SwingIgnoreSliding()
	{
		sc.ignoreSlidingPlayer = true;
	}

	public void ResolveStuckness()
	{
		Collider[] array = Physics.OverlapCapsule(base.transform.position + base.transform.up * 0.76f, base.transform.position + base.transform.up * 5.24f, 0.74f, LayerMaskDefaults.Get(LMD.Environment));
		if (array == null || array.Length == 0)
		{
			return;
		}
		if (gce.onGround)
		{
			gce.onGround = false;
			if (nma != null)
			{
				nma.enabled = false;
			}
		}
		for (int i = 0; i < 6; i++)
		{
			RaycastHit[] array2 = Physics.CapsuleCastAll(spawnPoint + base.transform.up * 0.75f, spawnPoint + base.transform.up * 5.25f, 0.75f, base.transform.position - spawnPoint, Vector3.Distance(spawnPoint, base.transform.position), LayerMaskDefaults.Get(LMD.Environment));
			if (array2 == null || array2.Length == 0)
			{
				break;
			}
			RaycastHit[] array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				RaycastHit raycastHit = array3[j];
				bool flag = false;
				Collider[] array4 = array;
				for (int k = 0; k < array4.Length; k++)
				{
					if (array4[k] == raycastHit.collider)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					base.transform.position = spawnPoint + (base.transform.position - spawnPoint).normalized * raycastHit.distance + raycastHit.normal * 0.1f;
					break;
				}
			}
			_ = 5;
		}
	}
}



public class SisyphusPrimeIntro : MonoBehaviour
{
	public GameObject groundImpactEffect;

	public UltrakillEvent onGroundImpact;

	private bool hasHitGround;

	private Rigidbody rb;

	private TimeSince ts;

	private bool tracking;

	private void Start()
	{
		ts = 0f;
		Vector3 position = MonoSingleton<PlayerTracker>.Instance.GetPlayer().position;
		position.y = base.transform.position.y;
		base.transform.rotation = Quaternion.LookRotation(position - base.transform.position);
	}

	private void Update()
	{
		if (tracking)
		{
			Vector3 position = MonoSingleton<PlayerTracker>.Instance.GetPlayer().position;
			position.y = base.transform.position.y;
			Quaternion quaternion = Quaternion.LookRotation(position - base.transform.position);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * 10f * Quaternion.Angle(base.transform.rotation, quaternion));
		}
	}

	private void FixedUpdate()
	{
		if (!hasHitGround)
		{
			if (!rb)
			{
				rb = GetComponent<Rigidbody>();
			}
			rb.velocity -= Vector3.up * Mathf.Lerp(0f, 100f, ts) * Time.fixedDeltaTime;
		}
	}

	private void OnCollisionEnter(Collision col)
	{
		if (!hasHitGround && (col.gameObject.layer == 8 || col.gameObject.layer == 24))
		{
			hasHitGround = true;
			GetComponent<Animator>().Play("Intro");
			Object.Instantiate(groundImpactEffect, base.transform.position, Quaternion.identity);
			onGroundImpact?.Invoke();
			rb.isKinematic = true;
			base.gameObject.layer = 16;
			tracking = true;
		}
	}
}



public class Skull : MonoBehaviour
{
	private Light lit;

	private float origRange;

	private float litTime;

	private AudioSource aud;

	private void Start()
	{
		lit = GetComponent<Light>();
		origRange = lit.range;
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (litTime > 0f)
		{
			litTime = Mathf.MoveTowards(litTime, 0f, Time.deltaTime);
		}
		else if (lit.range > origRange)
		{
			lit.range = Mathf.MoveTowards(lit.range, origRange, Time.deltaTime * 5f);
		}
	}

	public void PunchWith()
	{
		if (lit.range == origRange)
		{
			litTime = 1f;
			lit.range = origRange * 2.5f;
			aud.Play();
		}
	}

	public void HitWith(GameObject target)
	{
		Flammable component = target.gameObject.GetComponent<Flammable>();
		if (component != null && !component.enemyOnly)
		{
			component.Burn(4f);
		}
	}

	public void HitSurface(RaycastHit hit)
	{
		MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(hit.point);
	}
}



public class SkyboxEnabler : MonoBehaviour
{
	public bool disable;

	public bool oneTime;

	public bool dontActivateOnEnable;

	private bool activated;

	public Material changeSkybox;

	private void OnEnable()
	{
		if (!dontActivateOnEnable)
		{
			Activate();
		}
	}

	public void Activate()
	{
		if (!oneTime || !activated)
		{
			activated = true;
			if (MonoSingleton<CameraController>.Instance.TryGetComponent<Camera>(out var component))
			{
				component.clearFlags = ((!disable) ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			}
			if ((bool)changeSkybox)
			{
				RenderSettings.skybox = new Material(changeSkybox);
			}
		}
	}
}



public class SlideLengthChallenge : MonoBehaviour
{
	public float slideLength;

	private void Update()
	{
		if (MonoSingleton<NewMovement>.Instance.longestSlide >= slideLength)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
	}
}



public class SliderGetPlayerPref : MonoBehaviour
{
	public bool isFloat;

	public string playerPref;

	public float defaultFloat;

	public int defaultInt;

	private void Awake()
	{
		if (isFloat)
		{
			GetComponent<Slider>().value = PlayerPrefs.GetFloat(playerPref, defaultFloat);
		}
		else
		{
			GetComponent<Slider>().value = PlayerPrefs.GetInt(playerPref, defaultInt);
		}
	}
}



public class SliderLabel : MonoBehaviour
{
	public bool floor = true;

	public float multiplier = 1f;

	[SerializeField]
	private Slider slider;

	[SerializeField]
	private string postfix = "";

	private TMP_Text text;

	private void Awake()
	{
		text = GetComponent<TMP_Text>();
	}

	private void Update()
	{
		if (floor)
		{
			text.text = $"{Mathf.FloorToInt(slider.value * multiplier)}{postfix}";
		}
		else
		{
			text.text = $"{(float)Mathf.FloorToInt(slider.value * multiplier * 10f) / 10f}{postfix}";
		}
	}
}



[Serializable]
public class SliderLayer
{
	public Color color;

	public Color afterImageColor;
}



public class SliderToFillAmount : MonoBehaviour
{
	public Slider targetSlider;

	public float maxFill;

	public bool copyColor;

	private Image img;

	public FadeOutBars mama;

	public bool dontFadeUntilEmpty;

	private bool isInvisible;

	private bool lastInvisible;

	private void OnEnable()
	{
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		lastInvisible = !isInvisible;
	}

	private void Update()
	{
		isInvisible = Mathf.Approximately(img.color.a, 0f);
		if (isInvisible != lastInvisible)
		{
			img.enabled = !isInvisible;
			lastInvisible = isInvisible;
		}
		float fillAmount = img.fillAmount;
		float num = (targetSlider.value - targetSlider.minValue) / (targetSlider.maxValue - targetSlider.minValue) * maxFill;
		if (num != fillAmount)
		{
			img.fillAmount = num;
			ResetFadeTimer();
		}
		if (copyColor)
		{
			Color color = img.color;
			Color color2 = targetSlider.targetGraphic.color;
			if (color2 != color)
			{
				img.color = color2;
			}
		}
		if (mama != null)
		{
			Color color3 = img.color;
			float num2 = ((mama.fadeOutTime < 1f) ? mama.fadeOutTime : 1f);
			if (num2 != color3.a)
			{
				color3.a = num2;
				img.color = color3;
			}
		}
	}

	private void ResetFadeTimer()
	{
		if ((bool)mama)
		{
			mama.ResetTimer();
		}
	}
}



public class SliderValueToText : MonoBehaviour
{
	public DecimalType decimalType;

	private string decString;

	private Slider targetSlider;

	private Text targetText;

	private TMP_Text targetTextTMP;

	public string suffix;

	public string ifMax;

	public string ifMin;

	public Color minColor;

	public Color maxColor;

	private Color origColor;

	private Color nullColor;

	private void Start()
	{
		switch (decimalType)
		{
		case DecimalType.Three:
			decString = "F3";
			break;
		case DecimalType.Two:
			decString = "F2";
			break;
		case DecimalType.One:
			decString = "F1";
			break;
		case DecimalType.NoDecimals:
			decString = "F0";
			break;
		}
		targetSlider = GetComponentInParent<Slider>();
		targetTextTMP = GetComponent<TMP_Text>();
		if (targetTextTMP == null)
		{
			targetText = GetComponent<Text>();
		}
		origColor = (targetTextTMP ? targetTextTMP.color : targetText.color);
		nullColor = new Color(0f, 0f, 0f, 0f);
	}

	private void Update()
	{
		string text = "";
		Color color = origColor;
		text = ((ifMax != "" && targetSlider.value == targetSlider.maxValue) ? ifMax : ((!(ifMin != "") || targetSlider.value != targetSlider.minValue) ? (targetSlider.value.ToString(decString) + suffix) : ifMin));
		if (maxColor != nullColor && targetSlider.value == targetSlider.maxValue)
		{
			color = maxColor;
		}
		else if (minColor != nullColor && targetSlider.value == targetSlider.minValue)
		{
			color = minColor;
		}
		if ((bool)targetTextTMP)
		{
			targetTextTMP.text = text;
			targetTextTMP.color = color;
		}
		else
		{
			targetText.text = text;
			targetText.color = color;
		}
	}
}



public class SlotRowPanel : MonoBehaviour
{
	public int slotIndex;

	public TMP_Text slotNumberLabel;

	public TMP_Text stateLabel;

	public Image backgroundPanel;

	public Button selectButton;

	public Button deleteButton;
}



public class SlowMo : MonoBehaviour
{
	public float amount;

	private void OnEnable()
	{
		MonoSingleton<TimeController>.Instance.SlowDown(amount);
		Object.Destroy(this);
	}
}



public class Soap : MonoBehaviour
{
	private ItemIdentifier itid;

	private Rigidbody rb;

	private Vector3 velocityBeforeCollision;

	private void Start()
	{
		itid = GetComponent<ItemIdentifier>();
		rb = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		if ((bool)rb)
		{
			velocityBeforeCollision = rb.velocity;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (itid.pickedUp || !(velocityBeforeCollision.magnitude > 15f))
		{
			return;
		}
		Breakable component2;
		Bleeder component3;
		if ((collision.gameObject.layer == 11 || collision.gameObject.layer == 10) && collision.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
		{
			if ((bool)component.eid)
			{
				component.eid.DeliverDamage(collision.gameObject, Vector3.zero, collision.GetContact(0).point, 999999f, tryForExplode: true);
			}
			rb.velocity = Vector3.zero;
		}
		else if (collision.gameObject.TryGetComponent<Breakable>(out component2))
		{
			component2.Break();
			rb.velocity = Vector3.zero;
		}
		else if (collision.gameObject.TryGetComponent<Bleeder>(out component3))
		{
			component3.GetHit(base.transform.position, GoreType.Head);
		}
	}

	public void HitWith(GameObject target)
	{
		if (target.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
		{
			component.eid.DeliverDamage(target, Vector3.zero, target.transform.position, 999999f, tryForExplode: true);
		}
	}
}



public class SoundChanger : MonoBehaviour
{
	public AudioSource target;

	public AudioClip newSound;

	public bool keepProgress;

	private void Start()
	{
		float time = 0f;
		if (keepProgress)
		{
			time = target.time;
		}
		target.clip = newSound;
		target.Play();
		if (keepProgress)
		{
			target.time = time;
		}
	}
}



public class SoundLoopWithIntro : MonoBehaviour
{
	private AudioSource aud;

	[SerializeField]
	private AudioClip intro;

	[SerializeField]
	private AudioClip loop;

	private bool introOver;

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
		aud.clip = intro;
		aud.loop = false;
		aud.Play();
	}

	private void Update()
	{
		if (!introOver && (!aud.isPlaying || aud.time > aud.clip.length - 0.1f))
		{
			introOver = true;
			aud.clip = loop;
			aud.loop = true;
			aud.Play();
		}
	}
}



public class SoundOff : MonoBehaviour
{
	private AudioSource aud;

	private void Start()
	{
		aud = GetComponentInChildren<AudioSource>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			aud.volume = 0f;
		}
	}
}



public class SoundOn : MonoBehaviour
{
	private AudioSource aud;

	public float volume;

	private void Awake()
	{
		aud = GetComponentInChildren<AudioSource>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			aud.volume = volume;
		}
	}
}



public class SoundOnMove : MonoBehaviour
{
	private AudioSource aud;

	private Rigidbody rb;

	public float minSpeed;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		rb = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (!aud.isPlaying && rb.velocity.magnitude > minSpeed)
		{
			aud.Play();
		}
		else if (aud.isPlaying && rb.velocity.magnitude <= minSpeed)
		{
			aud.Stop();
		}
	}
}



public class SoundPause : MonoBehaviour
{
	private AudioSource aud;

	private bool wasPlaying;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if ((bool)aud)
		{
			if (aud.isPlaying && Time.timeScale == 0f)
			{
				wasPlaying = true;
				aud.Pause();
			}
			else if (Time.timeScale != 0f && wasPlaying)
			{
				wasPlaying = false;
				aud.UnPause();
			}
		}
	}
}



public class SoundPitch : MonoBehaviour
{
	private AudioSource aud;

	public float targetPitch;

	public float speed;

	public bool notOnEnable;

	private bool activated;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if (!notOnEnable)
		{
			activated = true;
		}
	}

	private void Update()
	{
		if ((bool)aud && activated)
		{
			aud.pitch = Mathf.MoveTowards(aud.pitch, targetPitch, speed * Time.deltaTime);
		}
	}

	public void Activate()
	{
		activated = true;
	}

	public void Deactivate()
	{
		activated = false;
	}

	public void ChangePitch(float newPitch)
	{
		targetPitch = newPitch;
	}

	public void ChangeSpeed(float newSpeed)
	{
		speed = newSpeed;
	}
}



public class SoundPitchDip : MonoBehaviour
{
	private AudioSource aud;

	private bool dipping;

	private float origPitch;

	private float target;

	public float speed;

	public bool onEnable;

	private void OnEnable()
	{
		if (onEnable)
		{
			Dip(0f);
		}
	}

	public void Dip(float pitch)
	{
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
			if ((bool)aud)
			{
				origPitch = aud.pitch;
				aud.pitch = pitch;
				target = origPitch;
				dipping = true;
			}
		}
	}

	public void DipToZero()
	{
		if (!aud)
		{
			aud = GetComponent<AudioSource>();
			if ((bool)aud)
			{
				origPitch = aud.pitch;
				target = 0f;
				dipping = true;
			}
		}
	}

	private void Update()
	{
		if (dipping)
		{
			aud.pitch = Mathf.MoveTowards(aud.pitch, target, Time.deltaTime * speed);
			if (aud.pitch == target)
			{
				dipping = false;
			}
		}
	}
}



public class SoundStopper : MonoBehaviour
{
	public AudioSource toStop;

	private void Start()
	{
		toStop.Stop();
	}
}



[Serializable]
public class SoundtrackFolder
{
	public string name;

	public List<AssetReferenceSoundtrackSong> songs;

	public SoundtrackFolder(string name, List<AssetReferenceSoundtrackSong> songs)
	{
		this.name = name;
		this.songs = songs;
	}
}



[CreateAssetMenu(menuName = "ULTRAKILL/Soundtrack Song Data")]
public class SoundtrackSong : ScriptableObject
{
	[Space]
	public Sprite icon;

	public string songName;

	public string levelName;

	[Header("Clips")]
	public AudioClip introClip;

	public List<AudioClip> clips;

	public int maxClipsIfNotRepeating = -1;

	[SerializeReference]
	[PolymorphicField(typeof(UnlockCondition))]
	public List<UnlockCondition> conditions;

	public string extraLevelBit
	{
		get
		{
			if (!(levelName == ""))
			{
				return "(" + levelName + ")";
			}
			return "";
		}
	}
}



public class SoundVolume : MonoBehaviour
{
	private AudioSource aud;

	public float targetVolume;

	public float speed;

	public bool notOnEnable;

	private bool activated;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		if (!notOnEnable)
		{
			activated = true;
		}
	}

	private void Update()
	{
		if ((bool)aud && activated)
		{
			aud.volume = Mathf.MoveTowards(aud.volume, targetVolume, speed * Time.deltaTime);
		}
	}

	public void Activate()
	{
		activated = true;
	}

	public void Deactivate()
	{
		activated = false;
	}

	public void ChangeVolume(float newVolume)
	{
		targetVolume = newVolume;
	}

	public void ChangeSpeed(float newSpeed)
	{
		speed = newSpeed;
	}
}



public class SoundWobbler : MonoBehaviour
{
	private AudioSource aud;

	public float wobbleTime;

	public float wobbleSpeed;

	public bool wobbleUp;

	private void Awake()
	{
		aud = GetComponentInChildren<AudioSource>();
		Invoke("ChangeWobble", wobbleTime);
	}

	private void Update()
	{
		if (wobbleUp)
		{
			aud.pitch += wobbleSpeed * Time.deltaTime;
		}
		else
		{
			aud.pitch -= wobbleSpeed * Time.deltaTime;
		}
	}

	private void ChangeWobble()
	{
		if (wobbleUp)
		{
			wobbleUp = false;
		}
		else
		{
			wobbleUp = true;
		}
		Invoke("ChangeWobble", wobbleTime);
	}
}



public class SpatialMusic : MonoBehaviour
{
	public float minDistance;

	public float maxDistance;

	private AudioHighPassFilter hiPass;

	private float hiPassDefaultFrequency;

	private AudioSource aud;

	private Transform target;

	private void Start()
	{
		aud = GetComponent<AudioSource>();
		hiPass = GetComponent<AudioHighPassFilter>();
		target = MonoSingleton<CameraController>.Instance.transform;
		if ((bool)hiPass)
		{
			hiPassDefaultFrequency = hiPass.cutoffFrequency;
		}
	}

	private void Update()
	{
		float num = (Mathf.Clamp(Vector3.Distance(base.transform.position, target.position), minDistance, maxDistance) - minDistance) / (maxDistance - minDistance);
		aud.spatialBlend = num;
		if ((bool)hiPass)
		{
			hiPass.cutoffFrequency = Mathf.Lerp(0f, hiPassDefaultFrequency, num);
		}
	}
}


public enum SPAttack
{
	UppercutCombo,
	StompCombo,
	Chop,
	Clap,
	AirStomp,
	AirKick,
	Explosion
}



[CreateAssetMenu(menuName = "ULTRAKILL/Spawnable Object")]
public class SpawnableObject : ScriptableObject
{
	public enum SpawnableObjectDataType
	{
		Object = 0,
		Enemy = 1,
		Tool = 3,
		Unlockable = 4
	}

	public string identifier;

	public SpawnableObjectDataType spawnableObjectType;

	public UnlockableType unlockableType;

	public bool sandboxOnly;

	public string objectName;

	public string type;

	[TextArea]
	public string description;

	[TextArea]
	public string strategy;

	public GameObject gameObject;

	public GameObject preview;

	public string iconKey;

	public Sprite gridIcon;

	public Color backgroundColor;

	public EnemyType enemyType;

	public bool fullEnemyComponent;

	public SpawnableType spawnableType;

	public Vector3 armOffset = Vector3.zero;

	[FormerlySerializedAs("rotationOffset")]
	public Vector3 armRotationOffset = Vector3.zero;

	public Vector3 menuOffset = Vector3.zero;

	public float spawnOffset;

	public bool isWater;

	public bool triggerOnly;

	public bool alwaysKinematic;

	public AlterOption[] defaultSettings;
}



[CreateAssetMenu(menuName = "ULTRAKILL/Spawnable Object List")]
public class SpawnableObjectsDatabase : ScriptableObject
{
	public SpawnableObject[] enemies;

	public SpawnableObject[] objects;

	public SpawnableObject[] sandboxTools;

	public SpawnableObject[] sandboxObjects;

	public SpawnableObject[] specialSandbox;

	public SpawnableObject[] unlockables;

	public SpawnableObject[] debug;
}


public enum SpawnableType
{
	SimpleSpawn,
	Prop,
	BuildHand,
	MoveHand,
	DestroyHand,
	AlterHand
}



public class SpawnEffect : MonoBehaviour
{
	private AudioSource aud;

	private Transform bubble;

	private Light light;

	public float pitch;

	private bool simple;

	private void Start()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetBoolLocal("simpleSpawns"))
		{
			simple = true;
		}
		aud = GetComponent<AudioSource>();
		aud.pitch = Random.Range(pitch - 0.1f, pitch + 0.1f);
		aud.Play();
		bubble = base.transform.GetChild(0);
		if (!simple)
		{
			light = GetComponentInChildren<Light>();
			light.enabled = true;
			GetComponent<ParticleSystem>().Play();
		}
	}

	private void Update()
	{
		if (bubble.localScale.x > 0f)
		{
			bubble.localScale -= Vector3.one * 2f * Time.deltaTime;
		}
		else
		{
			bubble.localScale = Vector3.zero;
		}
		if (!simple && light != null && light.range > 0f)
		{
			light.range -= Time.deltaTime * 50f;
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SpawnMenu : MonoSingleton<SpawnMenu>
{
	[SerializeField]
	private SpawnMenuSectionReference sectionReference;

	[SerializeField]
	private SpawnableObjectsDatabase objects;

	[HideInInspector]
	public SummonSandboxArm armManager;

	[SerializeField]
	private Sprite lockedIcon;

	private Dictionary<string, Sprite> spriteIcons;

	protected override void Awake()
	{
		base.Awake();
		RebuildIcons();
		RebuildMenu();
		if (MonoSingleton<UnlockablesData>.Instance != null)
		{
			UnlockablesData unlockablesData = MonoSingleton<UnlockablesData>.Instance;
			unlockablesData.unlockableFound = (UnityAction)Delegate.Combine(unlockablesData.unlockableFound, new UnityAction(RebuildMenu));
		}
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		if (MonoSingleton<UnlockablesData>.Instance != null)
		{
			UnlockablesData unlockablesData = MonoSingleton<UnlockablesData>.Instance;
			unlockablesData.unlockableFound = (UnityAction)Delegate.Remove(unlockablesData.unlockableFound, new UnityAction(RebuildMenu));
		}
	}

	public void RebuildIcons()
	{
		spriteIcons = new Dictionary<string, Sprite>();
		CheatAssetObject.KeyIcon[] sandboxMenuIcons = MonoSingleton<IconManager>.Instance.CurrentIcons.sandboxMenuIcons;
		for (int i = 0; i < sandboxMenuIcons.Length; i++)
		{
			CheatAssetObject.KeyIcon keyIcon = sandboxMenuIcons[i];
			spriteIcons.Add(keyIcon.key, keyIcon.sprite);
		}
	}

	public void ResetMenu()
	{
		if (!(sectionReference == null) && !(sectionReference.transform.parent == null))
		{
			for (int i = 1; i < sectionReference.transform.parent.childCount; i++)
			{
				UnityEngine.Object.Destroy(sectionReference.transform.parent.GetChild(i).gameObject);
			}
		}
	}

	public void RebuildMenu()
	{
		ResetMenu();
		CreateButtons(objects.sandboxTools, "SANDBOX TOOLS :^)");
		if (MapInfoBase.InstanceAnyType.sandboxTools)
		{
			CreateButtons(objects.sandboxObjects, "SANDBOX");
			CreateButtons(objects.specialSandbox, "SPECIAL");
		}
		CreateButtons(objects.enemies, "ENEMIES");
		CreateButtons(objects.objects, "ITEMS");
		CreateButtons(objects.unlockables, "UNLOCKABLES");
		sectionReference.gameObject.SetActive(value: false);
	}

	private Sprite ResolveSprite(SpawnableObject target)
	{
		if (!string.IsNullOrEmpty(target.iconKey) && spriteIcons.ContainsKey(target.iconKey))
		{
			return spriteIcons[target.iconKey];
		}
		if (target.gridIcon != null)
		{
			return target.gridIcon;
		}
		return MonoSingleton<IconManager>.Instance.CurrentIcons.genericSandboxToolIcon;
	}

	private void CreateButtons(SpawnableObject[] list, string sectionName)
	{
		SpawnMenuSectionReference spawnMenuSectionReference = UnityEngine.Object.Instantiate(sectionReference, sectionReference.transform.parent);
		spawnMenuSectionReference.gameObject.SetActive(value: true);
		spawnMenuSectionReference.sectionName.text = sectionName;
		for (int i = 0; i < list.Length; i++)
		{
			if (list[i] == null || (list[i].sandboxOnly && !MapInfoBase.InstanceAnyType.sandboxTools))
			{
				continue;
			}
			bool flag = list != objects.enemies || MonoSingleton<BestiaryData>.Instance.GetEnemy(list[i].enemyType) >= 1;
			if (list[i].spawnableObjectType == SpawnableObject.SpawnableObjectDataType.Unlockable)
			{
				UnlockableType unlockableType = list[i].unlockableType;
				if (!MonoSingleton<UnlockablesData>.Instance.IsUnlocked(unlockableType))
				{
					flag = false;
				}
			}
			if (OverwriteUnlocks.Enabled)
			{
				flag = true;
			}
			if (flag)
			{
				spawnMenuSectionReference.buttonBackgroundImage.color = list[i].backgroundColor;
				spawnMenuSectionReference.buttonForegroundImage.sprite = ResolveSprite(list[i]);
			}
			else
			{
				spawnMenuSectionReference.buttonBackgroundImage.color = Color.gray;
				spawnMenuSectionReference.buttonForegroundImage.sprite = lockedIcon;
			}
			Button button = UnityEngine.Object.Instantiate(spawnMenuSectionReference.button, spawnMenuSectionReference.grid.transform, worldPositionStays: false);
			SpawnableObject spawnableObj = list[i];
			if (flag)
			{
				button.onClick.AddListener(delegate
				{
					SelectObject(spawnableObj);
				});
			}
		}
		spawnMenuSectionReference.button.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<OptionsManager>.Instance.UnFreeze();
		}
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		GameStateManager.Instance.RegisterState(new GameState("sandbox-spawn-menu", base.gameObject)
		{
			cursorLock = LockMode.Unlock,
			playerInputLock = LockMode.Lock,
			cameraInputLock = LockMode.Lock
		});
	}

	private void SelectObject(SpawnableObject obj)
	{
		armManager.SelectArm(obj);
	}
}



public class SpawnMenuSectionReference : MonoBehaviour
{
	public TMP_Text sectionName;

	public GameObject grid;

	public Button button;

	public Image buttonBackgroundImage;

	public Image buttonForegroundImage;
}



public class Speaker : MonoBehaviour
{
	public AudioClip[] sounds;

	private void Start()
	{
		AudioSource component = GetComponent<AudioSource>();
		component.clip = sounds[Random.Range(0, sounds.Length)];
		component.Play();
		component.time = Random.Range(0f, component.clip.length);
	}
}



public class SpeedKillChallenge : MonoBehaviour
{
	public float timeLeft;

	private EnemyIdentifier eid;

	private void Start()
	{
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Update()
	{
		if (timeLeft > 0f)
		{
			if (eid.dead)
			{
				MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
			}
			else
			{
				timeLeft = Mathf.MoveTowards(timeLeft, 0f, Time.deltaTime);
			}
		}
		else
		{
			Object.Destroy(this);
		}
	}
}



public class Speedometer : MonoBehaviour
{
	public TextMeshProUGUI textMesh;

	public Vector3 lastPos;

	public bool classicVersion;

	private TimeSince lastUpdate;

	public RectTransform rect;

	private int type;

	private void Awake()
	{
		PrefsManager instance = MonoSingleton<PrefsManager>.Instance;
		instance.prefChanged = (Action<string, object>)Delegate.Combine(instance.prefChanged, new Action<string, object>(OnPrefChanged));
	}

	private void OnEnable()
	{
		type = MonoSingleton<PrefsManager>.Instance.GetInt("speedometer");
		base.gameObject.SetActive(type > 0);
	}

	private void OnDestroy()
	{
		if ((bool)MonoSingleton<PrefsManager>.Instance)
		{
			PrefsManager instance = MonoSingleton<PrefsManager>.Instance;
			instance.prefChanged = (Action<string, object>)Delegate.Remove(instance.prefChanged, new Action<string, object>(OnPrefChanged));
		}
	}

	private void OnPrefChanged(string id, object value)
	{
		if (id == "speedometer" && value is int num)
		{
			base.gameObject.SetActive(num > 0);
			type = num;
		}
	}

	private void FixedUpdate()
	{
		float num = 0f;
		string arg = "";
		switch (type)
		{
		case 0:
			return;
		case 1:
			num = MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity(trueVelocity: true).magnitude;
			arg = "u";
			break;
		case 2:
			num = Vector3.ProjectOnPlane(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity(trueVelocity: true), Vector3.up).magnitude;
			arg = "hu";
			break;
		case 3:
			num = Mathf.Abs(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity(trueVelocity: true).y);
			arg = "vu";
			break;
		}
		if ((float)lastUpdate > 0.064f)
		{
			if (classicVersion)
			{
				textMesh.text = $"{num:0}";
			}
			else
			{
				textMesh.text = $"SPEED: {num:0.00} {arg}/s";
			}
			lastUpdate = 0f;
		}
	}
}



public class SpeedWeed : MonoBehaviour
{
	private Vector3 lastPosition;

	private float lastSpeed;

	private TimeSince timeSinceLastSpeedChange;

	private void FixedUpdate()
	{
		float num = (base.transform.position - lastPosition).magnitude / Time.deltaTime;
		lastPosition = base.transform.position;
		if (!(Math.Abs(num - lastSpeed) < 0.1f))
		{
			TimeSince timeSince = timeSinceLastSpeedChange;
			timeSinceLastSpeedChange = 0f;
			lastSpeed = num;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Speed: ");
			stringBuilder.Append(num);
			if ((float)timeSince > 1f)
			{
				stringBuilder.Append(" (changed after ");
				stringBuilder.Append(timeSince);
				stringBuilder.Append("s)");
			}
		}
	}
}



public class SphereForce : MonoBehaviour
{
	public float strength = 10f;

	private void OnTriggerStay(Collider other)
	{
		Rigidbody attachedRigidbody = other.attachedRigidbody;
		if (!(attachedRigidbody == null))
		{
			Vector3 vector = base.transform.position - attachedRigidbody.position;
			float magnitude = vector.magnitude;
			vector = vector.normalized / magnitude;
			other.attachedRigidbody.AddForce(vector * strength, ForceMode.Force);
		}
	}
}



public class SpiderBody : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	private NavMeshAgent nma;

	private Quaternion followPlayerRot;

	public GameObject proj;

	private RaycastHit hit2;

	public LayerMask aimlm;

	private bool readyToShoot = true;

	private float burstCharge = 5f;

	private int maxBurst;

	private int currentBurst;

	public float health;

	public bool stationary;

	private Rigidbody rb;

	private bool falling;

	private Enemy enemy;

	private Transform firstChild;

	private CharacterJoint[] cjs;

	private CharacterJoint cj;

	public GameObject impactParticle;

	public GameObject impactSprite;

	private Quaternion spriteRot;

	private Vector3 spritePos;

	public Transform mouth;

	private GameObject currentProj;

	private bool charging;

	public GameObject chargeEffect;

	[HideInInspector]
	public GameObject currentCE;

	private float beamCharge;

	private AudioSource ceAud;

	private Light ceLight;

	private Vector3 predictedPlayerPos;

	public GameObject spiderBeam;

	private GameObject currentBeam;

	public AssetReference beamExplosion;

	private GameObject currentExplosion;

	private float beamProbability;

	private Quaternion predictedRot;

	private bool rotating;

	public GameObject dripBlood;

	private GameObject currentDrip;

	public AudioClip hurtSound;

	private StyleCalculator scalc;

	private EnemyIdentifier eid;

	public GameObject spark;

	private int difficulty;

	private float coolDownMultiplier = 1f;

	private int beamsAmount = 1;

	private float maxHealth;

	public GameObject enrageEffect;

	[HideInInspector]
	public GameObject currentEnrageEffect;

	private Material origMaterial;

	public Material woundedMaterial;

	public Material woundedEnrageMaterial;

	public GameObject woundedParticle;

	private bool parryable;

	private MusicManager muman;

	private bool requestedMusic;

	private GoreZone gz;

	[SerializeField]
	private Transform headModel;

	public GameObject breakParticle;

	private bool corpseBroken;

	public AssetReference shockwave;

	private EnemySimplifier[] ensims;

	public Renderer mainMesh;

	public float targetHeight = 1f;

	private float defaultHeight;

	[SerializeField]
	private Collider headCollider;

	private List<EnemyIdentifier> fallEnemiesHit = new List<EnemyIdentifier>();

	private int parryFramesLeft;

	private EnemyTarget target => eid.target;

	public string alterKey => "spider";

	public string alterCategoryName => "malicious face";

	public AlterOption<bool>[] options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			value = isEnraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		}
	};

	public bool isEnraged { get; private set; }

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		nma = GetComponent<NavMeshAgent>();
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Start()
	{
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		maxHealth = health;
		if (difficulty >= 3)
		{
			coolDownMultiplier = 1.25f;
		}
		else if (difficulty == 1)
		{
			coolDownMultiplier = 0.75f;
		}
		else if (difficulty == 0)
		{
			coolDownMultiplier = 0.5f;
		}
		if (difficulty >= 4)
		{
			maxBurst = 10;
		}
		else if (difficulty >= 2)
		{
			maxBurst = 5;
		}
		else
		{
			maxBurst = 2;
		}
		if (!mainMesh)
		{
			mainMesh = GetComponentInChildren<SkinnedMeshRenderer>();
		}
		origMaterial = mainMesh.material;
		gz = GoreZone.ResolveGoreZone(base.transform.parent ? base.transform.parent : base.transform);
		if ((bool)nma)
		{
			nma.updateRotation = false;
			if (stationary)
			{
				nma.speed = 0f;
			}
		}
		if ((bool)currentCE)
		{
			Object.Destroy(currentCE);
		}
		defaultHeight = targetHeight;
	}

	private void OnDisable()
	{
		if (!eid.dead)
		{
			requestedMusic = false;
			if (muman == null)
			{
				muman = MonoSingleton<MusicManager>.Instance;
			}
			if ((bool)muman)
			{
				muman.PlayCleanMusic();
			}
		}
	}

	private void Update()
	{
		if (target == null)
		{
			return;
		}
		followPlayerRot = Quaternion.LookRotation((target.headPosition - base.transform.position).normalized);
		if (eid.dead)
		{
			return;
		}
		if (beamCharge < 1f)
		{
			headModel.transform.rotation = Quaternion.RotateTowards(headModel.transform.rotation, followPlayerRot, (Quaternion.Angle(headModel.transform.rotation, followPlayerRot) + 10f) * Time.deltaTime * 15f * eid.totalSpeedModifier);
		}
		else if (rotating && beamCharge == 1f)
		{
			headModel.transform.rotation = Quaternion.RotateTowards(headModel.transform.rotation, predictedRot, Quaternion.Angle(headModel.transform.rotation, predictedRot) * Time.deltaTime * 20f * eid.totalSpeedModifier);
		}
		else if (!rotating && beamCharge == 1f)
		{
			predictedRot = Quaternion.LookRotation(target.position - base.transform.position);
			headModel.transform.rotation = Quaternion.RotateTowards(headModel.transform.rotation, predictedRot, (Quaternion.Angle(headModel.transform.rotation, predictedRot) + 10f) * Time.deltaTime * 10f * eid.totalSpeedModifier);
		}
		if (difficulty > 2 && currentEnrageEffect == null && health < maxHealth / 2f)
		{
			Enrage();
		}
		if (!requestedMusic)
		{
			requestedMusic = true;
			muman = MonoSingleton<MusicManager>.Instance;
			muman.PlayBattleMusic();
		}
		if (!charging && beamCharge == 0f)
		{
			if (nma != null && !nma.enabled && !stationary)
			{
				nma.enabled = true;
				if (nma.isOnNavMesh)
				{
					nma.isStopped = false;
				}
				nma.speed = 3.5f * eid.totalSpeedModifier;
			}
			if (nma != null && nma.isOnNavMesh && !stationary)
			{
				if ((bool)eid.buffTargeter)
				{
					nma.SetDestination(eid.buffTargeter.transform.position);
					if (Vector3.Distance(base.transform.position, eid.buffTargeter.transform.position) < 15f)
					{
						targetHeight = 0.35f;
					}
					else
					{
						targetHeight = defaultHeight;
					}
				}
				else
				{
					nma.SetDestination(target.position);
					targetHeight = defaultHeight;
				}
				nma.baseOffset = Mathf.MoveTowards(nma.baseOffset, targetHeight, Time.deltaTime * defaultHeight / 2f * eid.totalSpeedModifier);
			}
			if (currentBurst > maxBurst && burstCharge == 0f)
			{
				currentBurst = 0;
				if (difficulty > 0)
				{
					burstCharge = 5f;
				}
				else
				{
					burstCharge = 10f;
				}
			}
			if (burstCharge > 0f)
			{
				burstCharge = Mathf.MoveTowards(burstCharge, 0f, Time.deltaTime * coolDownMultiplier * 5f * eid.totalSpeedModifier);
			}
			if (burstCharge < 0f)
			{
				burstCharge = 0f;
			}
			if (!readyToShoot || burstCharge != 0f || (!(Quaternion.Angle(headModel.rotation, followPlayerRot) < 1f) && !(Vector3.Distance(base.transform.position, target.position) < 10f)) || Physics.Raycast(base.transform.position, target.position - base.transform.position, out var _, Vector3.Distance(base.transform.position, target.position), aimlm))
			{
				return;
			}
			if (currentBurst != 0)
			{
				ShootProj();
			}
			else if ((Random.Range(0f, health * 0.4f) >= beamProbability && beamProbability <= 5f) || (Vector3.Distance(base.transform.position, target.position) > 50f && !MonoSingleton<NewMovement>.Instance.ridingRocket))
			{
				ShootProj();
				beamProbability += 1f;
			}
			else if (!eid.buffTargeter || Vector3.Distance(base.transform.position, eid.buffTargeter.transform.position) > 15f)
			{
				ChargeBeam();
				if (difficulty > 2 && health < maxHealth / 2f)
				{
					beamsAmount = 2;
				}
				if (health > 10f)
				{
					beamProbability = 0f;
				}
				else
				{
					beamProbability = 1f;
				}
			}
		}
		else
		{
			if (!charging)
			{
				return;
			}
			if (beamCharge + 0.5f * coolDownMultiplier * Time.deltaTime * eid.totalSpeedModifier < 1f)
			{
				nma.speed = 0f;
				if (nma.isOnNavMesh)
				{
					nma.SetDestination(base.transform.position);
					nma.isStopped = true;
				}
				float num = 1f;
				if (difficulty >= 4)
				{
					num = 1.5f;
				}
				beamCharge += 0.5f * coolDownMultiplier * num * Time.deltaTime * eid.totalSpeedModifier;
				currentCE.transform.localScale = Vector3.one * beamCharge * 2.5f;
				ceAud.pitch = beamCharge * 2f;
				ceLight.intensity = beamCharge * 30f;
			}
			else
			{
				beamCharge = 1f;
				charging = false;
				BeamChargeEnd();
			}
		}
	}

	private void FixedUpdate()
	{
		if (parryFramesLeft > 0)
		{
			parryFramesLeft--;
		}
	}

	public void GetHurt(GameObject target, Vector3 force, Vector3 hitPoint, float multiplier, GameObject sourceWeapon = null)
	{
		bool dead = false;
		float num = health;
		bool flag = true;
		if (hitPoint == Vector3.zero)
		{
			hitPoint = target.transform.position;
		}
		flag = MonoSingleton<BloodsplatterManager>.Instance.goreOn;
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (eid.hitter != "fire")
		{
			if (!eid.sandified && !eid.blessed)
			{
				GameObject gameObject = Object.Instantiate(MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Small, eid), hitPoint, Quaternion.identity);
				if ((bool)gameObject)
				{
					gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
					if (eid.hitter == "drill")
					{
						gameObject.transform.localScale *= 2f;
					}
					if (health > 0f)
					{
						gameObject.GetComponent<Bloodsplatter>().GetReady();
					}
					if (multiplier >= 1f)
					{
						gameObject.GetComponent<Bloodsplatter>().hpAmount = 30;
					}
					if (flag)
					{
						gameObject.GetComponent<ParticleSystem>().Play();
					}
				}
				if (eid.hitter != "shotgun" && eid.hitter != "drill" && base.gameObject.activeInHierarchy)
				{
					if (dripBlood != null)
					{
						currentDrip = Object.Instantiate(dripBlood, hitPoint, Quaternion.identity);
					}
					if ((bool)currentDrip)
					{
						currentDrip.transform.parent = base.transform;
						currentDrip.transform.LookAt(base.transform);
						currentDrip.transform.Rotate(180f, 180f, 180f);
						if (flag)
						{
							currentDrip.GetComponent<ParticleSystem>().Play();
						}
					}
				}
			}
			else
			{
				Object.Instantiate(MonoSingleton<BloodsplatterManager>.Instance.GetGore(GoreType.Small, eid), hitPoint, Quaternion.identity);
			}
		}
		if (!eid.dead)
		{
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= 1f * multiplier;
			}
			if (scalc == null)
			{
				scalc = MonoSingleton<StyleCalculator>.Instance;
			}
			if (health <= 0f)
			{
				dead = true;
			}
			if (((eid.hitter == "shotgunzone" || eid.hitter == "hammerzone") && parryable) || eid.hitter == "punch")
			{
				if (parryable)
				{
					parryable = false;
					MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: false, eid);
					currentExplosion = Object.Instantiate(beamExplosion.ToAsset(), base.transform.position, Quaternion.identity);
					if (!InvincibleEnemies.Enabled && !eid.blessed)
					{
						health -= (float)((parryFramesLeft > 0) ? 4 : 5) / eid.totalHealthModifier;
					}
					Explosion[] componentsInChildren = currentExplosion.GetComponentsInChildren<Explosion>();
					foreach (Explosion obj in componentsInChildren)
					{
						obj.speed *= eid.totalDamageModifier;
						obj.maxSize *= 1.75f * eid.totalDamageModifier;
						obj.damage = Mathf.RoundToInt(50f * eid.totalDamageModifier);
						obj.canHit = AffectedSubjects.EnemiesOnly;
						obj.friendlyFire = true;
					}
					if (currentEnrageEffect == null)
					{
						CancelInvoke("BeamFire");
						Invoke("StopWaiting", 1f);
						Object.Destroy(currentCE);
					}
					parryFramesLeft = 0;
				}
				else
				{
					parryFramesLeft = MonoSingleton<FistControl>.Instance.currentPunch.activeFrames;
				}
			}
			if (multiplier != 0f)
			{
				scalc.HitCalculator(eid.hitter, "spider", "", dead, eid, sourceWeapon);
			}
			if (num >= maxHealth / 2f && health < maxHealth / 2f)
			{
				if (ensims == null || ensims.Length == 0)
				{
					ensims = GetComponentsInChildren<EnemySimplifier>();
				}
				Object.Instantiate(woundedParticle, base.transform.position, Quaternion.identity);
				if (!eid.puppet)
				{
					EnemySimplifier[] array = ensims;
					foreach (EnemySimplifier enemySimplifier in array)
					{
						if (!enemySimplifier.ignoreCustomColor)
						{
							enemySimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, woundedMaterial);
							enemySimplifier.ChangeMaterialNew(EnemySimplifier.MaterialState.enraged, woundedEnrageMaterial);
						}
					}
				}
			}
			if ((bool)hurtSound && num > 0f)
			{
				hurtSound.PlayClipAtPoint(MonoSingleton<AudioMixerController>.Instance.goreGroup, base.transform.position, 12, 1f, 0.75f, Random.Range(0.85f, 1.35f));
			}
			if (health <= 0f && !eid.dead)
			{
				Die();
			}
		}
		else if (eid.hitter == "ground slam")
		{
			BreakCorpse();
		}
	}

	public void Die()
	{
		rb = GetComponentInChildren<Rigidbody>();
		DoubleRender[] componentsInChildren = GetComponentsInChildren<DoubleRender>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].RemoveEffect();
		}
		falling = true;
		parryable = false;
		rb.isKinematic = false;
		rb.useGravity = true;
		if (health > 0f)
		{
			health = 0f;
		}
		base.gameObject.layer = 11;
		ResolveStuckness();
		for (int j = 1; j < base.transform.parent.childCount - 1; j++)
		{
			Object.Destroy(base.transform.parent.GetChild(j).gameObject);
		}
		if (currentCE != null)
		{
			Object.Destroy(currentCE);
		}
		Object.Destroy(nma);
		if (!eid.dontCountAsKills)
		{
			if (gz != null && gz.checkpoint != null)
			{
				gz.AddDeath();
				gz.checkpoint.sm.kills++;
			}
			else
			{
				MonoSingleton<StatsManager>.Instance.kills++;
			}
			ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
			if (componentInParent != null)
			{
				componentInParent.AddDeadEnemy();
			}
		}
		if (muman == null)
		{
			muman = MonoSingleton<MusicManager>.Instance;
		}
		muman.PlayCleanMusic();
		EnemySimplifier[] array;
		if (currentEnrageEffect != null)
		{
			mainMesh.material = origMaterial;
			MeshRenderer[] componentsInChildren2 = GetComponentsInChildren<MeshRenderer>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].material = origMaterial;
			}
			array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = false;
			}
			Object.Destroy(currentEnrageEffect);
		}
		if (ensims == null)
		{
			ensims = GetComponentsInChildren<EnemySimplifier>();
		}
		array = ensims;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Begone();
		}
		if (eid.hitter == "ground slam" || eid.hitter == "breaker")
		{
			BreakCorpse();
		}
	}

	private void ShootProj()
	{
		if (target == null)
		{
			return;
		}
		currentProj = Object.Instantiate(proj, mouth.position, headModel.transform.rotation);
		currentProj.transform.rotation = Quaternion.LookRotation(target.headPosition - mouth.position);
		if (difficulty >= 4)
		{
			switch (currentBurst % 5)
			{
			case 1:
				currentProj.transform.LookAt(target.headPosition + base.transform.right * (1 + currentBurst / 5 * 2));
				break;
			case 2:
				currentProj.transform.LookAt(target.headPosition + base.transform.up * (1 + currentBurst / 5 * 2));
				break;
			case 3:
				currentProj.transform.LookAt(target.headPosition - base.transform.right * (1 + currentBurst / 5 * 2));
				break;
			case 4:
				currentProj.transform.LookAt(target.headPosition - base.transform.up * (1 + currentBurst / 5 * 2));
				break;
			}
		}
		currentBurst++;
		Projectile component = currentProj.GetComponent<Projectile>();
		component.safeEnemyType = EnemyType.MaliciousFace;
		component.target = eid.target;
		if (difficulty > 2)
		{
			component.speed *= 1.25f;
		}
		else if (difficulty == 1)
		{
			component.speed *= 0.75f;
		}
		else if (difficulty == 0)
		{
			component.speed *= 0.5f;
		}
		component.damage *= eid.totalDamageModifier;
		readyToShoot = false;
		if (difficulty >= 4)
		{
			Invoke("ReadyToShoot", 0.05f / eid.totalSpeedModifier);
		}
		else if (difficulty > 0)
		{
			Invoke("ReadyToShoot", 0.1f / eid.totalSpeedModifier);
		}
		else
		{
			Invoke("ReadyToShoot", 0.2f / eid.totalSpeedModifier);
		}
	}

	private void ChargeBeam()
	{
		charging = true;
		currentCE = Object.Instantiate(chargeEffect, mouth);
		currentCE.transform.localScale = Vector3.zero;
		ceAud = currentCE.GetComponent<AudioSource>();
		ceLight = currentCE.GetComponent<Light>();
	}

	private void BeamChargeEnd()
	{
		if (beamsAmount <= 1 && (bool)ceAud)
		{
			ceAud.Stop();
		}
		if (target != null)
		{
			Vector3 velocity = target.GetVelocity();
			Vector3 vector = new Vector3(velocity.x, velocity.y / (float)((eid.target.isPlayer && (bool)MonoSingleton<NewMovement>.Instance.ridingRocket) ? 1 : 2), velocity.z);
			predictedPlayerPos = ((eid.target.isPlayer && (bool)MonoSingleton<NewMovement>.Instance.ridingRocket) ? MonoSingleton<NewMovement>.Instance.ridingRocket.transform.position : target.position) + vector / 2f / eid.totalSpeedModifier;
			if (velocity.magnitude > 1f && headCollider.Raycast(new Ray(target.position, velocity.normalized), out var hitInfo, velocity.magnitude * 0.5f / eid.totalSpeedModifier))
			{
				predictedPlayerPos = target.position;
			}
			else if (Physics.Raycast(target.position, predictedPlayerPos - target.position, out hitInfo, Vector3.Distance(predictedPlayerPos, target.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Collide))
			{
				predictedPlayerPos = hitInfo.point;
			}
			if ((bool)nma)
			{
				nma.enabled = false;
			}
			predictedRot = Quaternion.LookRotation(predictedPlayerPos - base.transform.position);
			rotating = true;
			Object.Instantiate(spark, mouth.position, mouth.rotation).transform.LookAt(predictedPlayerPos);
			if (difficulty > 1)
			{
				Invoke("BeamFire", 0.5f / eid.totalSpeedModifier);
			}
			else if (difficulty == 1)
			{
				Invoke("BeamFire", 0.75f / eid.totalSpeedModifier);
			}
			else
			{
				Invoke("BeamFire", 1f / eid.totalSpeedModifier);
			}
			parryable = true;
			if (parryFramesLeft > 0)
			{
				eid.hitter = "punch";
				eid.DeliverDamage(base.gameObject, MonoSingleton<CameraController>.Instance.transform.forward * 25000f, base.transform.position, 1f, tryForExplode: false);
			}
		}
	}

	private void BeamFire()
	{
		parryable = false;
		if (!eid.dead)
		{
			currentBeam = Object.Instantiate(spiderBeam, mouth.position, mouth.rotation);
			rotating = false;
			if (eid.totalDamageModifier != 1f && currentBeam.TryGetComponent<RevolverBeam>(out var component))
			{
				component.damage *= eid.totalDamageModifier;
			}
			if (beamsAmount > 1)
			{
				beamsAmount--;
				ceAud.pitch = 4f;
				ceAud.volume = 1f;
				Invoke("BeamChargeEnd", 0.5f / eid.totalSpeedModifier);
			}
			else
			{
				Object.Destroy(currentCE);
				Invoke("StopWaiting", 1f / eid.totalSpeedModifier);
			}
		}
	}

	private void StopWaiting()
	{
		if (!eid.dead)
		{
			beamCharge = 0f;
		}
	}

	private void ReadyToShoot()
	{
		readyToShoot = true;
	}

	public void TriggerHit(Collider other)
	{
		if (!falling)
		{
			return;
		}
		EnemyIdentifier enemyIdentifier = other.gameObject.GetComponent<EnemyIdentifier>();
		if (enemyIdentifier == null)
		{
			EnemyIdentifierIdentifier component = other.gameObject.GetComponent<EnemyIdentifierIdentifier>();
			if (component != null && component.eid != null)
			{
				enemyIdentifier = component.eid;
			}
		}
		if (enemyIdentifier == null && other.gameObject.TryGetComponent<IdolMauricer>(out var _))
		{
			enemyIdentifier = other.gameObject.GetComponentInParent<EnemyIdentifier>();
		}
		if ((bool)enemyIdentifier && enemyIdentifier != eid && !fallEnemiesHit.Contains(enemyIdentifier))
		{
			FallKillEnemy(enemyIdentifier);
		}
	}

	private void FallKillEnemy(EnemyIdentifier targetEid)
	{
		if ((bool)MonoSingleton<StyleHUD>.Instance && !targetEid.dead)
		{
			MonoSingleton<StyleHUD>.Instance.AddPoints(80, "ultrakill.mauriced", null, eid);
		}
		targetEid.hitter = "maurice";
		fallEnemiesHit.Add(targetEid);
		if (targetEid.TryGetComponent<Collider>(out var component))
		{
			Physics.IgnoreCollision(headCollider, component, ignore: true);
		}
		EnemyIdentifier.FallOnEnemy(targetEid);
	}

	private void OnCollisionEnter(Collision other)
	{
		if (!falling)
		{
			return;
		}
		if (other.gameObject.CompareTag("Moving"))
		{
			BreakCorpse();
			MonoSingleton<CameraController>.Instance.CameraShake(2f);
		}
		else
		{
			if (other.gameObject.layer != 8 && other.gameObject.layer != 24)
			{
				return;
			}
			Breakable component3;
			if (other.gameObject.CompareTag("Floor"))
			{
				rb.isKinematic = true;
				rb.useGravity = false;
				Transform transform = base.transform;
				Object.Instantiate(impactParticle, transform.position, transform.rotation);
				spriteRot.eulerAngles = new Vector3(other.contacts[0].normal.x + 90f, other.contacts[0].normal.y, other.contacts[0].normal.z);
				spritePos = new Vector3(other.contacts[0].point.x, other.contacts[0].point.y + 0.1f, other.contacts[0].point.z);
				AudioSource componentInChildren = Object.Instantiate(shockwave.ToAsset(), spritePos, Quaternion.identity).GetComponentInChildren<AudioSource>();
				if ((bool)componentInChildren)
				{
					Object.Destroy(componentInChildren);
				}
				Object.Instantiate(impactSprite, spritePos, spriteRot).transform.SetParent(gz.goreZone, worldPositionStays: true);
				Transform transform2 = base.transform;
				transform2.position -= transform2.up * 1.5f;
				falling = false;
				if (TryGetComponent<SphereCollider>(out var component))
				{
					Object.Destroy(component);
				}
				SpiderBodyTrigger componentInChildren2 = base.transform.parent.GetComponentInChildren<SpiderBodyTrigger>(includeInactive: true);
				if ((bool)componentInChildren2)
				{
					Object.Destroy(componentInChildren2.gameObject);
				}
				rb.GetComponent<NavMeshObstacle>().enabled = true;
				MonoSingleton<CameraController>.Instance.CameraShake(2f);
				if (fallEnemiesHit.Count <= 0)
				{
					return;
				}
				foreach (EnemyIdentifier item in fallEnemiesHit)
				{
					if (item != null && !item.dead && item.TryGetComponent<Collider>(out var component2))
					{
						Physics.IgnoreCollision(headCollider, component2, ignore: false);
					}
				}
				fallEnemiesHit.Clear();
			}
			else if (other.gameObject.TryGetComponent<Breakable>(out component3) && !component3.playerOnly)
			{
				component3.Break();
			}
		}
	}

	public void BreakCorpse()
	{
		if (!corpseBroken)
		{
			corpseBroken = true;
			if (breakParticle != null)
			{
				Transform transform = base.transform;
				Object.Instantiate(breakParticle, transform.position, transform.rotation).transform.SetParent(gz.gibZone);
			}
			Object.Destroy(base.gameObject);
		}
	}

	private void ResolveStuckness()
	{
		Collider[] array = Physics.OverlapSphere(base.transform.position, 2f, LayerMaskDefaults.Get(LMD.Environment));
		if (array != null && array.Length != 0)
		{
			SphereCollider component = GetComponent<SphereCollider>();
			Collider[] array2 = array;
			foreach (Collider collider in array2)
			{
				Physics.ComputePenetration(component, base.transform.position, base.transform.rotation, collider, collider.transform.position, collider.transform.rotation, out var direction, out var distance);
				base.transform.position = base.transform.position + direction * (distance + 0.5f);
			}
		}
		array = Physics.OverlapSphere(base.transform.position, 2f, LayerMaskDefaults.Get(LMD.Environment));
		if (array != null && array.Length != 0)
		{
			BreakCorpse();
		}
	}

	public void Enrage()
	{
		if (!eid.dead && !isEnraged)
		{
			isEnraged = true;
			if (ensims == null || ensims.Length == 0)
			{
				ensims = GetComponentsInChildren<EnemySimplifier>();
			}
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = true;
			}
			currentEnrageEffect = Object.Instantiate(enrageEffect, base.transform);
			currentEnrageEffect.transform.localScale = Vector3.one * 0.2f;
		}
	}

	public void UnEnrage()
	{
		if (!eid.dead && isEnraged)
		{
			isEnraged = false;
			if (ensims == null || ensims.Length == 0)
			{
				ensims = GetComponentsInChildren<EnemySimplifier>();
			}
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = false;
			}
			if (currentEnrageEffect != null)
			{
				Object.Destroy(currentEnrageEffect);
			}
		}
	}
}



public class SpiderBodyTrigger : MonoBehaviour
{
	private SpiderBody spbody;

	private void Start()
	{
		spbody = base.transform.parent.GetComponentInChildren<SpiderBody>(includeInactive: true);
		UpdatePosition();
	}

	private void Update()
	{
		UpdatePosition();
	}

	private void UpdatePosition()
	{
		if (spbody != null)
		{
			base.transform.SetPositionAndRotation(spbody.transform.position, spbody.transform.rotation);
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 12)
		{
			if (!spbody)
			{
				spbody = base.transform.parent.GetComponentInChildren<SpiderBody>();
			}
			if ((bool)spbody)
			{
				spbody.TriggerHit(other);
			}
		}
	}
}



public class SpiderLeg : MonoBehaviour
{
	public Vector3 target;

	private void Start()
	{
		target = base.transform.position;
	}

	private void Update()
	{
		if (base.transform.position != target)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, target, Time.deltaTime * 10f);
		}
	}
}



public class SpiderLegLines : MonoBehaviour
{
	private GameObject body;

	public GameObject legEnd;

	private LineRenderer lr;

	private void Start()
	{
		body = base.transform.parent.GetChild(0).gameObject;
		lr = GetComponent<LineRenderer>();
	}

	private void Update()
	{
		lr.SetPosition(0, body.transform.position);
		lr.SetPosition(1, base.transform.position);
		lr.SetPosition(2, legEnd.transform.position);
	}
}



public class SpiderLegPos : MonoBehaviour
{
	public GameObject childLeg;

	public SpiderLeg sl;

	private bool movingLeg;

	private RaycastHit hit;

	public bool backLeg;

	private void Start()
	{
		MoveLeg();
	}

	private void Update()
	{
		if (movingLeg)
		{
			childLeg.transform.position = Vector3.MoveTowards(childLeg.transform.position, base.transform.position, Time.deltaTime * (20f * Vector3.Distance(base.transform.position, childLeg.transform.position) + 0.1f));
			if (childLeg.transform.position == base.transform.position)
			{
				movingLeg = false;
			}
		}
		else if (Vector3.Distance(base.transform.position, childLeg.transform.position) > 3f)
		{
			MoveLeg();
		}
	}

	private void MoveLeg()
	{
		bool flag = false;
		if (!backLeg)
		{
			if (Physics.Raycast(base.transform.position, base.transform.up * -1f + (base.transform.forward + base.transform.right * -1f) * Random.Range(-1f, 2f), out hit, 35f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				flag = true;
			}
		}
		else if (Physics.Raycast(base.transform.position, base.transform.up * -1f + (base.transform.forward + base.transform.right) * -1f * Random.Range(-1f, 2f), out hit, 35f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			flag = true;
		}
		if (flag && hit.transform != null)
		{
			sl.target = hit.point;
			movingLeg = true;
		}
	}
}



public class SpiderLegsController : MonoBehaviour
{
	private GameObject spiderBody;

	private Vector3 bodyRotV;

	private Quaternion bodyRotQ;

	private void Start()
	{
		spiderBody = base.transform.parent.GetChild(0).gameObject;
	}

	private void Update()
	{
		bodyRotV = spiderBody.transform.rotation.eulerAngles;
		bodyRotQ.eulerAngles = new Vector3(0f, bodyRotV.y, 0f);
		base.transform.SetPositionAndRotation(spiderBody.transform.position, bodyRotQ);
	}
}



public class SpiderLimbController : MonoBehaviour
{
	private LineRenderer lr;

	private void Start()
	{
	}

	private void Update()
	{
	}
}



public class Spin : MonoBehaviour
{
	public Vector3 spinDirection;

	public float speed;

	public bool inLateUpdate;

	private Vector3 totalRotation;

	public bool notRelative;

	public bool gradual;

	public float gradualSpeed;

	private float currentSpeed;

	public bool off;

	[HideInInspector]
	private AudioSource aud;

	[HideInInspector]
	private float originalPitch;

	[HideInInspector]
	public float pitchMultiplier = 1f;

	[Header("Enemy")]
	public EnemyIdentifier eid;

	private int difficulty;

	public bool difficultyVariance;

	private float difficultySpeedMultiplier = 1f;

	private void Start()
	{
		if ((bool)eid && eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (difficultyVariance)
		{
			if (difficulty == 1)
			{
				difficultySpeedMultiplier = 0.8f;
			}
			else if (difficulty == 0)
			{
				difficultySpeedMultiplier = 0.6f;
			}
		}
		if (gradual)
		{
			aud = GetComponent<AudioSource>();
			if ((bool)aud)
			{
				originalPitch = aud.pitch;
				aud.pitch = currentSpeed;
			}
		}
	}

	private void FixedUpdate()
	{
		if (inLateUpdate)
		{
			return;
		}
		float num = speed * difficultySpeedMultiplier;
		if ((bool)eid)
		{
			num *= eid.totalSpeedModifier;
		}
		if (gradual)
		{
			if (!off && currentSpeed != num)
			{
				currentSpeed = Mathf.MoveTowards(currentSpeed, num, Time.deltaTime * gradualSpeed);
			}
			else if (off && currentSpeed != 0f)
			{
				currentSpeed = Mathf.MoveTowards(currentSpeed, 0f, Time.deltaTime * gradualSpeed);
			}
			if (currentSpeed != 0f)
			{
				if (!notRelative)
				{
					base.transform.Rotate(spinDirection, currentSpeed * Time.deltaTime, Space.Self);
				}
				else
				{
					base.transform.Rotate(spinDirection, currentSpeed * Time.deltaTime, Space.World);
				}
			}
			if ((bool)aud)
			{
				aud.pitch = currentSpeed / num * originalPitch * pitchMultiplier;
			}
		}
		else if (!notRelative)
		{
			base.transform.Rotate(spinDirection, num * Time.deltaTime, Space.Self);
		}
		else
		{
			base.transform.Rotate(spinDirection, num * Time.deltaTime, Space.World);
		}
	}

	private void LateUpdate()
	{
		if (inLateUpdate)
		{
			if (totalRotation == Vector3.zero)
			{
				totalRotation = base.transform.localRotation.eulerAngles;
			}
			float num = speed * difficultySpeedMultiplier;
			if ((bool)eid)
			{
				num *= eid.totalSpeedModifier;
			}
			base.transform.localRotation = Quaternion.Euler(totalRotation);
			base.transform.Rotate(spinDirection, num * Time.deltaTime);
			totalRotation = base.transform.localRotation.eulerAngles;
		}
	}

	public void ChangeState(bool on)
	{
		off = !on;
	}

	public void ChangeSpeed(float newSpeed)
	{
		speed = newSpeed;
	}

	public void ChangeGradualSpeed(float newGradualSpeed)
	{
		gradualSpeed = newGradualSpeed;
	}

	public void ChangePitchMultiplier(float newPitch)
	{
		pitchMultiplier = newPitch;
	}

	public void ChangeSpinDirection(Vector3 newDirection)
	{
		spinDirection = newDirection;
	}
}



public class SpinDirectionChanger : MonoBehaviour
{
	public Spin target;

	public Vector3 direction;

	private void Start()
	{
		target.spinDirection = direction;
	}
}



public class SpinFromForce : MonoBehaviour
{
	public Vector3 rotationAxis = Vector3.up;

	public float angularDrag = 0.01f;

	public float mass = 1f;

	private Vector3 angularVelocity = Vector3.zero;

	private void Update()
	{
		angularVelocity *= 1f - angularDrag;
		Vector3 vector = base.transform.TransformDirection(rotationAxis);
		Quaternion quaternion = Quaternion.AngleAxis(Vector3.Dot(angularVelocity, vector) * Time.deltaTime, vector);
		base.transform.rotation = quaternion * base.transform.rotation;
	}

	public void AddSpin(ref List<ParticleCollisionEvent> pEvents)
	{
		foreach (ParticleCollisionEvent pEvent in pEvents)
		{
			Vector3 vector = Vector3.Cross(pEvent.intersection - base.transform.position, pEvent.velocity);
			angularVelocity += vector / mass;
			angularVelocity = Vector3.Project(angularVelocity, base.transform.TransformDirection(rotationAxis));
		}
	}
}



public class SpinZone : MonoBehaviour
{
	public GameObject spinSound;

	public bool dontSpinEnemies;

	private bool interactedWithItem;

	private void OnDisable()
	{
		interactedWithItem = false;
	}

	private void OnEnable()
	{
		if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
		{
			MonoSingleton<FistControl>.Instance.currentPunch.ForceThrow();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		EnemyIdentifier component2;
		Breakable component3;
		Glass component4;
		if (other.gameObject.layer == 10 || other.gameObject.layer == 11)
		{
			if (other.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && (bool)component.eid && !component.eid.dead)
			{
				SpinEnemy(component.eid);
			}
		}
		else if ((other.gameObject.layer == 12 || other.gameObject.CompareTag("Armor")) && other.TryGetComponent<EnemyIdentifier>(out component2) && !component2.dead)
		{
			SpinEnemy(component2);
		}
		else if (other.TryGetComponent<Breakable>(out component3) && !component3.precisionOnly)
		{
			component3.Break();
		}
		else if (other.TryGetComponent<Glass>(out component4))
		{
			component4.Shatter();
		}
		else
		{
			if (other.gameObject.layer != 22 || interactedWithItem)
			{
				return;
			}
			ItemIdentifier component5 = other.GetComponent<ItemIdentifier>();
			ItemPlaceZone[] components = other.GetComponents<ItemPlaceZone>();
			if ((bool)MonoSingleton<FistControl>.Instance.heldObject && components != null && components.Length != 0)
			{
				interactedWithItem = true;
				MonoSingleton<FistControl>.Instance.heldObject.SendMessage("PutDown", SendMessageOptions.DontRequireReceiver);
				MonoSingleton<FistControl>.Instance.currentPunch.PlaceHeldObject(components, other.transform);
			}
			else if (!MonoSingleton<FistControl>.Instance.heldObject && component5 != null)
			{
				interactedWithItem = true;
				component5.SendMessage("PickUp", SendMessageOptions.DontRequireReceiver);
				MonoSingleton<FistControl>.Instance.currentPunch.ForceHold(component5);
				if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
				{
					MonoSingleton<PlatformerMovement>.Instance.CheckItem();
				}
			}
			else if ((bool)MonoSingleton<FistControl>.Instance.heldObject)
			{
				MonoSingleton<FistControl>.Instance.heldObject.SendMessage("HitWith", other.gameObject, SendMessageOptions.DontRequireReceiver);
			}
		}
	}

	private void SpinEnemy(EnemyIdentifier eid)
	{
		if (eid.blessed)
		{
			return;
		}
		if (dontSpinEnemies)
		{
			eid.Explode();
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.transform.position = eid.transform.position;
		gameObject.transform.SetParent(GoreZone.ResolveGoreZone(eid.transform).gibZone);
		gameObject.gameObject.layer = 1;
		GameObject gameObject2 = Object.Instantiate(eid.gameObject, eid.transform.position, eid.transform.rotation);
		gameObject2.transform.localScale = eid.transform.lossyScale;
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: true);
		eid.gameObject.SetActive(value: false);
		eid.hitter = "spin";
		eid.InstaKill();
		Object.Destroy(eid.gameObject);
		SandboxUtils.StripForPreview(gameObject2.transform);
		Object.Instantiate(spinSound, base.transform.position + (gameObject2.transform.position - base.transform.position).normalized, Quaternion.identity, gameObject2.transform);
		Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
		rigidbody.velocity = (new Vector3(gameObject.transform.position.x, base.transform.position.y, gameObject.transform.position.z) - base.transform.position).normalized * 250f;
		rigidbody.useGravity = false;
		if (gameObject2.TryGetComponent<Collider>(out var component))
		{
			BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
			boxCollider.size = new Vector3(component.bounds.size.x, component.bounds.size.y, component.bounds.size.z);
			boxCollider.isTrigger = true;
			gameObject.AddComponent<SpinZone>().dontSpinEnemies = true;
		}
		gameObject.AddComponent<RemoveOnTime>().time = 3f;
	}
}



public class SplashContinuous : MonoBehaviour
{
	private bool active = true;

	private float cooldown;

	[SerializeField]
	private ParticleSystem particles;

	[SerializeField]
	private GameObject wadingSound;

	[SerializeField]
	private AudioClip[] wadingSounds;

	[SerializeField]
	private float wadingSoundPitch = 0.8f;

	private Vector3 previousPosition;

	[SerializeField]
	private float movingEmissionRate = 20f;

	[SerializeField]
	private float stillEmissionRate = 2f;

	[HideInInspector]
	public NavMeshAgent nma;

	private void FixedUpdate()
	{
		if (!active)
		{
			return;
		}
		ParticleSystem.EmissionModule emission = particles.emission;
		if (((bool)nma && nma.velocity.magnitude > 4f) || Vector3.Distance(base.transform.position, previousPosition) > 0.05f)
		{
			emission.rateOverTime = movingEmissionRate;
			if (cooldown == 0f)
			{
				if (Object.Instantiate(wadingSound, base.transform).TryGetComponent<AudioSource>(out var component))
				{
					component.clip = wadingSounds[Random.Range(0, wadingSounds.Length)];
					component.pitch = Random.Range(wadingSoundPitch - 0.05f, wadingSoundPitch + 0.05f);
					component.Play();
				}
				cooldown = 0.75f;
			}
		}
		else
		{
			emission.rateOverTime = stillEmissionRate;
		}
		cooldown = Mathf.MoveTowards(cooldown, 0f, Time.fixedDeltaTime * (1f + Vector3.Distance(base.transform.position, previousPosition) * 5f));
		previousPosition = base.transform.position;
	}

	public void DestroySoon()
	{
		particles.Stop();
		active = false;
		Invoke("DestroyNow", 2f);
	}

	private void DestroyNow()
	{
		Object.Destroy(base.gameObject);
	}
}



public class SplashingElement : MonoBehaviour
{
	public SplashingElement previousElement;

	private bool _isSplashing;

	private Vector3 _splashPosition;

	public bool isSplashing => _isSplashing;

	public Vector3 splashPosition => _splashPosition;

	public void FixedUpdate()
	{
		if ((bool)previousElement)
		{
			Vector3 position = base.transform.position;
			Vector3 position2 = previousElement.transform.position;
			Ray ray = new Ray(position, position2 - position);
			Ray ray2 = new Ray(position2, position - position2);
			float maxDistance = Vector3.Distance(position2, base.transform.position);
			RaycastHit hitInfo;
			bool flag = Physics.Raycast(ray, out hitInfo, maxDistance, LayerMask.GetMask("Water"));
			if (!flag)
			{
				flag = Physics.Raycast(ray2, out hitInfo, maxDistance, LayerMask.GetMask("Water"));
			}
			_isSplashing = flag;
			if (flag)
			{
				_splashPosition = hitInfo.point;
			}
		}
	}
}



public class SpriteController : MonoBehaviour
{
	public Vector3 randomRotation;

	public bool blinking;

	public float fadeSpeed;

	public float shrinkSpeed;

	private SpriteRenderer spr;

	private float originalAlpha;

	private Vector3 originalScale;

	private void Awake()
	{
		if (randomRotation != Vector3.zero)
		{
			base.transform.Rotate(randomRotation * Random.Range(0, 360));
		}
		spr = GetComponent<SpriteRenderer>();
		originalAlpha = spr.color.a;
		originalScale = base.transform.localScale;
	}

	private void Update()
	{
		if (fadeSpeed != 0f)
		{
			if (blinking)
			{
				if (spr.color.a >= originalAlpha && fadeSpeed < 0f)
				{
					fadeSpeed = Mathf.Abs(fadeSpeed);
				}
				else if (spr.color.a <= 0f && fadeSpeed > 0f)
				{
					fadeSpeed = Mathf.Abs(fadeSpeed) * -1f;
				}
			}
			Color color = spr.color;
			color.a -= fadeSpeed * Time.deltaTime;
			spr.color = color;
		}
		if (shrinkSpeed > 0f)
		{
			base.transform.localScale = base.transform.localScale - Vector3.one * shrinkSpeed * Time.deltaTime;
		}
	}
}



public class SpriteGetVariationColor : MonoBehaviour
{
	[SerializeField]
	private SpriteRenderer[] sprites;

	[SerializeField]
	private int variation;

	private void Update()
	{
		SpriteRenderer[] array = sprites;
		foreach (SpriteRenderer spriteRenderer in array)
		{
			spriteRenderer.color = new Color(MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation].r, MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation].g, MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation].b, spriteRenderer.color.a);
		}
	}
}



public class SpritePoses : MonoBehaviour
{
	public Sprite[] poses;

	private Image img;

	public SpritePoses[] copyChangeTo;

	public void ChangePose(int target)
	{
		if (!img)
		{
			img = GetComponent<Image>();
		}
		if (target < poses.Length)
		{
			img.sprite = poses[target];
		}
		else if (poses.Length != 0)
		{
			img.sprite = poses[0];
		}
		SpritePoses[] array = copyChangeTo;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ChangePose(target);
		}
	}
}



[Serializable]
public class StainVoxel
{
	public readonly Vector3Int VoxelPosition;

	public readonly Vector3 RoundedWorldPosition;

	public readonly int HashCode;

	public VoxelProxy staticProxy;

	public Dictionary<Transform, List<VoxelProxy>> dynamicProxies;

	private readonly Collider[] waterOverlapResult = new Collider[3];

	private const string StaticVoxelName = "VoxelProxy";

	public bool isEmpty
	{
		get
		{
			if (staticProxy == null)
			{
				if (dynamicProxies != null)
				{
					return dynamicProxies.Count == 0;
				}
				return true;
			}
			return false;
		}
	}

	public bool isBurning => HasBurningProxies();

	public StainVoxel(Vector3Int voxelPosition)
	{
		VoxelPosition = voxelPosition;
		HashCode = VoxelPosition.GetHashCode();
		RoundedWorldPosition = StainVoxelManager.VoxelToWorldPosition(voxelPosition);
		staticProxy = null;
		dynamicProxies = null;
	}

	public VoxelProxy CreateOrGetProxyFor(GasolineStain stain)
	{
		if (stain.IsStatic)
		{
			if (staticProxy == null)
			{
				staticProxy = CreateNewProxy(stain, isStatic: true);
			}
			staticProxy.Add(stain);
			return staticProxy;
		}
		if (dynamicProxies == null)
		{
			dynamicProxies = new Dictionary<Transform, List<VoxelProxy>>();
		}
		if (!dynamicProxies.ContainsKey(stain.Parent))
		{
			dynamicProxies[stain.Parent] = new List<VoxelProxy>();
		}
		if (dynamicProxies[stain.Parent].Count == 0)
		{
			VoxelProxy item = CreateNewProxy(stain, isStatic: false);
			dynamicProxies[stain.Parent].Add(item);
		}
		dynamicProxies[stain.Parent][0].Add(stain);
		return dynamicProxies[stain.Parent][0];
	}

	public void AcknowledgeNewStain()
	{
		if (!isBurning)
		{
			return;
		}
		foreach (VoxelProxy item in GetProxies(ProxySearchMode.Any).ToList())
		{
			item.StartBurningOrRefuel();
		}
	}

	public void AddProxy(VoxelProxy existingProxy)
	{
		if (existingProxy.isBurning)
		{
			TryIgnite();
		}
		else if (isBurning)
		{
			existingProxy.StartBurningOrRefuel();
		}
		if (existingProxy.isStatic)
		{
			staticProxy = existingProxy;
		}
		else
		{
			if (dynamicProxies == null)
			{
				dynamicProxies = new Dictionary<Transform, List<VoxelProxy>>();
			}
			if (!dynamicProxies.ContainsKey(existingProxy.parent))
			{
				dynamicProxies[existingProxy.parent] = new List<VoxelProxy>();
			}
			dynamicProxies[existingProxy.parent].Add(existingProxy);
		}
		existingProxy.voxel = this;
	}

	public void RemoveProxy(VoxelProxy proxy, bool destroy = true)
	{
		if (proxy.isStatic)
		{
			if (staticProxy == proxy)
			{
				staticProxy = null;
			}
		}
		else
		{
			if (dynamicProxies == null)
			{
				return;
			}
			if (dynamicProxies.ContainsKey(proxy.parent))
			{
				dynamicProxies[proxy.parent].Remove(proxy);
				if (dynamicProxies[proxy.parent].Count == 0)
				{
					dynamicProxies.Remove(proxy.parent);
				}
			}
			if (dynamicProxies.Count == 0)
			{
				dynamicProxies = null;
			}
		}
		if (destroy)
		{
			proxy.DestroySelf();
		}
		MonoSingleton<StainVoxelManager>.Instance.RefreshVoxel(this);
	}

	public void DestroySelf()
	{
		if (staticProxy != null)
		{
			staticProxy.DestroySelf();
		}
		if (dynamicProxies != null)
		{
			foreach (List<VoxelProxy> value in dynamicProxies.Values)
			{
				foreach (VoxelProxy item in value)
				{
					item.DestroySelf();
				}
			}
		}
		staticProxy = null;
		dynamicProxies = null;
	}

	public IEnumerable<VoxelProxy> GetProxies(ProxySearchMode mode)
	{
		if (mode.HasFlag(ProxySearchMode.IncludeStatic) && staticProxy != null && staticProxy.IsMatch(mode))
		{
			yield return staticProxy;
		}
		if (!mode.HasFlag(ProxySearchMode.IncludeDynamic) || dynamicProxies == null)
		{
			yield break;
		}
		foreach (List<VoxelProxy> value in dynamicProxies.Values)
		{
			foreach (VoxelProxy item in value)
			{
				if (item.IsMatch(mode))
				{
					yield return item;
				}
			}
		}
	}

	public bool HasFloorStains()
	{
		return GetProxies(ProxySearchMode.FloorOnly).Any();
	}

	public bool HasBurningProxies()
	{
		return GetProxies(ProxySearchMode.AnyBurning).Any();
	}

	public bool HasStains(ProxySearchMode mode)
	{
		return GetProxies(mode).Any();
	}

	public bool TryIgnite()
	{
		if (isBurning)
		{
			return false;
		}
		List<VoxelProxy> list = GetProxies(ProxySearchMode.AnyNotBurning).ToList();
		if (list.Count == 0)
		{
			return false;
		}
		StainVoxelManager instance = MonoSingleton<StainVoxelManager>.Instance;
		bool flag = true;
		if (Physics.OverlapSphereNonAlloc(RoundedWorldPosition, 1.375f, waterOverlapResult, 16, QueryTriggerInteraction.Collide) > 0)
		{
			flag = false;
			int num = 65536;
			num |= 0x40000;
			int count = Physics.OverlapSphereNonAlloc(RoundedWorldPosition, 1.375f, waterOverlapResult, num, QueryTriggerInteraction.Collide);
			foreach (Collider item in waterOverlapResult.Take(count))
			{
				if (item.TryGetComponent<DryZone>(out var _))
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			foreach (VoxelProxy item2 in list)
			{
				item2.StartBurningOrRefuel();
			}
		}
		else if (instance.ShouldExplodeAt(VoxelPosition))
		{
			foreach (VoxelProxy item3 in list)
			{
				item3.ExplodeAndDestroy();
			}
		}
		else
		{
			foreach (VoxelProxy item4 in list)
			{
				item4.DestroySelf();
			}
		}
		MonoSingleton<StainVoxelManager>.Instance.ScheduleFirePropagation(this);
		return true;
	}

	private VoxelProxy CreateNewProxy(GasolineStain stain, bool isStatic)
	{
		GameObject gameObject = new GameObject(GetProxyName());
		gameObject.transform.position = RoundedWorldPosition;
		VoxelProxy voxelProxy = gameObject.AddComponent<VoxelProxy>();
		voxelProxy.gameObject.AddComponent<DestroyOnCheckpointRestart>();
		Transform parent = stain.transform.parent;
		voxelProxy.SetParent(parent, isStatic);
		voxelProxy.voxel = this;
		return voxelProxy;
	}

	public string GetProxyName()
	{
		return "VoxelProxy";
	}

	public override int GetHashCode()
	{
		return HashCode;
	}

	public override bool Equals(object obj)
	{
		if (obj is StainVoxel stainVoxel)
		{
			return HashCode == stainVoxel.HashCode;
		}
		return false;
	}
}



public class StainVoxelManager : MonoSingleton<StainVoxelManager>
{
	private static readonly plog.Logger Log = new plog.Logger("StainVoxelManager");

	private const int FireSpreadDistance = 5;

	public const float VoxelSize = 2.75f;

	public const float VoxelOverlapSphereRadius = 1.375f;

	public const int ExplosionMargin = 2;

	private readonly Dictionary<Vector3Int, StainVoxel> stainVoxels = new Dictionary<Vector3Int, StainVoxel>();

	private readonly HashSet<Vector3Int> pendingIgnitions = new HashSet<Vector3Int>();

	private TimeSince? lastPropagationTick;

	private readonly HashSet<Vector3Int> explodedVoxels = new HashSet<Vector3Int>();

	public readonly HurtCooldownCollection SharedHurtCooldownCollection = new HurtCooldownCollection();

	public void AcknowledgeNewStain(StainVoxel voxel)
	{
		voxel.AcknowledgeNewStain();
		if (voxel.isBurning)
		{
			return;
		}
		Vector3Int[] array = GetShapeIterator(voxel.VoxelPosition, VoxelCheckingShape.Box, 3).ToArray();
		foreach (Vector3Int key in array)
		{
			if (stainVoxels.TryGetValue(key, out var value) && value.isBurning)
			{
				voxel.TryIgnite();
			}
		}
	}

	private void Update()
	{
		if (!lastPropagationTick.HasValue || (float?)lastPropagationTick < 0.05f || pendingIgnitions == null || pendingIgnitions.Count == 0)
		{
			return;
		}
		lastPropagationTick = 0f - Random.Range(0f, 0.005f);
		List<StainVoxel> list = new List<StainVoxel>();
		foreach (Vector3Int pendingIgnition in pendingIgnitions)
		{
			StainVoxel stainVoxel = CreateOrGetVoxel(VoxelToWorldPosition(pendingIgnition), dontCreate: true);
			if (stainVoxel != null && !stainVoxel.isBurning)
			{
				list.Add(stainVoxel);
			}
		}
		pendingIgnitions.Clear();
		bool flag = false;
		foreach (StainVoxel item in list)
		{
			if (item.TryIgnite())
			{
				flag = true;
				ScheduleFirePropagation(item);
			}
		}
		if (!flag)
		{
			explodedVoxels.Clear();
			lastPropagationTick = null;
		}
	}

	public StainVoxel CreateOrGetVoxel(Vector3 worldPosition, bool dontCreate = false)
	{
		Vector3Int vector3Int = WorldToVoxelPosition(worldPosition);
		if (stainVoxels.TryGetValue(vector3Int, out var value))
		{
			return value;
		}
		if (dontCreate)
		{
			return null;
		}
		value = new StainVoxel(vector3Int);
		stainVoxels.Add(vector3Int, value);
		return value;
	}

	public void RefreshVoxel(StainVoxel voxel)
	{
		if (voxel.isEmpty)
		{
			stainVoxels.Remove(voxel.VoxelPosition);
			voxel.DestroySelf();
		}
	}

	public void UpdateProxyPosition(VoxelProxy proxy, Vector3Int newPosition)
	{
		Vector3Int voxelPosition = proxy.voxel.VoxelPosition;
		if (!(voxelPosition == newPosition))
		{
			if (!stainVoxels.TryGetValue(voxelPosition, out var value))
			{
				Log.Warning($"Failed to find voxel at {voxelPosition}");
				return;
			}
			value.RemoveProxy(proxy, destroy: false);
			CreateOrGetVoxel(VoxelToWorldPosition(newPosition)).AddProxy(proxy);
		}
	}

	public bool ShouldExplodeAt(Vector3Int voxelPosition)
	{
		if (explodedVoxels.Count == 0)
		{
			explodedVoxels.Add(voxelPosition);
			return true;
		}
		foreach (Vector3Int explodedVoxel in explodedVoxels)
		{
			if (Mathf.Abs(voxelPosition.x - explodedVoxel.x) <= 2 && Mathf.Abs(voxelPosition.y - explodedVoxel.y) <= 2 && Mathf.Abs(voxelPosition.z - explodedVoxel.z) <= 2)
			{
				return false;
			}
		}
		explodedVoxels.Add(voxelPosition);
		return true;
	}

	public bool TryIgniteAt(Vector3 worldPosition, int checkSize = 3)
	{
		if (stainVoxels.Count == 0)
		{
			return false;
		}
		Vector3Int voxelPosition = WorldToVoxelPosition(worldPosition);
		return TryIgniteAt(voxelPosition, checkSize);
	}

	public bool TryIgniteAt(Vector3Int voxelPosition, int checkSize = 3)
	{
		Log.Info($"TryIgniteAt {voxelPosition}");
		if (stainVoxels.Count == 0)
		{
			return false;
		}
		if (!TryGetVoxels(voxelPosition, out var voxels, checkSize))
		{
			return false;
		}
		bool result = false;
		foreach (StainVoxel item in voxels)
		{
			if (item.TryIgnite())
			{
				result = true;
			}
		}
		return result;
	}

	public void ScheduleFirePropagation(StainVoxel voxel)
	{
		if (voxel == null)
		{
			Log.Warning("ScheduleFirePropagation called with null voxel");
			return;
		}
		if (!lastPropagationTick.HasValue)
		{
			lastPropagationTick = 0f;
		}
		Vector3Int voxelPosition = voxel.VoxelPosition;
		Vector3Int[] array = IterateBox(voxelPosition, 5).ToArray();
		foreach (Vector3Int vector3Int in array)
		{
			if (!(vector3Int == voxelPosition) && !pendingIgnitions.Contains(vector3Int) && stainVoxels.TryGetValue(vector3Int, out var value) && !value.isBurning)
			{
				pendingIgnitions.Add(vector3Int);
			}
		}
		if (explodedVoxels.Count != 0 && pendingIgnitions.Count == 0)
		{
			explodedVoxels.Clear();
		}
	}

	public void DoneBurning(VoxelProxy proxy)
	{
		if (!(proxy == null))
		{
			proxy.voxel?.RemoveProxy(proxy);
		}
	}

	public bool TryGetVoxelsWorld(Vector3 worldPosition, out List<StainVoxel> voxels, int checkSize = 3, VoxelCheckingShape shape = VoxelCheckingShape.Box, bool returnOnHit = false)
	{
		Vector3Int voxelPosition = WorldToVoxelPosition(worldPosition);
		return TryGetVoxels(voxelPosition, out voxels, checkSize, shape, returnOnHit);
	}

	public bool TryGetVoxels(Vector3Int voxelPosition, out List<StainVoxel> voxels, int checkSize = 3, VoxelCheckingShape shape = VoxelCheckingShape.Box, bool returnOnHit = false)
	{
		voxels = new List<StainVoxel>();
		if (checkSize <= 1)
		{
			if (stainVoxels.TryGetValue(voxelPosition, out var value))
			{
				voxels.Add(value);
				DrawVoxel(voxelPosition, success: true);
				return true;
			}
			DrawVoxel(voxelPosition, success: false);
			return false;
		}
		foreach (Vector3Int item in GetShapeIterator(voxelPosition, shape, checkSize))
		{
			if (stainVoxels.TryGetValue(item, out var value2))
			{
				voxels.Add(value2);
				DrawVoxel(item, success: true);
				if (returnOnHit)
				{
					return true;
				}
			}
			else
			{
				DrawVoxel(item, success: false);
			}
		}
		return voxels.Count > 0;
	}

	public bool HasProxiesAt(Vector3Int voxelPosition, int checkSize = 3, VoxelCheckingShape shape = VoxelCheckingShape.Box, ProxySearchMode searchMode = ProxySearchMode.Any, bool returnOnHit = true)
	{
		if (stainVoxels.Count == 0)
		{
			return false;
		}
		if (checkSize <= 1)
		{
			return ProxyExistsAt(voxelPosition, searchMode);
		}
		foreach (Vector3Int item in GetShapeIterator(voxelPosition, shape, checkSize))
		{
			if (ProxyExistsAt(item, searchMode))
			{
				DrawVoxel(item, success: true);
				if (returnOnHit)
				{
					return true;
				}
			}
			else
			{
				DrawVoxel(item, success: false);
			}
		}
		return false;
	}

	private IEnumerable<Vector3Int> GetShapeIterator(Vector3Int center, VoxelCheckingShape shape, int size)
	{
		return shape switch
		{
			VoxelCheckingShape.Box => IterateBox(center, size), 
			VoxelCheckingShape.VerticalBox => IterateVerticalBox(center, size, 2), 
			VoxelCheckingShape.Cross => IterateCross(center, size, 2), 
			VoxelCheckingShape.Pole => IteratePole(center, size), 
			_ => null, 
		};
	}

	private bool ProxyExistsAt(Vector3Int voxelPosition, ProxySearchMode searchMode = ProxySearchMode.Any)
	{
		if (stainVoxels.Count == 0)
		{
			return false;
		}
		if (!stainVoxels.ContainsKey(voxelPosition))
		{
			return false;
		}
		if (!stainVoxels.TryGetValue(voxelPosition, out var value))
		{
			return false;
		}
		return value.HasStains(searchMode);
	}

	private static IEnumerable<Vector3Int> IterateBox(Vector3Int center, int size)
	{
		int halfSize = size / 2;
		for (int x = -halfSize; x <= halfSize; x++)
		{
			for (int y = -halfSize; y <= halfSize; y++)
			{
				for (int z = -halfSize; z <= halfSize; z++)
				{
					yield return new Vector3Int(center.x + x, center.y + y, center.z + z);
				}
			}
		}
	}

	private static IEnumerable<Vector3Int> IterateVerticalBox(Vector3Int center, int size, int height)
	{
		int halfSize = size / 2;
		for (int x = -halfSize; x <= halfSize; x++)
		{
			for (int z = -halfSize; z <= halfSize; z++)
			{
				for (int y = 0; y < height; y++)
				{
					yield return new Vector3Int(center.x + x, center.y + y, center.z + z);
				}
			}
		}
	}

	private static IEnumerable<Vector3Int> IterateCross(Vector3Int center, int size, int height)
	{
		int halfSize = size / 2;
		for (int y = 0; y < height; y++)
		{
			for (int x = -halfSize; x <= halfSize; x++)
			{
				yield return new Vector3Int(center.x + x, center.y + y, center.z);
			}
			for (int x = -halfSize; x <= halfSize; x++)
			{
				if (x != 0)
				{
					yield return new Vector3Int(center.x, center.y + y, center.z + x);
				}
			}
		}
	}

	private static IEnumerable<Vector3Int> IteratePole(Vector3Int center, int size)
	{
		int halfSize = size / 2;
		for (int i = -halfSize; i <= halfSize; i++)
		{
			yield return new Vector3Int(center.x, center.y + i, center.z);
		}
	}

	public static Vector3Int WorldToVoxelPosition(Vector3 position)
	{
		int x = Mathf.RoundToInt(position.x / 2.75f);
		int y = Mathf.RoundToInt(position.y / 2.75f);
		int z = Mathf.RoundToInt(position.z / 2.75f);
		return new Vector3Int(x, y, z);
	}

	public static Vector3 VoxelToWorldPosition(Vector3Int position)
	{
		return new Vector3((float)position.x * 2.75f, (float)position.y * 2.75f, (float)position.z * 2.75f);
	}

	private static void DrawVoxel(Vector3Int voxelPosition, bool success)
	{
	}

	private static void DrawVoxel(Vector3 roundedWorldPosition, bool success)
	{
	}
}



public class Stalker : MonoBehaviour, IEnemyRelationshipLogic
{
	private EnemyIdentifier eid;

	private Machine mach;

	private int difficulty = -1;

	private NavMeshAgent nma;

	[HideInInspector]
	public float defaultMovementSpeed;

	private Animator anim;

	private bool inAction;

	private float explosionCharge;

	private float countDownAmount;

	private bool exploding;

	private bool exploded;

	public AssetReference explosion;

	private float maxHp;

	private Light lit;

	private Color currentColor;

	public Color[] lightColors;

	private bool blinking;

	private float blinkTimer;

	private AudioSource lightAud;

	public AudioClip[] lightSounds;

	public SkinnedMeshRenderer canRenderer;

	public GameObject stepSound;

	public GameObject screamSound;

	private float explodeSpeed = 1f;

	public float prepareTime = 5f;

	public float prepareWarningTime = 3f;

	private void Awake()
	{
		mach = GetComponent<Machine>();
		lit = GetComponentInChildren<Light>();
		lightAud = lit.GetComponent<AudioSource>();
		anim = GetComponent<Animator>();
		eid = GetComponent<EnemyIdentifier>();
		nma = GetComponent<NavMeshAgent>();
	}

	private void Start()
	{
		maxHp = mach.health;
		currentColor = lightColors[0];
		lightAud.clip = lightSounds[0];
		lightAud.loop = false;
		lightAud.pitch = 1f;
		lightAud.volume = 0.35f;
		SetSpeed();
		NavigationUpdate();
		SlowUpdate();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (!nma)
		{
			nma = GetComponent<NavMeshAgent>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (defaultMovementSpeed == 0f)
		{
			defaultMovementSpeed = nma.speed;
		}
		nma.speed = defaultMovementSpeed * eid.totalSpeedModifier;
		anim.speed = eid.totalSpeedModifier;
		anim.SetFloat("ExplodeSpeed", explodeSpeed);
	}

	private void OnDisable()
	{
		if (exploding)
		{
			exploding = false;
			explosionCharge = prepareTime;
			inAction = false;
			blinking = false;
		}
	}

	private void NavigationUpdate()
	{
		if ((bool)nma && nma.isOnNavMesh)
		{
			if (eid.target == null)
			{
				nma?.SetDestination(base.transform.position);
			}
			else if (eid.target != null && !inAction && (bool)mach && mach.grounded)
			{
				nma?.SetDestination(eid.target.position);
			}
			else if ((bool)mach && mach.grounded && inAction)
			{
				nma?.SetDestination(base.transform.position);
			}
		}
		Invoke("NavigationUpdate", 0.1f);
	}

	private void SlowUpdate()
	{
		if (inAction || ((bool)mach && !mach.grounded) || ((bool)nma && !nma.isOnNavMesh) || !eid.AttackEnemies)
		{
			Invoke("SlowUpdate", 0.5f);
			return;
		}
		List<EnemyIdentifier> currentEnemies = MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies();
		if (currentEnemies != null && currentEnemies.Count > 0)
		{
			bool flag = false;
			bool flag2 = false;
			float num = float.PositiveInfinity;
			EnemyIdentifier enemyIdentifier = null;
			for (int num2 = 6; num2 >= 0; num2--)
			{
				for (int i = 0; i < currentEnemies.Count; i++)
				{
					if (currentEnemies[i].flying || currentEnemies[i].puppet || currentEnemies[i].sandified || MonoSingleton<EnemyTracker>.Instance.GetEnemyRank(currentEnemies[i]) != num2)
					{
						continue;
					}
					float num3 = Vector3.Distance(base.transform.position, currentEnemies[i].transform.position);
					if (!(num3 < num) || ((currentEnemies[i].enemyType == EnemyType.MaliciousFace || !CheckForPath(currentEnemies[i].transform.position)) && (currentEnemies[i].enemyType != EnemyType.MaliciousFace || !CheckForOffsetPath(currentEnemies[i]))))
					{
						continue;
					}
					if (eid.target != null && currentEnemies[i].transform != eid.target.targetTransform)
					{
						if (!MonoSingleton<StalkerController>.Instance.CheckIfTargetTaken(currentEnemies[i].transform))
						{
							if (eid.target != null && MonoSingleton<StalkerController>.Instance.CheckIfTargetTaken(eid.target.targetTransform))
							{
								MonoSingleton<StalkerController>.Instance.targets.Remove(eid.target.targetTransform);
							}
							if (enemyIdentifier != null && MonoSingleton<StalkerController>.Instance.CheckIfTargetTaken(enemyIdentifier.transform))
							{
								MonoSingleton<StalkerController>.Instance.targets.Remove(enemyIdentifier.transform);
							}
							enemyIdentifier = currentEnemies[i];
							MonoSingleton<StalkerController>.Instance.targets.Add(currentEnemies[i].transform);
							if (num3 < 100f)
							{
								flag = true;
							}
							else
							{
								flag2 = true;
							}
							num = Vector3.Distance(base.transform.position, currentEnemies[i].transform.position);
						}
						else if (!flag)
						{
							enemyIdentifier = currentEnemies[i];
							flag2 = true;
							num = Vector3.Distance(base.transform.position, currentEnemies[i].transform.position);
						}
					}
					else
					{
						if (num3 < 100f)
						{
							enemyIdentifier = currentEnemies[i];
							flag = true;
						}
						else
						{
							enemyIdentifier = currentEnemies[i];
							flag2 = true;
						}
						num = Vector3.Distance(base.transform.position, currentEnemies[i].transform.position);
					}
				}
				if (flag)
				{
					eid.target = new EnemyTarget(enemyIdentifier.transform);
					enemyIdentifier.buffTargeter = eid;
					break;
				}
			}
			if (!flag && flag2)
			{
				eid.target = new EnemyTarget(enemyIdentifier.transform);
				enemyIdentifier.buffTargeter = eid;
			}
			else if (!flag)
			{
				if (eid.target != null)
				{
					if (MonoSingleton<StalkerController>.Instance.CheckIfTargetTaken(eid.target.targetTransform))
					{
						MonoSingleton<StalkerController>.Instance.targets.Remove(eid.target.targetTransform);
					}
					if (eid.target.targetTransform.TryGetComponent<EnemyIdentifier>(out var component) && component.buffTargeter == eid)
					{
						component.buffTargeter = null;
					}
				}
				eid.enemyScanner?.Reset();
				eid.target = EnemyTarget.TrackPlayerIfAllowed();
			}
		}
		Invoke("SlowUpdate", 0.5f);
	}

	private void Update()
	{
		if (exploding)
		{
			if (countDownAmount < 2f)
			{
				countDownAmount = Mathf.MoveTowards(countDownAmount, 2f, Time.deltaTime * explodeSpeed * eid.totalSpeedModifier);
			}
			else
			{
				exploding = false;
				SandExplode(0);
			}
		}
		else if (explosionCharge < prepareTime)
		{
			explosionCharge = Mathf.MoveTowards(explosionCharge, prepareTime, Time.deltaTime * eid.totalSpeedModifier);
			if (explosionCharge > prepareWarningTime)
			{
				blinking = true;
			}
		}
		else
		{
			if (lit.color != lightColors[1] * (mach.health / maxHp))
			{
				blinking = false;
				currentColor = lightColors[1];
				lightAud.clip = lightSounds[1];
				lightAud.loop = true;
				lightAud.pitch = 0.5f;
				lightAud.volume = 0.65f;
				lightAud.Play();
			}
			if (explosionCharge < prepareTime + 1f)
			{
				explosionCharge = Mathf.MoveTowards(explosionCharge, prepareTime + 1f, Time.deltaTime * eid.totalSpeedModifier);
			}
			else if (eid.target != null && Vector3.Distance(base.transform.position, eid.target.position) < 8f && !exploding)
			{
				exploding = true;
				Countdown();
			}
		}
		if (!inAction)
		{
			if (nma.velocity.magnitude > 5f)
			{
				anim.SetBool("Running", value: true);
			}
			else
			{
				anim.SetBool("Running", value: false);
			}
			if (nma.velocity.magnitude > 0f)
			{
				anim.SetBool("Walking", value: true);
			}
			else
			{
				anim.SetBool("Walking", value: false);
			}
			if (!mach.grounded)
			{
				anim.SetBool("Falling", value: true);
			}
			else
			{
				anim.SetBool("Falling", value: false);
			}
		}
		if (blinking)
		{
			if (blinkTimer > 0f)
			{
				blinkTimer = Mathf.MoveTowards(blinkTimer, 0f, Time.deltaTime);
			}
			else
			{
				if (lit.color != Color.black)
				{
					lit.color = Color.black;
					lightAud?.Stop();
				}
				else
				{
					lit.color = currentColor * ((mach.health + 0.2f) / (maxHp + 0.2f));
					lightAud?.Play();
				}
				blinkTimer = 0.1f;
			}
		}
		else
		{
			lit.color = currentColor * ((mach.health + 0.2f) / (maxHp + 0.2f));
			blinkTimer = 0f;
		}
		if ((bool)canRenderer)
		{
			canRenderer.material.SetColor("_EmissiveColor", lit.color);
		}
	}

	public void Countdown()
	{
		inAction = true;
		blinking = true;
		currentColor = lightColors[2];
		lightAud.clip = lightSounds[2];
		lightAud.loop = false;
		lightAud.pitch = 1f;
		lightAud.volume = 0.65f;
		explosionCharge = 0f;
		countDownAmount = 0f;
		Object.Instantiate(screamSound, base.transform);
		anim.SetTrigger("Explode");
	}

	public void SandExplode(int onDeath = 1)
	{
		if (exploded)
		{
			return;
		}
		GameObject gameObject = Object.Instantiate(explosion.ToAsset(), base.transform.position + Vector3.up * 2.5f, Quaternion.identity);
		if (onDeath != 1)
		{
			gameObject.transform.localScale *= 1.5f;
		}
		if (eid.stuckMagnets.Count > 0)
		{
			float num = 0.75f;
			if (eid.stuckMagnets.Count > 1)
			{
				num -= 0.125f * (float)(eid.stuckMagnets.Count - 1);
			}
			gameObject.transform.localScale *= num;
		}
		if (eid.target != null && (bool)eid.target.enemyIdentifier && eid.target.enemyIdentifier.sandified)
		{
			if (MonoSingleton<StalkerController>.Instance.CheckIfTargetTaken(eid.target.targetTransform))
			{
				MonoSingleton<StalkerController>.Instance.targets.Remove(eid.target.targetTransform);
			}
			if (eid.target.targetTransform.TryGetComponent<EnemyIdentifier>(out var component) && component.buffTargeter == eid)
			{
				component.buffTargeter = null;
			}
		}
		if ((difficulty > 3 || eid.blessed || InvincibleEnemies.Enabled) && onDeath != 1)
		{
			exploding = false;
			countDownAmount = 0f;
			explosionCharge = 0f;
			currentColor = lightColors[0];
			lightAud.clip = lightSounds[0];
			blinking = false;
			return;
		}
		exploded = true;
		if (!mach.limp && onDeath != 1)
		{
			mach.GoLimp();
			eid.Death();
		}
		if (eid.drillers.Count != 0)
		{
			for (int num2 = eid.drillers.Count - 1; num2 >= 0; num2--)
			{
				Object.Destroy(eid.drillers[num2].gameObject);
			}
		}
		base.gameObject.SetActive(value: false);
		Object.Destroy(base.gameObject);
	}

	public bool CheckForPath(Vector3 pathTarget)
	{
		NavMeshPath navMeshPath = new NavMeshPath();
		nma.CalculatePath(pathTarget, navMeshPath);
		if (navMeshPath != null && navMeshPath.status == NavMeshPathStatus.PathComplete)
		{
			return true;
		}
		return false;
	}

	public bool CheckForOffsetPath(EnemyIdentifier ed)
	{
		if (ed.TryGetComponent<NavMeshAgent>(out var component))
		{
			return CheckForPath(ed.transform.position + Vector3.down * component.height * component.baseOffset * ed.transform.localScale.y);
		}
		return false;
	}

	public void StopAction()
	{
		inAction = false;
	}

	public void Step()
	{
		Object.Instantiate(stepSound, base.transform.position, Quaternion.identity);
	}

	public bool ShouldAttackEnemies()
	{
		return true;
	}

	public bool ShouldIgnorePlayer()
	{
		return false;
	}
}



public class StalkerController : MonoSingleton<StalkerController>
{
	public List<Transform> targets = new List<Transform>();

	public bool CheckIfTargetTaken(Transform target)
	{
		if (targets.Contains(target))
		{
			return true;
		}
		return false;
	}
}



public class StaminaFail : MonoBehaviour
{
	private void Start()
	{
		StaminaMeter[] array = Object.FindObjectsOfType<StaminaMeter>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Flash(red: true);
		}
	}
}



public class StaminaMeter : MonoBehaviour
{
	private NewMovement nmov;

	private float stamina;

	private Slider stm;

	private TMP_Text stmText;

	public bool changeTextColor;

	public Color normalTextColor;

	private Image staminaFlash;

	private Color flashColor;

	private Image staminaBar;

	private bool full = true;

	private AudioSource aud;

	private Color emptyColor;

	private Color origColor;

	public bool redEmpty;

	private bool intro = true;

	private float lastStamina;

	private Canvas parentCanvas;

	public bool alwaysUpdate;

	private void Start()
	{
		Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
		stm = GetComponent<Slider>();
		if (stm != null)
		{
			staminaBar = base.transform.GetChild(1).GetChild(0).GetComponent<Image>();
			staminaFlash = staminaBar.transform.GetChild(0).GetComponent<Image>();
			flashColor = staminaFlash.color;
			origColor = staminaBar.color;
		}
		stmText = GetComponent<TMP_Text>();
		nmov = MonoSingleton<NewMovement>.Instance;
		lastStamina = stamina;
		UpdateColors();
		parentCanvas = GetComponentInParent<Canvas>();
	}

	private void OnEnable()
	{
		UpdateColors();
	}

	private void Update()
	{
		if (intro)
		{
			stamina = Mathf.MoveTowards(stamina, nmov.boostCharge, Time.deltaTime * ((nmov.boostCharge - stamina) * 5f + 10f));
			if (stamina >= nmov.boostCharge)
			{
				intro = false;
			}
		}
		else if (stamina < nmov.boostCharge)
		{
			stamina = Mathf.MoveTowards(stamina, nmov.boostCharge, Time.deltaTime * ((nmov.boostCharge - stamina) * 25f + 25f));
		}
		else if (stamina > nmov.boostCharge)
		{
			stamina = Mathf.MoveTowards(stamina, nmov.boostCharge, Time.deltaTime * ((stamina - nmov.boostCharge) * 25f + 25f));
		}
		if (!alwaysUpdate && (!parentCanvas || !parentCanvas.enabled))
		{
			return;
		}
		if (stm != null)
		{
			stm.value = stamina;
			if (stm.value >= stm.maxValue && !full)
			{
				full = true;
				staminaBar.color = origColor;
				Flash();
			}
			if (flashColor.a > 0f)
			{
				if (flashColor.a - Time.deltaTime > 0f)
				{
					flashColor.a -= Time.deltaTime;
				}
				else
				{
					flashColor.a = 0f;
				}
				staminaFlash.color = flashColor;
			}
			if (stm.value < stm.maxValue)
			{
				full = false;
				staminaBar.color = emptyColor;
			}
		}
		if (!(stmText != null))
		{
			return;
		}
		if (lastStamina != stamina)
		{
			stmText.text = (stamina / 100f).ToString("0.00");
		}
		lastStamina = stamina;
		if (changeTextColor)
		{
			if (stamina < 100f)
			{
				stmText.color = Color.red;
			}
			else
			{
				stmText.color = MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(HudColorType.stamina);
			}
		}
		else if (normalTextColor == Color.white)
		{
			if (stamina < 100f)
			{
				stmText.color = Color.red;
			}
			else
			{
				stmText.color = MonoSingleton<ColorBlindSettings>.Instance.GetHudColor(HudColorType.healthText);
			}
		}
	}

	public void Flash(bool red = false)
	{
		if (stm != null)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.Play();
			if (red)
			{
				flashColor = Color.red;
			}
			else
			{
				flashColor = Color.white;
			}
			staminaFlash.color = flashColor;
		}
	}

	public void UpdateColors()
	{
		origColor = MonoSingleton<ColorBlindSettings>.Instance.staminaColor;
		if (redEmpty)
		{
			emptyColor = MonoSingleton<ColorBlindSettings>.Instance.staminaEmptyColor;
		}
		else
		{
			emptyColor = MonoSingleton<ColorBlindSettings>.Instance.staminaChargingColor;
		}
		if ((bool)staminaBar)
		{
			if (full)
			{
				staminaBar.color = origColor;
			}
			else
			{
				staminaBar.color = emptyColor;
			}
		}
	}
}


public enum State
{
	Hallway,
	Room
}


public enum StatePersistenceMode
{
	NotPersistent,
	Persistent
}


public static class StateProperties
{
	public const string Game = "game";

	public const string Intro = "intro";

	public const string MainMenu = "main-menu";

	public const string Pause = "pause";

	public const string PitFalling = "pit-falling";

	public const string CheatsMenu = "cheats-menu";

	public const string TeleportMenu = "teleport-menu";

	public const string SandboxSpawnMenu = "sandbox-spawn-menu";

	public const string SandboxAlterMenu = "alter-menu";

	public const string WorkshopMapCredits = "workshop-map-credits";

	public const string UnlockMouseComponent = "unlock-mouse-component";

	public const string Console = "console";

	public const string WorkshopRateScreen = "workshop-rate-screen";

	public const string WeaponWheel = "weapon-wheel";

	public const string AgonyMenu = "agony-menu";
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class StatsManager : MonoSingleton<StatsManager>
{
	[HideInInspector]
	public GameObject[] checkPoints;

	private GameObject player;

	private NewMovement nm;

	[HideInInspector]
	public Vector3 spawnPos;

	[HideInInspector]
	public CheckPoint currentCheckPoint;

	public GameObject debugCheckPoint;

	public int levelNumber;

	[HideInInspector]
	public int kills;

	[HideInInspector]
	public int stylePoints;

	[HideInInspector]
	public int restarts;

	[HideInInspector]
	public int secrets;

	[HideInInspector]
	public float seconds;

	public bool timer;

	public bool firstPlayThrough;

	private bool timerOnOnce;

	[HideInInspector]
	public bool levelStarted;

	[HideInInspector]
	public FinalRank fr;

	private StyleHUD shud;

	private GunControl gunc;

	[HideInInspector]
	public bool infoSent;

	private bool casualFR;

	public int[] timeRanks;

	public int[] killRanks;

	public int[] styleRanks;

	[HideInInspector]
	public int rankScore;

	public GameObject[] secretObjects;

	[HideInInspector]
	public List<int> prevSecrets;

	[HideInInspector]
	public List<int> newSecrets = new List<int>();

	[HideInInspector]
	public bool challengeComplete;

	public AudioClip[] rankSounds;

	[HideInInspector]
	public int maxGlassKills;

	[HideInInspector]
	public GameObject crosshair;

	[HideInInspector]
	public bool tookDamage;

	public GameObject bonusGhost;

	public GameObject bonusGhostSupercharge;

	[HideInInspector]
	public bool majorUsed;

	[HideInInspector]
	public bool endlessMode;

	private AssistController asscon;

	protected override void Awake()
	{
		base.Awake();
		GameStateManager.Instance.RegisterState(new GameState("game", base.gameObject)
		{
			playerInputLock = LockMode.Unlock,
			cameraInputLock = LockMode.Unlock,
			cursorLock = LockMode.Lock
		});
		int lvl = -1;
		if (levelNumber == 0)
		{
			int? levelIndexAfterIntermission = MonoSingleton<SceneHelper>.Instance.GetLevelIndexAfterIntermission(SceneHelper.CurrentScene);
			if (levelIndexAfterIntermission.HasValue)
			{
				lvl = levelIndexAfterIntermission.Value;
			}
		}
		RankData rank2 = GameProgressSaver.GetRank(returnNull: true, lvl);
		if (SceneHelper.IsSceneRankless)
		{
			firstPlayThrough = false;
		}
		else
		{
			firstPlayThrough = rank2 == null || (rank2.ranks != null && rank2.ranks.All((int rank) => rank < 0));
		}
		if (rank2 != null && rank2.levelNumber == levelNumber)
		{
			for (int i = 0; i < secretObjects.Length; i++)
			{
				if (secretObjects[i] == null)
				{
					continue;
				}
				Bonus component2;
				if (rank2.secretsFound.Length > i && rank2.secretsFound[i])
				{
					if (secretObjects[i].TryGetComponent<Bonus>(out var component))
					{
						component.beenFound = true;
						component.BeenFound();
					}
					secretObjects[i] = null;
					prevSecrets.Add(i);
				}
				else if (secretObjects[i].TryGetComponent<Bonus>(out component2))
				{
					component2.secretNumber = i;
				}
			}
			if (rank2.challenge)
			{
				challengeComplete = true;
			}
			return;
		}
		bool flag = false;
		for (int j = 0; j < secretObjects.Length; j++)
		{
			if (!(secretObjects[j] != null))
			{
				flag = true;
				break;
			}
		}
		if (secretObjects == null || (secretObjects.Length != 0 && flag))
		{
			secretObjects = (from b in UnityEngine.Object.FindObjectsOfType<Bonus>()
				select b.gameObject).ToArray();
			if (secretObjects.Length == 0)
			{
				Debug.Log("No secret objects found!");
				secretObjects = Array.Empty<GameObject>();
			}
		}
		for (int k = 0; k < secretObjects.Length; k++)
		{
			if (secretObjects[k].TryGetComponent<Bonus>(out var component3))
			{
				component3.secretNumber = k;
			}
		}
	}

	protected override void OnDestroy()
	{
		GameStateManager.Instance.PopState("game");
	}

	private void Start()
	{
		nm = MonoSingleton<NewMovement>.Instance;
		player = nm.gameObject;
		spawnPos = player.transform.position;
		asscon = MonoSingleton<AssistController>.Instance;
		fr = MonoSingleton<FinalRank>.Instance;
		if (fr != null)
		{
			fr.gameObject.SetActive(value: false);
		}
		spawnPos = player.transform.position;
		GameObject gameObject = GameObject.FindWithTag("PlayerPosInfo");
		if (gameObject != null)
		{
			if (!SceneHelper.IsPlayingCustom)
			{
				PlayerPosInfo component = gameObject.GetComponent<PlayerPosInfo>();
				if (!component.noPosition)
				{
					player.transform.position = component.position;
				}
				player.GetComponent<Rigidbody>().velocity = component.velocity;
				player.GetComponentInChildren<WallCheck>().GetComponent<AudioSource>().time = component.wooshTime;
			}
			UnityEngine.Object.Destroy(gameObject);
		}
		else
		{
			player.GetComponent<Rigidbody>().velocity = Vector3.down * 100f;
		}
		_ = SceneHelper.IsPlayingCustom;
		rankScore = -1;
	}

	private void Update()
	{
		if ((Input.GetKeyDown(KeyCode.R) || (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)) && nm.hp <= 0 && !nm.endlessMode && !MonoSingleton<OptionsManager>.Instance.paused)
		{
			Restart();
		}
		if (timer)
		{
			seconds += Time.deltaTime * GameStateManager.Instance.TimerModifier;
		}
		if (stylePoints < 0)
		{
			stylePoints = 0;
		}
		if (!endlessMode)
		{
			DiscordController.UpdateStyle(stylePoints);
		}
	}

	public void GetCheckPoint(Vector3 position)
	{
		spawnPos = position;
	}

	public void Restart()
	{
		MonoSingleton<MusicManager>.Instance.ArenaMusicEnd();
		timer = true;
		if (currentCheckPoint == null)
		{
			if ((bool)MonoSingleton<MapVarManager>.Instance)
			{
				MonoSingleton<MapVarManager>.Instance.ResetStores();
			}
			SceneHelper.RestartScene();
		}
		else
		{
			currentCheckPoint.OnRespawn();
			restarts++;
		}
	}

	public void StartTimer()
	{
		timer = true;
		if (timerOnOnce)
		{
			return;
		}
		if (asscon.majorEnabled)
		{
			if (!MonoSingleton<AssistController>.Instance.hidePopup)
			{
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=#4C99E6>MAJOR ASSISTS ARE ENABLED.</color>", "", "", 0, silent: true);
			}
			MajorUsed();
		}
		MonoSingleton<PlayerTracker>.Instance.LevelStart();
		timerOnOnce = true;
	}

	public void StopTimer()
	{
		timer = false;
	}

	public void HideShit()
	{
		if (shud == null)
		{
			shud = MonoSingleton<StyleHUD>.Instance;
		}
		shud.ComboOver();
		if (gunc == null)
		{
			gunc = MonoSingleton<GunControl>.Instance;
		}
		gunc.NoWeapon();
		if ((bool)crosshair)
		{
			crosshair.transform.parent.gameObject.SetActive(value: false);
		}
		HudController.Instance.gunCanvas.SetActive(value: false);
	}

	public void SendInfo()
	{
		if (infoSent)
		{
			return;
		}
		infoSent = true;
		string text = "";
		rankScore = 0;
		if (!fr)
		{
			fr = MonoSingleton<FinalRank>.Instance;
		}
		fr.gameObject.SetActive(value: true);
		if (fr.casual)
		{
			casualFR = true;
		}
		if (!casualFR)
		{
			text = GetRanks(timeRanks, seconds, reverse: true, addToRankScore: true);
			SetRankSound(text, fr.timeRank.gameObject);
			fr.SetTime(seconds, text);
			Debug.Log("Rankscore after time: " + rankScore);
			text = GetRanks(killRanks, kills, reverse: false, addToRankScore: true);
			SetRankSound(text, fr.killsRank.gameObject);
			fr.SetKills(kills, text);
			Debug.Log("Rankscore after kills: " + rankScore);
			text = GetRanks(styleRanks, stylePoints, reverse: false, addToRankScore: true);
			SetRankSound(text, fr.styleRank.gameObject);
			fr.SetStyle(stylePoints, text);
			Debug.Log("Rankscore after style: " + rankScore);
			fr.SetInfo(restarts, tookDamage, majorUsed, asscon.cheatsEnabled);
			GetFinalRank();
			GameProgressSaver.SaveRank();
			fr.SetSecrets(secrets, secretObjects.Length);
			fr.levelSecrets = secretObjects;
			fr.prevSecrets = prevSecrets;
			if (GameStateManager.CanSubmitScores)
			{
				string currentScene = SceneHelper.CurrentScene;
				if (!string.IsNullOrEmpty(currentScene) && SceneHelper.CurrentScene.StartsWith("Level ") && MonoSingleton<PrefsManager>.Instance.GetBool("levelLeaderboards"))
				{
					int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
					MonoSingleton<LeaderboardController>.Instance.SubmitLevelScore(currentScene, @int, seconds, kills, stylePoints, restarts);
					if (rankScore == 12)
					{
						MonoSingleton<LeaderboardController>.Instance.SubmitLevelScore(currentScene, @int, seconds, kills, stylePoints, restarts, pRank: true);
					}
				}
			}
		}
		fr.Appear();
	}

	public string GetRanks(int[] ranksToCheck, float value, bool reverse, bool addToRankScore = false)
	{
		int num = 0;
		bool flag = true;
		while (flag)
		{
			if (num < ranksToCheck.Length)
			{
				if ((reverse && value <= (float)ranksToCheck[num]) || (!reverse && value >= (float)ranksToCheck[num]))
				{
					num++;
					continue;
				}
				if (addToRankScore)
				{
					rankScore += num;
				}
				switch (num)
				{
				case 0:
					return "<color=#0094FF>D</color>";
				case 1:
					return "<color=#4CFF00>C</color>";
				case 2:
					return "<color=#FFD800>B</color>";
				case 3:
					return "<color=#FF6A00>A</color>";
				}
				continue;
			}
			if (addToRankScore)
			{
				rankScore += 4;
			}
			return "<color=#FF0000>S</color>";
		}
		return "X";
	}

	private void GetFinalRank()
	{
		string text = "";
		if (restarts != 0)
		{
			rankScore -= restarts;
		}
		if (rankScore < 0)
		{
			rankScore = 0;
		}
		if (majorUsed)
		{
			if (rankScore == 12)
			{
				rankScore = 11;
			}
			fr.totalRank.transform.parent.GetComponent<Image>().color = new Color(0.3f, 0.6f, 0.9f, 1f);
		}
		if (rankScore == 12 && !asscon.cheatsEnabled)
		{
			text = "<color=#FFFFFF>P</color>";
			fr.totalRank.transform.parent.GetComponent<Image>().color = new Color(1f, 0.686f, 0f, 1f);
		}
		else
		{
			float num = (float)rankScore / 3f;
			Debug.Log("Float: " + num);
			Debug.Log("PreInt: " + rankScore);
			rankScore = Mathf.RoundToInt(num);
			Debug.Log("PostInt: " + rankScore);
			if (asscon.cheatsEnabled)
			{
				text = "-";
			}
			else if (majorUsed)
			{
				switch (rankScore)
				{
				case 1:
					text = "C";
					break;
				case 2:
					text = "B";
					break;
				case 3:
					text = "A";
					break;
				case 4:
				case 5:
				case 6:
					text = "S";
					break;
				default:
					text = "D";
					break;
				}
			}
			else
			{
				switch (rankScore)
				{
				case 1:
					text = "<color=#4CFF00>C</color>";
					break;
				case 2:
					text = "<color=#FFD800>B</color>";
					break;
				case 3:
					text = "<color=#FF6A00>A</color>";
					break;
				case 4:
				case 5:
				case 6:
					text = "<color=#FF0000>S</color>";
					break;
				default:
					text = "<color=#0094FF>D</color>";
					break;
				}
			}
		}
		if (asscon.cheatsEnabled)
		{
			rankScore = -1;
			text = "<color=#FFFFFF>_</color>";
			fr.totalRank.transform.parent.GetComponent<Image>().color = new Color(0.25f, 1f, 0.25f);
		}
		fr.SetRank(text);
	}

	private void SetRankSound(string rank, GameObject target)
	{
		switch (rank)
		{
		case "<color=#FFD800>B</color>":
			target.GetComponent<AudioSource>().clip = rankSounds[0];
			break;
		case "<color=#FF6A00>A</color>":
			target.GetComponent<AudioSource>().clip = rankSounds[1];
			break;
		case "<color=#FF0000>S</color>":
			target.GetComponent<AudioSource>().clip = rankSounds[2];
			break;
		}
	}

	public void MajorUsed()
	{
		if (timer && !majorUsed && !MonoSingleton<AssistController>.Instance.hidePopup)
		{
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=#4C99E6>MAJOR ASSISTS ARE ENABLED.</color>", "", "", 0, silent: true);
		}
		if (timer)
		{
			majorUsed = true;
		}
	}

	public void SecretFound(int i)
	{
		if (!prevSecrets.Contains(i) && !newSecrets.Contains(i))
		{
			GameProgressSaver.SecretFound(i);
			newSecrets.Add(i);
			secretObjects[i] = null;
		}
	}

	public static string DivideMoney(int money)
	{
		string text = "";
		int num = money;
		int num2 = 0;
		while (num >= 1000)
		{
			num2++;
			num -= 1000;
		}
		if (num2 > 0)
		{
			if (num < 10)
			{
				return num2 + ",00" + num;
			}
			if (num < 100)
			{
				return num2 + ",0" + num;
			}
			return num2 + "," + num;
		}
		return string.Concat(num);
	}
}



public class Statue : MonoBehaviour
{
	public float health;

	[HideInInspector]
	public float originalHealth;

	private BloodsplatterManager bsm;

	public bool limp;

	private EnemyIdentifier eid;

	public GameObject chest;

	private float chestHP;

	private AudioSource aud;

	public AudioClip[] hurtSounds;

	private StyleCalculator scalc;

	private GoreZone gz;

	public Material deadMaterial;

	public Material woundedMaterial;

	public Material woundedEnrageMaterial;

	public GameObject woundedParticle;

	private Material originalMaterial;

	public SkinnedMeshRenderer smr;

	private NavMeshAgent nma;

	private Rigidbody rb;

	private Rigidbody[] rbs;

	private Animator anim;

	public AudioClip deathSound;

	private bool noheal;

	public List<GameObject> extraDamageZones = new List<GameObject>();

	public float extraDamageMultiplier;

	private StatueBoss sb;

	private Mass mass;

	private Vector3 origPos;

	private List<Transform> transforms = new List<Transform>();

	public bool grounded;

	private GroundCheckEnemy gc;

	public bool knockedBack;

	private float knockBackCharge;

	public float brakes;

	public float juggleWeight;

	public bool falling;

	private float fallSpeed;

	private float fallTime;

	private bool affectedByGravity = true;

	[HideInInspector]
	public bool musicRequested;

	public bool bigBlood;

	public bool massDeath;

	private bool massDying;

	public bool specialDeath;

	public bool parryable;

	public bool partiallyParryable;

	[HideInInspector]
	public List<Transform> parryables = new List<Transform>();

	private int parryFramesLeft;

	private bool parryFramesOnPartial;

	private void Start()
	{
		if (!limp)
		{
			nma = GetComponent<NavMeshAgent>();
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
			rbs = GetComponentsInChildren<Rigidbody>();
			anim = GetComponentInChildren<Animator>();
			if (smr != null)
			{
				originalMaterial = smr.material;
			}
			mass = GetComponent<Mass>();
			gc = GetComponentInChildren<GroundCheckEnemy>();
			if (gc == null)
			{
				affectedByGravity = false;
			}
			rb = GetComponent<Rigidbody>();
			eid = GetComponent<EnemyIdentifier>();
			if (!musicRequested)
			{
				musicRequested = true;
				MonoSingleton<MusicManager>.Instance.PlayBattleMusic();
			}
			if (originalHealth == 0f)
			{
				originalHealth = health;
			}
		}
		else
		{
			noheal = true;
		}
		if (gz == null)
		{
			gz = GoreZone.ResolveGoreZone((base.transform.parent == null) ? base.transform : base.transform.parent);
		}
	}

	private void OnDestroy()
	{
		if (massDying)
		{
			DeathEnd();
		}
	}

	private void Update()
	{
		if (!massDying)
		{
			return;
		}
		base.transform.position = new Vector3(origPos.x + Random.Range(-0.5f, 0.5f), origPos.y + Random.Range(-0.5f, 0.5f), origPos.z + Random.Range(-0.5f, 0.5f));
		if (!(Random.Range(0f, 1f) < Time.deltaTime * 5f))
		{
			return;
		}
		int index = Random.Range(0, transforms.Count);
		if (transforms[index] != null)
		{
			GameObject gore = bsm.GetGore(GoreType.Head, eid);
			if ((bool)gore)
			{
				gore.transform.position = transforms[index].position;
				if (gz != null && gz.goreZone != null)
				{
					gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				}
				if (gore.TryGetComponent<Bloodsplatter>(out var component))
				{
					component.GetReady();
				}
			}
		}
		else
		{
			transforms.RemoveAt(index);
		}
	}

	private void FixedUpdate()
	{
		if (parryFramesLeft > 0)
		{
			parryFramesLeft--;
		}
		if (!affectedByGravity || limp)
		{
			return;
		}
		if (knockedBack && knockBackCharge <= 0f && rb.velocity.magnitude < 1f && gc.onGround)
		{
			StopKnockBack();
		}
		else if (knockedBack)
		{
			if (knockBackCharge <= 0f)
			{
				brakes = Mathf.MoveTowards(brakes, 0f, 0.0005f * brakes);
			}
			if (rb.velocity.y > 0f)
			{
				rb.velocity = new Vector3(rb.velocity.x * 0.95f * brakes, (rb.velocity.y - juggleWeight) * brakes, rb.velocity.z * 0.95f * brakes);
			}
			else
			{
				rb.velocity = new Vector3(rb.velocity.x * 0.95f * brakes, rb.velocity.y - juggleWeight, rb.velocity.z * 0.95f * brakes);
			}
			juggleWeight += 0.00025f;
			nma.updatePosition = false;
			nma.updateRotation = false;
			nma.enabled = false;
			rb.isKinematic = false;
			rb.useGravity = true;
		}
		else if (!grounded && gc.onGround)
		{
			grounded = true;
		}
		else if (grounded && !gc.onGround)
		{
			grounded = false;
		}
		if (!gc.onGround && !falling && !nma.isOnOffMeshLink)
		{
			rb.isKinematic = false;
			rb.useGravity = true;
			nma.enabled = false;
			falling = true;
			anim.SetBool("Falling", value: true);
		}
		else if (gc.onGround && falling)
		{
			if (fallSpeed <= -50f && !InvincibleEnemies.Enabled && !eid.blessed)
			{
				eid.Splatter();
				return;
			}
			fallSpeed = 0f;
			nma.updatePosition = true;
			nma.updateRotation = true;
			rb.isKinematic = true;
			rb.useGravity = false;
			nma.enabled = true;
			nma.Warp(base.transform.position);
			falling = false;
			anim.SetBool("Falling", value: false);
		}
	}

	public void KnockBack(Vector3 force)
	{
		if (affectedByGravity && sb != null && !sb.inAction)
		{
			nma.enabled = false;
			rb.isKinematic = false;
			rb.useGravity = true;
			if (!knockedBack || (!gc.onGround && rb.velocity.y < 0f))
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			}
			if (!gc.onGround)
			{
				rb.AddForce(Vector3.up, ForceMode.VelocityChange);
			}
			rb.AddForce(force / 10f, ForceMode.VelocityChange);
			knockedBack = true;
			knockBackCharge = Mathf.Min(knockBackCharge + force.magnitude / 1500f, 0.35f);
			brakes = 1f;
		}
	}

	public void StopKnockBack()
	{
		if (!(nma != null))
		{
			return;
		}
		if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
		{
			_ = Vector3.zero;
			if (NavMesh.SamplePosition(hitInfo.point, out var hit, 4f, nma.areaMask))
			{
				knockedBack = false;
				nma.updatePosition = true;
				nma.updateRotation = true;
				nma.enabled = true;
				rb.isKinematic = true;
				juggleWeight = 0f;
				nma.Warp(hit.position);
			}
			else
			{
				knockBackCharge = 0.5f;
			}
		}
		else
		{
			knockBackCharge = 0.5f;
		}
	}

	public void GetHurt(GameObject target, Vector3 force, float multiplier, float critMultiplier, Vector3 hurtPos, GameObject sourceWeapon = null, bool fromExplosion = false)
	{
		string hitLimb = "";
		bool dead = false;
		bool flag = false;
		bool flag2 = false;
		float num = 0f;
		GameObject gameObject = null;
		float num2 = health;
		if (massDying || eid == null)
		{
			return;
		}
		if (target.gameObject.CompareTag("Head"))
		{
			num = 1f * multiplier + multiplier * critMultiplier;
			if (extraDamageZones.Count > 0 && extraDamageZones.Contains(target))
			{
				num *= extraDamageMultiplier;
				flag2 = true;
			}
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				gameObject = ((!(num >= 1f) && !(health <= 0f)) ? bsm.GetGore(GoreType.Small, eid, fromExplosion) : bsm.GetGore(GoreType.Head, eid, fromExplosion));
			}
			if (!limp)
			{
				flag = true;
				hitLimb = "head";
			}
			if (health <= 0f && !limp)
			{
				GoLimp();
			}
		}
		else if (target.gameObject.CompareTag("Limb") || target.gameObject.CompareTag("EndLimb"))
		{
			num = 1f * multiplier + 0.5f * multiplier * critMultiplier;
			if (extraDamageZones.Count > 0 && extraDamageZones.Contains(target))
			{
				num *= extraDamageMultiplier;
				flag2 = true;
			}
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				if (eid.hitter == "hammer")
				{
					gameObject = bsm.GetGore(GoreType.Head, eid, fromExplosion);
				}
				else if ((num >= 1f && health > 0f) || (health <= 0f && eid.hitter != "explosion") || (eid.hitter == "explosion" && target.gameObject.CompareTag("EndLimb")))
				{
					gameObject = bsm.GetGore(GoreType.Limb, eid, fromExplosion);
				}
				else if (eid.hitter != "explosion")
				{
					gameObject = bsm.GetGore(GoreType.Small, eid, fromExplosion);
				}
			}
			if (!limp)
			{
				flag = true;
				hitLimb = "limb";
			}
			if (health <= 0f && !limp)
			{
				GoLimp();
			}
		}
		else
		{
			num = 1f * multiplier;
			if (eid.hitter == "shotgunzone" || eid.hitter == "hammerzone")
			{
				if (!parryable && (!partiallyParryable || parryables == null || !parryables.Contains(target.transform)) && (target.gameObject != chest || health - num > 0f))
				{
					num = 0f;
				}
				else if ((parryable && (target.gameObject == chest || MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude > 18f)) || (partiallyParryable && parryables != null && parryables.Contains(target.transform)))
				{
					num *= 1.5f;
					parryable = false;
					partiallyParryable = false;
					parryables.Clear();
					MonoSingleton<NewMovement>.Instance.Parry(eid);
					SendMessage("GotParried", SendMessageOptions.DontRequireReceiver);
				}
			}
			if (extraDamageZones.Count > 0 && extraDamageZones.Contains(target))
			{
				num *= extraDamageMultiplier;
				flag2 = true;
			}
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				if (eid.hitter == "hammer")
				{
					gameObject = bsm.GetGore(GoreType.Head, eid, fromExplosion);
				}
				else if ((num >= 1f && health > 0f) || (health <= 0f && eid.hitter != "explosion") || (eid.hitter == "explosion" && target.gameObject.CompareTag("EndLimb")))
				{
					gameObject = bsm.GetGore(GoreType.Body, eid, fromExplosion);
				}
				else if (eid.hitter != "explosion")
				{
					gameObject = bsm.GetGore(GoreType.Small, eid, fromExplosion);
				}
			}
			if (!limp)
			{
				flag = true;
				hitLimb = "body";
			}
			if (health <= 0f)
			{
				if (!limp)
				{
					GoLimp();
				}
				if ((bool)target && target.GetComponentInParent<Rigidbody>() != null)
				{
					target.GetComponentInParent<Rigidbody>().AddForce(force);
				}
			}
		}
		if (mass != null)
		{
			if (mass.spearShot && (bool)mass.tempSpear && mass.tailHitboxes.Contains(target))
			{
				MassSpear component = mass.tempSpear.GetComponent<MassSpear>();
				if (component != null && component.hitPlayer)
				{
					if (num >= 1f || component.spearHealth - num <= 0f)
					{
						GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion);
						ReadyGib(gore, mass.tailEnd.GetChild(0).gameObject);
					}
					component.spearHealth -= num;
				}
			}
			else if (mass.spearShot && !mass.tempSpear)
			{
				mass.spearShot = false;
			}
		}
		if (gameObject != null)
		{
			if (gz == null)
			{
				gz = GoreZone.ResolveGoreZone(base.transform);
			}
			if (hurtPos != Vector3.zero)
			{
				gameObject.transform.position = hurtPos;
			}
			else
			{
				gameObject.transform.position = target.transform.position;
			}
			if (eid.hitter == "drill")
			{
				gameObject.transform.localScale *= 2f;
			}
			if (bigBlood)
			{
				gameObject.transform.localScale *= 2f;
			}
			if (gz != null && gz.goreZone != null)
			{
				gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
			}
			Bloodsplatter component2 = gameObject.GetComponent<Bloodsplatter>();
			if ((bool)component2)
			{
				ParticleSystem.CollisionModule collision = component2.GetComponent<ParticleSystem>().collision;
				if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone" || eid.hitter == "explosion")
				{
					if (Random.Range(0f, 1f) > 0.5f)
					{
						collision.enabled = false;
					}
					component2.hpAmount = 3;
				}
				else if (eid.hitter == "nail")
				{
					component2.hpAmount = 1;
					component2.GetComponent<AudioSource>().volume *= 0.8f;
				}
				if (!noheal)
				{
					component2.GetReady();
				}
			}
		}
		if ((bool)eid && eid.hitter == "punch")
		{
			bool flag3 = parryables != null && parryables.Count > 0 && parryables.Contains(target.transform);
			if (parryable || (partiallyParryable && (flag3 || (parryFramesLeft > 0 && parryFramesOnPartial))))
			{
				parryable = false;
				partiallyParryable = false;
				parryables.Clear();
				if (!InvincibleEnemies.Enabled && !eid.blessed)
				{
					num = 5f;
				}
				if (!eid.blessed && !InvincibleEnemies.Enabled)
				{
					health -= num;
				}
				MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: true, eid);
				SendMessage("GotParried", SendMessageOptions.DontRequireReceiver);
			}
			else
			{
				parryFramesOnPartial = flag3;
				parryFramesLeft = MonoSingleton<FistControl>.Instance.currentPunch.activeFrames;
			}
		}
		if (flag2 && (num >= 1f || (eid.hitter == "shotgun" && Random.Range(0f, 1f) > 0.5f) || (eid.hitter == "nail" && Random.Range(0f, 1f) > 0.85f)))
		{
			gameObject = ((!(extraDamageMultiplier >= 2f)) ? bsm.GetGore(GoreType.Limb, eid, fromExplosion) : bsm.GetGore(GoreType.Head, eid, fromExplosion));
			if ((bool)gameObject)
			{
				gameObject.transform.position = target.transform.position;
				if (gz != null && gz.goreZone != null)
				{
					gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
				}
				Bloodsplatter component3 = gameObject.GetComponent<Bloodsplatter>();
				if ((bool)component3)
				{
					ParticleSystem.CollisionModule collision2 = component3.GetComponent<ParticleSystem>().collision;
					if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone" || eid.hitter == "explosion")
					{
						if (Random.Range(0f, 1f) > 0.5f)
						{
							collision2.enabled = false;
						}
						component3.hpAmount = 3;
					}
					else if (eid.hitter == "nail")
					{
						component3.hpAmount = 1;
						component3.GetComponent<AudioSource>().volume *= 0.8f;
					}
					if (!noheal)
					{
						component3.GetReady();
					}
				}
			}
		}
		if (health > 0f && hurtSounds.Length != 0 && !eid.blessed)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = hurtSounds[Random.Range(0, hurtSounds.Length)];
			aud.volume = 0.75f;
			aud.pitch = Random.Range(0.85f, 1.35f);
			aud.priority = 12;
			aud.Play();
		}
		if (multiplier == 0f || eid.puppet)
		{
			flag = false;
		}
		if (flag && eid.hitter != "enemy")
		{
			if (scalc == null)
			{
				scalc = MonoSingleton<StyleCalculator>.Instance;
			}
			MinosArm component4 = GetComponent<MinosArm>();
			if (health <= 0f && !component4)
			{
				dead = true;
				if ((bool)gc && !gc.onGround && !eid.flying)
				{
					if (eid.hitter == "explosion" || eid.hitter == "ffexplosion" || eid.hitter == "railcannon")
					{
						scalc.shud.AddPoints(120, "ultrakill.fireworks", sourceWeapon, eid);
					}
					else if (eid.hitter == "ground slam")
					{
						scalc.shud.AddPoints(160, "ultrakill.airslam", sourceWeapon, eid);
					}
					else if (eid.hitter != "deathzone")
					{
						scalc.shud.AddPoints(50, "ultrakill.airshot", sourceWeapon, eid);
					}
				}
			}
			if (eid.hitter != "secret" && (bool)scalc)
			{
				scalc.HitCalculator(eid.hitter, "spider", hitLimb, dead, eid, sourceWeapon);
			}
		}
		if (!woundedMaterial || !(num2 >= originalHealth / 2f) || !(health < originalHealth / 2f))
		{
			return;
		}
		if ((bool)woundedParticle)
		{
			Object.Instantiate(woundedParticle, chest.transform.position, Quaternion.identity);
		}
		if (!eid.puppet)
		{
			smr.material = woundedMaterial;
			if (smr.TryGetComponent<EnemySimplifier>(out var component5))
			{
				component5.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, woundedMaterial);
				component5.ChangeMaterialNew(EnemySimplifier.MaterialState.enraged, woundedEnrageMaterial);
			}
		}
	}

	public void GoLimp()
	{
		if (limp)
		{
			return;
		}
		if (health > 0f)
		{
			health = 0f;
		}
		if (smr != null)
		{
			smr.updateWhenOffscreen = true;
		}
		gz = GetComponentInParent<GoreZone>();
		Invoke("StopHealing", 1f);
		StatueBoss component = GetComponent<StatueBoss>();
		SwingCheck2[] componentsInChildren = GetComponentsInChildren<SwingCheck2>();
		MinosArm component2 = GetComponent<MinosArm>();
		if (component2 != null)
		{
			component2.Retreat();
			limp = true;
			return;
		}
		if (component != null)
		{
			anim.StopPlayback();
			SwingCheck2[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				Object.Destroy(array[i]);
			}
			StatueBoss[] componentsInChildren2 = GoreZone.ResolveGoreZone(base.transform).GetComponentsInChildren<StatueBoss>();
			if (componentsInChildren2.Length != 0)
			{
				StatueBoss[] array2 = componentsInChildren2;
				foreach (StatueBoss statueBoss in array2)
				{
					if (!(statueBoss == component))
					{
						statueBoss.EnrageDelayed();
					}
				}
			}
			component.ForceStopDashSound();
			if (component.currentEnrageEffect != null)
			{
				Object.Destroy(component.currentEnrageEffect);
			}
			Object.Destroy(component);
		}
		else if ((mass != null || massDeath) && !massDying)
		{
			if (mass != null)
			{
				mass.dead = true;
				mass.enabled = false;
				anim.speed = 0f;
				SwingCheck2[] array = componentsInChildren;
				for (int i = 0; i < array.Length; i++)
				{
					Object.Destroy(array[i]);
				}
			}
			origPos = base.transform.position;
			transforms.AddRange(GetComponentsInChildren<Transform>());
			massDying = true;
			Invoke("BloodExplosion", 3f);
			if (mass != null && mass.currentEnrageEffect != null)
			{
				Object.Destroy(mass.currentEnrageEffect);
			}
		}
		if (!eid.dontCountAsKills)
		{
			if (gz != null && gz.checkpoint != null)
			{
				gz.AddDeath();
				gz.checkpoint.sm.kills++;
			}
			else
			{
				MonoSingleton<StatsManager>.Instance.kills++;
			}
		}
		EnemySimplifier[] componentsInChildren3 = GetComponentsInChildren<EnemySimplifier>();
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			componentsInChildren3[i].Begone();
		}
		if (smr != null)
		{
			if (deadMaterial != null)
			{
				smr.sharedMaterial = deadMaterial;
			}
			else if (woundedMaterial != null)
			{
				smr.sharedMaterial = woundedMaterial;
			}
			else
			{
				smr.sharedMaterial = originalMaterial;
			}
		}
		if (specialDeath)
		{
			SendMessage("SpecialDeath", SendMessageOptions.DontRequireReceiver);
		}
		else if (!massDying)
		{
			Object.Destroy(nma);
			nma = null;
			Object.Destroy(anim);
			Object.Destroy(base.gameObject.GetComponent<Collider>());
			if (rb == null)
			{
				rb = GetComponent<Rigidbody>();
			}
			Object.Destroy(rb);
			if (!limp && !eid.dontCountAsKills)
			{
				ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
				if (componentInParent != null)
				{
					componentInParent.AddDeadEnemy();
				}
			}
			if (!limp)
			{
				rbs = GetComponentsInChildren<Rigidbody>();
				Rigidbody[] array3 = rbs;
				foreach (Rigidbody rigidbody in array3)
				{
					if (rigidbody != null && rigidbody != rb)
					{
						rigidbody.isKinematic = false;
						rigidbody.useGravity = true;
						rigidbody.transform.SetParent(gz.transform);
						if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out var component3))
						{
							component3.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
						}
						rigidbody.AddForce(Random.onUnitSphere * 2.5f, ForceMode.VelocityChange);
					}
				}
			}
			if (musicRequested)
			{
				musicRequested = false;
				MonoSingleton<MusicManager>.Instance.PlayCleanMusic();
			}
		}
		if (deathSound != null)
		{
			if (aud == null)
			{
				aud = GetComponent<AudioSource>();
			}
			aud.clip = deathSound;
			aud.volume = 1f;
			aud.pitch = Random.Range(0.85f, 1.35f);
			aud.priority = 11;
			aud.Play();
		}
		limp = true;
	}

	private void StopHealing()
	{
		noheal = true;
	}

	private void BloodExplosion()
	{
		List<Transform> list = new List<Transform>();
		foreach (Transform transform in transforms)
		{
			if (transform != null && Random.Range(0f, 1f) < 0.33f)
			{
				GameObject gore = bsm.GetGore(GoreType.Head, eid);
				if ((bool)gore)
				{
					gore.transform.position = transform.position;
					if (gz != null && gz.goreZone != null)
					{
						gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
					}
					gore.GetComponent<Bloodsplatter>()?.GetReady();
				}
			}
			else if (transform == null)
			{
				list.Add(transform);
			}
		}
		if (list.Count > 0)
		{
			foreach (Transform item in list)
			{
				transforms.Remove(item);
			}
			list.Clear();
		}
		if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && base.gameObject.activeInHierarchy)
		{
			for (int i = 0; i < 40; i++)
			{
				GameObject gib;
				if (i < 30)
				{
					gib = bsm.GetGib(BSType.gib);
					if ((bool)gib)
					{
						if ((bool)gz && (bool)gz.gibZone)
						{
							ReadyGib(gib, transforms[Random.Range(0, transforms.Count)].gameObject);
						}
						gib.transform.localScale *= Random.Range(4f, 7f);
					}
					else
					{
						i = 30;
					}
					continue;
				}
				if (i < 35)
				{
					gib = bsm.GetGib(BSType.eyeball);
					if ((bool)gib)
					{
						if ((bool)gz && (bool)gz.gibZone)
						{
							ReadyGib(gib, transforms[Random.Range(0, transforms.Count)].gameObject);
						}
						gib.transform.localScale *= Random.Range(3f, 6f);
					}
					else
					{
						i = 35;
					}
					continue;
				}
				gib = bsm.GetGib(BSType.brainChunk);
				if (!gib)
				{
					break;
				}
				if ((bool)gz && (bool)gz.gibZone)
				{
					ReadyGib(gib, transforms[Random.Range(0, transforms.Count)].gameObject);
				}
				gib.transform.localScale *= Random.Range(3f, 4f);
			}
		}
		massDying = false;
		DeathEnd();
	}

	private void DeathEnd()
	{
		if (!eid.dontCountAsKills)
		{
			ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
			if (componentInParent != null)
			{
				componentInParent.AddDeadEnemy();
			}
		}
		if (musicRequested)
		{
			MonoSingleton<MusicManager>.Instance.PlayCleanMusic();
		}
		if ((bool)base.gameObject)
		{
			Object.Destroy(base.gameObject);
		}
	}

	private void ReadyGib(GameObject tempGib, GameObject target)
	{
		tempGib.transform.SetPositionAndRotation(target.transform.position, Random.rotation);
		if (!gz)
		{
			gz = GetComponentInParent<GoreZone>();
		}
		tempGib.transform.SetParent(gz.gibZone);
		if (!MonoSingleton<BloodsplatterManager>.Instance.goreOn)
		{
			tempGib.SetActive(value: false);
		}
	}

	public void ParryableCheck(bool partial = false)
	{
		if (partial)
		{
			partiallyParryable = true;
		}
		else
		{
			parryable = true;
		}
		if (parryFramesLeft > 0 && (!partial || parryFramesOnPartial))
		{
			eid.hitter = "punch";
			eid.DeliverDamage(base.gameObject, MonoSingleton<CameraController>.Instance.transform.forward * 25000f, base.transform.position, 1f, tryForExplode: false);
			parryFramesLeft = 0;
		}
	}
}



public class StatueActivator : MonoBehaviour
{
	private void Start()
	{
		base.transform.parent.GetComponentInChildren<StatueFake>().Activate();
		Object.Destroy(base.gameObject);
	}
}



public class StatueBoss : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	private Animator anim;

	private NavMeshAgent nma;

	private NavMeshPath nmp;

	private CameraController cc;

	private Rigidbody rb;

	public bool inAction;

	public Transform stompPos;

	public AssetReference stompWave;

	private bool tracking;

	private bool dashing;

	private float dashPower;

	private GameObject currentStompWave;

	private float meleeRecharge = 1f;

	private float playerInCloseRange;

	private bool dontFall;

	public bool damaging;

	public bool launching;

	public int damage;

	private int tackleChance = 50;

	private int extraTackles;

	private float rangedRecharge = 1f;

	private int throwChance = 50;

	public float attackCheckCooldown = 1f;

	public AssetReference orbProjectile;

	private Light orbLight;

	private Vector3 projectedPlayerPos;

	private bool orbGrowing;

	public GameObject stepSound;

	private ParticleSystem part;

	private AudioSource partAud;

	private Statue st;

	public GameObject backUp;

	public GameObject statueChargeSound;

	public GameObject statueChargeSound2;

	public GameObject statueChargeSound3;

	public bool enraged;

	public GameObject enrageEffect;

	public GameObject currentEnrageEffect;

	private EnemySimplifier[] ensims;

	private int difficulty = -1;

	public LayerMask lmask;

	private SwingCheck2 swingCheck;

	private GroundCheckEnemy gc;

	private EnemyIdentifier eid;

	private Collider enemyCollider;

	private float originalLightRange;

	private float originalNmaRange;

	private float originalNmaSpeed;

	private float originalNmaAcceleration;

	private float originalNmaAngularSpeed;

	private static readonly int WalkSpeed = Animator.StringToHash("WalkSpeed");

	private EnemyTarget target => eid.target;

	public bool isEnraged => enraged;

	public string alterKey => "statue";

	public string alterCategoryName => "statue";

	public AlterOption<bool>[] options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			value = enraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		}
	};

	private void Awake()
	{
		rb = GetComponentInChildren<Rigidbody>();
		part = base.transform.Find("DodgeParticle").GetComponent<ParticleSystem>();
		partAud = part.GetComponent<AudioSource>();
		st = GetComponent<Statue>();
		nma = GetComponentInChildren<NavMeshAgent>();
		anim = GetComponentInChildren<Animator>();
		eid = GetComponent<EnemyIdentifier>();
		gc = GetComponentInChildren<GroundCheckEnemy>();
		enemyCollider = GetComponent<Collider>();
		orbLight = GetComponentInChildren<Light>();
		originalLightRange = orbLight.range;
		originalNmaRange = nma.stoppingDistance;
		originalNmaSpeed = nma.speed;
		originalNmaAcceleration = nma.acceleration;
		originalNmaAngularSpeed = nma.angularSpeed;
		nmp = new NavMeshPath();
	}

	private void Start()
	{
		cc = MonoSingleton<CameraController>.Instance;
		SetSpeed();
		if (inAction)
		{
			StopAction();
		}
		SlowUpdate();
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!nma)
		{
			nma = GetComponentInChildren<NavMeshAgent>();
		}
		if (!anim)
		{
			anim = GetComponentInChildren<Animator>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty >= 4)
		{
			anim.speed = 1.35f;
		}
		else if (difficulty == 3)
		{
			anim.speed = 1.2f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.8f;
		}
		else if (difficulty == 0)
		{
			anim.speed = 0.6f;
		}
		else
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
		if (enraged)
		{
			if (difficulty <= 2)
			{
				anim.speed *= 1.2f;
			}
			else if (difficulty > 3)
			{
				anim.speed = 1.5f * eid.totalSpeedModifier;
			}
			else
			{
				anim.speed = 1.25f * eid.totalSpeedModifier;
			}
			anim.SetFloat("WalkSpeed", 1.5f);
		}
		if ((bool)nma)
		{
			nma.speed = (float)(enraged ? 25 : 5) * eid.totalSpeedModifier;
			nma.acceleration = (float)(enraged ? 120 : 24) * eid.totalSpeedModifier;
			nma.angularSpeed = (float)(enraged ? 6000 : 1200) * eid.totalSpeedModifier;
		}
	}

	private void OnEnable()
	{
		if ((bool)st)
		{
			StopAction();
			StopDamage();
			StopDash();
		}
	}

	private void OnDisable()
	{
		if (currentStompWave != null)
		{
			Object.Destroy(currentStompWave);
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.1f);
		Vector3 a = ((target != null) ? new Vector3(target.position.x, base.transform.position.y, target.position.z) : base.transform.position);
		if (inAction || !nma.isOnNavMesh)
		{
			return;
		}
		if (Vector3.Distance(a, base.transform.position) > 3f)
		{
			if (Physics.Raycast(target.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
			{
				SetDestination(hitInfo.point);
			}
			else
			{
				SetDestination(target.position);
			}
		}
		else
		{
			nma.SetDestination(base.transform.position);
		}
	}

	private void SetDestination(Vector3 position)
	{
		if ((bool)nma && nma.isOnNavMesh)
		{
			NavMesh.CalculatePath(base.transform.position, position, nma.areaMask, nmp);
			nma.SetPath(nmp);
		}
	}

	private void Update()
	{
		if (target == null)
		{
			StopAction();
			StopDamage();
			anim.SetBool("Walking", value: false);
			if (nma.isOnNavMesh && !nma.isStopped)
			{
				nma.isStopped = true;
			}
			return;
		}
		Vector3 vector = new Vector3(target.position.x, base.transform.position.y, target.position.z);
		if (!inAction)
		{
			if (nma.isOnNavMesh && Vector3.Distance(vector, base.transform.position) <= 3f)
			{
				base.transform.LookAt(vector);
			}
			if (nma.enabled && nma.velocity.magnitude > 1f)
			{
				anim.SetBool("Walking", value: true);
			}
			else
			{
				anim.SetBool("Walking", value: false);
			}
		}
		if (attackCheckCooldown > 0f)
		{
			attackCheckCooldown = Mathf.MoveTowards(attackCheckCooldown, 0f, Time.deltaTime);
		}
		if (!inAction && gc.onGround && attackCheckCooldown <= 0f && target != null)
		{
			attackCheckCooldown = 0.2f;
			if (!Physics.Raycast(st.chest.transform.position, target.position - st.chest.transform.position, Vector3.Distance(target.position, st.chest.transform.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				if (meleeRecharge >= 2f || (meleeRecharge >= 1f && Vector3.Distance(base.transform.position, vector) < 15f && (Mathf.Abs(base.transform.position.y - target.position.y) < 9f || (Mathf.Abs(MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().y) > 2f && Mathf.Abs(base.transform.position.y - target.position.y) < 19f))))
				{
					int num = Random.Range(0, 100);
					meleeRecharge = 0f;
					if (target.position.y < base.transform.position.y + 5f && num > tackleChance)
					{
						if (tackleChance < 50)
						{
							tackleChance = 50;
						}
						tackleChance += 20;
						inAction = true;
						Stomp();
					}
					else
					{
						if (tackleChance > 50)
						{
							tackleChance = 50;
						}
						tackleChance -= 20;
						inAction = true;
						Tackle();
					}
				}
				else if (rangedRecharge >= 1f && Vector3.Distance(base.transform.position, vector) >= 9f)
				{
					rangedRecharge = 0f;
					inAction = true;
					Throw();
				}
			}
		}
		if (tracking)
		{
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		}
		if (backUp != null && st.health < 40f)
		{
			backUp.SetActive(value: true);
			backUp = null;
		}
		if (orbGrowing)
		{
			orbLight.range = Mathf.MoveTowards(orbLight.range, originalLightRange, Time.deltaTime * 20f * eid.totalSpeedModifier);
			if (orbLight.range == originalLightRange)
			{
				orbGrowing = false;
			}
		}
		if (rangedRecharge < 1f)
		{
			float num2 = 1f;
			if (Vector3.Distance(base.transform.position, vector) < 15f)
			{
				num2 = 0.5f;
			}
			if (difficulty >= 4)
			{
				num2 += 0.5f;
			}
			else if (difficulty == 1)
			{
				num2 -= 0.2f;
			}
			else if (difficulty == 0)
			{
				num2 -= 0.35f;
			}
			num2 *= eid.totalSpeedModifier;
			if (enraged)
			{
				rangedRecharge = Mathf.MoveTowards(rangedRecharge, 1f, Time.deltaTime * 0.4f * num2);
			}
			else if (st.health < 60f)
			{
				rangedRecharge = Mathf.MoveTowards(rangedRecharge, 1f, Time.deltaTime * 0.15f * num2);
			}
			else if (difficulty > 3)
			{
				rangedRecharge = Mathf.MoveTowards(rangedRecharge, 1f, Time.deltaTime * 0.32f * num2);
			}
			else if (difficulty == 3)
			{
				rangedRecharge = Mathf.MoveTowards(rangedRecharge, 1f, Time.deltaTime * 0.285f * num2);
			}
			else
			{
				rangedRecharge = Mathf.MoveTowards(rangedRecharge, 1f, Time.deltaTime * 0.275f * num2);
			}
		}
		if (!(meleeRecharge < 1f))
		{
			return;
		}
		float num3 = 1f;
		if (Vector3.Distance(base.transform.position, vector) < 9f)
		{
			playerInCloseRange = Mathf.MoveTowards(playerInCloseRange, 1f, Time.deltaTime);
			if (playerInCloseRange >= 1f)
			{
				num3 = 2f;
			}
		}
		else
		{
			playerInCloseRange = Mathf.MoveTowards(playerInCloseRange, 0f, Time.deltaTime);
		}
		if (difficulty >= 4)
		{
			num3 += 0.5f;
		}
		else if (difficulty == 1)
		{
			num3 -= 0.25f;
		}
		else if (difficulty == 0)
		{
			num3 -= 0.5f;
		}
		num3 *= eid.totalSpeedModifier;
		if (enraged)
		{
			if (meleeRecharge < 1f && difficulty >= 2)
			{
				meleeRecharge = 1f;
			}
			else
			{
				meleeRecharge = Mathf.MoveTowards(meleeRecharge, 2f, Time.deltaTime * 0.4f);
			}
		}
		else if (st.health < 60f)
		{
			meleeRecharge = Mathf.MoveTowards(meleeRecharge, 2f, Time.deltaTime * 0.25f * num3);
		}
		else if (difficulty > 3)
		{
			meleeRecharge = Mathf.MoveTowards(meleeRecharge, 2f, Time.deltaTime * 0.4f * num3);
		}
		else if (difficulty == 3)
		{
			meleeRecharge = Mathf.MoveTowards(meleeRecharge, 2f, Time.deltaTime * 0.385f * num3);
		}
		else
		{
			meleeRecharge = Mathf.MoveTowards(meleeRecharge, 2f, Time.deltaTime * 0.375f * num3);
		}
	}

	private void FixedUpdate()
	{
		if (dashPower > 1f)
		{
			Vector3 velocity;
			if (difficulty > 2)
			{
				float num = 1f;
				if (difficulty >= 4)
				{
					num = 1.25f;
				}
				velocity = new Vector3(base.transform.forward.x * dashPower * num * eid.totalSpeedModifier, rb.velocity.y, base.transform.forward.z * dashPower * num * eid.totalSpeedModifier);
				dashPower /= 1.075f;
			}
			else if (difficulty == 2)
			{
				velocity = new Vector3(base.transform.forward.x * dashPower / 1.25f * eid.totalSpeedModifier, rb.velocity.y, base.transform.forward.z * dashPower / 1.25f * eid.totalSpeedModifier);
				dashPower /= 1.065625f;
			}
			else if (difficulty == 1)
			{
				velocity = new Vector3(base.transform.forward.x * dashPower / 1.5f * eid.totalSpeedModifier, rb.velocity.y, base.transform.forward.z * dashPower / 1.5f * eid.totalSpeedModifier);
				dashPower /= 1.05625f;
			}
			else
			{
				velocity = new Vector3(base.transform.forward.x * dashPower / 2f * eid.totalSpeedModifier, rb.velocity.y, base.transform.forward.z * dashPower / 2f * eid.totalSpeedModifier);
				dashPower /= 1.0375f;
			}
			if (enraged || Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward * Mathf.Max(1f, velocity.magnitude * Time.fixedDeltaTime), Vector3.down, out var _, 12f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				rb.velocity = velocity;
			}
			else
			{
				rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			}
			if (rb.velocity.y > 0f || dontFall)
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			}
		}
		else if (dashPower != 0f)
		{
			rb.velocity = Vector3.zero;
			dashPower = 0f;
			damaging = false;
		}
		else if (dontFall)
		{
			rb.velocity = Vector3.zero;
		}
	}

	private void Stomp()
	{
		if (target != null)
		{
			nma.updatePosition = false;
			nma.updateRotation = false;
			nma.enabled = false;
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			anim.SetTrigger("Stomp");
			launching = false;
			Object.Instantiate(statueChargeSound, base.transform.position, Quaternion.identity);
		}
	}

	private void Tackle()
	{
		if (target != null)
		{
			nma.updatePosition = false;
			nma.updateRotation = false;
			nma.enabled = false;
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			tracking = true;
			anim.SetTrigger("Tackle");
			if (difficulty >= 4)
			{
				extraTackles = 1;
			}
			damage = 25;
			launching = true;
			Object.Instantiate(statueChargeSound3, base.transform.position, Quaternion.identity);
		}
	}

	private void Throw()
	{
		if (target != null)
		{
			nma.updatePosition = false;
			nma.updateRotation = false;
			nma.enabled = false;
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			tracking = true;
			anim.SetTrigger("Throw");
			Object.Instantiate(statueChargeSound2, base.transform.position, Quaternion.identity);
		}
	}

	public void StompHit()
	{
		cc.CameraShake(1f);
		if (currentStompWave != null)
		{
			Object.Destroy(currentStompWave);
		}
		int num = 1;
		if (difficulty == 4)
		{
			num = 2;
		}
		if (difficulty == 5)
		{
			num = 3;
		}
		for (int i = 0; i < num; i++)
		{
			currentStompWave = Object.Instantiate(stompWave.ToAsset(), new Vector3(stompPos.position.x, base.transform.position.y, stompPos.position.z), Quaternion.identity);
			PhysicalShockwave component = currentStompWave.GetComponent<PhysicalShockwave>();
			component.damage = 25;
			if (difficulty >= 4)
			{
				component.speed = 75f;
			}
			else if (difficulty == 3)
			{
				component.speed = 50f;
			}
			else if (difficulty == 2)
			{
				component.speed = 35f;
			}
			else if (difficulty == 1)
			{
				component.speed = 25f;
			}
			else if (difficulty == 0)
			{
				component.speed = 15f;
			}
			if (i != 0)
			{
				component.speed /= 1 + i * 2;
				if (component.TryGetComponent<AudioSource>(out var component2))
				{
					component2.enabled = false;
				}
			}
			component.damage = Mathf.RoundToInt((float)component.damage * eid.totalDamageModifier);
			component.maxSize = 100f;
			component.enemy = true;
			component.enemyType = EnemyType.Cerberus;
		}
	}

	public void OrbSpawn()
	{
		GameObject gameObject = Object.Instantiate(orbProjectile.ToAsset(), orbLight.transform.position, Quaternion.identity);
		gameObject.transform.LookAt(projectedPlayerPos);
		if (difficulty > 2)
		{
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 20000f);
		}
		else if (difficulty == 2)
		{
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 15000f);
		}
		else
		{
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * 10000f);
		}
		if (gameObject.TryGetComponent<Projectile>(out var component))
		{
			component.target = eid.target;
			if (difficulty <= 2)
			{
				if (difficulty <= 2)
				{
					component.bigExplosion = false;
				}
				component.damage *= eid.totalDamageModifier;
			}
		}
		orbGrowing = false;
		orbLight.range = 0f;
		part.Play();
	}

	public void OrbRespawn()
	{
		orbGrowing = true;
	}

	public void StopAction()
	{
		if (gc.onGround)
		{
			nma.updatePosition = true;
			nma.updateRotation = true;
			nma.enabled = true;
		}
		tracking = false;
		inAction = false;
	}

	public void StopTracking()
	{
		tracking = false;
		if (target == null)
		{
			return;
		}
		if (target.GetVelocity().magnitude == 0f)
		{
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			projectedPlayerPos = target.position;
			return;
		}
		if (Physics.Raycast(target.position, MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity(), out var hitInfo, MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude * 0.35f / eid.totalSpeedModifier, 4096, QueryTriggerInteraction.Collide) && hitInfo.collider == enemyCollider)
		{
			projectedPlayerPos = target.position;
		}
		else if (Physics.Raycast(target.position, MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity(), out hitInfo, MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().magnitude * 0.35f / eid.totalSpeedModifier, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies), QueryTriggerInteraction.Collide))
		{
			projectedPlayerPos = hitInfo.point;
		}
		else
		{
			projectedPlayerPos = target.position + MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity() * 0.35f / eid.totalSpeedModifier;
			projectedPlayerPos = new Vector3(projectedPlayerPos.x, target.position.y + (target.position.y - projectedPlayerPos.y) * 0.5f, projectedPlayerPos.z);
		}
		base.transform.LookAt(new Vector3(projectedPlayerPos.x, base.transform.position.y, projectedPlayerPos.z));
	}

	public void Dash()
	{
		if (difficulty >= 4)
		{
			dontFall = true;
		}
		rb.velocity = Vector3.zero;
		dashPower = 200f;
		rb.isKinematic = false;
		damaging = true;
		part.Play();
		partAud.Play();
		StartDamage();
	}

	public void StopDash()
	{
		rb.velocity = Vector3.zero;
		dashPower = 0f;
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
		damaging = false;
		partAud.Stop();
		StopDamage();
		if (extraTackles > 0)
		{
			dontFall = true;
			extraTackles--;
			tracking = true;
			anim.speed = 0.1f;
			GameObject obj = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.unparryableFlash, base.transform.position + Vector3.up * 6f + base.transform.forward * 3f, base.transform.rotation);
			obj.transform.localScale *= 5f;
			obj.transform.SetParent(base.transform, worldPositionStays: true);
			anim.Play("Tackle", -1, 0.4f);
			Invoke("DelayedTackle", 0.5f / eid.totalSpeedModifier);
		}
		else
		{
			dontFall = false;
		}
	}

	private void DelayedTackle()
	{
		dontFall = false;
		SetSpeed();
		StopTracking();
	}

	public void ForceStopDashSound()
	{
		partAud.Stop();
	}

	public void StartDamage()
	{
		damaging = true;
		if (swingCheck == null)
		{
			swingCheck = GetComponentInChildren<SwingCheck2>();
		}
		swingCheck.damage = damage;
		swingCheck.DamageStart();
	}

	public void StopDamage()
	{
		damaging = false;
		if (swingCheck == null)
		{
			swingCheck = GetComponentInChildren<SwingCheck2>();
		}
		swingCheck.DamageStop();
	}

	public void Step()
	{
		Object.Instantiate(stepSound, base.transform.position, Quaternion.identity).GetComponent<AudioSource>().pitch = Random.Range(0.9f, 1.1f);
	}

	public void EnrageDelayed()
	{
		if (!enraged)
		{
			Invoke("Enrage", 1f / (eid ? eid.totalSpeedModifier : 1f));
		}
	}

	public void UnEnrage()
	{
		if (!eid.dead && enraged)
		{
			enraged = false;
			if (ensims == null || ensims.Length == 0)
			{
				ensims = GetComponentsInChildren<EnemySimplifier>();
			}
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = false;
			}
			if (currentEnrageEffect != null)
			{
				Object.Destroy(currentEnrageEffect);
			}
			if (difficulty <= 2)
			{
				anim.speed /= 1.2f;
			}
			else if (difficulty > 3)
			{
				anim.speed = 1.5f * eid.totalSpeedModifier;
			}
			else
			{
				anim.speed = 1.25f * eid.totalSpeedModifier;
			}
			orbLight.range = originalLightRange;
			nma.stoppingDistance = originalNmaRange;
			nma.speed = originalNmaSpeed * eid.totalSpeedModifier;
			nma.angularSpeed = originalNmaAngularSpeed * eid.totalSpeedModifier;
			nma.acceleration = originalNmaAcceleration * eid.totalSpeedModifier;
		}
	}

	public void Enrage()
	{
		if (!eid.dead && !enraged)
		{
			enraged = true;
			CancelInvoke("Enrage");
			GameObject obj = Object.Instantiate(statueChargeSound2, base.transform.position, Quaternion.identity);
			obj.GetComponent<AudioSource>().pitch = 0.3f;
			obj.GetComponent<AudioDistortionFilter>().distortionLevel = 0.5f;
			if (difficulty <= 2)
			{
				anim.speed *= 1.2f;
			}
			else if (difficulty > 3)
			{
				anim.speed = 1.5f * eid.totalSpeedModifier;
			}
			else
			{
				anim.speed = 1.25f * eid.totalSpeedModifier;
			}
			orbLight.range *= 2f;
			originalLightRange *= 2f;
			nma.speed = 25f * eid.totalSpeedModifier;
			nma.acceleration = 120f * eid.totalSpeedModifier;
			nma.angularSpeed = 6000f * eid.totalSpeedModifier;
			anim.SetFloat(WalkSpeed, 1.5f);
			currentEnrageEffect = Object.Instantiate(enrageEffect, st.chest.transform);
			currentEnrageEffect.transform.localScale = Vector3.one * 0.4f;
			currentEnrageEffect.transform.localPosition = new Vector3(-0.25f, 0f, 0f);
			if (ensims == null || ensims.Length == 0)
			{
				ensims = GetComponentsInChildren<EnemySimplifier>();
			}
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = true;
			}
		}
	}
}



public class StatueFake : MonoBehaviour
{
	private Animator anim;

	private AudioSource aud;

	private ParticleSystem part;

	public GameObject[] toDeactivate;

	public GameObject enemyObject;

	public bool spawn;

	public GameObject[] toActivate;

	public bool quickSpawn;

	[HideInInspector]
	public bool beingActivated;

	private void Start()
	{
		anim = GetComponentInChildren<Animator>();
		aud = GetComponentInChildren<AudioSource>();
		part = GetComponentInChildren<ParticleSystem>();
		StatueIntroChecker instance = MonoSingleton<StatueIntroChecker>.Instance;
		if (instance != null)
		{
			if (instance.beenSeen)
			{
				quickSpawn = true;
			}
			else if (!quickSpawn)
			{
				instance.beenSeen = true;
			}
		}
		if (quickSpawn)
		{
			anim.speed = 1.5f;
		}
		if (beingActivated)
		{
			Activate();
		}
	}

	public void Activate()
	{
		beingActivated = true;
		if (anim == null)
		{
			anim = GetComponentInChildren<Animator>();
		}
		if (quickSpawn)
		{
			anim.Play("Awaken", -1, 0.33f);
		}
		else
		{
			Invoke("SlowStart", 3f);
		}
	}

	public void Crack()
	{
		aud.Play();
		part.Play();
	}

	public void Done()
	{
		GameObject[] array = toDeactivate;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = toActivate;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		if (spawn)
		{
			Object.Instantiate(enemyObject, base.transform.position + base.transform.forward * 4f, base.transform.rotation);
		}
		Object.Destroy(this);
	}

	private void SlowStart()
	{
		anim.SetTrigger("Awaken");
	}
}


public class StatueIntroChecker : MonoSingleton<StatueIntroChecker>
{
	public bool beenSeen;

	public void BeenSeen()
	{
		beenSeen = true;
	}
}



public class SteamController : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("Steam");

	public static SteamController Instance;

	private Leaderboard? fishBoard;

	[SerializeField]
	private uint appId;

	private static string fishLeaderboard = "Fish Size";

	public static readonly ulong[] BuiltInVerifiedSteamIds = new ulong[2] { 76561198135929436uL, 76561197998177443uL };

	public static int FishSizeMulti
	{
		get
		{
			if (!SteamClient.IsValid)
			{
				return 1;
			}
			if (!BuiltInVerifiedSteamIds.Contains<ulong>(SteamClient.SteamId))
			{
				return 1;
			}
			return 2;
		}
	}

	private void Awake()
	{
		if ((bool)Instance)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		Instance = this;
		base.transform.SetParent(null);
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		try
		{
			SteamClient.Init(appId);
			Log.Info("Steam initialized!");
		}
		catch (Exception)
		{
			Log.Info("Couldn't initialize steam");
		}
	}

	public static async void FetchAvatar(RawImage target, Friend user)
	{
		Steamworks.Data.Image? image = await user.GetMediumAvatarAsync();
		if (image.HasValue)
		{
			Texture2D texture2D = new Texture2D((int)image.Value.Width, (int)image.Value.Height, TextureFormat.RGBA32, mipChain: false);
			texture2D.LoadRawTextureData(image.Value.Data);
			texture2D.Apply();
			target.texture = texture2D;
		}
	}

	public void UpdateTimeInSandbox(float deltaTime)
	{
		if (SteamClient.IsValid)
		{
			deltaTime /= 3600f;
			SteamUserStats.AddStat("sandbox_total_time", deltaTime);
		}
	}

	public void AddToStatInt(string statKey, int amount)
	{
		if (SteamClient.IsValid)
		{
			SteamUserStats.AddStat(statKey, amount);
		}
	}

	public SandboxStats GetSandboxStats()
	{
		if (!SteamClient.IsValid)
		{
			return new SandboxStats();
		}
		return new SandboxStats
		{
			brushesBuilt = SteamUserStats.GetStatInt("sandbox_built_brushes"),
			propsSpawned = SteamUserStats.GetStatInt("sandbox_spawned_props"),
			enemiesSpawned = SteamUserStats.GetStatInt("sandbox_spawned_enemies"),
			hoursSpend = SteamUserStats.GetStatFloat("sandbox_total_time")
		};
	}

	public void UpdateWave(int wave)
	{
		if (SteamClient.IsValid)
		{
			SteamFriends.SetRichPresence("wave", wave.ToString());
		}
	}

	public static async Task<Leaderboard?> FetchSteamLeaderboard(string key, bool createIfNotFound = false, LeaderboardSort sort = LeaderboardSort.Descending, LeaderboardDisplay display = LeaderboardDisplay.TimeMilliSeconds)
	{
		if (createIfNotFound)
		{
			return await SteamUserStats.FindOrCreateLeaderboardAsync(key, sort, display);
		}
		return await SteamUserStats.FindLeaderboardAsync(key);
	}

	public void FetchSceneActivity(string scene)
	{
		if (!SteamClient.IsValid)
		{
			return;
		}
		if (SceneHelper.IsPlayingCustom)
		{
			SteamFriends.SetRichPresence("steam_display", "#AtCustomLevel");
			return;
		}
		StockMapInfo instance = StockMapInfo.Instance;
		if (scene == "Main Menu")
		{
			SteamFriends.SetRichPresence("steam_display", "#AtMainMenu");
		}
		else if (scene == "Endless")
		{
			SteamFriends.SetRichPresence("steam_display", "#AtCyberGrind");
			SteamFriends.SetRichPresence("difficulty", MonoSingleton<PresenceController>.Instance.diffNames[MonoSingleton<PrefsManager>.Instance.GetInt("difficulty")]);
			SteamFriends.SetRichPresence("wave", "0");
		}
		else if (instance != null && !string.IsNullOrEmpty(instance.assets.Deserialize().LargeText))
		{
			SteamFriends.SetRichPresence("steam_display", "#AtStandardLevel");
			SteamFriends.SetRichPresence("difficulty", MonoSingleton<PresenceController>.Instance.diffNames[MonoSingleton<PrefsManager>.Instance.GetInt("difficulty")]);
			SteamFriends.SetRichPresence("level", instance.assets.Deserialize().LargeText);
		}
		else
		{
			SteamFriends.SetRichPresence("steam_display", "#UnknownLevel");
		}
	}

	private void OnApplicationQuit()
	{
		if (SteamClient.IsValid)
		{
			SteamClient.Shutdown();
		}
	}
}



[DefaultExecutionOrder(-300)]
public class StockMapInfo : MapInfoBase
{
	public static StockMapInfo Instance;

	public SerializedActivityAssets assets;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		MapInfoBase.InstanceAnyType = this;
	}
}



public class Streetcleaner : MonoBehaviour
{
	private Animator anim;

	private NavMeshAgent nma;

	private Rigidbody rb;

	public bool dead;

	private TrailRenderer handTrail;

	public LayerMask enviroMask;

	public bool dodging;

	private float dodgeSpeed;

	private float dodgeCooldown;

	public GameObject dodgeSound;

	public Transform hose;

	public Transform hoseTarget;

	public GameObject canister;

	public AssetReference explosion;

	public bool canisterHit;

	public GameObject firePoint;

	private Transform warningFlame;

	private ParticleSystem firePart;

	private Light fireLight;

	private AudioSource fireAud;

	public GameObject fireStopSound;

	public bool damaging;

	private bool attacking;

	public GameObject warningFlash;

	[SerializeField]
	private Transform aimBone;

	private Quaternion torsoDefaultRotation;

	[SerializeField]
	private Transform flameThrowerBone;

	private int difficulty;

	private float cooldown;

	private RaycastHit rhit;

	private GroundCheck playergc;

	private bool playerInAir;

	private GroundCheckEnemy gc;

	private Machine mach;

	[HideInInspector]
	public EnemyIdentifier eid;

	private EnemyTarget target => eid.target;

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
		eid = GetComponent<EnemyIdentifier>();
		anim = GetComponentInChildren<Animator>();
		nma = GetComponent<NavMeshAgent>();
	}

	private void Start()
	{
		if (!dead)
		{
			playergc = MonoSingleton<NewMovement>.Instance.gc;
			handTrail = GetComponentInChildren<TrailRenderer>();
			handTrail.emitting = false;
			warningFlame = firePoint.GetComponentInChildren<SpriteRenderer>().transform;
			warningFlame.localScale = Vector3.zero;
			firePart = firePoint.GetComponentInChildren<ParticleSystem>();
			fireLight = firePoint.GetComponentInChildren<Light>();
			fireLight.enabled = false;
			fireAud = firePoint.GetComponent<AudioSource>();
			torsoDefaultRotation = Quaternion.Inverse(base.transform.rotation) * aimBone.rotation;
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			gc = GetComponentInChildren<GroundCheckEnemy>();
			mach = GetComponent<Machine>();
			SlowUpdate();
		}
	}

	private void OnDisable()
	{
		if (dodging)
		{
			StopMoving();
		}
	}

	private void SlowUpdate()
	{
		if (dead)
		{
			return;
		}
		if (playerInAir && nma != null && nma.enabled && nma.isOnNavMesh && target != null)
		{
			if (Physics.Raycast(target.position + Vector3.up * 0.1f, Vector3.down, out rhit, 20f, enviroMask))
			{
				nma.SetDestination(rhit.point);
			}
			else
			{
				nma.SetDestination(target.position);
			}
		}
		Invoke("SlowUpdate", 0.25f);
	}

	private void Update()
	{
		if (dodgeCooldown != 0f)
		{
			dodgeCooldown = Mathf.MoveTowards(dodgeCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (difficulty <= 2 && cooldown > 0f)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (target == null)
		{
			if (!dead)
			{
				if ((bool)nma && nma.isOnNavMesh)
				{
					nma.isStopped = true;
					nma.ResetPath();
				}
				if ((bool)anim)
				{
					anim.SetBool("Running", value: false);
					anim.SetBool("Walking", value: false);
				}
			}
		}
		else
		{
			if (dead)
			{
				return;
			}
			if (nma.enabled && nma.isOnNavMesh)
			{
				if (target.isPlayer)
				{
					if (playergc != null && !playergc.onGround)
					{
						playerInAir = true;
					}
					else
					{
						playerInAir = false;
						nma.SetDestination(target.position);
					}
				}
				else
				{
					playerInAir = false;
					nma.SetDestination(target.position);
					if (nma.isStopped)
					{
						nma.isStopped = false;
					}
				}
				if ((!attacking && GetDistanceToTarget() > 6f) || (attacking && GetDistanceToTarget() > 16f))
				{
					if (difficulty >= 4)
					{
						anim.SetFloat("RunSpeed", 1.5f);
					}
					else
					{
						anim.SetFloat("RunSpeed", 1f);
					}
					if (difficulty >= 4)
					{
						nma.speed = 24f;
					}
					else if (difficulty >= 2)
					{
						nma.speed = 16f;
					}
					else if (difficulty == 1)
					{
						nma.speed = 14f;
					}
					else if (difficulty == 0)
					{
						nma.speed = 10f;
					}
					nma.speed *= eid.totalSpeedModifier;
					if (attacking)
					{
						StopFire();
					}
				}
				else if (GetDistanceToTarget() < 6f)
				{
					if (difficulty >= 4)
					{
						anim.SetFloat("RunSpeed", 1.25f);
					}
					else
					{
						anim.SetFloat("RunSpeed", 1f);
					}
					if (difficulty >= 4)
					{
						nma.speed = 20f;
					}
					else if (difficulty >= 2)
					{
						nma.speed = 16f;
					}
					else if (difficulty == 1)
					{
						nma.speed = 7f;
					}
					else if (difficulty == 0)
					{
						nma.speed = 1f;
					}
					nma.speed *= eid.totalSpeedModifier;
					if (!attacking && (difficulty > 2 || cooldown <= 0f))
					{
						attacking = true;
						GameObject obj = Object.Instantiate(warningFlash, firePoint.transform.position, firePoint.transform.rotation);
						obj.transform.localScale = Vector3.one * 8f;
						obj.transform.SetParent(firePoint.transform, worldPositionStays: true);
						if (difficulty >= 2)
						{
							Invoke("StartFire", 0.5f / eid.totalSpeedModifier);
						}
						else
						{
							Invoke("StartFire", 1f / eid.totalSpeedModifier);
						}
					}
				}
				float num = 12f;
				if (difficulty == 1)
				{
					num = 10f;
				}
				else if (difficulty == 0)
				{
					num = 4f;
				}
				if (nma.velocity.magnitude > num && !attacking)
				{
					anim.SetBool("Running", value: true);
					anim.SetBool("Walking", value: true);
				}
				else if (nma.velocity.magnitude > 2f)
				{
					anim.SetBool("Running", value: false);
					anim.SetBool("Walking", value: true);
				}
				else
				{
					anim.SetBool("Running", value: false);
					anim.SetBool("Walking", value: false);
				}
			}
			if (damaging)
			{
				TryIgniteStains();
			}
		}
	}

	private void FixedUpdate()
	{
		if (target != null && !dead && dodging)
		{
			rb.velocity = base.transform.forward * -1f * dodgeSpeed * eid.totalSpeedModifier;
			dodgeSpeed = dodgeSpeed * 0.95f / eid.totalSpeedModifier;
		}
	}

	private void LateUpdate()
	{
		if (difficulty >= 4 && attacking && target != null)
		{
			float maxDegreesDelta = ((difficulty == 5) ? 90 : 35);
			Quaternion rotation = aimBone.rotation;
			Quaternion quaternion = Quaternion.RotateTowards(aimBone.rotation, Quaternion.LookRotation(eid.target.headPosition - aimBone.position, Vector3.up), maxDegreesDelta);
			Quaternion quaternion2 = Quaternion.Inverse(base.transform.rotation * torsoDefaultRotation) * aimBone.rotation;
			if (Vector3.Dot(Vector3.up, quaternion * Vector3.forward) > 0f)
			{
				aimBone.rotation = quaternion * quaternion2;
			}
			Quaternion quaternion3 = Quaternion.Inverse(rotation) * aimBone.rotation;
			quaternion3 = Quaternion.Euler(0f - quaternion3.eulerAngles.y, quaternion3.eulerAngles.z, 0f - quaternion3.eulerAngles.x);
			flameThrowerBone.rotation *= quaternion3;
		}
	}

	public void StartFire()
	{
		fireAud.Play();
		firePart.Play();
		fireLight.enabled = true;
		Invoke("StartDamaging", 0.15f / eid.totalSpeedModifier);
		if (difficulty == 0)
		{
			Invoke("StopFire", 0.5f / eid.totalSpeedModifier);
		}
		else if (difficulty <= 2)
		{
			Invoke("StopFire", 1f / eid.totalSpeedModifier);
		}
	}

	public void StartDamaging()
	{
		damaging = true;
	}

	public void StopFire()
	{
		if ((bool)fireAud && fireAud.isPlaying)
		{
			fireAud.Stop();
			Object.Instantiate(fireStopSound, firePoint.transform.position, Quaternion.identity);
		}
		attacking = false;
		CancelInvoke("StartFire");
		CancelInvoke("StartDamaging");
		firePart.Stop();
		fireLight.enabled = false;
		warningFlame.localScale = Vector3.zero;
		damaging = false;
		if (difficulty <= 2)
		{
			if (difficulty == 2)
			{
				cooldown = 1f;
			}
			else if (difficulty == 1)
			{
				cooldown = 1.5f;
			}
			else if (difficulty == 0)
			{
				cooldown = 2f;
			}
			CancelInvoke("StopFire");
		}
	}

	public void Dodge()
	{
		if (!dead && dodgeCooldown == 0f)
		{
			dodgeCooldown = Random.Range(2f, 4f);
			dodgeSpeed = 60f;
			nma.enabled = false;
			rb.isKinematic = false;
			eid.hookIgnore = true;
			StopFire();
			if ((Random.Range(0f, 1f) > 0.5f && !Physics.Raycast(base.transform.position + Vector3.up, base.transform.right * -1f, 5f, enviroMask, QueryTriggerInteraction.Ignore)) || Physics.Raycast(base.transform.position + Vector3.up, base.transform.right, 5f, enviroMask, QueryTriggerInteraction.Ignore))
			{
				base.transform.LookAt(base.transform.position + base.transform.right);
			}
			else
			{
				base.transform.LookAt(base.transform.position + base.transform.right * -1f);
			}
			Object.Instantiate(dodgeSound, base.transform.position, Quaternion.identity);
			anim.SetTrigger("Dodge");
			dodging = true;
		}
	}

	public void StopMoving()
	{
		if (dead)
		{
			return;
		}
		dodging = false;
		nma.enabled = false;
		eid.hookIgnore = false;
		if (gc.onGround)
		{
			rb.isKinematic = true;
			if (NavMesh.SamplePosition(gc.transform.position, out var hit, 4f, 1))
			{
				nma.Warp(hit.position);
				nma.enabled = true;
			}
		}
		rb.velocity = Vector3.zero;
	}

	public void DodgeEnd()
	{
	}

	public void DeflectShot()
	{
		if (!dead)
		{
			anim.SetLayerWeight(1, 1f);
			anim.SetTrigger("Deflect");
			handTrail.emitting = true;
		}
	}

	public void SlapOver()
	{
		if (!dead)
		{
			handTrail.emitting = false;
		}
	}

	public void OverrideOver()
	{
		if (!dead)
		{
			anim.SetLayerWeight(1, 0f);
		}
	}

	private float GetDistanceToTarget()
	{
		float num = Vector3.Distance(base.transform.position, target.position);
		if (target != null && target.isEnemy && target.enemyIdentifier != null)
		{
			num *= target.enemyIdentifier.GetReachDistanceMultiplier();
		}
		return num;
	}

	private void TryIgniteStains()
	{
		Vector3 position = firePoint.transform.position;
		Vector3 forward = firePoint.transform.forward;
		Vector3 worldPosition = position + forward * 3.75f;
		Vector3 worldPosition2 = position + forward * 7.5f;
		Vector3 worldPosition3 = position + forward * 15f;
		StainVoxelManager instance = MonoSingleton<StainVoxelManager>.Instance;
		if (!(instance == null))
		{
			instance.TryIgniteAt(position, 1);
			instance.TryIgniteAt(worldPosition, 1);
			instance.TryIgniteAt(worldPosition2, 1);
			instance.TryIgniteAt(worldPosition3, 1);
		}
	}
}



public class StreetcleanerAnimations : MonoBehaviour
{
	private Streetcleaner sc;

	private AudioSource aud;

	private void Start()
	{
		sc = GetComponentInParent<Streetcleaner>();
		aud = GetComponent<AudioSource>();
	}

	public void SlapOver()
	{
		sc.SlapOver();
	}

	public void OverrideOver()
	{
		sc.OverrideOver();
	}

	public void DodgeEnd()
	{
		sc.DodgeEnd();
	}

	public void StopMoving()
	{
		sc.StopMoving();
	}

	public void Step()
	{
		aud.pitch = Random.Range(0.85f, 1.15f);
		aud.Play();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class StyleCalculator : MonoSingleton<StyleCalculator>
{
	public StyleHUD shud;

	private GameObject player;

	private NewMovement nmov;

	public TMP_Text airTimeText;

	public float airTime = 1f;

	private Vector3 airTimePos;

	private StatsManager sman;

	private GunControl gc;

	public bool enemiesShot;

	public float multikillTimer;

	public int multikillCount;

	private string maxAirTime = "<color=red><size=72>x3.00</size></color>";

	private float lastAirTime;

	private void Start()
	{
		shud = MonoSingleton<StyleHUD>.Instance;
		nmov = MonoSingleton<NewMovement>.Instance;
		player = nmov.gameObject;
		airTimePos = airTimeText.transform.localPosition;
		sman = MonoSingleton<StatsManager>.Instance;
		gc = nmov.GetComponentInChildren<GunControl>();
	}

	private void Update()
	{
		if (!nmov.gc.onGround || nmov.sliding)
		{
			airTime = Mathf.MoveTowards(airTime, 3f, Time.deltaTime * 2f);
			if (!airTimeText.gameObject.activeSelf)
			{
				airTimeText.gameObject.SetActive(value: true);
			}
		}
		else if (!nmov.boost)
		{
			airTime = Mathf.MoveTowards(airTime, 1f, Time.deltaTime * 10f);
			airTimeText.transform.localPosition = airTimePos;
		}
		if (airTime >= 2f && airTime < 3f)
		{
			if (lastAirTime != airTime)
			{
				airTimeText.text = "<color=orange><size=60>x" + airTime.ToString("F2") + "</size></color>";
			}
			airTimeText.transform.localPosition = new Vector3(airTimePos.x + (float)Random.Range(-3, 3), airTimePos.y + (float)Random.Range(-3, 3), airTimePos.z);
		}
		else if (airTime == 3f)
		{
			if (lastAirTime != airTime)
			{
				airTimeText.text = maxAirTime;
			}
			airTimeText.transform.localPosition = new Vector3(airTimePos.x + (float)Random.Range(-6, 6), airTimePos.y + (float)Random.Range(-6, 6), airTimePos.z);
		}
		else if (airTime == 1f && airTimeText.gameObject.activeSelf)
		{
			airTimeText.gameObject.SetActive(value: false);
		}
		else
		{
			if (lastAirTime != airTime)
			{
				airTimeText.text = "x" + airTime.ToString("F2");
			}
			airTimeText.transform.localPosition = airTimePos;
		}
		if (multikillTimer > 0f)
		{
			multikillTimer -= Time.deltaTime * 10f;
		}
		else if (multikillCount != 0)
		{
			multikillTimer = 0f;
			multikillCount = 0;
		}
		lastAirTime = airTime;
	}

	public void HitCalculator(string hitter, string enemyType, string hitLimb, bool dead, EnemyIdentifier eid = null, GameObject sourceWeapon = null)
	{
		if ((eid != null && eid.blessed) || MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			return;
		}
		switch (hitter)
		{
		case "punch":
		case "heavypunch":
			if (dead)
			{
				if (hitLimb == "head" || hitLimb == "limb")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(60, "ultrakill.criticalpunch", eid, sourceWeapon2);
				}
				else if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(150, "ultrakill.bigfistkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(30, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else if (enemyType == "spider")
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "ultrakill.disrespect", eid, sourceWeapon2);
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(20, "", eid, sourceWeapon2);
			}
			break;
		case "ground slam":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "ultrakill.groundslam", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(20, "", eid, sourceWeapon2);
			}
			break;
		case "revolver":
			enemiesShot = true;
			if (dead)
			{
				if (hitLimb == "head" && enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(150, "ultrakill.bigheadshot", eid, sourceWeapon2);
				}
				else if (hitLimb == "head")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(80, "ultrakill.headshot", eid, sourceWeapon2);
				}
				else if (hitLimb == "limb")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(60, "ultrakill.limbhit", eid, sourceWeapon2);
				}
				else if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(30, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else if (hitLimb == "head")
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(25, "", eid, sourceWeapon2);
			}
			else if (hitLimb == "limb")
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(15, "", eid, sourceWeapon2);
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(10, "", eid, sourceWeapon2);
			}
			break;
		case "shotgun":
			enemiesShot = true;
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(45, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(4, "ultrakill.shotgunhit", eid, sourceWeapon2);
			}
			break;
		case "hammer":
			if (dead)
			{
				gc.AddKill();
			}
			break;
		case "shotgunzone":
			enemiesShot = true;
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(125, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.overkill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			break;
		case "nail":
		case "sawblade":
			enemiesShot = true;
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(45, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(2, "ultrakill.nailhit", eid, sourceWeapon2);
			}
			break;
		case "railcannon":
			enemiesShot = true;
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(45, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(15, "", eid, sourceWeapon2);
			}
			break;
		case "zapper":
			enemiesShot = true;
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(175, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(80, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "ultrakill.zapperhit", eid, sourceWeapon2);
			}
			break;
		case "lightningbolt":
			enemiesShot = true;
			Debug.Log("Hit!");
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(300, "ultrakill.lightningbolt", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(250, "ultrakill.lightningbolt", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(200, "ultrakill.lightningbolt", eid, sourceWeapon2);
			}
			break;
		case "projectile":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(250, "ultrakill.friendlyfire", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(200, "ultrakill.friendlyfire", eid, sourceWeapon2);
			}
			break;
		case "ffexplosion":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(250, "ultrakill.friendlyfire", eid, sourceWeapon2);
				sourceWeapon2 = sourceWeapon;
				AddPoints(0, "ultrakill.exploded", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(200, "ultrakill.friendlyfire", eid, sourceWeapon2);
			}
			break;
		case "explosion":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(45, "ultrakill.exploded", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(15, "ultrakill.explosionhit", eid, sourceWeapon2);
			}
			break;
		case "fire":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(20, "FRIED", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(2, "ultrakill.firehit", eid, sourceWeapon2);
			}
			break;
		case "harpoon":
			if (dead)
			{
				if (enemyType == "spider")
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(100, "ultrakill.bigkill", eid, sourceWeapon2);
				}
				else
				{
					GameObject sourceWeapon2 = sourceWeapon;
					AddPoints(45, "ultrakill.kill", eid, sourceWeapon2);
				}
				gc.AddKill();
			}
			break;
		case "chainsawprojectile":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(80, "UNCHAINEDSAW", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(8, "ultrakill.nailhit", eid, sourceWeapon2);
			}
			break;
		case "chainsaw":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "NO-NO", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(4, "ultrakill.nailhit", eid, sourceWeapon2);
			}
			break;
		case "chainsawbounce":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(100, "RE-NO-NO", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(6, "ultrakill.nailhit", eid, sourceWeapon2);
			}
			break;
		case "chainsawzone":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "GROOVY", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(4, "ultrakill.drillhit", eid, sourceWeapon2);
			}
			break;
		case "drill":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(120, "SCREWED", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(4, "ultrakill.drillhit", eid, sourceWeapon2);
			}
			break;
		case "drillpunch":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(120, "ultrakill.drillpunchkill", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(60, "ultrakill.drillpunch", eid, sourceWeapon2);
			}
			break;
		case "cannonball":
			if (dead)
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(75, "ultrakill.cannonballed", eid, sourceWeapon2);
				gc.AddKill();
			}
			else
			{
				GameObject sourceWeapon2 = sourceWeapon;
				AddPoints(25, "", eid, sourceWeapon2);
			}
			break;
		}
		if (dead && !eid.puppet && hitter != "secret")
		{
			AddToMultiKill(sourceWeapon);
		}
	}

	public void AddToMultiKill(GameObject sourceWeapon = null)
	{
		if (MonoSingleton<PlayerTracker>.Instance.playerType != PlayerType.Platformer)
		{
			multikillCount++;
			multikillTimer = 5f;
			switch (multikillCount)
			{
			case 2:
				shud.AddPoints(25, "ultrakill.doublekill", sourceWeapon);
				return;
			case 3:
				shud.AddPoints(50, "ultrakill.triplekill", sourceWeapon);
				return;
			case 0:
			case 1:
				return;
			}
			StyleHUD styleHUD = shud;
			int count = multikillCount;
			styleHUD.AddPoints(100, "ultrakill.multikill", sourceWeapon, null, count);
		}
	}

	private void AddPoints(int points, string pointName, EnemyIdentifier eid, GameObject sourceWeapon = null)
	{
		int num = Mathf.RoundToInt((float)points * airTime - (float)points);
		shud.AddPoints(points + num, pointName, sourceWeapon, eid);
	}
}



public class StyleComboRank : MonoBehaviour
{
	public int rankToReach;

	private void Update()
	{
		if (MonoSingleton<StyleHUD>.Instance.maxReachedRank >= rankToReach)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
	}
}



[Serializable]
public class StyleFreshnessData
{
	public StyleFreshnessState state;

	public string text;

	public float scoreMultiplier;

	public float min;

	public float max;

	public Slider slider;

	public float span => Mathf.Abs(max - min);

	public float justAboveMin => min + span * 0.05f;
}


public enum StyleFreshnessState
{
	Fresh,
	Used,
	Stale,
	Dull
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class StyleHUD : MonoSingleton<StyleHUD>
{
	public Image rankImage;

	public List<StyleRank> ranks;

	public bool showStyleMeter;

	public bool forceMeterOn;

	private int _rankIndex;

	public int maxReachedRank;

	private Queue<string> hudItemsQueue = new Queue<string>();

	private float currentMeter;

	private GameObject styleHud;

	private Slider styleSlider;

	private TMP_Text styleInfo;

	private float rankShaking;

	private Vector3 defaultPos;

	private float rankScale;

	private bool comboActive;

	private StatsManager sman;

	private GunControl gc;

	private float styleNameTime = 0.1f;

	private AudioSource aud;

	[Header("Multipliers")]
	public float bossStyleGainMultiplier = 1.5f;

	public float bossFreshnessDecayMultiplier = 1.5f;

	[Header("Freshness")]
	public bool dualWieldScale;

	public float freshnessDecayPerMove = 0.5f;

	public float freshnessDecayPerSec = 0.25f;

	[Space]
	public float freshnessRegenPerMove = 1f;

	public float freshnessRegenPerSec = 0.5f;

	[Space]
	public List<StyleFreshnessData> freshnessStateData = new List<StyleFreshnessData>();

	private Dictionary<StyleFreshnessState, StyleFreshnessData> freshnessStateDict;

	public TMP_Text freshnessSliderText;

	private float freshnessSliderValue;

	private Dictionary<GameObject, float> weaponFreshness = new Dictionary<GameObject, float>();

	private float minFreshnessCache;

	private int weaponCountCache;

	private Dictionary<int, (float, float)> slotFreshnessLock = new Dictionary<int, (float, float)>();

	public Dictionary<string, float> freshnessDecayMultiplierDict = new Dictionary<string, float>
	{
		{ "ultrakill.shotgunhit", 0.15f },
		{ "ultrakill.nailhit", 0.1f },
		{ "ultrakill.explosionhit", 0.75f },
		{ "ultrakill.exploded", 1.25f },
		{ "ultrakill.kill", 0.3f },
		{ "ultrakill.firehit", 0f },
		{ "ultrakill.quickdraw", 0f },
		{ "ultrakill.projectileboost", 0f },
		{ "ultrakill.doublekill", 0.1f },
		{ "ultrakill.triplekill", 0.1f },
		{ "ultrakill.multikill", 0.1f },
		{ "ultrakill.arsenal", 0f },
		{ "ultrakill.drillhit", 0.025f },
		{ "ultrakill.drillpunch", 1f },
		{ "ultrakill.drillpunchkill", 1f },
		{ "ultrakill.hammerhit", 3f },
		{ "ultrakill.hammerhitheavy", 6f },
		{ "ultrakill.hammerhitred", 8f },
		{ "ultrakill.hammerhityellow", 5f },
		{ "ultrakill.hammerhitgreen", 3f }
	};

	private Dictionary<string, string> idNameDict = new Dictionary<string, string>
	{
		{ "ultrakill.kill", "KILL" },
		{ "ultrakill.doublekill", "<color=orange>DOUBLE KILL</color>" },
		{ "ultrakill.triplekill", "<color=orange>TRIPLE KILL</color>" },
		{ "ultrakill.bigkill", "BIG KILL" },
		{ "ultrakill.bigfistkill", "BIG FISTKILL" },
		{ "ultrakill.headshot", "HEADSHOT" },
		{ "ultrakill.bigheadshot", "BIG HEADSHOT" },
		{ "ultrakill.headshotcombo", "<color=#00ffffff>HEADSHOT COMBO</color>" },
		{ "ultrakill.criticalpunch", "CRITICAL PUNCH" },
		{ "ultrakill.ricoshot", "<color=#00ffffff>RICOSHOT</color>" },
		{ "ultrakill.limbhit", "LIMB HIT" },
		{ "ultrakill.secret", "<color=#00ffffff>SECRET</color>" },
		{ "ultrakill.cannonballed", "CANNONBALLED" },
		{ "ultrakill.cannonballedfrombounce", "<color=green>DUNKED</color>" },
		{ "ultrakill.cannonboost", "<color=green>CANNONBOOST</color>" },
		{ "ultrakill.insurrknockdown", "<color=green>TIME OUT</color>" },
		{ "ultrakill.quickdraw", "<color=#00ffffff>QUICKDRAW</color>" },
		{ "ultrakill.interruption", "<color=green>INTERRUPTION</color>" },
		{ "ultrakill.fistfullofdollar", "<color=#00ffffff>FISTFUL OF DOLLAR</color>" },
		{ "ultrakill.homerun", "HOMERUN" },
		{ "ultrakill.arsenal", "<color=#00ffffff>ARSENAL</color>" },
		{ "ultrakill.catapulted", "<color=#00ffffff>CATAPULTED</color>" },
		{ "ultrakill.splattered", "SPLATTERED" },
		{ "ultrakill.enraged", "<color=red>ENRAGED</color>" },
		{ "ultrakill.instakill", "<color=green>INSTAKILL</color>" },
		{ "ultrakill.fireworks", "<color=#00ffffff>FIREWORKS</color>" },
		{ "ultrakill.fireworksweak", "<color=#00ffffff>JUGGLE</color>" },
		{ "ultrakill.airslam", "<color=#00ffffff>AIR SLAM</color>" },
		{ "ultrakill.airshot", "<color=#00ffffff>AIRSHOT</color>" },
		{ "ultrakill.downtosize", "<color=#00ffffff>DOWN TO SIZE</color>" },
		{ "ultrakill.projectileboost", "<color=green>PROJECTILE BOOST</color>" },
		{ "ultrakill.parry", "<color=green>PARRY</color>" },
		{ "ultrakill.chargeback", "CHARGEBACK" },
		{ "ultrakill.disrespect", "DISRESPECT" },
		{ "ultrakill.groundslam", "GROUND SLAM" },
		{ "ultrakill.overkill", "OVERKILL" },
		{ "ultrakill.friendlyfire", "FRIENDLY FIRE" },
		{ "ultrakill.exploded", "EXPLODED" },
		{ "ultrakill.fried", "FRIED" },
		{ "ultrakill.finishedoff", "<color=#00ffffff>FINISHED OFF</color>" },
		{ "ultrakill.halfoff", "<color=#00ffffff>HALF OFF</color>" },
		{ "ultrakill.mauriced", "MAURICED" },
		{ "ultrakill.bipolar", "BIPOLAR" },
		{ "ultrakill.attripator", "<color=#00ffffff>ATTRAPTOR</color>" },
		{ "ultrakill.nailbombed", "NAILBOMBED" },
		{ "ultrakill.nailbombedalive", "<color=grey>NAILBOMBED</color>" },
		{ "ultrakill.multikill", "<color=orange>MULTIKILL</color>" },
		{ "ultrakill.shotgunhit", "" },
		{ "ultrakill.nailhit", "" },
		{ "ultrakill.explosionhit", "" },
		{ "ultrakill.firehit", "" },
		{ "ultrakill.zapperhit", "" },
		{ "ultrakill.compressed", "COMPRESSED" },
		{ "ultrakill.strike", "<color=#00ffffff>STRIKE!</color>" },
		{ "ultrakill.rocketreturn", "<color=#00ffffff>ROCKET RETURN</color>" },
		{ "ultrakill.roundtrip", "<color=green>ROUND TRIP</color>" },
		{ "ultrakill.serve", "<color=#00ffffff>SERVED</color>" },
		{ "ultrakill.landyours", "<color=green>LANDYOURS</color>" },
		{ "ultrakill.iconoclasm", "ICONOCLASM" },
		{ "ultrakill.drillhit", "" },
		{ "ultrakill.drillpunch", "<color=green>CORKSCREW BLOW</color>" },
		{ "ultrakill.drillpunchkill", "<color=green>GIGA DRILL BREAK</color>" },
		{ "ultrakill.hammerhit", "" },
		{ "ultrakill.hammerhitheavy", "BLASTING AWAY" },
		{ "ultrakill.hammerhitred", "FULL IMPACT" },
		{ "ultrakill.hammerhityellow", "HEAVY HITTER" },
		{ "ultrakill.hammerhitgreen", "BLUNT FORCE" },
		{ "ultrakill.lightningbolt", "<color=green>RIDE THE LIGHTNING</color>" }
	};

	private Coroutine updateItemsRoutine;

	private WaitForSeconds styleWait = new WaitForSeconds(0.05f);

	public StyleRank currentRank => ranks[rankIndex];

	public int rankIndex
	{
		get
		{
			return _rankIndex;
		}
		private set
		{
			_rankIndex = Mathf.Clamp(value, 0, ranks.Count - 1);
			rankImage.sprite = currentRank.sprite;
		}
	}

	private bool freshnessEnabled
	{
		get
		{
			if (!(MonoSingleton<AssistController>.Instance == null))
			{
				if (MonoSingleton<AssistController>.Instance.majorEnabled)
				{
					return !MonoSingleton<AssistController>.Instance.disableWeaponFreshness;
				}
				return true;
			}
			return true;
		}
	}

	public string GetLocalizedName(string id)
	{
		if (!idNameDict.TryGetValue(id, out var value))
		{
			return id;
		}
		return value;
	}

	private void Start()
	{
		styleHud = base.transform.GetChild(0).gameObject;
		styleSlider = GetComponentInChildren<Slider>();
		styleInfo = GetComponentInChildren<TMP_Text>();
		freshnessStateDict = freshnessStateData.ToDictionary((StyleFreshnessData x) => x.state, (StyleFreshnessData x) => x);
		sman = MonoSingleton<StatsManager>.Instance;
		gc = MonoSingleton<GunControl>.Instance;
		weaponFreshness.Clear();
		foreach (GameObject allWeapon in gc.allWeapons)
		{
			if (allWeapon != null)
			{
				weaponFreshness.Add(allWeapon, 10f);
			}
		}
		foreach (StyleFreshnessData freshnessStateDatum in freshnessStateData)
		{
			freshnessStateDatum.slider.minValue = freshnessStateDatum.min;
			freshnessStateDatum.slider.maxValue = freshnessStateDatum.max;
		}
		ComboOver();
		defaultPos = rankImage.transform.localPosition;
		aud = GetComponent<AudioSource>();
	}

	protected override void Awake()
	{
		base.Awake();
		defaultPos = rankImage.transform.localPosition;
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		if (updateItemsRoutine != null)
		{
			StopCoroutine(updateItemsRoutine);
		}
		updateItemsRoutine = StartCoroutine(UpdateItems());
	}

	private void OnDisable()
	{
		if (updateItemsRoutine != null)
		{
			StopCoroutine(updateItemsRoutine);
		}
	}

	private void Update()
	{
		UpdateMeter();
		UpdateFreshness();
		UpdateHUD();
	}

	private IEnumerator UpdateItems()
	{
		while (true)
		{
			if (hudItemsQueue.Count > 0)
			{
				string text = hudItemsQueue.Dequeue();
				styleInfo.text = text + "\n" + styleInfo.text;
				aud?.Play();
				Invoke("RemoveText", 3f);
				yield return styleWait;
			}
			else
			{
				yield return null;
			}
		}
	}

	private void UpdateMeter()
	{
		if (currentMeter > 0f && !comboActive)
		{
			ComboStart();
		}
		if (currentMeter < 0f)
		{
			DescendRank();
		}
		else
		{
			currentMeter -= Time.deltaTime * (currentRank.drainSpeed * 15f);
		}
		bool flag = comboActive || forceMeterOn;
		if (styleHud.activeSelf != flag)
		{
			styleHud.SetActive(flag);
		}
	}

	private void UpdateFreshness()
	{
		if (!comboActive || !freshnessEnabled || !gc.activated)
		{
			return;
		}
		foreach (GameObject allWeapon in gc.allWeapons)
		{
			if (allWeapon == gc.currentWeapon)
			{
				AddFreshness(allWeapon, (0f - freshnessDecayPerSec) * Time.deltaTime);
				if (slotFreshnessLock.TryGetValue(gc.currentSlot, out var value))
				{
					weaponFreshness[allWeapon] = Mathf.Clamp(weaponFreshness[allWeapon], value.Item1, value.Item2);
				}
			}
			else
			{
				AddFreshness(allWeapon, freshnessRegenPerSec * Time.deltaTime);
			}
		}
	}

	private void UpdateHUD()
	{
		styleSlider.value = currentMeter / (float)currentRank.maxMeter;
		if (freshnessEnabled)
		{
			if (!freshnessSliderText.gameObject.activeSelf)
			{
				freshnessSliderText.gameObject.SetActive(value: true);
			}
			if ((bool)gc.currentWeapon)
			{
				float value;
				bool flag = weaponFreshness.TryGetValue(gc.currentWeapon, out value);
				if (!flag)
				{
					Debug.LogWarning("Current weapon not in StyleHUD weaponFreshness dict!!!");
				}
				float t = 30f * Time.deltaTime;
				foreach (KeyValuePair<StyleFreshnessState, StyleFreshnessData> item in freshnessStateDict)
				{
					Slider slider = item.Value.slider;
					if (gc.activated)
					{
						if (slider != null && gc != null && gc.allWeapons.Count > 0 && gc.currentWeapon != null && flag)
						{
							freshnessSliderValue = Mathf.Lerp(freshnessSliderValue, value, t);
						}
						slider.value = freshnessSliderValue;
					}
				}
			}
		}
		else if (freshnessSliderText.gameObject.activeSelf)
		{
			freshnessSliderText.gameObject.SetActive(value: false);
			foreach (StyleFreshnessData freshnessStateDatum in freshnessStateData)
			{
				freshnessStateDatum.slider.gameObject.SetActive(value: false);
			}
		}
		if (styleNameTime > 0f)
		{
			styleNameTime = Mathf.MoveTowards(styleNameTime, 0f, Time.deltaTime * 2f);
		}
		else
		{
			styleNameTime = 0.1f;
		}
		if (rankShaking > 0f)
		{
			rankImage.transform.localPosition = new Vector3(defaultPos.x + rankShaking * (float)Random.Range(-3, 3), defaultPos.y + rankShaking * (float)Random.Range(-3, 3), defaultPos.z);
			rankShaking -= Time.deltaTime * 5f;
		}
		else
		{
			rankImage.transform.localPosition = defaultPos;
		}
		if (rankScale > 0f)
		{
			rankImage.transform.localScale = new Vector3(2f, 1f, 1f) + Vector3.one * rankScale;
			rankScale -= Time.deltaTime;
		}
		else
		{
			rankImage.transform.localScale = new Vector3(2f, 1f, 1f);
		}
	}

	public void RegisterStyleItem(string id, string name)
	{
		idNameDict.Add(id, name);
	}

	public void ComboStart()
	{
		CancelInvoke("ResetFreshness");
		currentMeter = Mathf.Max(currentMeter, currentRank.maxMeter / 4);
		comboActive = true;
	}

	public void ComboOver()
	{
		currentMeter = 0f;
		rankIndex = 0;
		Invoke("ResetFreshness", 10f);
		comboActive = false;
	}

	private void AscendRank()
	{
		while (currentMeter >= (float)currentRank.maxMeter)
		{
			currentMeter -= currentRank.maxMeter;
			rankIndex++;
			if (rankIndex + 1 == ranks.Count - 1)
			{
				break;
			}
		}
		currentMeter = Mathf.Max(currentMeter, currentRank.maxMeter / 4);
		maxReachedRank = Mathf.Max(maxReachedRank, rankIndex);
		DiscordController.UpdateRank(rankIndex);
	}

	private void UpdateFreshnessSlider()
	{
		StyleFreshnessState freshnessState = GetFreshnessState(gc.currentWeapon);
		freshnessSliderText.text = freshnessStateDict[freshnessState].text;
	}

	public void ResetFreshness()
	{
		gc = gc ?? MonoSingleton<GunControl>.Instance;
		foreach (GameObject allWeapon in gc.allWeapons)
		{
			weaponFreshness[allWeapon] = 10f;
		}
	}

	public void SnapFreshnessSlider()
	{
		if (!(gc == null) && !(gc.currentWeapon == null) && weaponFreshness.TryGetValue(gc.currentWeapon, out var value))
		{
			freshnessSliderValue = value;
		}
	}

	public StyleFreshnessState GetFreshnessState(GameObject sourceWeapon)
	{
		StyleFreshnessState result = StyleFreshnessState.Dull;
		if (!weaponFreshness.TryGetValue(sourceWeapon, out var value))
		{
			Debug.LogWarning("Current weapon not in StyleHUD weaponFreshness dict!!!");
			return StyleFreshnessState.Fresh;
		}
		foreach (KeyValuePair<StyleFreshnessState, StyleFreshnessData> item in freshnessStateDict)
		{
			if (value >= item.Value.min)
			{
				result = item.Key;
			}
		}
		return result;
	}

	public void LockFreshness(int slot, float? min = null, float? max = null)
	{
		if (slotFreshnessLock.TryGetValue(slot, out var value))
		{
			Dictionary<int, (float, float)> dictionary = slotFreshnessLock;
			float? num = min;
			float item;
			if (!num.HasValue)
			{
				(item, _) = value;
			}
			else
			{
				item = num.GetValueOrDefault();
			}
			dictionary[slot] = (item, max ?? value.Item2);
		}
		else
		{
			slotFreshnessLock.Add(slot, (min ?? 0f, max ?? 10f));
		}
	}

	public void LockFreshness(int slot, StyleFreshnessState? minState = null, StyleFreshnessState? maxState = null)
	{
		StyleFreshnessData styleFreshnessData = (maxState.HasValue ? freshnessStateDict[maxState.Value] : null);
		StyleFreshnessData styleFreshnessData2 = (minState.HasValue ? freshnessStateDict[minState.Value] : null);
		float value = 0f;
		float value2 = 10f;
		if (styleFreshnessData2 != null)
		{
			value = styleFreshnessData2.justAboveMin;
		}
		if (styleFreshnessData != null)
		{
			value2 = styleFreshnessData.max - 0.01f;
		}
		LockFreshness(slot, value, value2);
	}

	public void UnlockFreshness(int slot)
	{
		slotFreshnessLock.Remove(slot);
	}

	private void ClampFreshness(GameObject sourceWeapon, float amt)
	{
		float max = 10f;
		UpdateMinFreshnessCache(gc.allWeapons.Count);
		float num = minFreshnessCache;
		if (sourceWeapon == gc.currentWeapon && slotFreshnessLock.TryGetValue(gc.currentSlot, out var value))
		{
			num = Mathf.Max(num, value.Item1);
			max = value.Item2;
		}
		weaponFreshness[sourceWeapon] = Mathf.Clamp(amt, num, max);
	}

	public void UpdateMinFreshnessCache(int count)
	{
		if (weaponCountCache == count)
		{
			return;
		}
		weaponCountCache = count;
		if (SummonSandboxArm.armSlot.Count > 0)
		{
			count--;
		}
		if (count <= 1)
		{
			minFreshnessCache = freshnessStateDict[StyleFreshnessState.Fresh].max;
			return;
		}
		switch (count)
		{
		case 2:
			minFreshnessCache = freshnessStateDict[StyleFreshnessState.Used].justAboveMin;
			break;
		case 3:
		case 4:
			minFreshnessCache = freshnessStateDict[StyleFreshnessState.Stale].justAboveMin;
			break;
		default:
			minFreshnessCache = freshnessStateDict[StyleFreshnessState.Dull].justAboveMin;
			break;
		}
	}

	public float GetFreshness(GameObject sourceWeapon)
	{
		return weaponFreshness[sourceWeapon];
	}

	public void SetFreshness(GameObject sourceWeapon, float amt)
	{
		ClampFreshness(sourceWeapon, amt);
		if (sourceWeapon == gc?.currentWeapon)
		{
			UpdateFreshnessSlider();
		}
	}

	public void AddFreshness(GameObject sourceWeapon, float amt)
	{
		float num = amt;
		int dualWieldCount = gc.dualWieldCount;
		if (dualWieldScale && dualWieldCount > 0)
		{
			num /= (float)(dualWieldCount + 1);
		}
		SetFreshness(sourceWeapon, GetFreshness(sourceWeapon) + num);
	}

	public void DecayFreshness(GameObject sourceWeapon, string pointID, bool boss)
	{
		if (!weaponFreshness.TryGetValue(sourceWeapon, out var value))
		{
			Debug.LogWarning($"Weapon {sourceWeapon} not in StyleHUD weaponFreshness dict");
			return;
		}
		float num = freshnessDecayPerMove;
		float num2 = gc.dualWieldCount;
		if (dualWieldScale && num2 > 0f)
		{
			num /= num2 + 1f;
		}
		if (freshnessDecayMultiplierDict.TryGetValue(pointID, out var value2))
		{
			num *= value2;
		}
		if (boss)
		{
			num *= bossFreshnessDecayMultiplier;
		}
		SetFreshness(sourceWeapon, value - num);
		int num3 = gc.slotDict[sourceWeapon];
		foreach (GameObject allWeapon in gc.allWeapons)
		{
			if (!(allWeapon == sourceWeapon) && gc.slotDict[allWeapon] != num3)
			{
				float num4 = freshnessRegenPerMove;
				if (value2 > 0f)
				{
					num4 *= value2;
				}
				AddFreshness(allWeapon, num4);
			}
		}
		if (sourceWeapon == gc?.currentWeapon)
		{
			UpdateFreshnessSlider();
		}
	}

	public void DescendRank()
	{
		if (comboActive)
		{
			if (rankIndex > 0)
			{
				currentMeter = currentRank.maxMeter;
				rankIndex--;
				rankImage.sprite = ranks[rankIndex].sprite;
				currentMeter = currentRank.maxMeter - currentRank.maxMeter / 4;
			}
			else if (rankIndex == 0)
			{
				ComboOver();
			}
			DiscordController.UpdateRank(rankIndex);
		}
	}

	public void AddPoints(int points, string pointID, GameObject sourceWeapon = null, EnemyIdentifier eid = null, int count = -1, string prefix = "", string postfix = "")
	{
		GameObject gameObject = ((pointID == "ultrakill.arsenal") ? gc.currentWeapon : sourceWeapon);
		if ((bool)eid && eid.puppet)
		{
			return;
		}
		bool flag = false;
		if ((bool)eid)
		{
			flag = eid.isBoss;
		}
		if (points > 0)
		{
			float num = points;
			if (freshnessEnabled && gameObject != null)
			{
				StyleFreshnessState freshnessState = GetFreshnessState(gameObject);
				num *= freshnessStateDict[freshnessState].scoreMultiplier;
				DecayFreshness(gameObject, pointID, flag);
			}
			if (flag)
			{
				num *= bossStyleGainMultiplier;
			}
			sman.stylePoints += Mathf.RoundToInt(num);
			currentMeter += num;
			rankScale = 0.2f;
		}
		string localizedName = GetLocalizedName(pointID);
		if (localizedName != "")
		{
			if (count >= 0)
			{
				hudItemsQueue.Enqueue("+ " + prefix + localizedName + postfix + " x" + count);
			}
			else
			{
				hudItemsQueue.Enqueue("+ " + prefix + localizedName + postfix);
			}
		}
		if (currentMeter >= (float)currentRank.maxMeter && rankIndex < 7)
		{
			AscendRank();
		}
		else if (currentMeter > (float)currentRank.maxMeter)
		{
			currentMeter = currentRank.maxMeter;
		}
	}

	public void RemovePoints(int points)
	{
		rankShaking = 5f;
		currentMeter -= points;
	}

	public void ResetFreshness(GameObject weapon)
	{
		if (weaponFreshness.ContainsKey(weapon))
		{
			weaponFreshness[weapon] = 10f;
		}
	}

	public void ResetAllFreshness()
	{
		foreach (GameObject allWeapon in gc.allWeapons)
		{
			ResetFreshness(allWeapon);
		}
	}

	private void RemoveText()
	{
		styleInfo.text = styleInfo.text.Substring(0, styleInfo.text.LastIndexOf("+"));
	}
}



[Serializable]
public class StyleRank
{
	public Sprite sprite;

	public int maxMeter;

	public float drainSpeed;
}



public class SubDoor : MonoBehaviour
{
	public SubDoorType type;

	public Vector3 openPos;

	public Vector3 origPos;

	public Vector3 targetPos;

	public float speed = 1f;

	public bool playerSpeedMultiplier;

	[HideInInspector]
	public bool valuesSet;

	[HideInInspector]
	public bool isOpen;

	[HideInInspector]
	public AudioSource aud;

	private float origPitch;

	public Door dr;

	[HideInInspector]
	public Animator anim;

	public AudioClip[] sounds;

	public AudioClip openSound;

	public AudioClip stopSound;

	public UltrakillEvent[] animationEvents;

	private void Awake()
	{
		SetValues();
	}

	private void Update()
	{
		if (type == SubDoorType.Animation)
		{
			if (!anim)
			{
				return;
			}
			float normalizedTime = anim.GetCurrentAnimatorStateInfo(0).normalizedTime;
			if (normalizedTime > 1f)
			{
				anim.Play(0, -1, 1f);
				anim.SetFloat("Speed", 0f);
				if ((bool)aud)
				{
					PlayStopSound();
				}
			}
			else if (normalizedTime < 0f)
			{
				anim.Play(0, -1, 0f);
				anim.SetFloat("Speed", 0f);
				if ((bool)aud)
				{
					PlayStopSound();
				}
			}
		}
		else
		{
			if (!(base.transform.localPosition != targetPos))
			{
				return;
			}
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Time.deltaTime * (playerSpeedMultiplier ? Mathf.Max(speed, speed * (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 15f)) : speed));
			if (!(base.transform.localPosition == targetPos))
			{
				return;
			}
			if (targetPos == origPos)
			{
				dr?.BigDoorClosed();
			}
			else
			{
				dr?.onFullyOpened?.Invoke();
			}
			if ((bool)aud)
			{
				if ((bool)stopSound)
				{
					aud.clip = stopSound;
					aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
					aud.Play();
				}
				else
				{
					aud.Stop();
				}
			}
		}
	}

	public void Open()
	{
		SetValues();
		isOpen = true;
		if (type == SubDoorType.Animation)
		{
			if ((bool)aud && anim.GetFloat("Speed") != speed)
			{
				if ((bool)openSound)
				{
					aud.clip = openSound;
				}
				aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
				aud.Play();
			}
			anim.SetFloat("Speed", playerSpeedMultiplier ? Mathf.Max(speed, speed * (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 15f)) : speed);
			return;
		}
		targetPos = origPos + openPos;
		if ((bool)aud && base.transform.localPosition != targetPos)
		{
			if ((bool)openSound)
			{
				aud.clip = openSound;
			}
			aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
			aud.Play();
		}
	}

	public void Close()
	{
		SetValues();
		isOpen = false;
		if (type == SubDoorType.Animation)
		{
			if ((bool)aud && anim.GetFloat("Speed") != 0f - speed)
			{
				if ((bool)openSound)
				{
					aud.clip = openSound;
				}
				aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
				aud.Play();
			}
			anim.SetFloat("Speed", 0f - (playerSpeedMultiplier ? Mathf.Max(speed, speed * (MonoSingleton<NewMovement>.Instance.rb.velocity.magnitude / 15f)) : speed));
			return;
		}
		targetPos = origPos;
		if ((bool)aud && base.transform.localPosition != targetPos)
		{
			if ((bool)openSound)
			{
				aud.clip = openSound;
			}
			aud.pitch = origPitch + Random.Range(-0.1f, 0.1f);
			aud.Play();
		}
	}

	public void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			origPos = base.transform.localPosition;
			targetPos = origPos;
			aud = GetComponent<AudioSource>();
			if ((bool)aud)
			{
				origPitch = aud.pitch;
			}
			if (type == SubDoorType.Animation)
			{
				anim = GetComponent<Animator>();
			}
		}
	}

	public void AnimationEvent(int i)
	{
		animationEvents[i].Invoke();
	}

	public void PlaySound(int targetSound)
	{
		if (!(aud.clip == sounds[targetSound]) || !aud.isPlaying)
		{
			aud.clip = sounds[targetSound];
			aud.loop = true;
			aud.Play();
		}
	}

	public void PlayStopSound()
	{
		if ((bool)aud)
		{
			if ((bool)stopSound)
			{
				aud.loop = false;
				aud.clip = stopSound;
				aud.Play();
			}
			else if (aud.isPlaying)
			{
				aud.Stop();
			}
		}
	}
}


public enum SubDoorType
{
	Standard,
	Animation
}



public class Subtitle : MonoBehaviour
{
	public AudioSource distanceCheckObject;

	public Subtitle nextInChain;

	[SerializeField]
	private float fadeInSpeed = 0.001f;

	[SerializeField]
	private float holdForBase = 2f;

	[SerializeField]
	private float holdForPerChar = 0.1f;

	[SerializeField]
	private float fadeOutSpeed = 0.0001f;

	[SerializeField]
	private float paddingHorizontal;

	[SerializeField]
	private TMP_Text uiText;

	private CanvasGroup group;

	private float currentAlpha;

	private bool isFadingIn;

	private bool chainContinue;

	private float holdFor;

	private bool isFadingOut;

	private TimeSince holdingSince;

	private RectTransform rectTransform;

	private float baseAlpha = 1f;

	private void Awake()
	{
		group = GetComponent<CanvasGroup>();
		rectTransform = GetComponent<RectTransform>();
	}

	private void OnEnable()
	{
		Fit();
		string text = new Regex("<[^>]*>").Replace(uiText.text, "");
		holdFor = holdForBase + (float)text.Length * holdForPerChar;
		currentAlpha = 0f;
		isFadingIn = true;
	}

	public void ContinueChain()
	{
		chainContinue = true;
	}

	private void Update()
	{
		if (distanceCheckObject == null)
		{
			baseAlpha = 1f;
		}
		else
		{
			float num = Vector3.Distance(MonoSingleton<CameraController>.Instance.transform.position, distanceCheckObject.transform.position);
			float num2 = distanceCheckObject.minDistance + (distanceCheckObject.maxDistance - distanceCheckObject.minDistance) * 0.5f;
			if (num <= num2)
			{
				baseAlpha = 1f;
			}
			else
			{
				float num3 = num - num2;
				float num4 = distanceCheckObject.maxDistance - num2;
				float num5 = Mathf.Clamp01(num3 / num4);
				switch (distanceCheckObject.rolloffMode)
				{
				case AudioRolloffMode.Custom:
					baseAlpha = distanceCheckObject.GetCustomCurve(AudioSourceCurveType.CustomRolloff).Evaluate(num5);
					break;
				case AudioRolloffMode.Linear:
					baseAlpha = 1f - num5;
					break;
				case AudioRolloffMode.Logarithmic:
					baseAlpha = 1f - Mathf.Clamp01(Mathf.Log10(num3) / Mathf.Log10(num4));
					break;
				}
			}
		}
		if (isFadingIn)
		{
			currentAlpha += fadeInSpeed * Time.deltaTime;
			if (currentAlpha >= 1f)
			{
				currentAlpha = 1f;
				isFadingIn = false;
				holdingSince = 0f;
			}
			group.alpha = currentAlpha * baseAlpha;
			return;
		}
		if (isFadingOut)
		{
			currentAlpha -= fadeOutSpeed * Time.deltaTime;
			if (currentAlpha <= 0f)
			{
				Object.Destroy(base.gameObject);
			}
			group.alpha = currentAlpha * baseAlpha;
			return;
		}
		if (distanceCheckObject != null)
		{
			group.alpha = currentAlpha * baseAlpha;
		}
		if ((float)holdingSince > holdFor && chainContinue)
		{
			isFadingOut = true;
			MonoSingleton<SubtitleController>.Instance.NotifyHoldEnd(this);
			if ((bool)nextInChain)
			{
				nextInChain.ContinueChain();
			}
		}
	}

	private void Fit()
	{
		StartCoroutine(FitAsync());
	}

	private IEnumerator FitAsync()
	{
		yield return new WaitForFixedUpdate();
		float preferredSize = LayoutUtility.GetPreferredSize(uiText.rectTransform, 0);
		uiText.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, preferredSize);
		rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, preferredSize + paddingHorizontal * 2f);
	}
}



public class SubtitleController : MonoSingleton<SubtitleController>
{
	public class SubtitleData
	{
		public string caption;

		public float time;

		public GameObject origin;
	}

	[SerializeField]
	private Transform container;

	[SerializeField]
	private Subtitle subtitleLine;

	private Subtitle previousSubtitle;

	private List<SubtitleData> delayedSubs = new List<SubtitleData>();

	private bool subtitlesEnabled;

	public bool SubtitlesEnabled
	{
		get
		{
			if (subtitlesEnabled)
			{
				return !HideUI.Active;
			}
			return false;
		}
		set
		{
			subtitlesEnabled = value;
		}
	}

	private void Start()
	{
		SubtitlesEnabled = MonoSingleton<PrefsManager>.Instance.GetBool("subtitlesEnabled");
	}

	private void Update()
	{
		if (delayedSubs.Count <= 0)
		{
			return;
		}
		for (int num = delayedSubs.Count - 1; num >= 0; num--)
		{
			if (delayedSubs[num] == null || delayedSubs[num].origin == null || !delayedSubs[num].origin.activeInHierarchy)
			{
				delayedSubs.RemoveAt(num);
			}
			else
			{
				delayedSubs[num].time = Mathf.MoveTowards(delayedSubs[num].time, 0f, Time.deltaTime);
				if (delayedSubs[num].time <= 0f)
				{
					DisplaySubtitle(delayedSubs[num].caption);
					delayedSubs.RemoveAt(num);
				}
			}
		}
	}

	public void NotifyHoldEnd(Subtitle self)
	{
		if (previousSubtitle == self)
		{
			previousSubtitle = null;
		}
	}

	public void DisplaySubtitleTranslated(string translationKey)
	{
		_ = SubtitlesEnabled;
	}

	public void DisplaySubtitle(string caption, AudioSource audioSource = null, bool ignoreSetting = false)
	{
		if (ignoreSetting ? (!HideUI.Active) : SubtitlesEnabled)
		{
			Subtitle subtitle = Object.Instantiate(subtitleLine, container, worldPositionStays: true);
			subtitle.GetComponentInChildren<TMP_Text>().text = caption;
			if (audioSource != null)
			{
				subtitle.distanceCheckObject = audioSource;
			}
			subtitle.gameObject.SetActive(value: true);
			if (!previousSubtitle)
			{
				subtitle.ContinueChain();
			}
			else
			{
				previousSubtitle.nextInChain = subtitle;
			}
			previousSubtitle = subtitle;
		}
	}

	public void DisplaySubtitle(string caption, float time, GameObject origin)
	{
		SubtitleData subtitleData = new SubtitleData();
		subtitleData.caption = caption;
		subtitleData.time = time;
		subtitleData.origin = origin;
		delayedSubs.Add(subtitleData);
	}

	public void CancelSubtitle(GameObject origin)
	{
		if (delayedSubs.Count <= 0)
		{
			return;
		}
		for (int num = delayedSubs.Count - 1; num >= 0; num--)
		{
			if (delayedSubs[num].origin == origin)
			{
				delayedSubs.RemoveAt(num);
			}
		}
	}
}



[RequireComponent(typeof(AudioSource))]
public class SubtitledAudioSource : MonoBehaviour
{
	[Serializable]
	public class SubtitleData
	{
		public SubtitleDataLine[] lines;
	}

	[Serializable]
	public class SubtitleDataLine
	{
		public string subtitle;

		public float time;
	}

	[SerializeField]
	private SubtitleData subtitles;

	[SerializeField]
	private bool distanceAware;

	private AudioSource audioSource;

	private int currentVoiceLine;

	private float lastAudioTime;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void OnEnable()
	{
		if (audioSource.playOnAwake)
		{
			currentVoiceLine = 0;
		}
	}

	private void Update()
	{
		if (audioSource.time < lastAudioTime)
		{
			currentVoiceLine = 0;
		}
		if (audioSource.isPlaying && subtitles.lines.Length > currentVoiceLine)
		{
			if (audioSource.time >= subtitles.lines[currentVoiceLine].time)
			{
				MonoSingleton<SubtitleController>.Instance.DisplaySubtitle(subtitles.lines[currentVoiceLine].subtitle, distanceAware ? audioSource : null);
				currentVoiceLine++;
			}
			lastAudioTime = audioSource.time;
		}
	}
}


public enum SummonedSwordFormation
{
	Spiral
}



public class SummonedSwords : MonoBehaviour
{
	public EnemyTarget target;

	private bool inFormation;

	private SummonedSwordFormation formation;

	private Projectile[] swords;

	public float speed = 1f;

	[HideInInspector]
	public EnemyTarget targetEnemy;

	private int difficulty;

	private bool spinning;

	private void Start()
	{
		swords = GetComponentsInChildren<Projectile>();
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		Invoke("Begin", 5f * speed);
	}

	private void FixedUpdate()
	{
		if (!inFormation)
		{
			if (target != null)
			{
				base.transform.position = target.position;
			}
			base.transform.Rotate(Vector3.up, Time.deltaTime * 720f * speed, Space.Self);
		}
		else if (formation == SummonedSwordFormation.Spiral)
		{
			base.transform.position = target.position;
			if (spinning)
			{
				base.transform.Rotate(Vector3.up, Time.deltaTime * 720f * speed, Space.Self);
			}
		}
	}

	private void Begin()
	{
		Projectile[] array;
		if (difficulty > 3)
		{
			inFormation = true;
			target = targetEnemy;
			base.transform.position = target.position;
			array = swords;
			foreach (Projectile projectile in array)
			{
				if ((bool)projectile)
				{
					projectile.target = target;
					projectile.transform.localPosition += projectile.transform.forward * 5f;
					projectile.transform.Rotate(Vector3.up, 180f, Space.World);
				}
			}
			spinning = true;
			Invoke("StopSpinning", 0.75f * speed);
			Invoke("SpiralStab", 1f * speed);
			return;
		}
		array = swords;
		foreach (Projectile projectile2 in array)
		{
			if ((bool)projectile2)
			{
				Object.Instantiate(projectile2.explosionEffect, projectile2.transform.position, Quaternion.identity);
			}
		}
		Object.Destroy(base.gameObject);
	}

	private void SpiralStab()
	{
		Projectile[] array = swords;
		foreach (Projectile projectile in array)
		{
			if ((bool)projectile)
			{
				if (projectile.TryGetComponent<Collider>(out var component))
				{
					component.enabled = true;
				}
				projectile.speed = 150f;
			}
		}
		Object.Destroy(base.gameObject);
	}

	private void StopSpinning()
	{
		spinning = false;
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, base.transform.position, Quaternion.identity);
		Projectile[] array = swords;
		foreach (Projectile projectile in array)
		{
			if ((bool)projectile)
			{
				Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.parryableFlash, projectile.transform.position, projectile.transform.rotation).transform.localScale *= 10f;
				if (projectile.TryGetComponent<Collider>(out var component))
				{
					component.enabled = false;
				}
				projectile.transform.SetParent(null, worldPositionStays: true);
				projectile.unparryable = false;
				projectile.undeflectable = false;
			}
		}
	}
}



public class SwingCheck2 : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("SwingCheck2");

	[HideInInspector]
	public EnemyIdentifier eid;

	public EnemyType type;

	public List<Collider> hitColliders = new List<Collider>();

	private NewMovement nmov;

	public int damage;

	public int enemyDamage;

	public float knockBackForce;

	public bool knockBackDirectionOverride;

	public Vector3 knockBackDirection;

	private LayerMask lmask;

	private List<EnemyIdentifier> hitEnemies = new List<EnemyIdentifier>();

	public bool strong;

	[HideInInspector]
	public Collider col;

	public Collider[] additionalColliders;

	public bool useRaycastCheck;

	private AudioSource aud;

	private bool physicalCollider;

	[HideInInspector]
	public bool damaging;

	public bool ignoreSlidingPlayer;

	public bool canHitPlayerMultipleTimes;

	public bool startActive;

	public bool interpolateBetweenFrames;

	public Transform checkForCollisionsBetween;

	private Vector3 previousPosition;

	private SwingCheckDebugOverlay debugOverlay;

	private bool hasPrinted;

	private bool playerOnly
	{
		get
		{
			if (!(eid == null) && eid.target != null)
			{
				return eid.target.isPlayer;
			}
			return true;
		}
	}

	private LayerMask relevantLMask => lmask;

	private void Awake()
	{
		col = GetComponent<Collider>();
		aud = GetComponent<AudioSource>();
		lmask = (int)lmask | 0x100;
		lmask = (int)lmask | 0x1000000;
	}

	private void Start()
	{
		if (!eid)
		{
			eid = GetComponentInParent<EnemyIdentifier>();
		}
		if ((bool)eid)
		{
			type = eid.enemyType;
		}
		if (!col.isTrigger)
		{
			physicalCollider = true;
		}
		else if (!startActive)
		{
			col.enabled = false;
		}
		else
		{
			DamageStart();
		}
		if (interpolateBetweenFrames)
		{
			previousPosition = base.transform.position;
		}
	}

	private void OnEnable()
	{
		if (startActive && (bool)col)
		{
			col.enabled = true;
			DamageStart();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (damaging)
		{
			CheckCollision(other);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (damaging)
		{
			CheckCollision(collision.collider);
		}
	}

	private void Update()
	{
		if ((interpolateBetweenFrames || (bool)checkForCollisionsBetween) && damaging && (bool)col.attachedRigidbody)
		{
			if (interpolateBetweenFrames)
			{
				if (Input.GetKey(KeyCode.Alpha7) && !hasPrinted)
				{
					hasPrinted = true;
					Object.Instantiate(new GameObject("previousPosition"), previousPosition, Quaternion.identity);
					Object.Instantiate(new GameObject("position"), base.transform.position, Quaternion.identity);
					Object.Instantiate(new GameObject("rigidbodyPosition"), col.attachedRigidbody.position, Quaternion.identity);
					Object.Instantiate(new GameObject("checkForCollisionBetween"), checkForCollisionsBetween.position, Quaternion.identity);
				}
				RaycastHit[] array = col.attachedRigidbody.SweepTestAll(previousPosition - base.transform.position, Vector3.Distance(previousPosition, base.transform.position), QueryTriggerInteraction.Collide);
				foreach (RaycastHit raycastHit in array)
				{
					CheckCollision(raycastHit.collider);
				}
			}
			if ((bool)checkForCollisionsBetween)
			{
				RaycastHit[] array = col.attachedRigidbody.SweepTestAll(checkForCollisionsBetween.position - base.transform.position, Vector3.Distance(checkForCollisionsBetween.position, base.transform.position), QueryTriggerInteraction.Collide);
				foreach (RaycastHit raycastHit2 in array)
				{
					CheckCollision(raycastHit2.collider);
				}
			}
			previousPosition = base.transform.position;
		}
		UpdateDebugOverlay();
	}

	private void CheckCollision(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			if (hitColliders.Contains(other) || other.gameObject.layer == 15)
			{
				return;
			}
			bool flag = false;
			if (useRaycastCheck && (bool)eid)
			{
				Vector3 vector = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
				if (Physics.Raycast(vector, other.bounds.center - vector, Vector3.Distance(vector, other.bounds.center), relevantLMask))
				{
					flag = true;
				}
			}
			if (flag)
			{
				return;
			}
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
			{
				if (!ignoreSlidingPlayer || !MonoSingleton<PlatformerMovement>.Instance.sliding)
				{
					MonoSingleton<PlatformerMovement>.Instance.Explode();
				}
				return;
			}
			if (nmov == null)
			{
				nmov = other.GetComponent<NewMovement>();
			}
			if (ignoreSlidingPlayer && nmov.sliding)
			{
				return;
			}
			nmov.GetHurt(Mathf.RoundToInt((float)damage * eid.totalDamageModifier), invincible: true);
			if (!canHitPlayerMultipleTimes)
			{
				hitColliders.Add(other);
			}
			if (knockBackForce > 0f)
			{
				Vector3 forward = base.transform.forward;
				if (knockBackDirectionOverride)
				{
					forward = knockBackDirection;
				}
				if (knockBackDirection == Vector3.down)
				{
					nmov.Slamdown(knockBackForce);
				}
				else
				{
					nmov.LaunchFromPoint(nmov.transform.position + forward * -1f, knockBackForce, knockBackForce);
				}
			}
			NotifyTargetBeenHit();
		}
		else if (other.gameObject.layer == 10 && !playerOnly && !hitColliders.Contains(other))
		{
			EnemyIdentifierIdentifier component = other.GetComponent<EnemyIdentifierIdentifier>();
			if (component != null && component.eid != null)
			{
				EnemyIdentifier enid = component.eid;
				CheckEidCollision(enid, other);
			}
		}
		else if (other.gameObject.layer == 12 && !playerOnly && !hitColliders.Contains(other))
		{
			EnemyIdentifier component2 = other.GetComponent<EnemyIdentifier>();
			if (component2 != null)
			{
				CheckEidCollision(component2, other);
			}
		}
		else if (other.gameObject.CompareTag("Breakable"))
		{
			Breakable component3 = other.gameObject.GetComponent<Breakable>();
			if (component3 != null && (strong || component3.weak) && !component3.playerOnly && !component3.precisionOnly)
			{
				component3.Break();
			}
		}
	}

	private void CheckEidCollision(EnemyIdentifier enid, Collider other)
	{
		if (hitEnemies.Contains(enid) || enid.enemyType == type || eid.immuneToFriendlyFire || EnemyIdentifier.CheckHurtException(type, enid.enemyType, (eid != null) ? eid.target : null))
		{
			return;
		}
		if (EnemyIdentifierDebug.Active)
		{
			Log.Fine("We're in, no hurt exception");
		}
		if (hitEnemies.Contains(enid) && !(hitEnemies[hitEnemies.IndexOf(enid)] != null) && (!enid.dead || !other.gameObject.CompareTag("Head")))
		{
			return;
		}
		if (EnemyIdentifierDebug.Active)
		{
			Log.Finer("hit enemies doesn't contain " + enid.gameObject.name);
		}
		if (enid.dead && (!enid.dead || other.gameObject.CompareTag("Body")))
		{
			return;
		}
		if (EnemyIdentifierDebug.Active)
		{
			Log.Finer("enid not dead or enid dead and not body");
		}
		bool flag = false;
		if (useRaycastCheck && (bool)eid)
		{
			Vector3 vector = new Vector3(eid.transform.position.x, base.transform.position.y, eid.transform.position.z);
			if (Physics.Raycast(vector, other.transform.position - vector, out var hitInfo, Vector3.Distance(vector, other.transform.position), relevantLMask))
			{
				flag = true;
				if (EnemyIdentifierDebug.Active)
				{
					Log.Finer("block hit by " + hitInfo.collider.gameObject.name);
				}
			}
			else if (EnemyIdentifierDebug.Active)
			{
				Log.Finer("no block hit");
			}
		}
		if (flag)
		{
			return;
		}
		enid.hitter = "enemy";
		if (enemyDamage == 0)
		{
			enemyDamage = damage / 10;
		}
		float num = (float)enemyDamage * eid.totalDamageModifier;
		if (type == EnemyType.Guttertank && enid.enemyType == EnemyType.Gutterman && !enid.dead && enid.TryGetComponent<Gutterman>(out var component))
		{
			if (component.hasShield)
			{
				component.ShieldBreak(player: false, flash: false);
			}
			else
			{
				component.GotParried();
			}
			num *= 4f;
		}
		enid.DeliverDamage(other.gameObject, ((base.transform.position - other.transform.position).normalized + Vector3.up) * 10000f, other.transform.position, num, tryForExplode: false);
		hitEnemies.Add(enid);
		hitColliders.Add(other);
		NotifyTargetBeenHit();
	}

	private void NotifyTargetBeenHit()
	{
		if ((bool)eid)
		{
			IHitTargetCallback[] components = eid.GetComponents<IHitTargetCallback>();
			if (EnemyIdentifierDebug.Active)
			{
				Log.Info(string.Format("We've hit <b>{0}</b>. Broadcasting to <b>{1}</b> receiver{2}.", eid.target, components.Length, (components.Length == 1) ? string.Empty : "s"));
			}
			IHitTargetCallback[] array = components;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].TargetBeenHit();
			}
		}
	}

	public void DamageStart()
	{
		if (damaging)
		{
			DamageStop();
		}
		previousPosition = base.transform.position;
		damaging = true;
		if (!physicalCollider)
		{
			if ((bool)col)
			{
				col.enabled = true;
			}
			if (additionalColliders != null)
			{
				Collider[] array = additionalColliders;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].enabled = true;
				}
			}
		}
		if (aud != null)
		{
			aud.Play();
		}
	}

	public void DamageStop()
	{
		damaging = false;
		if (hitColliders.Count > 0)
		{
			hitColliders.Clear();
		}
		if (hitEnemies.Count > 0)
		{
			hitEnemies.Clear();
		}
		if (physicalCollider)
		{
			return;
		}
		if ((bool)col)
		{
			col.enabled = false;
		}
		if (additionalColliders != null)
		{
			Collider[] array = additionalColliders;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
		}
	}

	public void OverrideEnemyIdentifier(EnemyIdentifier newEid)
	{
		eid = newEid;
	}

	private void UpdateDebugOverlay()
	{
		if (EnemyIdentifierDebug.Active)
		{
			if (debugOverlay == null)
			{
				debugOverlay = base.gameObject.AddComponent<SwingCheckDebugOverlay>();
			}
			debugOverlay.ConsumeData(damaging, eid);
		}
		else if (debugOverlay != null)
		{
			Object.Destroy(debugOverlay);
		}
	}

	public void CanHitPlayerMultipleTimes(bool yes)
	{
		canHitPlayerMultipleTimes = yes;
		if (yes && hitColliders.Contains(MonoSingleton<NewMovement>.Instance.playerCollider))
		{
			hitColliders.Remove(MonoSingleton<NewMovement>.Instance.playerCollider);
		}
	}
}


public enum SwitchLockType
{
	None,
	Limbo,
	PRank,
	Shotgun
}



public class SwitchMaterial : MonoBehaviour
{
	public Material[] materials;

	private MeshRenderer mr;

	private void Start()
	{
		mr = GetComponent<MeshRenderer>();
	}

	public void Switch(int i)
	{
		mr.sharedMaterial = materials[i];
	}
}



public class SwitchOnBeat : MonoBehaviour
{
	[HideInInspector]
	public BeatInfo currentBeatInfo;

	private float timer;

	private float nextMeasure;

	private bool switching;

	private int target;

	public BeatInfo[] switches;

	private bool initialized;

	private void Awake()
	{
		if (!initialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		initialized = true;
		if (!currentBeatInfo)
		{
			currentBeatInfo = switches[target];
		}
		BeatInfo[] array = switches;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetValues();
		}
		timer = currentBeatInfo.aud.time;
	}

	private void Update()
	{
		timer = currentBeatInfo.aud.time;
		if (switching && timer >= nextMeasure)
		{
			Switch();
		}
	}

	private void Switch()
	{
		if (!initialized)
		{
			Initialize();
		}
		switching = false;
		for (int i = 0; i < switches.Length; i++)
		{
			if (i == target)
			{
				switches[i].gameObject.SetActive(value: true);
				currentBeatInfo = switches[i];
				timer = currentBeatInfo.aud.time;
			}
			else
			{
				switches[i].gameObject.SetActive(value: false);
			}
		}
	}

	public void SetTarget(int newTarget)
	{
		if (!initialized)
		{
			Initialize();
		}
		target = newTarget;
		switching = true;
		nextMeasure = 0f;
		if (currentBeatInfo.timeSignatureChanges == null || currentBeatInfo.timeSignatureChanges.Length == 0 || currentBeatInfo.timeSignatureChanges[0] == null || timer < currentBeatInfo.timeSignatureChanges[0].time)
		{
			while (nextMeasure < timer)
			{
				nextMeasure += 60f / currentBeatInfo.bpm * 4f * currentBeatInfo.timeSignature;
			}
		}
		else
		{
			for (int i = 0; i < currentBeatInfo.timeSignatureChanges.Length; i++)
			{
				if (currentBeatInfo.timeSignatureChanges[i].time > timer)
				{
					for (nextMeasure = currentBeatInfo.timeSignatureChanges[i - 1].time; nextMeasure < timer; nextMeasure += 60f / currentBeatInfo.bpm * 4f * currentBeatInfo.timeSignatureChanges[i - 1].timeSignature)
					{
					}
					break;
				}
				if (i == currentBeatInfo.timeSignatureChanges.Length - 1)
				{
					for (nextMeasure = currentBeatInfo.timeSignatureChanges[i].time; nextMeasure < timer; nextMeasure += 60f / currentBeatInfo.bpm * 4f * currentBeatInfo.timeSignatureChanges[i].timeSignature)
					{
					}
				}
			}
		}
		if (nextMeasure >= currentBeatInfo.aud.clip.length)
		{
			nextMeasure = 0f;
		}
	}
}



public class SwordsMachine : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>, IEnemyRelationshipLogic
{
	private static readonly plog.Logger Log = new plog.Logger("SwordsMachine");

	public Transform targetZone;

	private NavMeshAgent nma;

	private Animator anim;

	private Rigidbody rb;

	private Machine mach;

	public float phaseChangeHealth;

	public bool firstPhase;

	public bool active = true;

	public Transform rightArm;

	[SerializeField]
	private Transform[] aimBones;

	private float aimLerp;

	public bool inAction;

	public bool inSemiAction;

	[HideInInspector]
	public bool moveAtTarget;

	private Vector3 moveTarget;

	private float moveSpeed;

	public TrailRenderer swordTrail;

	public TrailRenderer slapTrail;

	public SkinnedMeshRenderer swordMR;

	public Material enragedSword;

	public Material heatMat;

	private Material origMat;

	private AudioSource swordAud;

	public GameObject swingSound;

	public GameObject head;

	public AssetReference flash;

	public AssetReference gunFlash;

	private bool runningAttack = true;

	public float runningAttackCharge;

	public bool damaging;

	public int damage;

	public float runningAttackChance = 50f;

	private EnemyShotgun shotgun;

	private bool shotgunning;

	private bool gunDelay;

	public GameObject shotgunPickUp;

	public GameObject activateOnPhaseChange;

	private bool usingShotgun;

	public Transform secondPhasePosTarget;

	public CheckPoint cpToReset;

	public float swordThrowCharge = 3f;

	public int throwType;

	public GameObject[] thrownSword;

	private GameObject currentThrownSword;

	public Transform handTransform;

	public LayerMask swordThrowMask;

	private float swordThrowChance = 50f;

	private float spiralSwordChance = 50f;

	public float chaseThrowCharge;

	public GameObject bigPainSound;

	private Vector3 targetFuturePos;

	private int difficulty = -1;

	public bool enraged;

	private float rageLeft;

	public EnemySimplifier ensim;

	private float normalAnimSpeed;

	private float normalMovSpeed;

	public GameObject enrageEffect;

	public GameObject currentEnrageEffect;

	private AudioSource enrageAud;

	public Door[] doorsInPath;

	public bool eternalRage;

	public bool bothPhases;

	private bool knockedDown;

	public bool downed;

	[SerializeField]
	private SwingCheck2[] swordSwingCheck;

	[SerializeField]
	private SwingCheck2 slapSwingCheck;

	private GroundCheckEnemy gc;

	private bool bossVersion;

	private EnemyIdentifier eid;

	private BloodsplatterManager bsm;

	private float idleFailsafe = 1f;

	private bool idling;

	private bool inPhaseChange;

	private float moveSpeedMultiplier = 1f;

	private bool breakableInWay;

	private bool targetViewBlocked;

	private bool targetingStalker;

	public float spawnAttackDelay = 0.5f;

	private EnemyTarget target => eid.target;

	public bool isEnraged => enraged;

	public string alterKey => "swordsmachine";

	public string alterCategoryName => "swordsmachine";

	AlterOption<bool>[] IAlterOptions<bool>.options => new AlterOption<bool>[2]
	{
		new AlterOption<bool>
		{
			value = isEnraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		},
		new AlterOption<bool>
		{
			value = eternalRage,
			callback = delegate(bool value)
			{
				eternalRage = value;
			},
			key = "eternal-rage",
			name = "Eternal Rage"
		}
	};

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
		mach = GetComponent<Machine>();
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		swordAud = swordTrail.GetComponent<AudioSource>();
		shotgun = GetComponentInChildren<EnemyShotgun>();
		gc = GetComponentInChildren<GroundCheckEnemy>();
		origMat = swordMR.sharedMaterial;
	}

	private void Start()
	{
		swordTrail.emitting = false;
		slapTrail.emitting = false;
		SetSpeed();
		gunDelay = true;
		BossHealthBar component = GetComponent<BossHealthBar>();
		if (component == null || !component.enabled)
		{
			bossVersion = false;
		}
		else
		{
			bossVersion = true;
		}
		Invoke("SlowUpdate", 0.5f);
		Invoke("NavigationUpdate", 0.1f);
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!nma)
		{
			nma = GetComponent<NavMeshAgent>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (!anim)
		{
			anim = GetComponentInChildren<Animator>();
		}
		if (!ensim)
		{
			ensim = GetComponentInChildren<EnemySimplifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty != 2)
		{
			if (difficulty >= 3)
			{
				nma.speed = (firstPhase ? 19 : 23);
				anim.speed = 1.2f;
				anim.SetFloat("ThrowSpeedMultiplier", 1.35f);
				anim.SetFloat("AttackSpeedMultiplier", 1f);
				moveSpeedMultiplier = ((difficulty == 3) ? 1.2f : 1.35f);
			}
			else if (difficulty <= 1)
			{
				nma.speed = (firstPhase ? 14 : 18);
				anim.speed = 0.85f;
				if (difficulty == 1)
				{
					anim.SetFloat("ThrowSpeedMultiplier", 0.825f);
					anim.SetFloat("AttackSpeedMultiplier", 0.825f);
					moveSpeedMultiplier = 0.8f;
				}
				else
				{
					anim.SetFloat("ThrowSpeedMultiplier", 0.75f);
					anim.SetFloat("AttackSpeedMultiplier", 0.75f);
					moveSpeedMultiplier = 0.65f;
				}
			}
		}
		else
		{
			nma.speed = (firstPhase ? 16 : 20);
			anim.speed = 1f;
			anim.SetFloat("ThrowSpeedMultiplier", 1f);
			anim.SetFloat("AttackSpeedMultiplier", 1f);
			moveSpeedMultiplier = 1f;
		}
		anim.SetFloat("RecoverySpeedMultiplier", (difficulty < 4) ? 1 : 2);
		nma.speed *= eid.totalSpeedModifier;
		anim.speed *= eid.totalSpeedModifier;
		moveSpeedMultiplier *= eid.totalSpeedModifier;
		normalAnimSpeed = anim.speed;
		normalMovSpeed = nma.speed;
		if (enraged)
		{
			anim.speed = normalAnimSpeed * 1.15f;
			nma.speed = normalMovSpeed * 1.25f;
			ensim.enraged = true;
			if (!eid.puppet)
			{
				swordMR.sharedMaterial = enragedSword;
			}
		}
		if ((bool)shotgun)
		{
			shotgun.UpdateBuffs(eid);
		}
	}

	private void OnDisable()
	{
		if (GetComponent<BossHealthBar>() != null)
		{
			GetComponent<BossHealthBar>().DisappearBar();
		}
		if (currentThrownSword != null)
		{
			Object.Destroy(currentThrownSword);
		}
	}

	private void OnEnable()
	{
		if ((bool)mach)
		{
			StopAction();
			CoolSword();
			StopMoving();
			DamageStop();
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.5f);
		targetingStalker = false;
		if (!BlindEnemies.Blind && nma.isOnNavMesh && !eid.sandified)
		{
			List<EnemyIdentifier> enemiesOfType = MonoSingleton<EnemyTracker>.Instance.GetEnemiesOfType(EnemyType.Stalker);
			if (enemiesOfType.Count > 0)
			{
				float num = 100f;
				foreach (EnemyIdentifier item in enemiesOfType)
				{
					if (item.blessed)
					{
						continue;
					}
					NavMeshPath navMeshPath = new NavMeshPath();
					nma.CalculatePath(item.transform.position, navMeshPath);
					if (navMeshPath == null || navMeshPath.status != 0)
					{
						continue;
					}
					float num2 = 0f;
					for (int i = 1; i < navMeshPath.corners.Length; i++)
					{
						num2 += Vector3.Distance(navMeshPath.corners[i - 1], navMeshPath.corners[i]);
					}
					if (!(num2 < num))
					{
						continue;
					}
					eid.target = new EnemyTarget(item.transform);
					targetingStalker = true;
					num = num2;
					if (shotgunning)
					{
						anim.SetLayerWeight(1, 0f);
						shotgunning = false;
						if (!gunDelay)
						{
							gunDelay = true;
							Invoke("ShootDelay", (float)Random.Range(5, 10) / eid.totalSpeedModifier);
						}
					}
				}
			}
		}
		if (target == null)
		{
			return;
		}
		if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, target.position - base.transform.position, out var hitInfo, Vector3.Distance(base.transform.position + Vector3.up * 0.1f, target.position), LayerMaskDefaults.Get(LMD.Environment)))
		{
			targetViewBlocked = true;
			if (hitInfo.distance < 5f && hitInfo.transform.TryGetComponent<Breakable>(out var component) && !component.playerOnly)
			{
				breakableInWay = true;
			}
		}
		else
		{
			targetViewBlocked = false;
			if (target.position.y > base.transform.position.y + 2.5f && Vector2.Distance(new Vector2(base.transform.position.x, base.transform.position.z), new Vector3(target.position.x, target.position.z)) < 5f && Physics.Raycast(target.position + Vector3.up * 0.1f, Vector3.down, out hitInfo, Mathf.Clamp(target.position.y - base.transform.position.y, 0f, 5f), LayerMaskDefaults.Get(LMD.Environment)) && hitInfo.transform.TryGetComponent<Breakable>(out var component2) && !component2.playerOnly)
			{
				breakableInWay = true;
			}
		}
	}

	private void NavigationUpdate()
	{
		Invoke("NavigationUpdate", 0.1f);
		if (target != null && !inAction && nma.enabled && nma.isOnNavMesh)
		{
			nma.SetDestination(target.position);
		}
	}

	private void Update()
	{
		if (active && nma != null)
		{
			if (spawnAttackDelay > 0f)
			{
				spawnAttackDelay = Mathf.MoveTowards(spawnAttackDelay, 0f, Time.deltaTime * eid.totalSpeedModifier);
			}
			if (breakableInWay && !inAction)
			{
				breakableInWay = false;
				inAction = true;
				RunningSwing();
			}
			else if (target != null && spawnAttackDelay <= 0f)
			{
				if ((firstPhase || bothPhases) && (!enraged || difficulty >= 4) && !inAction && shotgun.gunReady && !gunDelay && !shotgunning && Vector3.Distance(target.position, base.transform.position) > 5f && !targetingStalker)
				{
					shotgunning = true;
					anim.SetLayerWeight(1, 1f);
					anim.SetTrigger("Shoot");
					aimLerp = 0f;
				}
				else if (!firstPhase && (!enraged || difficulty >= 4) && !inAction && !inSemiAction && !targetViewBlocked && ((swordThrowCharge == 0f && Vector3.Distance(target.position, base.transform.position) > 5f) || Vector3.Distance(target.position, base.transform.position) > 20f) && !targetingStalker)
				{
					swordThrowCharge = 3f;
					if ((float)Random.Range(0, 100) <= swordThrowChance || target.position.y > base.transform.position.y + 3f || Vector3.Distance(target.position, base.transform.position) > 16f)
					{
						inAction = true;
						throwType = 2;
						SwordThrow();
						if (swordThrowChance > 50f)
						{
							swordThrowChance = 25f;
						}
						else
						{
							swordThrowChance -= 25f;
						}
					}
					else if (swordThrowChance < 50f)
					{
						swordThrowChance = 75f;
					}
					else
					{
						swordThrowChance += 25f;
					}
				}
				if (runningAttack && !inAction && (!inSemiAction || difficulty >= 4) && Vector3.Distance(target.position, base.transform.position) <= 8f && Vector3.Distance(target.position, base.transform.position) >= 5f)
				{
					runningAttackCharge = 3f;
					if ((float)Random.Range(0, 100) <= runningAttackChance)
					{
						if (runningAttackChance > 50f)
						{
							runningAttackChance = 50f;
						}
						runningAttackChance -= 25f;
						inAction = true;
						RunningSwing();
						if (shotgunning)
						{
							anim.SetLayerWeight(1, 0f);
							shotgunning = false;
							if (!gunDelay)
							{
								gunDelay = true;
								Invoke("ShootDelay", Random.Range(5, 10));
							}
						}
					}
					else
					{
						if (runningAttackChance < 50f)
						{
							runningAttackChance = 50f;
						}
						runningAttackChance += 25f;
						runningAttack = false;
					}
				}
				else if (!inAction && (!inSemiAction || difficulty >= 4) && Vector3.Distance(target.position, base.transform.position) <= 5f)
				{
					inAction = true;
					if (shotgunning)
					{
						anim.SetLayerWeight(1, 0f);
						shotgunning = false;
						if (!gunDelay)
						{
							gunDelay = true;
							Invoke("ShootDelay", (float)Random.Range(5, 10) / eid.totalSpeedModifier);
						}
					}
					if (!firstPhase && !enraged && !targetingStalker)
					{
						if ((float)Random.Range(0, 100) <= spiralSwordChance && !inSemiAction)
						{
							SwordSpiral();
							if (spiralSwordChance > 50f)
							{
								spiralSwordChance = 25f;
							}
							else
							{
								spiralSwordChance -= 25f;
							}
						}
						else
						{
							Combo();
							if (spiralSwordChance < 50f)
							{
								spiralSwordChance = 50f;
							}
							spiralSwordChance += 25f;
						}
					}
					else
					{
						Combo();
					}
				}
				if (!runningAttack && runningAttackCharge > 0f)
				{
					runningAttackCharge -= Time.deltaTime * eid.totalSpeedModifier;
					if (runningAttackCharge <= 0f)
					{
						runningAttackCharge = 0f;
						runningAttack = true;
					}
				}
				if (!firstPhase)
				{
					if (swordThrowCharge > 0f && Vector3.Distance(target.position, base.transform.position) > 5f)
					{
						swordThrowCharge = Mathf.MoveTowards(swordThrowCharge, 0f, Time.deltaTime * eid.totalSpeedModifier);
					}
					else
					{
						swordThrowCharge = 0f;
					}
					if (chaseThrowCharge > 0f)
					{
						chaseThrowCharge = Mathf.MoveTowards(chaseThrowCharge, 0f, Time.deltaTime * eid.totalSpeedModifier);
					}
				}
			}
		}
		if (!inAction && (bool)nma && nma.enabled && nma.isOnNavMesh)
		{
			if (nma.velocity.magnitude > 0.1f)
			{
				anim.SetBool("Running", value: true);
			}
			else
			{
				anim.SetBool("Running", value: false);
			}
		}
		if (!eternalRage && rageLeft > 0f)
		{
			rageLeft = Mathf.MoveTowards(rageLeft, 0f, Time.deltaTime * eid.totalSpeedModifier);
			if (enrageAud != null && rageLeft < 3f)
			{
				enrageAud.pitch = rageLeft / 3f;
			}
			if (rageLeft <= 0f)
			{
				enraged = false;
				ensim.enraged = false;
				if (!eid.puppet)
				{
					swordMR.sharedMaterial = origMat;
				}
				nma.speed = normalMovSpeed;
				anim.speed = normalAnimSpeed;
				if (currentEnrageEffect != null)
				{
					Object.Destroy(currentEnrageEffect);
				}
			}
		}
		if (firstPhase && mach.health <= phaseChangeHealth)
		{
			firstPhase = false;
			phaseChangeHealth = 0f;
			if (bossVersion)
			{
				MonoSingleton<NewMovement>.Instance.ResetHardDamage();
				MonoSingleton<NewMovement>.Instance.GetHealth(999, silent: true);
			}
			EndFirstPhase();
		}
		if (((firstPhase && mach.health < 110f) || bothPhases) && !usingShotgun)
		{
			usingShotgun = true;
			gunDelay = false;
		}
		if (mach.health < 95f)
		{
			gunDelay = false;
		}
		if (idleFailsafe > 0f && (bool)anim && (inAction || !active || knockedDown || downed) && anim.GetCurrentAnimatorClipInfo(0).Length != 0 && anim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "Idle")
		{
			idleFailsafe = Mathf.MoveTowards(idleFailsafe, 0f, Time.deltaTime);
			if (idleFailsafe == 0f)
			{
				StopAction();
				if (knockedDown || downed)
				{
					Disappear();
				}
			}
		}
		else
		{
			idleFailsafe = 1f;
		}
	}

	private void FixedUpdate()
	{
		if (moveAtTarget)
		{
			float y = Mathf.Min(0f, rb.velocity.y);
			if (enraged || Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward, Vector3.down, out var _, Mathf.Max(22f, base.transform.position.y - MonoSingleton<PlayerTracker>.Instance.GetPlayer().position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
			{
				rb.velocity = moveTarget * moveSpeed;
			}
			else
			{
				rb.velocity = Vector3.zero;
			}
			rb.velocity = new Vector3(rb.velocity.x, y, rb.velocity.z);
		}
		else
		{
			rb.velocity = new Vector3(0f, Mathf.Min(0f, rb.velocity.y), 0f);
		}
	}

	private void LateUpdate()
	{
		if (!firstPhase && !eternalRage && !bothPhases)
		{
			rightArm.localScale = Vector3.zero;
		}
		if (difficulty < 4 || !usingShotgun || eid.target == null)
		{
			return;
		}
		if (shotgunning)
		{
			aimLerp = Mathf.MoveTowards(aimLerp, 1f, Time.deltaTime * 2f);
		}
		else
		{
			aimLerp = Mathf.MoveTowards(aimLerp, 0f, Time.deltaTime * 8f);
		}
		if (!(aimLerp > 0f))
		{
			return;
		}
		Quaternion[] array = new Quaternion[aimBones.Length];
		for (int i = 0; i < aimBones.Length; i++)
		{
			array[i] = aimBones[i].localRotation;
			aimBones[i].LookAt(eid.target.position);
			if (i == 1)
			{
				aimBones[i].transform.Rotate(Vector3.right * 90f, Space.Self);
			}
			aimBones[i].localRotation = Quaternion.Lerp(array[i], aimBones[i].localRotation, aimLerp);
		}
	}

	public void RunningSwing()
	{
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.SetTrigger("RunningSwing");
		rb.velocity = Vector3.zero;
		moveSpeed = 30f * moveSpeedMultiplier;
		damage = 40;
	}

	private void Combo()
	{
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.SetTrigger("Combo");
		rb.velocity = Vector3.zero;
		moveSpeed = 60f * moveSpeedMultiplier;
		damage = 25;
	}

	private void SwordThrow()
	{
		anim.SetBool("Running", value: false);
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.SetTrigger("SwordThrow");
		rb.velocity = Vector3.zero;
		damage = 0;
	}

	private void SwordSpiral()
	{
		throwType = 1;
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.SetTrigger("SwordSpiral");
		rb.velocity = Vector3.zero;
		damage = 0;
	}

	public void StartMoving()
	{
		if (!knockedDown && !downed && target != null)
		{
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			rb.isKinematic = false;
			moveTarget = base.transform.forward;
			moveAtTarget = true;
		}
	}

	public void StopMoving()
	{
		moveAtTarget = false;
		rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
	}

	public void LookAt()
	{
		if (target != null)
		{
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		}
	}

	public void StopAction()
	{
		mach.parryable = false;
		if (gc.onGround && (bool)nma)
		{
			nma.updatePosition = true;
			nma.updateRotation = true;
			nma.enabled = true;
		}
		StopMoving();
		inAction = false;
		runningAttack = true;
	}

	public void SemiStopAction()
	{
		mach.parryable = false;
		if (gc.onGround && (bool)nma)
		{
			nma.updatePosition = true;
			nma.updateRotation = true;
			nma.enabled = true;
		}
		inSemiAction = true;
		inAction = false;
		anim.SetTrigger("AnimationCancel");
	}

	public void HeatSword()
	{
		if (!inSemiAction)
		{
			swordTrail.emitting = true;
		}
		else
		{
			slapTrail.emitting = true;
		}
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = heatMat;
		}
		swordAud.pitch = 1.5f;
		Object.Instantiate(flash.ToAsset(), head.transform.position + Vector3.up + head.transform.forward, head.transform.rotation, head.transform);
		mach.ParryableCheck();
	}

	public void HeatSwordThrow()
	{
		if ((bool)swordTrail)
		{
			swordTrail.emitting = true;
		}
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = heatMat;
		}
		swordAud.pitch = 1.5f;
		Object.Instantiate(gunFlash.ToAsset(), head.transform);
		if (throwType == 2 && target != null)
		{
			if (target.isPlayer)
			{
				targetFuturePos = target.position + target.GetVelocity() * (Vector3.Distance(base.transform.position, target.position) / 80f) * Vector3.Distance(base.transform.position, target.position) * 0.08f / anim.speed;
			}
			else
			{
				targetFuturePos = target.position + target.GetVelocity();
			}
			base.transform.LookAt(new Vector3(targetFuturePos.x, base.transform.position.y, targetFuturePos.z));
		}
		mach.ParryableCheck();
	}

	public void CoolSword()
	{
		if ((bool)swordTrail)
		{
			swordTrail.emitting = false;
		}
		if ((bool)slapTrail)
		{
			slapTrail.emitting = false;
		}
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = (enraged ? enragedSword : origMat);
		}
		swordAud.pitch = 1f;
	}

	public void DamageStart()
	{
		damaging = true;
		if (!inSemiAction)
		{
			if ((bool)swordTrail)
			{
				Object.Instantiate(swingSound, swordTrail.transform);
			}
			SwingCheck2[] array = swordSwingCheck;
			foreach (SwingCheck2 obj in array)
			{
				obj.OverrideEnemyIdentifier(eid);
				obj.damage = damage;
				obj.DamageStart();
			}
		}
		else
		{
			slapSwingCheck.OverrideEnemyIdentifier(eid);
			slapSwingCheck.DamageStart();
		}
	}

	public void DamageStop()
	{
		damaging = false;
		mach.parryable = false;
		SwingCheck2[] array = swordSwingCheck;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStop();
		}
		slapSwingCheck.DamageStop();
	}

	public void ShootGun()
	{
		if (!inAction)
		{
			shotgun.UpdateTarget(target);
			shotgun.Fire();
		}
	}

	public void StopShootAnimation()
	{
		mach.parryable = false;
		anim.SetLayerWeight(1, 0f);
		gunDelay = true;
		shotgunning = false;
		Invoke("ShootDelay", (float)Random.Range(5, 20) / eid.totalSpeedModifier);
	}

	private void ShootDelay()
	{
		gunDelay = false;
	}

	public void FlashGun()
	{
		Object.Instantiate(gunFlash.ToAsset(), head.transform.position + Vector3.up + head.transform.forward, head.transform.rotation, head.transform);
	}

	public void SwordSpawn()
	{
		mach.parryable = false;
		if (target == null)
		{
			return;
		}
		RaycastHit hitInfo;
		if (throwType != 2)
		{
			targetFuturePos = target.position;
		}
		else if (target.isPlayer)
		{
			targetFuturePos = new Vector3(targetFuturePos.x, target.position.y + MonoSingleton<PlayerTracker>.Instance.GetPlayerVelocity().y * Vector3.Distance(base.transform.position, target.position) * 0.01f, targetFuturePos.z);
			if (Physics.Raycast(target.position, targetFuturePos - target.position, out hitInfo, Vector3.Distance(target.position, targetFuturePos), swordThrowMask, QueryTriggerInteraction.Ignore))
			{
				targetFuturePos = hitInfo.point;
			}
		}
		else
		{
			targetFuturePos = target.position + target.GetVelocity() / eid.totalSpeedModifier;
		}
		base.transform.LookAt(new Vector3(targetFuturePos.x, base.transform.position.y, targetFuturePos.z));
		currentThrownSword = Object.Instantiate(thrownSword[throwType], new Vector3(base.transform.position.x, handTransform.position.y, base.transform.position.z), Quaternion.identity);
		ThrownSword componentInChildren = currentThrownSword.GetComponentInChildren<ThrownSword>();
		componentInChildren.thrownBy = eid;
		if (throwType != 1)
		{
			currentThrownSword.transform.rotation = base.transform.rotation;
		}
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = origMat;
		}
		swordMR.enabled = false;
		swordTrail.emitting = false;
		slapTrail.emitting = false;
		swordAud.pitch = 0f;
		if (Physics.Raycast(base.transform.position + Vector3.up * 2f, (targetFuturePos - base.transform.position).normalized, out hitInfo, float.PositiveInfinity, swordThrowMask))
		{
			componentInChildren.SetPoints(hitInfo.point, handTransform);
		}
		else
		{
			componentInChildren.thrownAtVoid = true;
			componentInChildren.SetPoints((targetFuturePos - base.transform.position) * 9999f, handTransform);
		}
		if (throwType == 2)
		{
			SemiStopAction();
		}
		Invoke("SwordCatch", 5f);
	}

	public void SwordCatch()
	{
		mach.parryable = false;
		if ((bool)currentThrownSword)
		{
			Object.Destroy(currentThrownSword);
		}
		if (!knockedDown && !downed)
		{
			inAction = true;
			anim.SetTrigger("SwordCatch");
		}
		inSemiAction = false;
		swordMR.enabled = true;
		swordAud.pitch = 1f;
		swordThrowCharge = 3f;
		CancelInvoke("SwordCatch");
	}

	private void EndFirstPhase()
	{
		DamageStop();
		knockedDown = true;
		inAction = true;
		inSemiAction = false;
		anim.SetLayerWeight(1, 0f);
		gunDelay = true;
		shotgunning = false;
		swordTrail.emitting = false;
		slapTrail.emitting = false;
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = origMat;
		}
		swordAud.pitch = 1f;
		nma.enabled = true;
		inPhaseChange = true;
		active = false;
		moveAtTarget = false;
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		if (target != null)
		{
			base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		}
		rb.velocity = Vector3.zero;
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.isKinematic = false;
		}
		if (!bsm)
		{
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
		}
		GameObject gore = bsm.GetGore(GoreType.Limb, eid);
		if ((bool)gore)
		{
			gore.transform.position = rightArm.position;
		}
		if (bossVersion && shotgunPickUp != null)
		{
			shotgunPickUp.transform.SetPositionAndRotation(shotgun.transform.position, shotgun.transform.rotation);
			shotgunPickUp.SetActive(value: true);
		}
		CharacterJoint[] componentsInChildren = rightArm.GetComponentsInChildren<CharacterJoint>();
		GetComponentInParent<GoreZone>();
		if (componentsInChildren.Length != 0)
		{
			CharacterJoint[] array = componentsInChildren;
			foreach (CharacterJoint obj in array)
			{
				Object.Destroy(obj);
				obj.transform.localScale = Vector3.zero;
				obj.gameObject.SetActive(value: false);
			}
		}
		anim.Rebind();
		SetSpeed();
		anim.SetTrigger("Knockdown");
		if (bossVersion)
		{
			MonoSingleton<TimeController>.Instance.SlowDown(0.15f);
		}
		Object.Instantiate(bigPainSound, base.transform);
		if (secondPhasePosTarget != null)
		{
			MonoSingleton<MusicManager>.Instance.ArenaMusicEnd();
			MonoSingleton<MusicManager>.Instance.PlayCleanMusic();
		}
		normalMovSpeed = nma.speed;
		rageLeft = 0.01f;
	}

	public void Knockdown(bool light = false, bool fromExplosion = false)
	{
		DamageStop();
		knockedDown = true;
		inAction = true;
		inSemiAction = false;
		anim.SetLayerWeight(1, 0f);
		gunDelay = true;
		shotgunning = false;
		swordMR.enabled = true;
		swordTrail.emitting = false;
		slapTrail.emitting = false;
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = origMat;
		}
		swordAud.pitch = 1f;
		nma.enabled = true;
		SetSpeed();
		moveAtTarget = false;
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		rb.velocity = Vector3.zero;
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.isKinematic = false;
		}
		moveAtTarget = false;
		if (light)
		{
			anim.Play("LightKnockdown");
		}
		else
		{
			anim.Play("Knockdown");
		}
		if (mach == null)
		{
			mach = GetComponent<Machine>();
		}
		if (!light)
		{
			GetComponent<EnemyIdentifier>().hitter = "projectile";
			if (mach.health > 20f)
			{
				mach.GetHurt(GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, Vector3.zero, 20f, 0f);
			}
			else
			{
				mach.GetHurt(GetComponentInChildren<EnemyIdentifierIdentifier>().gameObject, Vector3.zero, mach.health - 0.1f, 0f);
			}
		}
		if (!bsm)
		{
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
		}
		GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion);
		gore.transform.position = GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position;
		gore.GetComponent<Bloodsplatter>()?.GetReady();
		gore.GetComponent<ParticleSystem>()?.Play();
		if (!light)
		{
			Object.Instantiate(bigPainSound, base.transform);
		}
		Enrage();
	}

	public void Down(bool fromExplosion = false)
	{
		downed = true;
		DamageStop();
		inAction = true;
		inSemiAction = false;
		anim.SetLayerWeight(1, 0f);
		gunDelay = true;
		shotgunning = false;
		swordMR.enabled = true;
		swordTrail.emitting = false;
		slapTrail.emitting = false;
		if (!eid.puppet)
		{
			swordMR.sharedMaterial = origMat;
		}
		swordAud.pitch = 1f;
		nma.enabled = true;
		SetSpeed();
		moveAtTarget = false;
		nma.updatePosition = false;
		nma.updateRotation = false;
		nma.enabled = false;
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		rb.velocity = Vector3.zero;
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
		else
		{
			rb.isKinematic = false;
		}
		moveAtTarget = false;
		anim.Play("Knockdown");
		Invoke("CheckLoop", 0.5f);
		if (mach == null)
		{
			mach = GetComponent<Machine>();
		}
		if (!bsm)
		{
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
		}
		GameObject gore = bsm.GetGore(GoreType.Head, eid, fromExplosion);
		gore.transform.position = GetComponentInChildren<EnemyIdentifierIdentifier>().transform.position;
		gore.GetComponent<Bloodsplatter>()?.GetReady();
		gore.GetComponent<ParticleSystem>()?.Play();
		Object.Instantiate(bigPainSound, base.transform);
	}

	public void Disappear()
	{
		if (secondPhasePosTarget != null && !firstPhase)
		{
			BossHealthBar component = GetComponent<BossHealthBar>();
			component.DisappearBar();
			Object.Instantiate(position: new Vector3(base.transform.position.x, base.transform.position.y + 1.5f, base.transform.position.z), original: eid.spawnEffect, rotation: base.transform.rotation);
			base.gameObject.SetActive(value: false);
			SwordsMachine[] componentsInChildren = secondPhasePosTarget.GetComponentsInChildren<SwordsMachine>();
			if (componentsInChildren.Length != 0)
			{
				SwordsMachine[] array = componentsInChildren;
				foreach (SwordsMachine obj in array)
				{
					obj.gameObject.SetActive(value: false);
					Object.Destroy(obj.gameObject);
				}
			}
			nma.updatePosition = true;
			nma.updateRotation = true;
			nma.enabled = true;
			base.transform.position = secondPhasePosTarget.position;
			base.transform.parent = secondPhasePosTarget;
			eid.spawnIn = true;
			base.gameObject.SetActive(value: true);
			component.enabled = true;
		}
		knockedDown = false;
		moveAtTarget = false;
		if (gc.onGround)
		{
			rb.isKinematic = true;
		}
		inPhaseChange = false;
		active = true;
		if (gc.onGround)
		{
			nma.updatePosition = true;
			nma.updateRotation = true;
			nma.enabled = true;
		}
		inAction = false;
		inSemiAction = false;
		if (activateOnPhaseChange != null && !firstPhase)
		{
			activateOnPhaseChange.SetActive(value: true);
		}
		GetComponent<AudioSource>().volume = 0f;
		if (secondPhasePosTarget != null && !firstPhase)
		{
			secondPhasePosTarget = null;
			cpToReset.UpdateRooms();
		}
	}

	public void Enrage()
	{
		if (!enraged && !bothPhases)
		{
			enraged = true;
			rageLeft = 10f;
			anim.speed = normalAnimSpeed * 1.15f;
			nma.speed = normalMovSpeed * 1.25f;
			ensim.enraged = true;
			if (!eid.puppet)
			{
				swordMR.sharedMaterial = enragedSword;
			}
			Object.Instantiate(bigPainSound, base.transform).GetComponent<AudioSource>().pitch = 2f;
			if (currentEnrageEffect == null)
			{
				currentEnrageEffect = Object.Instantiate(enrageEffect, mach.chest.transform);
				enrageAud = currentEnrageEffect.GetComponent<AudioSource>();
			}
			enrageAud.pitch = 1f;
		}
	}

	public void UnEnrage()
	{
		if (enraged)
		{
			rageLeft = 0f;
			anim.speed = normalAnimSpeed;
			nma.speed = normalMovSpeed;
			ensim.enraged = false;
			if (!eid.puppet)
			{
				swordMR.sharedMaterial = origMat;
			}
			enraged = false;
			Object.Destroy(currentEnrageEffect);
		}
	}

	public void CheckLoop()
	{
		if (downed)
		{
			anim.Play("Knockdown", 0, 0.25f);
			Invoke("CheckLoop", 0.25f);
		}
	}

	public bool ShouldAttackEnemies()
	{
		return false;
	}

	public bool ShouldIgnorePlayer()
	{
		if (target != null && target.isEnemy)
		{
			return target.enemyIdentifier.enemyType == EnemyType.Stalker;
		}
		return false;
	}
}



public class TeleportCheat : MonoBehaviour
{
	private class TeleportTarget
	{
		public string overrideName;

		public CheckPoint checkpoint;

		public FirstRoomPrefab firstRoom;

		public Transform target;
	}

	[SerializeField]
	private GameObject buttonTemplate;

	[SerializeField]
	private Color checkpointColor;

	[SerializeField]
	private Color roomColor;

	private void Start()
	{
		GenerateList();
	}

	private void GenerateList()
	{
		List<TeleportTarget> list = new List<TeleportTarget>();
		FirstRoomPrefab firstRoom = Object.FindObjectOfType<FirstRoomPrefab>();
		if ((bool)firstRoom)
		{
			list.Add(new TeleportTarget
			{
				overrideName = "First Room",
				target = firstRoom.transform,
				firstRoom = firstRoom
			});
		}
		CheckPoint[] array = Object.FindObjectsOfType<CheckPoint>();
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].unteleportable)
			{
				list.Add(new TeleportTarget
				{
					target = array[i].transform,
					checkpoint = array[i]
				});
			}
		}
		foreach (TeleportTarget point in list)
		{
			GameObject obj = Object.Instantiate(buttonTemplate, buttonTemplate.transform.parent);
			obj.GetComponentInChildren<TMP_Text>().text = ((!string.IsNullOrEmpty(point.overrideName)) ? point.overrideName : (point.checkpoint ? (point.checkpoint.toActivate ? ImproveCheckpointName(point.checkpoint.toActivate.name) : "<color=red>Missing toActivate</color>") : point.target.name));
			obj.GetComponentInChildren<TMP_Text>().color = (point.checkpoint ? checkpointColor : roomColor);
			obj.GetComponentInChildren<Button>().onClick.AddListener(delegate
			{
				Teleport(point.target);
				if ((bool)point.checkpoint)
				{
					point.checkpoint.toActivate.SetActive(value: true);
					if (point.checkpoint.doorsToUnlock.Length != 0)
					{
						Door[] doorsToUnlock = point.checkpoint.doorsToUnlock;
						foreach (Door door in doorsToUnlock)
						{
							if (door.locked)
							{
								door.Unlock();
							}
							if (door.startOpen)
							{
								door.Open();
							}
						}
					}
					if (point.checkpoint.newRooms.Count > 0 && (MonoSingleton<StatsManager>.Instance.currentCheckPoint == point.checkpoint || (!point.checkpoint.multiUse && !point.checkpoint.activated)))
					{
						point.checkpoint.ResetRoom();
					}
					point.checkpoint.onRestart?.Invoke();
				}
				if ((bool)firstRoom)
				{
					GameObject[] activatedRooms = firstRoom.mainDoor.activatedRooms;
					foreach (GameObject gameObject in activatedRooms)
					{
						if (gameObject != null)
						{
							gameObject.SetActive(value: true);
						}
					}
				}
			});
			obj.SetActive(value: true);
		}
		buttonTemplate.SetActive(value: false);
	}

	private void Update()
	{
		if (MonoSingleton<InputManager>.Instance.InputSource.Pause.WasPerformedThisFrame)
		{
			base.gameObject.SetActive(value: false);
			MonoSingleton<OptionsManager>.Instance.UnFreeze();
		}
	}

	private string ImproveCheckpointName(string original)
	{
		if (!original.Contains("- "))
		{
			return original;
		}
		return original.Split('-')[^1];
	}

	private void Teleport(Transform target)
	{
		MonoSingleton<NewMovement>.Instance.transform.position = target.position + target.right * 0.1f + Vector3.up * 1.25f;
		float num = target.rotation.eulerAngles.y + 0.1f;
		if ((bool)MonoSingleton<NewMovement>.Instance.transform.parent && MonoSingleton<NewMovement>.Instance.transform.parent.gameObject.CompareTag("Moving"))
		{
			num -= MonoSingleton<NewMovement>.Instance.transform.parent.rotation.eulerAngles.y;
		}
		MonoSingleton<CameraController>.Instance.ResetCamera(num);
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
		{
			MonoSingleton<PlatformerMovement>.Instance.transform.position = target.position;
			MonoSingleton<PlatformerMovement>.Instance.rb.velocity = Vector3.zero;
			MonoSingleton<PlatformerMovement>.Instance.playerModel.rotation = target.rotation;
			MonoSingleton<PlatformerMovement>.Instance.SnapCamera();
		}
		base.gameObject.SetActive(value: false);
		MonoSingleton<OptionsManager>.Instance.UnFreeze();
		MonoSingleton<OutdoorLightMaster>.Instance?.FirstDoorOpen();
		MonoSingleton<PlayerTracker>.Instance.LevelStart();
	}
}



public class TeleportFinalPit : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			other.transform.position = other.transform.position + base.transform.forward * 20f + Vector3.up * 20f;
		}
	}
}



public class TeleportItem : MonoBehaviour
{
	public Vector3 position;

	public bool resetVelocity;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 22)
		{
			other.transform.position = position;
			if (resetVelocity && (bool)other.attachedRigidbody)
			{
				other.attachedRigidbody.velocity = Vector3.zero;
			}
		}
	}
}



public class TeleportObject : MonoBehaviour
{
	public Vector3 position;

	public void Teleport(Transform target)
	{
		target.position = position;
	}
}



public class TeleportPlayer : MonoBehaviour
{
	public bool affectPosition = true;

	public Vector3 relativePosition;

	public bool notRelative;

	public bool relativeToCollider;

	public Vector3 objectivePosition;

	public bool includeOffsetFromCollider;

	public bool affectRotation;

	public bool notRelativeRotation;

	public Vector2 rotationDelta;

	public Vector2 objectiveRotation;

	public bool resetPlayerSpeed;

	public bool cancelGroundSlam;

	public bool dontDetachPlayerFromMovementParent;

	public Transform[] teleportWithPlayer;

	public GameObject teleportEffect;

	public UltrakillEvent onTeleportPlayer;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			PerformTheTeleport(other.transform);
		}
	}

	public void PerformTheTeleport()
	{
		if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
		{
			PerformTheTeleport(MonoSingleton<NewMovement>.Instance.transform);
		}
		else
		{
			PerformTheTeleport(MonoSingleton<PlatformerMovement>.Instance.transform);
		}
	}

	private void PerformTheTeleport(Transform target)
	{
		if ((MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS && MonoSingleton<NewMovement>.Instance.dead) || (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer && MonoSingleton<PlatformerMovement>.Instance.dead))
		{
			return;
		}
		if ((bool)MonoSingleton<NewMovement>.Instance && (bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
		{
			MonoSingleton<NewMovement>.Instance.ridingRocket.PlayerRideEnd();
		}
		if (affectPosition)
		{
			Vector3 position = target.position;
			Vector3 position2 = target.position;
			if (dontDetachPlayerFromMovementParent)
			{
				MonoSingleton<PlayerMovementParenting>.Instance.LockMovementParentTeleport(fuck: true);
			}
			position2 = (target.position = (notRelative ? ((!includeOffsetFromCollider) ? objectivePosition : (objectivePosition - (base.transform.position - target.position))) : ((!relativeToCollider) ? (target.position + relativePosition) : (base.transform.position + relativePosition))));
			if (teleportWithPlayer != null && teleportWithPlayer.Length != 0)
			{
				for (int i = 0; i < teleportWithPlayer.Length; i++)
				{
					if (teleportWithPlayer[i] != null)
					{
						teleportWithPlayer[i].position += position2 - position;
					}
				}
			}
			if (dontDetachPlayerFromMovementParent)
			{
				MonoSingleton<PlayerMovementParenting>.Instance.LockMovementParentTeleport(fuck: false);
			}
		}
		if (affectRotation)
		{
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				if (notRelativeRotation)
				{
					MonoSingleton<CameraController>.Instance.rotationY = objectiveRotation.y;
					MonoSingleton<CameraController>.Instance.rotationX = objectiveRotation.x;
				}
				else
				{
					MonoSingleton<CameraController>.Instance.rotationY += rotationDelta.y;
					MonoSingleton<CameraController>.Instance.rotationX += rotationDelta.x;
				}
				MonoSingleton<NewMovement>.Instance.transform.rotation = Quaternion.Euler(0f, MonoSingleton<CameraController>.Instance.rotationY, 0f);
				MonoSingleton<CameraController>.Instance.transform.localRotation = Quaternion.Euler(MonoSingleton<CameraController>.Instance.rotationX, 0f, 0f);
			}
			else
			{
				if (notRelativeRotation)
				{
					MonoSingleton<PlatformerMovement>.Instance.rotationY = objectiveRotation.y;
					MonoSingleton<PlatformerMovement>.Instance.rotationX = objectiveRotation.x;
				}
				else
				{
					MonoSingleton<PlatformerMovement>.Instance.rotationY += rotationDelta.y;
					MonoSingleton<PlatformerMovement>.Instance.rotationX += rotationDelta.x;
				}
				MonoSingleton<PlatformerMovement>.Instance.transform.rotation = Quaternion.Euler(0f, MonoSingleton<CameraController>.Instance.rotationY, 0f);
				MonoSingleton<CameraController>.Instance.transform.localRotation = Quaternion.Euler(MonoSingleton<CameraController>.Instance.rotationX, 0f, 0f);
			}
		}
		if (resetPlayerSpeed && MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
		{
			MonoSingleton<NewMovement>.Instance.StopMovement();
		}
		if (cancelGroundSlam && MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
		{
			MonoSingleton<NewMovement>.Instance.gc.heavyFall = false;
		}
		if ((bool)teleportEffect)
		{
			Object.Instantiate(teleportEffect, target.position, Quaternion.identity);
		}
		onTeleportPlayer.Invoke();
	}
}



public class TerribleTasteBook : MonoBehaviour
{
	public float spinTime = 2f;

	public Coroutine crt;

	public TerribleTasteBook otherSideBook;

	private void Start()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}

	public void ActivateBookShelf()
	{
		if (crt == null && otherSideBook.GetComponent<TerribleTasteBook>().crt == null)
		{
			crt = StartCoroutine(SpinShelf());
		}
	}

	private IEnumerator SpinShelf()
	{
		otherSideBook.enabled = false;
		Renderer rend = GetComponent<Renderer>();
		rend.enabled = false;
		MeshCollider col = rend.GetComponent<MeshCollider>();
		col.enabled = false;
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		Transform parent = base.transform.parent;
		Quaternion startRot = parent.rotation;
		Quaternion endRot = parent.rotation * Quaternion.AngleAxis(180f, Vector3.forward);
		float progress = 0f;
		while (progress <= spinTime)
		{
			progress += Time.deltaTime;
			parent.rotation = Quaternion.Slerp(startRot, endRot, progress / spinTime);
			yield return null;
		}
		rend.enabled = true;
		col.enabled = true;
		base.transform.GetChild(0).gameObject.SetActive(value: false);
		yield return null;
		crt = null;
		otherSideBook.enabled = true;
	}
}



public class test : MonoBehaviour
{
	private float FixedUpdatesPerFrame;

	private void FixedUpdate()
	{
		FixedUpdatesPerFrame += 1f;
	}

	private void Update()
	{
		Debug.Log("FixedUpdatesPerFrame: " + FixedUpdatesPerFrame);
		FixedUpdatesPerFrame = 0f;
	}
}



public class TextBinds : MonoBehaviour
{
	public string text1;

	public string input;

	public string text2;

	private Text text;

	private TMP_Text textmp;

	private void OnEnable()
	{
		string text = "";
		if (input == "")
		{
			text = text1;
		}
		else
		{
			string text2 = "";
			KeyCode keyCode = MonoSingleton<InputManager>.Instance.Inputs[input];
			switch (keyCode)
			{
			case KeyCode.Mouse0:
				text2 = "Left Mouse Button";
				break;
			case KeyCode.Mouse1:
				text2 = "Right Mouse Button";
				break;
			case KeyCode.Mouse2:
				text2 = "Middle Mouse Button";
				break;
			case KeyCode.Mouse3:
			case KeyCode.Mouse4:
			case KeyCode.Mouse5:
			case KeyCode.Mouse6:
			{
				text2 = keyCode.ToString();
				string s = text2.Substring(text2.Length - 1, 1);
				text2 = text2.Substring(0, text2.Length - 1);
				text2 += int.Parse(s) + 1;
				break;
			}
			default:
				text2 = keyCode.ToString();
				break;
			}
			text2 = MonoSingleton<InputManager>.Instance.GetBindingString(input) ?? text2;
			text = text1 + text2 + this.text2;
		}
		text = text.Replace('$', '\n');
		if (!this.text && !textmp)
		{
			this.text = GetComponent<Text>();
			if (!this.text)
			{
				textmp = GetComponent<TMP_Text>();
			}
		}
		if ((bool)this.text)
		{
			this.text.text = text;
		}
		else if ((bool)textmp)
		{
			textmp.text = text;
		}
	}
}



internal sealed class TextOverride : MonoBehaviour
{
	private Component m_TextComponent;

	[TextArea]
	[SerializeField]
	private string m_KeyboardText;

	[TextArea]
	[SerializeField]
	private string m_GenericText;

	[TextArea]
	[SerializeField]
	private string m_DualShockText;

	private void Awake()
	{
		TMP_Text component2;
		if (TryGetComponent<Text>(out var component))
		{
			m_TextComponent = component;
		}
		else if (TryGetComponent<TMP_Text>(out component2))
		{
			m_TextComponent = component2;
		}
		if (string.IsNullOrEmpty(m_KeyboardText))
		{
			m_KeyboardText = GetText();
		}
	}

	private void Update()
	{
		if (!string.IsNullOrEmpty(m_DualShockText) && MonoSingleton<InputManager>.Instance.LastButtonDevice is DualShockGamepad)
		{
			SetText(m_DualShockText);
		}
		else if (MonoSingleton<InputManager>.Instance.LastButtonDevice is Gamepad)
		{
			SetText(m_GenericText);
		}
		else
		{
			SetText(m_KeyboardText);
		}
	}

	private void SetText(string value)
	{
		if (m_TextComponent is Text)
		{
			((Text)m_TextComponent).text = value;
		}
		else if (m_TextComponent is TMP_Text)
		{
			((TMP_Text)m_TextComponent).text = value;
		}
	}

	private string GetText()
	{
		if (m_TextComponent is Text)
		{
			return ((Text)m_TextComponent).text;
		}
		if (m_TextComponent is TMP_Text)
		{
			return ((TMP_Text)m_TextComponent).text;
		}
		return null;
	}
}


public enum TextureType
{
	Main,
	Emissive
}



public class ThreadedParticleCollision : MonoBehaviour
{
	public ParticleSystem particles;

	public Bloodsplatter bloodsplatter;

	public NativeArray<RaycastCommand> raycasts;

	public NativeArray<RaycastHit> results;

	private CommandJob commandJob;

	private JobHandle handle;

	private List<Vector4> customData = new List<Vector4>();

	private BloodsplatterManager bsm;

	private static Matrix4x4 identityMatrix = Matrix4x4.identity;

	public event Action<NativeSlice<RaycastHit>> collisionEvent;

	private void Awake()
	{
		commandJob.layerMask = LayerMaskDefaults.Get(LMD.Environment);
		if (StockMapInfo.Instance.continuousGibCollisions)
		{
			commandJob.layerMask = (commandJob.layerMask |= 16);
		}
		particles.SetCustomParticleData(customData, ParticleSystemCustomData.Custom1);
		results = new NativeArray<RaycastHit>(particles.main.maxParticles, Allocator.Persistent);
		raycasts = new NativeArray<RaycastCommand>(particles.main.maxParticles, Allocator.Persistent);
		commandJob.raycasts = raycasts;
		commandJob.lastFrameHits = results;
	}

	private void OnEnable()
	{
		bsm = MonoSingleton<BloodsplatterManager>.Instance;
		MonoSingleton<BloodsplatterManager>.Instance.ParticleCollisionStep += Step;
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<BloodsplatterManager>.Instance)
		{
			MonoSingleton<BloodsplatterManager>.Instance.ParticleCollisionStep -= Step;
		}
	}

	private unsafe void Step(float dt)
	{
		if (!handle.IsCompleted)
		{
			return;
		}
		handle.Complete();
		if (results.IsCreated)
		{
			particles.GetCustomParticleData(customData, ParticleSystemCustomData.Custom1);
			int particleCount = particles.particleCount;
			RaycastHit* unsafeBufferPointerWithoutChecks = (RaycastHit*)NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(results);
			for (int i = 0; i < particleCount; i++)
			{
				RaycastHit source = unsafeBufferPointerWithoutChecks[(int)customData[i].w];
				if (source.distance != 0f)
				{
					bloodsplatter.CreateBloodstain(ref Unsafe.AsRef(in source), bsm);
				}
			}
		}
		Transform transform = particles.transform;
		if (transform.hasChanged)
		{
			transform.hasChanged = false;
			if (particles.main.simulationSpace == ParticleSystemSimulationSpace.Local)
			{
				commandJob.transform = transform.localToWorldMatrix;
				commandJob.worldSpace = false;
			}
			else
			{
				commandJob.transform = identityMatrix;
				commandJob.worldSpace = true;
				commandJob.center = transform.position;
			}
		}
		JobHandle dependsOn = commandJob.Schedule(particles, 128);
		handle = RaycastCommand.ScheduleBatch(raycasts, results, 128, dependsOn);
	}

	private void OnDestroy()
	{
		raycasts.Dispose(handle);
		results.Dispose(handle);
	}
}



public class ThrownSword : MonoBehaviour
{
	public EnemyIdentifier thrownBy;

	public Vector3 targetPos;

	public Transform returnTransform;

	public bool active;

	public float speed;

	private bool returning;

	private bool calledReturn;

	public int type;

	public bool friendly;

	public bool deflected;

	private bool hittingPlayer;

	[HideInInspector]
	public bool thrownAtVoid;

	private TimeSince timeSince;

	private List<EnemyIdentifier> hitEnemies = new List<EnemyIdentifier>();

	private int difficulty;

	private void Start()
	{
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		if (type == 1 && difficulty < 2)
		{
			Spin component = base.transform.parent.GetComponent<Spin>();
			if ((bool)component)
			{
				component.speed /= 2f;
			}
		}
		timeSince = 0f;
	}

	private void Update()
	{
		if (hittingPlayer)
		{
			base.transform.position = MonoSingleton<NewMovement>.Instance.transform.position;
		}
		else
		{
			if (!active)
			{
				return;
			}
			if (type == 0)
			{
				if (!returning && base.transform.position != targetPos)
				{
					if (difficulty == 1)
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, targetPos, Time.deltaTime * speed / 1.5f);
					}
					else if (difficulty == 0)
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, targetPos, Time.deltaTime * speed / 2f);
					}
					else
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, targetPos, Time.deltaTime * speed);
					}
					if (base.transform.position == targetPos && !calledReturn)
					{
						calledReturn = true;
						CancelInvoke("Return");
						Invoke("Return", 1f);
					}
					if (thrownAtVoid && (float)timeSince > 1f && Vector3.Distance(base.transform.position, thrownBy.transform.position) - 15f > Vector3.Distance(thrownBy.transform.position, thrownBy.target.headTransform.position))
					{
						calledReturn = true;
						Return();
					}
				}
				else if (returnTransform != null)
				{
					if (difficulty == 1)
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, returnTransform.position, Time.deltaTime * speed / 1.5f);
					}
					else if (difficulty == 0)
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, returnTransform.position, Time.deltaTime * speed / 2f);
					}
					else
					{
						base.transform.position = Vector3.MoveTowards(base.transform.position, returnTransform.position, Time.deltaTime * speed);
					}
					if (!(base.transform.position == returnTransform.position))
					{
						return;
					}
					SwordsMachine componentInParent = returnTransform.GetComponentInParent<SwordsMachine>();
					if (componentInParent != null)
					{
						if (!friendly)
						{
							componentInParent.SwordCatch();
						}
						else if (friendly)
						{
							componentInParent.Knockdown();
						}
					}
					Object.Destroy(base.gameObject);
				}
				else
				{
					Object.Destroy(base.gameObject);
				}
			}
			else
			{
				if (type != 1)
				{
					return;
				}
				if (!returning)
				{
					if (difficulty < 2)
					{
						base.transform.position += base.transform.parent.forward * (15 + difficulty * 5) * Time.deltaTime;
					}
					else if (difficulty < 4)
					{
						base.transform.position += base.transform.parent.forward * 25f * Time.deltaTime;
					}
					else
					{
						base.transform.position += base.transform.parent.forward * 35f * Time.deltaTime;
					}
					return;
				}
				if (base.transform.parent != null)
				{
					base.transform.parent = null;
				}
				if (returnTransform == null)
				{
					Object.Destroy(base.gameObject);
					return;
				}
				base.transform.position = Vector3.MoveTowards(base.transform.position, returnTransform.position, Time.deltaTime * speed * 3f);
				if (!(base.transform.position == returnTransform.position))
				{
					return;
				}
				SwordsMachine componentInParent2 = returnTransform.GetComponentInParent<SwordsMachine>();
				if (componentInParent2 != null)
				{
					if (!friendly)
					{
						componentInParent2.SwordCatch();
					}
					else if (friendly)
					{
						componentInParent2.Knockdown();
					}
				}
				Object.Destroy(base.gameObject);
			}
		}
	}

	public void SetPoints(Vector3 target, Transform origin)
	{
		targetPos = target;
		returnTransform = origin;
		active = true;
		if (type == 1)
		{
			Invoke("Return", 1f);
		}
		else if (!thrownAtVoid)
		{
			Invoke("Return", 2f);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			Invoke("RecheckPlayerHit", 0.05f);
			hittingPlayer = true;
		}
		else
		{
			EnemyIdentifier enemyIdentifier = other.gameObject.GetComponent<EnemyIdentifier>();
			if (enemyIdentifier == null && other.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
			{
				enemyIdentifier = component.eid;
			}
			if (enemyIdentifier != null && !hitEnemies.Contains(enemyIdentifier) && (thrownBy == null || (!enemyIdentifier.immuneToFriendlyFire && !EnemyIdentifier.CheckHurtException(thrownBy.enemyType, enemyIdentifier.enemyType))))
			{
				if (!enemyIdentifier.dead)
				{
					hitEnemies.Add(enemyIdentifier);
				}
				enemyIdentifier.hitter = "enemy";
				enemyIdentifier.DeliverDamage(other.gameObject, GetComponent<Rigidbody>().velocity, base.transform.position, 5f, tryForExplode: false, 0f, null, ignoreTotalDamageTakenMultiplier: true);
			}
		}
		if (deflected && other.gameObject.layer == 8 && !calledReturn)
		{
			targetPos = other.ClosestPoint(base.transform.position);
			if (targetPos.magnitude < 9999f)
			{
				base.transform.position = targetPos;
			}
			else
			{
				targetPos = base.transform.position;
			}
			GetComponent<Rigidbody>().velocity = Vector3.zero;
			calledReturn = true;
			CancelInvoke("Return");
			Invoke("Return", 1f);
		}
	}

	private void RecheckPlayerHit()
	{
		if (hittingPlayer)
		{
			hittingPlayer = false;
			GetComponent<Collider>().enabled = false;
			MonoSingleton<NewMovement>.Instance.GetHurt(30, invincible: true);
		}
	}

	private void Return()
	{
		if (!returning)
		{
			returning = true;
			if (type == 1)
			{
				GetComponent<Collider>().enabled = false;
			}
			else
			{
				base.transform.LookAt(returnTransform);
			}
		}
	}

	public void GetParried()
	{
		CancelInvoke("RecheckPlayerHit");
		hittingPlayer = false;
		friendly = true;
		GetComponent<Collider>().enabled = false;
		Return();
	}
}


public enum TileColor
{
	None,
	Red,
	Green,
	Blue
}


public enum TileType
{
	None,
	White,
	WhiteEnd,
	WhiteFill,
	WhitePit
}



public class TimeBomb : MonoBehaviour
{
	public bool dontStartOnAwake;

	private bool activated;

	public float timer;

	public float beeptimer;

	public bool freezeOnNoCooldown;

	private AudioSource aud;

	public GameObject beepLight;

	public float beeperSize;

	[HideInInspector]
	public float beeperSizeMultiplier = 1f;

	private GameObject beeper;

	private Vector3 origScale;

	public Color beeperColor = Color.white;

	private SpriteRenderer beeperSpriteRenderer;

	public float beeperPitch = 0.65f;

	public GameObject explosion;

	public bool dontExplode;

	private bool isActive;

	private void Start()
	{
		if (!dontStartOnAwake)
		{
			StartCountdown();
		}
	}

	private void OnEnable()
	{
		if (!isActive && (bool)MonoSingleton<GunControl>.Instance && MonoSingleton<GunControl>.Instance.gameObject.activeInHierarchy && MonoSingleton<GunControl>.Instance.enabled)
		{
			MonoSingleton<GunControl>.Instance.StartCoroutine(CheckDisabled());
		}
	}

	private IEnumerator CheckDisabled()
	{
		WaitForEndOfFrame waitForEnd = new WaitForEndOfFrame();
		isActive = true;
		while ((bool)this && base.gameObject.activeInHierarchy)
		{
			yield return waitForEnd;
		}
		isActive = false;
	}

	private void OnDestroy()
	{
		if (!dontExplode && explosion != null && isActive)
		{
			Object.Instantiate(explosion, base.transform.position, base.transform.rotation);
		}
	}

	private void Update()
	{
		if (!activated)
		{
			return;
		}
		if (!PauseTimedBombs.Paused && (!NoWeaponCooldown.NoCooldown || !freezeOnNoCooldown))
		{
			timer = Mathf.MoveTowards(timer, 0f, Time.deltaTime);
			beeptimer = Mathf.MoveTowards(beeptimer, 0f, Time.deltaTime);
			if (beeptimer == 0f)
			{
				Beep();
			}
		}
		if ((bool)beeperSpriteRenderer)
		{
			beeperSpriteRenderer.color = beeperColor;
		}
		if ((bool)aud)
		{
			aud.pitch = beeperPitch;
		}
		if (timer != 0f && (bool)beeper)
		{
			beeper.transform.localScale = Vector3.Lerp(beeper.transform.localScale, Vector3.zero, Time.deltaTime * 5f);
		}
		else
		{
			Object.Destroy(base.gameObject);
		}
	}

	public void StartCountdown()
	{
		if (!activated)
		{
			activated = true;
		}
		Beep();
	}

	private void Beep()
	{
		if (beeper == null)
		{
			beeper = Object.Instantiate(beepLight, base.transform.position, base.transform.rotation);
			beeper.transform.SetParent(base.transform, worldPositionStays: true);
			origScale = new Vector3(beeperSize, beeperSize, 1f);
			beeperSpriteRenderer = beeper.GetComponent<SpriteRenderer>();
			aud = beeper.GetComponent<AudioSource>();
			if ((bool)aud)
			{
				aud.pitch = beeperPitch;
			}
		}
		if ((bool)aud)
		{
			aud.Play();
		}
		beeper.transform.localScale = origScale * beeperSizeMultiplier;
		beeptimer = timer / 6f;
	}
}



public class TimeChallenge : MonoBehaviour
{
	public float time;

	public bool reachedGoal;

	private void Update()
	{
		if (MonoSingleton<StatsManager>.Instance.seconds >= time && !reachedGoal)
		{
			MonoSingleton<ChallengeManager>.Instance.challengeFailed = true;
			MonoSingleton<ChallengeManager>.Instance.challengeFailedPermanently = true;
			base.enabled = false;
		}
		else
		{
			MonoSingleton<ChallengeManager>.Instance.challengeDone = true;
		}
	}

	public void ReachedGoal()
	{
		reachedGoal = true;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class TimeController : MonoSingleton<TimeController>
{
	[SerializeField]
	private GameObject parryLight;

	[SerializeField]
	private GameObject parryFlash;

	private float currentStop;

	private AudioMixer[] audmix;

	[HideInInspector]
	public bool controlTimeScale = true;

	[HideInInspector]
	public bool controlPitch = true;

	[HideInInspector]
	public bool parryFlashEnabled = true;

	public float timeScale = 1f;

	public float timeScaleModifier = 1f;

	private float slowDown = 1f;

	private void Start()
	{
		audmix = new AudioMixer[4]
		{
			MonoSingleton<AudioMixerController>.Instance.allSound,
			MonoSingleton<AudioMixerController>.Instance.goreSound,
			MonoSingleton<AudioMixerController>.Instance.musicSound,
			MonoSingleton<AudioMixerController>.Instance.doorSound
		};
		if ((bool)MonoSingleton<AssistController>.Instance && MonoSingleton<AssistController>.Instance.majorEnabled)
		{
			timeScale = MonoSingleton<AssistController>.Instance.gameSpeed;
		}
		else
		{
			timeScale = 1f;
		}
		Time.timeScale = timeScale * timeScaleModifier;
		parryFlashEnabled = MonoSingleton<PrefsManager>.Instance.GetBool("parryFlash");
	}

	private void Update()
	{
		if (controlTimeScale)
		{
			if (MonoSingleton<AssistController>.Instance.majorEnabled && timeScale != MonoSingleton<AssistController>.Instance.gameSpeed)
			{
				timeScale = MonoSingleton<AssistController>.Instance.gameSpeed;
				Time.timeScale = timeScale * timeScaleModifier;
			}
			else if (!MonoSingleton<AssistController>.Instance.majorEnabled && timeScale != 1f)
			{
				timeScale = 1f;
				Time.timeScale = timeScale * timeScaleModifier;
			}
		}
	}

	private void FixedUpdate()
	{
		if (MonoSingleton<OptionsManager>.Instance.paused)
		{
			return;
		}
		if (slowDown < timeScale * timeScaleModifier)
		{
			slowDown = Mathf.MoveTowards(slowDown, timeScale * timeScaleModifier, 0.02f);
			Time.timeScale = slowDown;
			if (controlPitch)
			{
				AudioMixer[] array = audmix;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetFloat("allPitch", slowDown / timeScale / (MonoSingleton<AssistController>.Instance.majorEnabled ? MonoSingleton<AssistController>.Instance.gameSpeed : 1f));
				}
			}
		}
		else if (controlPitch)
		{
			AudioMixer[] array = audmix;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetFloat("allPitch", timeScale / (MonoSingleton<AssistController>.Instance.majorEnabled ? MonoSingleton<AssistController>.Instance.gameSpeed : 1f));
			}
		}
	}

	public void ParryFlash()
	{
		GameObject gameObject = Object.Instantiate(parryLight, MonoSingleton<PlayerTracker>.Instance.GetTarget().position, Quaternion.identity, MonoSingleton<PlayerTracker>.Instance.GetTarget());
		Light component;
		if (parryFlashEnabled)
		{
			if (parryFlash != null)
			{
				parryFlash.SetActive(value: true);
			}
			Invoke("HideFlash", 0.1f);
		}
		else if (gameObject.TryGetComponent<Light>(out component))
		{
			component.enabled = false;
		}
		TrueStop(0.25f);
		MonoSingleton<CameraController>.Instance.CameraShake(0.5f);
		MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.ParryFlash);
	}

	private void HideFlash()
	{
		parryFlash?.SetActive(value: false);
		if ((bool)MonoSingleton<CrowdReactions>.Instance && MonoSingleton<CrowdReactions>.Instance.enabled)
		{
			MonoSingleton<CrowdReactions>.Instance.React(MonoSingleton<CrowdReactions>.Instance.cheer);
		}
	}

	public void SlowDown(float amount)
	{
		if (amount <= 0f)
		{
			amount = 0.01f;
		}
		slowDown = amount;
	}

	public void HitStop(float length)
	{
		if (length > currentStop)
		{
			currentStop = length;
			Time.timeScale = 0f;
			StartCoroutine(TimeIsStopped(length, trueStop: false));
		}
	}

	public void TrueStop(float length)
	{
		if (!(length > currentStop))
		{
			return;
		}
		currentStop = length;
		if (controlPitch)
		{
			AudioMixer[] array = audmix;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetFloat("allPitch", 0f);
			}
		}
		Time.timeScale = 0f;
		StartCoroutine(TimeIsStopped(length, trueStop: true));
	}

	private IEnumerator TimeIsStopped(float length, bool trueStop)
	{
		yield return new WaitForSecondsRealtime(length);
		ContinueTime(length, trueStop);
	}

	private void ContinueTime(float length, bool trueStop)
	{
		if (!(length >= currentStop))
		{
			return;
		}
		Time.timeScale = timeScale * timeScaleModifier;
		if (trueStop && controlPitch)
		{
			AudioMixer[] array = audmix;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetFloat("allPitch", 1f);
			}
		}
		currentStop = 0f;
	}

	public void RestoreTime()
	{
		Time.timeScale = timeScale * timeScaleModifier;
		currentStop = 0f;
	}
}



public static class TimeHelper
{
	public static string ConvertSecondsToString(float seconds)
	{
		int num = Mathf.FloorToInt(seconds / 60f);
		return string.Concat(arg2: (seconds % 60f).ToString("00.000"), arg0: num, arg1: ":");
	}
}



public class TimeOfDayChanger : MonoBehaviour
{
	public float speedMultiplier = 1f;

	private bool allOff;

	private bool allDone = true;

	public bool oneTime;

	public bool dontActivateOnEnable;

	private bool activated;

	private bool colliderless;

	public Light[] oldLights;

	public Light[] newLights;

	private List<float> orgOldIntensities = new List<float>();

	private List<float> origIntensities = new List<float>();

	public Material oldWalls;

	public Material oldSky;

	public Material newWalls;

	public Material newSky;

	public bool toBattleMusic;

	public bool toBossMusic;

	public bool musicWaitsUntilChange;

	public bool revertValuesOnFinish;

	public Material newSkybox;

	private Color skyboxColor;

	private Material oldSkyboxTemp;

	private Material newSkyboxTemp;

	public SpriteRenderer sunSprite;

	public Color sunSpriteColor;

	[Header("Fog")]
	public Color fogColor;

	public bool overrideFogSettings;

	public float fogStart = 450f;

	public float fogEnd = 600f;

	[Header("Lighting")]
	public Color ambientLightingColor;

	[Header("Events")]
	public UnityEvent onMaterialChange;

	private Color originalFogColor;

	private float originalFogStart;

	private float originalFogEnd;

	private Color originalSkyboxTint;

	private Color originalAmbientColor;

	private float transitionState;

	private static readonly int Tint = Shader.PropertyToID("_Tint");

	private void OnEnable()
	{
		if (!TryGetComponent<Collider>(out var _) && !TryGetComponent<Rigidbody>(out var _))
		{
			colliderless = true;
		}
		if (!dontActivateOnEnable && colliderless)
		{
			Activate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.transform == MonoSingleton<NewMovement>.Instance.transform)
		{
			Activate();
		}
	}

	public void Activate()
	{
		if (oneTime && activated)
		{
			return;
		}
		activated = true;
		if (newLights.Length != 0)
		{
			for (int i = 0; i < newLights.Length; i++)
			{
				if (!newLights[i])
				{
					origIntensities.Add(0f);
					continue;
				}
				origIntensities.Add(newLights[i].intensity);
				if (oldLights.Length != 0)
				{
					newLights[i].intensity = 0f;
				}
				newLights[i].enabled = true;
			}
		}
		if (oldLights.Length != 0)
		{
			Light[] array = oldLights;
			foreach (Light light in array)
			{
				if (!light)
				{
					orgOldIntensities.Add(0f);
				}
				else
				{
					orgOldIntensities.Add(light.intensity);
				}
			}
		}
		if ((bool)newSkybox && newLights.Length != 0)
		{
			oldSkyboxTemp = new Material(RenderSettings.skybox);
			RenderSettings.skybox = oldSkyboxTemp;
		}
		originalFogColor = RenderSettings.fogColor;
		originalFogStart = RenderSettings.fogStartDistance;
		originalFogEnd = RenderSettings.fogEndDistance;
		originalAmbientColor = RenderSettings.ambientLight;
		if ((bool)RenderSettings.skybox && newLights.Length != 0 && RenderSettings.skybox.HasProperty(Tint))
		{
			originalSkyboxTint = RenderSettings.skybox.GetColor("_Tint");
		}
		transitionState = 0f;
		allDone = false;
		allOff = false;
		if (!musicWaitsUntilChange)
		{
			if (toBattleMusic)
			{
				MonoSingleton<MusicManager>.Instance.ArenaMusicStart();
			}
			else if (toBossMusic)
			{
				MonoSingleton<MusicManager>.Instance.PlayBossMusic();
			}
		}
	}

	private void ChangeMaterials()
	{
		MeshRenderer[] array = Object.FindObjectsOfType<MeshRenderer>();
		foreach (MeshRenderer meshRenderer in array)
		{
			if (meshRenderer.sharedMaterial == oldWalls)
			{
				meshRenderer.material = newWalls;
			}
			else if (meshRenderer.sharedMaterial == oldSky)
			{
				meshRenderer.material = newSky;
			}
		}
		if (musicWaitsUntilChange)
		{
			if (toBattleMusic)
			{
				MonoSingleton<MusicManager>.Instance.ArenaMusicStart();
			}
			else if (toBossMusic)
			{
				MonoSingleton<MusicManager>.Instance.PlayBossMusic();
			}
		}
		if ((bool)newSkybox)
		{
			newSkyboxTemp = new Material(newSkybox);
			RenderSettings.skybox = newSkyboxTemp;
			if (newLights.Length != 0 && RenderSettings.skybox.HasProperty(Tint))
			{
				skyboxColor = RenderSettings.skybox.GetColor("_Tint");
				RenderSettings.skybox.SetColor("_Tint", Color.black);
			}
		}
		if (revertValuesOnFinish)
		{
			for (int j = 0; j < oldLights.Length; j++)
			{
				if ((bool)oldLights[j])
				{
					oldLights[j].transform.parent.gameObject.SetActive(value: false);
					oldLights[j].intensity = orgOldIntensities[j];
				}
			}
		}
		onMaterialChange?.Invoke();
	}

	private void Update()
	{
		if (allDone)
		{
			return;
		}
		transitionState += Time.deltaTime * speedMultiplier;
		RenderSettings.fogColor = Color.Lerp(originalFogColor, fogColor, transitionState / 2f);
		if (overrideFogSettings)
		{
			RenderSettings.fogStartDistance = Mathf.Lerp(originalFogStart, fogStart, transitionState / 2f);
			RenderSettings.fogEndDistance = Mathf.Lerp(originalFogEnd, fogEnd, transitionState / 2f);
		}
		RenderSettings.ambientLight = Color.Lerp(originalAmbientColor, ambientLightingColor, transitionState / 2f);
		if ((bool)sunSprite)
		{
			sunSprite.color = Color.Lerp(sunSprite.color, sunSpriteColor, transitionState / 2f);
		}
		if (!allOff)
		{
			bool flag = true;
			for (int i = 0; i < oldLights.Length; i++)
			{
				if (!oldLights[i])
				{
					continue;
				}
				Light light = oldLights[i];
				if (light.intensity != 0f)
				{
					light.intensity = Mathf.MoveTowards(light.intensity, 0f, Time.deltaTime * orgOldIntensities[i] * speedMultiplier);
					if (light.intensity != 0f)
					{
						flag = false;
					}
				}
			}
			if ((bool)newSkybox && newLights.Length != 0 && RenderSettings.skybox.HasProperty(Tint))
			{
				RenderSettings.skybox.SetColor(Tint, Color.Lerp(originalSkyboxTint, Color.black, transitionState));
			}
			if (flag)
			{
				allOff = true;
				ChangeMaterials();
			}
		}
		else if (newLights.Length != 0)
		{
			bool flag2 = true;
			for (int j = 0; j < newLights.Length; j++)
			{
				if ((bool)newLights[j] && newLights[j].intensity != origIntensities[j])
				{
					newLights[j].intensity = Mathf.MoveTowards(newLights[j].intensity, origIntensities[j], Time.deltaTime * origIntensities[j] * speedMultiplier);
					if (newLights[j].intensity != origIntensities[j])
					{
						flag2 = false;
					}
				}
			}
			if ((bool)newSkybox && RenderSettings.skybox.HasProperty(Tint))
			{
				RenderSettings.skybox.SetColor(Tint, Color.Lerp(Color.black, skyboxColor, transitionState - 1f));
			}
			if (flag2)
			{
				if ((bool)newSkybox && RenderSettings.skybox.HasProperty(Tint))
				{
					RenderSettings.skybox.SetColor(Tint, skyboxColor);
				}
				RenderSettings.fogColor = fogColor;
				if (overrideFogSettings)
				{
					RenderSettings.fogStartDistance = fogStart;
					RenderSettings.fogEndDistance = fogEnd;
				}
				RenderSettings.ambientLight = ambientLightingColor;
				allDone = true;
			}
			else
			{
				RenderSettings.fogColor = Color.Lerp(originalFogColor, fogColor, transitionState / 2f);
				if (overrideFogSettings)
				{
					RenderSettings.fogStartDistance = Mathf.Lerp(originalFogStart, fogStart, transitionState / 2f);
					RenderSettings.fogEndDistance = Mathf.Lerp(originalFogEnd, fogEnd, transitionState / 2f);
				}
				RenderSettings.ambientLight = Color.Lerp(originalAmbientColor, ambientLightingColor, transitionState / 2f);
			}
		}
		else
		{
			RenderSettings.fogColor = fogColor;
			if (overrideFogSettings)
			{
				RenderSettings.fogStartDistance = fogStart;
				RenderSettings.fogEndDistance = fogEnd;
			}
			RenderSettings.ambientLight = ambientLightingColor;
			allDone = true;
		}
	}
}



[Serializable]
public class TimeSignatureChange
{
	public float onMeasure;

	[HideInInspector]
	public float time;

	public float timeSignature;
}



[Serializable]
public struct TimeSince
{
	private float time;

	public const int Now = 0;

	public static implicit operator float(TimeSince ts)
	{
		return Time.time - ts.time;
	}

	public static implicit operator TimeSince(float ts)
	{
		TimeSince result = default(TimeSince);
		result.time = Time.time - ts;
		return result;
	}

	public new string ToString()
	{
		return ((float)this).ToString(CultureInfo.InvariantCulture);
	}
}



public class TitleScreen : MonoBehaviour
{
	private bool sequenceStarted;

	public MusicManager mman;

	public GameObject[] hud;

	public GameObject titleScreen;

	private Text title;

	public GameObject worldRevolver;

	public GameObject revolver;

	public GameObject arenaActivator;

	private void OnTriggerEnter(Collider other)
	{
		if (!sequenceStarted && other.gameObject.CompareTag("Player"))
		{
			sequenceStarted = true;
			RevolverPickedUp();
			GameObject[] array = hud;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			mman.StartMusic();
			mman.ArenaMusicStart();
			titleScreen.SetActive(value: true);
			title = titleScreen.GetComponent<Text>();
			title.resizeTextMaxSize = 1000;
			Invoke("HideTitle", 4.5f);
		}
	}

	private void Update()
	{
		if (sequenceStarted && titleScreen.activeSelf)
		{
			base.transform.parent.position += Vector3.down * Time.deltaTime * 10f;
		}
	}

	private void HideTitle()
	{
		titleScreen.SetActive(value: false);
		arenaActivator.SetActive(value: true);
	}

	private void RevolverPickedUp()
	{
		worldRevolver.SetActive(value: false);
		revolver.SetActive(value: true);
	}
}


public enum ToDo
{
	Nothing,
	Disable,
	Destroy
}



public class TooltipManager : MonoBehaviour
{
	public GameObject tooltipTemplate;

	private Dictionary<Guid, GameObject> dict = new Dictionary<Guid, GameObject>();

	private RectTransform canvasRect;

	private void Awake()
	{
		Canvas componentInParent = GetComponentInParent<Canvas>();
		if (componentInParent != null)
		{
			canvasRect = componentInParent.GetComponent<RectTransform>();
		}
	}

	public Guid ShowTooltip(Vector2 position, string text = "")
	{
		Guid guid = Guid.NewGuid();
		GameObject gameObject = UnityEngine.Object.Instantiate(tooltipTemplate);
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject.SetActive(value: true);
		TextMeshProUGUI componentInChildren = gameObject.GetComponentInChildren<TextMeshProUGUI>();
		componentInChildren.text = text;
		componentInChildren.ForceMeshUpdate();
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.position = position;
		Vector2 preferredValues = componentInChildren.GetPreferredValues();
		component.sizeDelta = preferredValues;
		EnsureWithinBounds(component);
		dict.Add(guid, gameObject);
		return guid;
	}

	public void HideTooltip(Guid id)
	{
		if (dict.TryGetValue(id, out var value))
		{
			UnityEngine.Object.Destroy(value);
			dict.Remove(id);
		}
	}

	private void EnsureWithinBounds(RectTransform rect)
	{
		if (!(canvasRect == null) && !(rect == null))
		{
			Vector2 sizeDelta = canvasRect.sizeDelta;
			Vector2 sizeDelta2 = rect.sizeDelta;
			Vector2 anchoredPosition = rect.anchoredPosition;
			if (anchoredPosition.x + sizeDelta2.x > sizeDelta.x)
			{
				anchoredPosition.x = sizeDelta.x - sizeDelta2.x;
			}
			if (anchoredPosition.y - sizeDelta2.y < 0f - sizeDelta.y)
			{
				anchoredPosition.y = 0f - sizeDelta.y + sizeDelta2.y;
			}
			rect.anchoredPosition = anchoredPosition;
		}
	}
}



public class TooltipOnHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public TooltipManager tooltipManager;

	public float hoverTime = 0.5f;

	[HideInInspector]
	public bool multiline;

	[HideInInspector]
	public string text;

	private bool hovered;

	private UnscaledTimeSince sinceHoverStart;

	private Guid tooltipId = Guid.Empty;

	public void OnPointerEnter(PointerEventData eventData)
	{
		hovered = true;
		sinceHoverStart = 0f;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		hovered = false;
		if (tooltipId != Guid.Empty)
		{
			tooltipManager.HideTooltip(tooltipId);
			tooltipId = Guid.Empty;
		}
	}

	private void Update()
	{
		if (hovered && (float)sinceHoverStart > hoverTime && tooltipId == Guid.Empty)
		{
			if (!multiline)
			{
				text = text.Replace("\n", " ");
			}
			tooltipId = tooltipManager.ShowTooltip(Mouse.current.position.ReadValue(), text);
		}
	}

	private void OnDisable()
	{
		if (tooltipId != Guid.Empty)
		{
			tooltipManager.HideTooltip(tooltipId);
			tooltipId = Guid.Empty;
		}
	}
}



public class Torch : MonoBehaviour
{
	private Light torchLight;

	private bool pickedUp;

	private Vector3 originalPos;

	private ItemIdentifier itid;

	private void Start()
	{
		torchLight = GetComponentInChildren<Light>();
		originalPos = torchLight.transform.localPosition;
		itid = GetComponent<ItemIdentifier>();
	}

	private void Update()
	{
		if (pickedUp && (bool)torchLight && !itid.hooked)
		{
			torchLight.transform.position = MonoSingleton<PlayerTracker>.Instance.GetTarget().position;
		}
		else if (torchLight.transform.localPosition != originalPos)
		{
			torchLight.transform.localPosition = originalPos;
		}
	}

	public void HitWith(GameObject target)
	{
		Flammable component = target.gameObject.GetComponent<Flammable>();
		if (component != null && !component.enemyOnly)
		{
			component.Burn(4f);
		}
	}

	public void HitSurface(RaycastHit hit)
	{
		MonoSingleton<StainVoxelManager>.Instance.TryIgniteAt(hit.point);
	}

	public void PickUp()
	{
		pickedUp = true;
	}

	public void PutDown()
	{
		pickedUp = false;
		torchLight.transform.localPosition = originalPos;
	}
}



public class TramControl : MonoBehaviour
{
	[SerializeField]
	private Tram targetTram;

	[Space]
	[SerializeField]
	private GameObject clickSound;

	[SerializeField]
	private GameObject clickFailSound;

	[Space]
	[SerializeField]
	private int maxSpeedStep;

	[SerializeField]
	private int minSpeedStep;

	[SerializeField]
	private float speedMultiplier;

	[HideInInspector]
	public float zapAmount;

	[SerializeField]
	private Image[] speedIndicators;

	public float maxPlayerDistance = 15f;

	public int currentSpeedStep;

	private int lastSpeedStep;

	[SerializeField]
	private GameObject zapEffects;

	[SerializeField]
	private Light zapLight;

	[SerializeField]
	private SpriteRenderer zapSprite;

	[SerializeField]
	private AudioSource zapSound;

	private void Awake()
	{
		if ((bool)targetTram)
		{
			targetTram.controller = this;
		}
	}

	public void SpeedUp()
	{
		if (SpeedUp(1))
		{
			if ((bool)clickSound)
			{
				Object.Instantiate(clickSound, base.transform.position, Quaternion.identity);
			}
		}
		else if ((bool)clickFailSound)
		{
			Object.Instantiate(clickFailSound, base.transform.position, Quaternion.identity);
		}
	}

	public void SpeedDown()
	{
		if (SpeedDown(1))
		{
			if ((bool)clickSound)
			{
				Object.Instantiate(clickSound, base.transform.position, Quaternion.identity);
			}
		}
		else if ((bool)clickFailSound)
		{
			Object.Instantiate(clickFailSound, base.transform.position, Quaternion.identity);
		}
	}

	public bool SpeedUp(int amount)
	{
		if (!targetTram.poweredOn)
		{
			return false;
		}
		if (targetTram.currentPoint != null && targetTram.currentPoint.GetDestination() == null)
		{
			return false;
		}
		if (zapAmount > 0f)
		{
			currentSpeedStep = maxSpeedStep;
		}
		else if (currentSpeedStep < maxSpeedStep)
		{
			if (currentSpeedStep + amount <= maxSpeedStep)
			{
				currentSpeedStep += amount;
			}
			else
			{
				currentSpeedStep = maxSpeedStep;
			}
			return true;
		}
		return false;
	}

	public bool SpeedDown(int amount)
	{
		if (!targetTram.poweredOn)
		{
			return false;
		}
		if (targetTram.currentPoint != null && targetTram.currentPoint.GetDestination(forward: false) == null)
		{
			return false;
		}
		if (zapAmount > 0f)
		{
			currentSpeedStep = minSpeedStep;
		}
		else if (currentSpeedStep > minSpeedStep)
		{
			if (currentSpeedStep - amount >= minSpeedStep)
			{
				currentSpeedStep -= amount;
			}
			else
			{
				currentSpeedStep = minSpeedStep;
			}
			return true;
		}
		return false;
	}

	private void LateUpdate()
	{
		if (zapAmount > 0f)
		{
			zapAmount = Mathf.MoveTowards(zapAmount, 0f, Time.deltaTime);
			targetTram.zapAmount = zapAmount;
			if (currentSpeedStep != 0)
			{
				currentSpeedStep = ((currentSpeedStep > 0) ? maxSpeedStep : minSpeedStep);
			}
			targetTram.speed = (float)currentSpeedStep * (speedMultiplier / 10f);
		}
		else
		{
			targetTram.speed = Mathf.MoveTowards(targetTram.speed, (float)currentSpeedStep * (speedMultiplier / 10f), speedMultiplier / 10f * Time.deltaTime);
		}
		UpdateZapEffects();
		if (currentSpeedStep != 0)
		{
			if (!targetTram.poweredOn)
			{
				currentSpeedStep = 0;
			}
			else if (targetTram.movementDirection == TramMovementDirection.Forward && !targetTram.canGoForward)
			{
				currentSpeedStep = 0;
				targetTram.speed = 0f;
			}
			else if (targetTram.movementDirection == TramMovementDirection.Backward && !targetTram.canGoBackward)
			{
				currentSpeedStep = 0;
				targetTram.speed = 0f;
			}
		}
		if (lastSpeedStep != currentSpeedStep)
		{
			lastSpeedStep = currentSpeedStep;
			UpdateSpeedIndicators();
		}
	}

	private void FixedUpdate()
	{
		if (maxPlayerDistance != 0f && Vector3.Distance(base.transform.position, MonoSingleton<PlayerTracker>.Instance.GetPlayer().position) > maxPlayerDistance)
		{
			currentSpeedStep = 0;
		}
	}

	private void UpdateSpeedIndicators()
	{
		for (int i = 0; i < speedIndicators.Length; i++)
		{
			speedIndicators[i].fillCenter = i == currentSpeedStep - minSpeedStep;
		}
	}

	public void Zap()
	{
		zapAmount = 5f;
		targetTram.zapAmount = zapAmount;
		UpdateZapEffects();
	}

	private void UpdateZapEffects()
	{
		if (zapAmount > 0f && !zapEffects.activeSelf)
		{
			zapEffects.SetActive(value: true);
		}
		else if (zapAmount <= 0f && zapEffects.activeSelf)
		{
			zapEffects.SetActive(value: false);
		}
		zapLight.intensity = Mathf.Lerp(0f, 10f, zapAmount);
		zapSprite.color = new Color(zapSprite.color.r, zapSprite.color.g, zapSprite.color.b, Mathf.Lerp(0f, 1f, zapAmount));
		zapSound.volume = Mathf.Lerp(0f, 0.5f, zapAmount);
		zapSound.pitch = Mathf.Lerp(0f, 1f, zapAmount);
	}
}



[DisallowMultipleComponent]
public sealed class TriggerEnterMessage : MessageDispatcher<Collider>.Callback<UnityEventCollider>
{
	private void OnTriggerEnter(Collider other)
	{
		Handler.Invoke(other);
	}
}



[DisallowMultipleComponent]
public sealed class TriggerExitMessage : MessageDispatcher<Collider>.Callback<UnityEventCollider>
{
	private void OnTriggerExit(Collider other)
	{
		Handler.Invoke(other);
	}
}



[DisallowMultipleComponent]
public sealed class TriggerStayMessage : MessageDispatcher<Collider>.Callback<UnityEventCollider>
{
	private void OnTriggerStay(Collider other)
	{
		Handler.Invoke(other);
	}
}



public class TriggerSubtitle : MonoBehaviour
{
	[SerializeField]
	[TextArea]
	private string caption;

	[SerializeField]
	private bool ignorePlayerPreferences;

	[SerializeField]
	private bool activateOnEnableIfNoTrigger = true;

	private Collider col;

	private void Awake()
	{
		Collider component = GetComponent<Collider>();
		if ((bool)component && component.isTrigger)
		{
			col = component;
		}
	}

	private void OnEnable()
	{
		if (!col && activateOnEnableIfNoTrigger)
		{
			PushCaption();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player"))
		{
			PushCaption();
		}
	}

	public void PushCaption()
	{
		PushCaptionOverride(caption);
	}

	public void PushCaptionOverride(string caption)
	{
		if ((bool)MonoSingleton<SubtitleController>.Instance)
		{
			MonoSingleton<SubtitleController>.Instance.DisplaySubtitle(caption, null, ignorePlayerPreferences);
		}
	}
}



public class Turret : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("Turret");

	public bool stationary;

	public bool quickStart;

	private Vector3 stationaryPosition;

	private NavMeshPath path;

	private Vector3 aimPos;

	[HideInInspector]
	public bool lodged;

	[HideInInspector]
	public bool aiming;

	private float outOfSightTimer;

	private float aimTime;

	private float maxAimTime = 5f;

	private float flashTime;

	private float nextBeepTime;

	private bool whiteLine;

	private Color defaultColor = new Color(1f, 0.44f, 0.74f);

	private Vector3 lastPlayerPosition;

	private int shotsInARow;

	private TimeSince sinceLastBeep;

	private int difficulty;

	private float cooldown = 2f;

	private float kickCooldown = 1f;

	[HideInInspector]
	public bool inAction;

	private bool bodyRotate;

	private bool bodyTrackPlayer;

	private bool bodyReset;

	private Quaternion currentBodyRotation;

	private bool walking;

	private Vector3 walkTarget;

	public Color defaultLightsColor;

	public Color attackingLightsColor;

	private float lightsIntensityTarget = 1.5f;

	private float currentLightsIntensity = 1.25f;

	[Header("Defaults")]
	[SerializeField]
	private Transform torso;

	[SerializeField]
	private Transform turret;

	[SerializeField]
	private Transform shootPoint;

	[SerializeField]
	private LineRenderer aimLine;

	[SerializeField]
	private RevolverBeam beam;

	[SerializeField]
	private GameObject warningFlash;

	[SerializeField]
	private ParticleSystem antennaFlash;

	[SerializeField]
	private Light antennaLight;

	[SerializeField]
	private AudioSource antennaSound;

	[SerializeField]
	private Animator anim;

	[SerializeField]
	private Machine mach;

	[SerializeField]
	private EnemyIdentifier eid;

	[SerializeField]
	private GameObject head;

	[SerializeField]
	private NavMeshAgent nma;

	public GameObject antenna;

	public List<Transform> interruptables = new List<Transform>();

	[SerializeField]
	private AudioSource interruptSound;

	[SerializeField]
	private AudioSource cancelSound;

	[SerializeField]
	private AudioSource footStep;

	[SerializeField]
	private AudioSource extendSound;

	[SerializeField]
	private AudioSource thunkSound;

	[SerializeField]
	private AudioSource kickWarningSound;

	[SerializeField]
	private AudioSource aimWarningSound;

	private AudioSource currentSound;

	[SerializeField]
	private GameObject rubble;

	[SerializeField]
	private GameObject rubbleLeft;

	[SerializeField]
	private GameObject rubbleRight;

	private bool leftLodged;

	private bool rightLodged;

	[SerializeField]
	private SkinnedMeshRenderer smr;

	[SerializeField]
	private GameObject unparryableFlash;

	[SerializeField]
	private SwingCheck2 sc;

	[SerializeField]
	private TrailRenderer tr;

	private EnemyTarget target => eid.target;

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
	}

	private void Start()
	{
		currentBodyRotation = base.transform.rotation;
		difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		path = new NavMeshPath();
		if (stationary)
		{
			stationaryPosition = base.transform.position;
		}
		if (quickStart)
		{
			cooldown = 0.5f;
		}
		Invoke("SlowUpdate", 0.5f);
		switch (difficulty)
		{
		case 0:
			maxAimTime = 7.5f;
			anim.speed = 0.5f;
			break;
		case 1:
			maxAimTime = 5f;
			anim.speed = 0.75f;
			break;
		case 2:
			maxAimTime = 5f;
			break;
		case 3:
			maxAimTime = 4f;
			break;
		case 4:
		case 5:
			maxAimTime = 3f;
			break;
		}
		if (difficulty >= 2)
		{
			anim.speed = 1f;
		}
		anim.speed *= eid.totalSpeedModifier;
	}

	private void UpdateBuff()
	{
		if (difficulty >= 2)
		{
			anim.speed = 1f;
		}
		else if (difficulty == 1)
		{
			anim.speed = 0.75f;
		}
		else
		{
			anim.speed = 0.5f;
		}
		anim.speed *= eid.totalSpeedModifier;
	}

	private void OnEnable()
	{
		Unlodge();
		CancelAim(instant: true);
		DamageStop();
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.25f);
		if (target == null)
		{
			return;
		}
		if (!inAction && mach.grounded && nma.isOnNavMesh)
		{
			if (stationary)
			{
				if (!(Vector3.Distance(base.transform.position, stationaryPosition) > 1f))
				{
					return;
				}
				NavMesh.CalculatePath(base.transform.position, stationaryPosition, nma.areaMask, path);
				if (path.status == NavMeshPathStatus.PathComplete)
				{
					nma.path = path;
					return;
				}
			}
			bool flag = false;
			if (Physics.CheckSphere(torso.position - Vector3.up * 0.5f, 1.5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)) || Physics.SphereCast(torso.position - Vector3.up * 0.5f, 1.5f, target.position + Vector3.up - torso.position, out var _, Vector3.Distance(target.position + Vector3.up, torso.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies)))
			{
				NavMesh.CalculatePath(base.transform.position, target.position, nma.areaMask, path);
				if (path.status == NavMeshPathStatus.PathComplete)
				{
					walking = false;
					flag = true;
					nma.path = path;
				}
			}
			if (!walking && !flag)
			{
				Vector3 onUnitSphere = Random.onUnitSphere;
				onUnitSphere = new Vector3(onUnitSphere.x, 0f, onUnitSphere.z);
				RaycastHit hitInfo3;
				if (Physics.Raycast(torso.position, onUnitSphere, out var hitInfo2, 25f, LayerMaskDefaults.Get(LMD.Environment)))
				{
					if (NavMesh.SamplePosition(hitInfo2.point, out var hit, 5f, nma.areaMask))
					{
						walkTarget = hit.position;
					}
					else if (Physics.SphereCast(hitInfo2.point, 1f, Vector3.down, out hitInfo2, 25f, LayerMaskDefaults.Get(LMD.Environment)))
					{
						walkTarget = hitInfo2.point;
					}
				}
				else if (Physics.Raycast(torso.position + onUnitSphere * 25f, Vector3.down, out hitInfo3, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.Environment)))
				{
					walkTarget = hitInfo3.point;
				}
				NavMesh.CalculatePath(base.transform.position, walkTarget, nma.areaMask, path);
				nma.path = path;
				walking = true;
			}
			else if (Vector3.Distance(base.transform.position, walkTarget) < 1f || nma.path.status != 0)
			{
				walking = false;
			}
		}
		else
		{
			walking = false;
		}
	}

	private void Update()
	{
		if (target == null)
		{
			anim.SetBool("Running", value: false);
			if ((bool)currentSound)
			{
				Object.Destroy(currentSound.gameObject);
			}
			if (aiming)
			{
				CancelAim();
			}
			return;
		}
		if (aiming && !mach.grounded)
		{
			CancelAim(instant: true);
		}
		if (!inAction)
		{
			rubbleLeft.SetActive(value: false);
			rubbleRight.SetActive(value: false);
		}
		if (!inAction && mach.grounded && eid.target != null)
		{
			cooldown = Mathf.MoveTowards(cooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			kickCooldown = Mathf.MoveTowards(kickCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
			if (stationary && Vector3.Distance(base.transform.position, stationaryPosition) <= 1f)
			{
				base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
			}
			if (Vector3.Distance(target.position, base.transform.position) < 5f && kickCooldown <= 0f && difficulty >= 2)
			{
				Kick();
			}
			else
			{
				bool flag = Physics.CheckSphere(torso.position - Vector3.up * 0.5f, 1.5f, LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies));
				if (EnemyIdentifierDebug.Active && flag)
				{
					Log.Finer($"Turret windup for <b>{eid.target}</b> blocked by <color=red>sphere check</color>");
				}
				RaycastHit hitInfo;
				bool flag2 = Physics.SphereCast(torso.position - Vector3.up * 0.5f, 1.5f, target.position + Vector3.up - torso.position, out hitInfo, Vector3.Distance(target.position + Vector3.up, torso.position), LayerMaskDefaults.Get(LMD.EnvironmentAndBigEnemies));
				if (flag2 && target.isEnemy && hitInfo.collider.TryGetComponent<EnemyIdentifierIdentifier>(out var component) && component.eid == target.enemyIdentifier)
				{
					flag2 = false;
				}
				if (EnemyIdentifierDebug.Active && flag2)
				{
					Log.Finer($"Turret windup for <b>{eid.target}</b> blocked by <color=blue>sphere cast</color>\n{hitInfo.collider.gameObject.name}");
				}
				if (cooldown <= 0f && !flag && !flag2)
				{
					StartWindup();
				}
				else if (nma.velocity.magnitude >= 1f)
				{
					anim.SetBool("Running", value: true);
				}
				else
				{
					anim.SetBool("Running", value: false);
				}
			}
		}
		else
		{
			anim.SetBool("Running", value: false);
		}
		if (aiming)
		{
			if (eid.target == null)
			{
				CancelAim();
				return;
			}
			RaycastHit hitInfo3;
			if (difficulty < 2 && aimTime >= maxAimTime)
			{
				if (difficulty == 1)
				{
					lastPlayerPosition = Vector3.MoveTowards(lastPlayerPosition, target.position, Time.deltaTime * Vector3.Distance(lastPlayerPosition, target.position) * 5f * eid.totalSpeedModifier);
				}
				if (Physics.Raycast(torso.position, lastPlayerPosition - torso.position, out var hitInfo2, float.PositiveInfinity, LayerMaskDefaults.Get(LMD.EnvironmentAndPlayer)))
				{
					aimPos = hitInfo2.point;
				}
				else
				{
					aimPos = torso.position + (lastPlayerPosition - torso.position).normalized * 10000f;
				}
				outOfSightTimer = 0f;
			}
			else if (Physics.Raycast(torso.position, target.position - torso.position, out hitInfo3, Vector3.Distance(torso.position, target.position), LayerMaskDefaults.Get(LMD.Environment)))
			{
				aimPos = hitInfo3.point;
				if (flashTime == 0f)
				{
					outOfSightTimer += Time.deltaTime;
				}
			}
			else
			{
				aimPos = target.position;
				outOfSightTimer = 0f;
			}
			aimTime = Mathf.MoveTowards(aimTime, maxAimTime, Time.deltaTime * eid.totalSpeedModifier);
			if (outOfSightTimer >= 1f)
			{
				if ((bool)currentSound)
				{
					Object.Destroy(currentSound.gameObject);
				}
				currentSound = Object.Instantiate(cancelSound, torso);
				CancelAim();
			}
			else if (aimTime >= maxAimTime && (outOfSightTimer == 0f || flashTime != 0f))
			{
				if (flashTime == 0f)
				{
					Object.Instantiate(warningFlash, shootPoint.transform).transform.localScale *= 2.5f;
					ChangeLineColor(new Color(1f, 0.75f, 0.5f));
					lastPlayerPosition = target.position;
					ChangeLightsColor(attackingLightsColor);
					mach.ParryableCheck();
				}
				flashTime = Mathf.MoveTowards(flashTime, 1f, Time.deltaTime * (float)((difficulty < 2) ? 1 : 2) * eid.totalSpeedModifier);
				if (flashTime >= 1f)
				{
					Shoot();
				}
			}
			else if (aimTime >= nextBeepTime && (float)sinceLastBeep >= 0.075f)
			{
				if (whiteLine)
				{
					ChangeLineColor(defaultColor);
				}
				else
				{
					ChangeLineColor(Color.white);
				}
				antennaFlash?.Play();
				antennaSound?.Play();
				whiteLine = !whiteLine;
				nextBeepTime = aimTime + (maxAimTime - aimTime) / 6f;
				sinceLastBeep = 0f;
			}
		}
		currentLightsIntensity = Mathf.MoveTowards(currentLightsIntensity, lightsIntensityTarget, Time.deltaTime / 4f);
		if (currentLightsIntensity == lightsIntensityTarget)
		{
			lightsIntensityTarget = ((lightsIntensityTarget == 1.5f) ? (lightsIntensityTarget = 1.25f) : (lightsIntensityTarget = 1.5f));
		}
		ChangeLightsIntensity(currentLightsIntensity);
	}

	private void LateUpdate()
	{
		if (target == null)
		{
			return;
		}
		if (aiming)
		{
			if (difficulty < 2 && aimTime >= maxAimTime)
			{
				AimAt(lastPlayerPosition);
			}
			else
			{
				AimAt(target.position);
			}
		}
		else
		{
			if (!bodyRotate)
			{
				return;
			}
			if (bodyTrackPlayer || bodyReset)
			{
				Quaternion quaternion = Quaternion.LookRotation(target.position - torso.position);
				if (bodyReset)
				{
					quaternion = base.transform.rotation;
				}
				float num = 10f;
				if (bodyTrackPlayer)
				{
					num = 35f;
				}
				currentBodyRotation = Quaternion.RotateTowards(currentBodyRotation, quaternion, Time.deltaTime * (Quaternion.Angle(quaternion, currentBodyRotation) * num + num) * eid.totalSpeedModifier);
				if (bodyReset && currentBodyRotation == quaternion)
				{
					bodyRotate = false;
					bodyReset = false;
				}
			}
			torso.rotation = currentBodyRotation;
			torso.Rotate(Vector3.up * -90f, Space.Self);
		}
	}

	private void StartWindup()
	{
		anim.SetBool("Aiming", value: true);
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		inAction = true;
		kickCooldown = 0f;
		if ((bool)currentSound)
		{
			Object.Destroy(currentSound.gameObject);
		}
		currentSound = Object.Instantiate(aimWarningSound, torso);
	}

	private void BodyTrack()
	{
		bodyRotate = true;
		bodyTrackPlayer = true;
		bodyReset = false;
	}

	private void BodyFreeze()
	{
		bodyRotate = true;
		bodyTrackPlayer = false;
		bodyReset = false;
	}

	private void BodyReset()
	{
		bodyRotate = true;
		bodyTrackPlayer = false;
		bodyReset = true;
	}

	private void StartAiming()
	{
		aiming = true;
		whiteLine = false;
		ChangeLineColor(defaultColor);
		nextBeepTime = aimTime + (maxAimTime - aimTime) / 6f;
		flashTime = 0f;
		eid.weakPoint = antenna;
		shotsInARow = 0;
		antennaFlash?.Play();
		antennaSound?.Play();
	}

	private void Kick()
	{
		anim.SetTrigger("Kick");
		if (nma.isOnNavMesh)
		{
			nma.SetDestination(base.transform.position);
		}
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		inAction = true;
		ChangeLightsColor(new Color(0.35f, 0.55f, 1f));
		kickCooldown = 1f;
		if ((bool)currentSound)
		{
			Object.Destroy(currentSound.gameObject);
		}
		currentSound = Object.Instantiate(kickWarningSound, torso);
		UnparryableFlash();
	}

	private void StopAction()
	{
		inAction = false;
		rubbleLeft.SetActive(value: false);
		rubbleRight.SetActive(value: false);
	}

	private void AimAt(Vector3 position)
	{
		torso.LookAt(position);
		currentBodyRotation = torso.rotation;
		torso.Rotate(Vector3.up * -90f, Space.Self);
		turret.LookAt(position, torso.up);
		turret.Rotate(Vector3.up * -90f, Space.Self);
		aimLine.enabled = true;
		aimLine.SetPosition(0, shootPoint.position);
		aimLine.SetPosition(1, aimPos);
	}

	private void Shoot()
	{
		RevolverBeam revolverBeam = Object.Instantiate(beam, new Vector3(base.transform.position.x, shootPoint.transform.position.y, base.transform.position.z), shootPoint.transform.rotation);
		revolverBeam.alternateStartPoint = shootPoint.transform.position;
		if (revolverBeam.TryGetComponent<RevolverBeam>(out var component))
		{
			component.target = eid.target;
			if (eid.totalDamageModifier != 1f)
			{
				component.damage *= eid.totalDamageModifier;
			}
		}
		anim.Play("Shoot");
		CancelAim();
		BodyFreeze();
		cooldown = Random.Range(2.5f, 3.5f);
		shotsInARow++;
		if ((difficulty == 4 && shotsInARow < 2) || difficulty == 5)
		{
			Invoke("PreReAim", 0.25f);
		}
	}

	private void PreReAim()
	{
		anim.SetBool("Aiming", value: true);
		anim.Play("Aiming", -1, 0f);
		Invoke("ReAim", 0.25f);
	}

	private void ReAim()
	{
		flashTime = 0f;
		aiming = true;
		aimLine.enabled = true;
		aimTime = maxAimTime;
		eid.weakPoint = antenna;
	}

	private void ChangeLineColor(Color clr)
	{
		Gradient gradient = new Gradient();
		GradientColorKey[] array = new GradientColorKey[1];
		array[0].color = clr;
		GradientAlphaKey[] array2 = new GradientAlphaKey[1];
		array2[0].alpha = 1f;
		gradient.SetKeys(array, array2);
		aimLine.colorGradient = gradient;
		nextBeepTime = (maxAimTime - aimTime) / 2f;
	}

	public void CancelAim(bool instant = false)
	{
		ChangeLightsColor(defaultLightsColor);
		aiming = false;
		aimLine.enabled = false;
		aimTime = 0f;
		outOfSightTimer = 0f;
		anim.SetBool("Aiming", value: false);
		BodyReset();
		eid.weakPoint = head;
		mach.parryable = false;
		if (instant)
		{
			inAction = false;
			if (mach.grounded)
			{
				anim.Play("Idle");
			}
		}
		if (cooldown < 1f)
		{
			cooldown = 1f;
		}
	}

	public void LodgeFoot(int type)
	{
		if (type == 0)
		{
			leftLodged = true;
			rubbleLeft.SetActive(value: true);
		}
		else
		{
			rightLodged = true;
			rubbleRight.SetActive(value: true);
		}
		if (leftLodged && rightLodged)
		{
			lodged = true;
		}
	}

	public void UnlodgeFoot(int type)
	{
		if (type == 0 && leftLodged)
		{
			leftLodged = false;
			rubbleLeft.SetActive(value: false);
			Object.Instantiate(rubble, rubbleLeft.transform.position, base.transform.rotation);
		}
		else if (type == 1 && rightLodged)
		{
			rightLodged = false;
			rubbleRight.SetActive(value: false);
			Object.Instantiate(rubble, rubbleRight.transform.position, base.transform.rotation);
		}
		lodged = false;
	}

	public void Unlodge()
	{
		UnlodgeFoot(0);
		UnlodgeFoot(1);
		kickCooldown = 0.25f;
	}

	public void Interrupt()
	{
		if (!mach.limp)
		{
			anim.SetTrigger("Interrupt");
			CancelAim();
			BodyFreeze();
			cooldown = 3f;
			if ((bool)currentSound)
			{
				Object.Destroy(currentSound.gameObject);
			}
			currentSound = Object.Instantiate(interruptSound, torso);
		}
	}

	public void OnDeath()
	{
		CancelAim();
		if ((bool)currentSound)
		{
			Object.Destroy(currentSound.gameObject);
		}
		ChangeLightsColor(new Color(0.05f, 0.05f, 0.05f, 1f));
		if ((bool)antennaLight)
		{
			antennaLight.enabled = false;
		}
		Unlodge();
		if ((bool)sc)
		{
			sc.gameObject.SetActive(value: false);
		}
		Object.Destroy(this);
	}

	private void FootStep(float targetPitch)
	{
		if (targetPitch == 0f)
		{
			targetPitch = 1.5f;
		}
		Object.Instantiate(footStep, base.transform.position, Quaternion.identity).pitch = Random.Range(targetPitch - 0.1f, targetPitch + 0.1f);
	}

	private void Thunk()
	{
		Object.Instantiate(thunkSound, base.transform.position, Quaternion.identity);
	}

	private void ExtendBarrel()
	{
		Object.Instantiate(extendSound, base.transform.position, Quaternion.identity);
	}

	private void GotParried()
	{
		Interrupt();
	}

	public void UnparryableFlash()
	{
		Object.Instantiate(unparryableFlash, torso.position + base.transform.forward, base.transform.rotation).transform.localScale *= 2.5f;
	}

	public void DamageStart()
	{
		sc.DamageStart();
		tr.enabled = true;
	}

	public void DamageStop()
	{
		sc.DamageStop();
		tr.enabled = false;
		ChangeLightsColor(defaultLightsColor);
	}

	public void ChangeLightsColor(Color target)
	{
		if ((bool)smr && (bool)smr.sharedMaterial && smr.sharedMaterial.HasProperty("_EmissiveColor"))
		{
			smr.material.SetColor("_EmissiveColor", target);
			if ((bool)antennaLight)
			{
				antennaLight.color = target;
			}
		}
	}

	public void ChangeLightsIntensity(float amount)
	{
		if ((bool)smr && (bool)smr.sharedMaterial && smr.sharedMaterial.HasProperty("_EmissiveIntensity"))
		{
			smr.material.SetFloat("_EmissiveIntensity", amount);
			if ((bool)antennaLight)
			{
				antennaLight.intensity = amount * 8f;
			}
		}
	}
}



public class UciChessEngine
{
	private Process engineProcess;

	private static string EngineDirectory => Path.Combine(Application.streamingAssetsPath, "ChessEngine");

	public UciChessEngine()
	{
		string fileName = FindExecutableInDirectory(EngineDirectory);
		engineProcess = new Process
		{
			StartInfo = new ProcessStartInfo
			{
				FileName = fileName,
				UseShellExecute = false,
				RedirectStandardInput = true,
				RedirectStandardOutput = true,
				CreateNoWindow = true
			}
		};
	}

	private string FindExecutableInDirectory(string directoryPath)
	{
		try
		{
			string[] files = Directory.GetFiles(directoryPath, "*.exe");
			if (files.Length != 0)
			{
				return files[0];
			}
			return null;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Error finding executable: " + ex.Message);
			return null;
		}
	}

	public async Task InitializeUciModeAsync(bool whiteIsBot, int elo)
	{
		engineProcess.Start();
		await Task.Delay(1);
		await SendCommandAsync("uci");
		while (!(await ReadResponseAsync()).StartsWith("uciok"))
		{
		}
		await SendCommandAsync("isready");
		while (await ReadResponseAsync() != "readyok")
		{
		}
		if (elo >= 1500)
		{
			await SetEloRatingAsync(elo);
		}
		else
		{
			await SetEloRatingAsync(500);
		}
		await SendCommandAsync("ucinewgame");
		await SendCommandAsync("position startpos");
		if (whiteIsBot)
		{
			MonoSingleton<ChessManager>.Instance.BotStartGame();
		}
	}

	public async Task SendPlayerMoveAndGetEngineResponseAsync(string moves, Action<string> callback, int moveTimeInMilliseconds = 2000)
	{
		await SendCommandAsync("position startpos moves " + moves);
		await SendCommandAsync("go movetime " + moveTimeInMilliseconds);
		string text;
		do
		{
			text = await ReadResponseAsync();
		}
		while (!text.StartsWith("bestmove"));
		callback(text);
	}

	public async Task SetEloRatingAsync(int eloRating)
	{
		if (eloRating < 0 || eloRating > 3200)
		{
			UnityEngine.Debug.LogError("Elo rating must be between 0 and 3200.");
		}
		await SendCommandAsync("setoption name UCI_LimitStrength value true");
		await SendCommandAsync($"setoption name UCI_Elo value {eloRating}");
	}

	public async Task SendCommandAsync(string command)
	{
		await engineProcess.StandardInput.WriteLineAsync(command);
	}

	public async Task<string> ReadResponseAsync()
	{
		return await engineProcess.StandardOutput.ReadLineAsync();
	}

	public async Task StopEngine()
	{
		await SendCommandAsync("quit");
		if (!engineProcess.HasExited)
		{
			engineProcess.Close();
		}
	}
}


public static class UKShaderProperties
{
	public static readonly int EmissiveColor = ShaderProperties.PrefixedPropertyToID("", "EmissiveColor");

	public static readonly int EmissiveTex = ShaderProperties.PrefixedPropertyToID("", "EmissiveTex");

	public static readonly int EmissiveIntensity = ShaderProperties.PrefixedPropertyToID("", "EmissiveIntensity");

	public static readonly int Color = ShaderProperties.PrefixedPropertyToID("", "Color");
}



[Serializable]
public class UltrakillEvent
{
	public GameObject[] toActivateObjects;

	public GameObject[] toDisActivateObjects;

	public UnityEvent onActivate;

	public UnityEvent onDisActivate;

	public void Invoke()
	{
		if (toDisActivateObjects != null)
		{
			GameObject[] array = toDisActivateObjects;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: false);
				}
			}
		}
		if (toActivateObjects != null)
		{
			GameObject[] array = toActivateObjects;
			foreach (GameObject gameObject2 in array)
			{
				if ((bool)gameObject2)
				{
					gameObject2.SetActive(value: true);
				}
			}
		}
		onActivate?.Invoke();
	}

	public void Revert()
	{
		if (toDisActivateObjects != null)
		{
			GameObject[] array = toDisActivateObjects;
			foreach (GameObject gameObject in array)
			{
				if ((bool)gameObject)
				{
					gameObject.SetActive(value: true);
				}
			}
		}
		if (toActivateObjects != null)
		{
			GameObject[] array = toActivateObjects;
			foreach (GameObject gameObject2 in array)
			{
				if ((bool)gameObject2)
				{
					gameObject2.SetActive(value: false);
				}
			}
		}
		onDisActivate?.Invoke();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class UnderwaterController : MonoSingleton<UnderwaterController>
{
	public Image overlay;

	private Color defaultColor;

	private Color offColor;

	private int underWaterCalls;

	private AudioLowPassFilter lowPass;

	public bool inWater;

	private AudioSource aud;

	public AudioClip underWater;

	public AudioClip surfacing;

	private void OnDisable()
	{
		if (underWaterCalls >= 1)
		{
			underWaterCalls = 1;
			OutWater();
		}
	}

	private void Start()
	{
		defaultColor = overlay.color;
		defaultColor.a = 0.3f;
		aud = overlay.GetComponent<AudioSource>();
	}

	public void InWater(Color clr)
	{
		if (underWaterCalls <= 0)
		{
			underWaterCalls = 0;
			aud.clip = underWater;
			aud.loop = true;
			aud.Play();
		}
		underWaterCalls++;
		UpdateColor(clr);
		MonoSingleton<AudioMixerController>.Instance.IsInWater(isInWater: true);
		inWater = true;
	}

	public void OutWater()
	{
		if (underWaterCalls > 0)
		{
			underWaterCalls--;
		}
		if (underWaterCalls <= 0)
		{
			underWaterCalls = 0;
			if (!(overlay == null))
			{
				overlay.color = offColor;
				MonoSingleton<AudioMixerController>.Instance.IsInWater(isInWater: false);
				aud.clip = surfacing;
				aud.loop = false;
				aud.Play();
				inWater = false;
			}
		}
	}

	public void UpdateColor(Color newColor)
	{
		if (newColor != new Color(0f, 0f, 0f, 0f))
		{
			newColor.a = 0.3f;
			overlay.color = newColor;
		}
		else
		{
			overlay.color = defaultColor;
		}
	}
}



[Serializable]
public sealed class UnityEventCollider : UnityEvent<Collider>
{
}



[Serializable]
public sealed class UnityEventCollision : UnityEvent<Collision>
{
}



[Serializable]
public sealed class UnityEventControllerColliderHit : UnityEvent<ControllerColliderHit>
{
}


public static class UnityShaderProperties
{
	public static readonly int Lightmap = ShaderProperties.PrefixedPropertyToID("unity", "Lightmap");

	public static readonly int MATRIX_MVP = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_MVP");

	public static readonly int MATRIX_MV = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_MV");

	public static readonly int MATRIX_V = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_V");

	public static readonly int MATRIX_VP = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_VP");

	public static readonly int MATRIX_T_MV = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_T_MV");

	public static readonly int MATRIX_IT_MV = ShaderProperties.PrefixedPropertyToID("UNITY", "MATRIX_IT_MV");

	public static readonly int OrthoParams = ShaderProperties.PrefixedPropertyToID("unity", "OrthoParams");

	public static readonly int CameraProjection = ShaderProperties.PrefixedPropertyToID("unity", "CameraProjection");

	public static readonly int CameraInvProjection = ShaderProperties.PrefixedPropertyToID("unity", "CameraInvProjection");

	public static readonly int CameraWorldClipPlanes = ShaderProperties.PrefixedPropertyToID("unity", "CameraWorldClipPlanes");

	public static readonly int DeltaTime = ShaderProperties.PrefixedPropertyToID("unity", "DeltaTime");

	public static readonly int _4LightPosX0 = ShaderProperties.PrefixedPropertyToID("unity", "_4LightPosX0");

	public static readonly int _4LightPosY0 = ShaderProperties.PrefixedPropertyToID("unity", "_4LightPosY0");

	public static readonly int _4LightPosZ0 = ShaderProperties.PrefixedPropertyToID("unity", "_4LightPosZ0");

	public static readonly int _4LightAtten0 = ShaderProperties.PrefixedPropertyToID("unity", "_4LightAtten0");

	public static readonly int LightColor = ShaderProperties.PrefixedPropertyToID("unity", "LightColor");

	public static readonly int LightPosition = ShaderProperties.PrefixedPropertyToID("unity", "LightPosition");

	public static readonly int LightAtten = ShaderProperties.PrefixedPropertyToID("unity", "LightAtten");

	public static readonly int SpotDirection = ShaderProperties.PrefixedPropertyToID("unity", "SpotDirection");

	public static readonly int AmbientSky = ShaderProperties.PrefixedPropertyToID("unity", "AmbientSky");

	public static readonly int AmbientEquator = ShaderProperties.PrefixedPropertyToID("unity", "AmbientEquator");

	public static readonly int AmbientGround = ShaderProperties.PrefixedPropertyToID("unity", "AmbientGround");

	public static readonly int LIGHTMODEL_AMBIENT = ShaderProperties.PrefixedPropertyToID("UNITY", "LIGHTMODEL_AMBIENT");

	public static readonly int FogColor = ShaderProperties.PrefixedPropertyToID("unity", "FogColor");

	public static readonly int FogParams = ShaderProperties.PrefixedPropertyToID("unity", "FogParams");

	public static readonly int LODFade = ShaderProperties.PrefixedPropertyToID("unity", "LODFade");

	public static readonly int WorldToShadow = ShaderProperties.PrefixedPropertyToID("unity", "WorldToShadow");

	public static readonly int ObjectToWorld = ShaderProperties.PrefixedPropertyToID("unity", "ObjectToWorld");

	public static readonly int WorldToObject = ShaderProperties.PrefixedPropertyToID("unity", "WorldToObject");
}



public class UnlockableFound : MonoBehaviour
{
	[SerializeField]
	private UnlockableType unlockableType;

	[SerializeField]
	private bool unlockOnEnable = true;

	[SerializeField]
	private bool unlockOnTriggerEnter;

	private void OnEnable()
	{
		if (unlockOnEnable)
		{
			Unlock();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player") && unlockOnTriggerEnter)
		{
			Unlock();
		}
	}

	public void Unlock()
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			MonoSingleton<UnlockablesData>.Instance.SetUnlocked(unlockableType, unlocked: true);
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class UnlockablesData : MonoSingleton<UnlockablesData>
{
	public UnityAction unlockableFound = delegate
	{
	};

	private bool checkedSave;

	private readonly HashSet<UnlockableType> unlocked = new HashSet<UnlockableType>();

	private void InitDictionary()
	{
		unlocked.Clear();
	}

	private void Start()
	{
		if (!checkedSave)
		{
			CheckSave();
		}
	}

	public bool IsUnlocked(UnlockableType unlockable)
	{
		if (!checkedSave)
		{
			CheckSave();
		}
		return unlocked.Contains(unlockable);
	}

	public void SetUnlocked(UnlockableType unlockable, bool unlocked)
	{
		if (!checkedSave)
		{
			CheckSave();
		}
		if (unlocked && !this.unlocked.Contains(unlockable))
		{
			this.unlocked.Add(unlockable);
			GameProgressSaver.SetUnlockable(unlockable, state: true);
			unlockableFound();
		}
		else if (!unlocked && this.unlocked.Contains(unlockable))
		{
			this.unlocked.Remove(unlockable);
			GameProgressSaver.SetUnlockable(unlockable, state: false);
			unlockableFound();
		}
	}

	public void CheckSave()
	{
		checkedSave = true;
		InitDictionary();
		UnlockableType[] unlockables = GameProgressSaver.GetUnlockables();
		for (int i = 0; i < unlockables.Length; i++)
		{
			unlocked.Add(unlockables[i]);
		}
	}
}


public enum UnlockableType
{
	Florp,
	KITR
}



public class UnlockBestiary : MonoBehaviour
{
	public EnemyType enemy;

	public bool fullUnlock;

	private void Start()
	{
		MonoSingleton<BestiaryData>.Instance.SetEnemy(enemy, (!fullUnlock) ? 1 : 2);
	}
}



[Serializable]
public abstract class UnlockCondition
{
	[Serializable]
	public class HasCompletedLevelChallenge : UnlockCondition
	{
		public int levelIndex = 1;

		public override bool conditionMet => GameProgressSaver.GetRank(levelIndex, returnNull: true)?.challenge ?? false;

		public override string description => "COMPLETE CHALLENGE FOR " + GetMissionName.GetMissionNumberOnly(levelIndex);
	}

	[Serializable]
	public class HasSeenEnemy : UnlockCondition
	{
		public EnemyType enemy;

		public override bool conditionMet => true;

		public override string description => "ENCOUNTER AN UNKNOWN FOE";
	}

	[Serializable]
	public class HasReachedLevel : UnlockCondition
	{
		public int levelIndex = 1;

		public override bool conditionMet => GameProgressSaver.GetRank(levelIndex, returnNull: true) != null;

		public override string description => "REACH " + GetMissionName.GetMissionNumberOnly(levelIndex);
	}

	[Serializable]
	public class HasCompletedLevel : UnlockCondition
	{
		public int levelIndex = 1;

		public override bool conditionMet
		{
			get
			{
				if (levelIndex >= 666)
				{
					return GameProgressSaver.GetPrime(0, levelIndex - 665) > 0;
				}
				return GameProgressSaver.GetRank(levelIndex, returnNull: true).ranks.Aggregate(seed: false, (bool acc, int rank) => acc || rank > -1);
			}
		}

		public override string description => "COMPLETE " + GetMissionName.GetMissionNumberOnly(levelIndex);
	}

	[Serializable]
	public class HasCompletedSecretLevel : UnlockCondition
	{
		public int secretLevelIndex = 1;

		public override bool conditionMet => GameProgressSaver.GetSecretMission(secretLevelIndex) == 2;

		public override string description => "COMPLETE " + secretLevelIndex + "-S";
	}

	[Serializable]
	public class HasObtainedWeapon : UnlockCondition
	{
		public string gearName;

		public override bool conditionMet => GameProgressSaver.CheckGear(gearName) > 0;

		public override string description => "UNLOCK A WEAPON YET UNDISCOVERED";
	}

	public abstract bool conditionMet { get; }

	public abstract string description { get; }

	public UnlockCondition()
	{
	}
}



public static class UnlockConditionExtensions
{
	public static bool AllMet(this List<UnlockCondition> list)
	{
		return list.Aggregate(seed: true, (bool acc, UnlockCondition cond) => acc && cond.conditionMet);
	}

	public static string DescribeAll(this List<UnlockCondition> list)
	{
		if (list.Count == 0)
		{
			return "";
		}
		if (list.Count == 1)
		{
			return list.First().description;
		}
		return list.Skip(1).Aggregate(list.First().description, (string desc, UnlockCondition cond) => desc + ", " + cond.description);
	}
}



public class UnlockMouse : MonoBehaviour
{
	public bool unlockOnEnable = true;

	public bool lockOnDisable;

	private bool wasEnabled;

	private void OnEnable()
	{
		if (unlockOnEnable)
		{
			Unlock();
		}
	}

	public void Unlock()
	{
		GameStateManager.Instance.RegisterState(new GameState("unlock-mouse-component", base.gameObject)
		{
			cursorLock = LockMode.Unlock
		});
		wasEnabled = true;
	}

	private void OnDisable()
	{
		if (lockOnDisable && wasEnabled && base.gameObject.scene.isLoaded)
		{
			Lock();
		}
	}

	public void Lock()
	{
		if (wasEnabled)
		{
			wasEnabled = false;
			GameStateManager.Instance.PopState("unlock-mouse-component");
		}
	}

	private void OnApplicationQuit()
	{
		lockOnDisable = false;
	}
}



[Serializable]
public struct UnscaledTimeSince
{
	private float time;

	public const int Now = 0;

	public static implicit operator float(UnscaledTimeSince ts)
	{
		return Time.unscaledTime - ts.time;
	}

	public static implicit operator UnscaledTimeSince(float ts)
	{
		UnscaledTimeSince result = default(UnscaledTimeSince);
		result.time = Time.unscaledTime - ts;
		return result;
	}
}



[DisallowMultipleComponent]
public sealed class UpdateMessage : MessageDispatcher
{
	private void Update()
	{
		base.Handler.Invoke();
	}
}



public class V2 : MonoBehaviour, IEnrage, IAlter, IAlterOptions<bool>
{
	private Animator anim;

	private Transform overrideTarget;

	private Rigidbody overrideTargetRb;

	private Vector3 targetPos;

	private Quaternion targetRot;

	public Transform[] aimAtTarget;

	private Rigidbody rb;

	private NavMeshAgent nma;

	private int currentWeapon;

	public SkinnedMeshRenderer smr;

	private EnemySimplifier[] ensims;

	public Texture[] wingTextures;

	public GameObject wingChangeEffect;

	public Color[] wingColors;

	public GameObject[] weapons;

	private GameObject currentWingChangeEffect;

	private TrailRenderer[] wingTrails;

	private DragBehind[] drags;

	private int currentPattern;

	private bool inPattern;

	public LayerMask environmentMask;

	public GroundCheckEnemy gc;

	public GroundCheckEnemy wc;

	private int pattern1direction = 1;

	public GameObject jumpSound;

	public GameObject dashJumpSound;

	public bool secondEncounter;

	public bool slowMode;

	public float movementSpeed;

	private float originalMovementSpeed;

	public float jumpPower;

	public float wallJumpPower;

	public float airAcceleration;

	public bool intro;

	[HideInInspector]
	public bool inIntro;

	public bool active;

	private bool running;

	private bool aiming;

	private bool sliding;

	private bool dodging;

	private bool jumping;

	private float patternCooldown;

	private float dodgeCooldown = 3f;

	private float dodgeLeft;

	public GameObject dodgeEffect;

	public GameObject slideEffect;

	private int difficulty = -1;

	private float slideStopTimer;

	private TimeSince randomSlideCheck;

	private float shootCooldown;

	private float altShootCooldown;

	public GameObject gunFlash;

	public GameObject altFlash;

	private bool aboutToShoot;

	private bool chargingAlt;

	private float predictAmount;

	private bool aimAtGround;

	public bool dontDie;

	public Transform escapeTarget;

	private bool escaping;

	private bool dead;

	public bool longIntro;

	private bool staringAtPlayer;

	private bool introHitGround;

	private EnemyIdentifierIdentifier[] eidids;

	private BossHealthBar bhb;

	public GameObject shockwave;

	public GameObject KoScream;

	private RaycastHit rhit;

	private float distancePatience;

	private bool enraged;

	public GameObject enrageEffect;

	private GameObject currentEnrageEffect;

	private Machine mac;

	private EnemyIdentifier eid;

	private bool drilled;

	private float circleTimer = 5f;

	public GameObject spawnOnDeath;

	private bool playerInSight;

	private int coinsToThrow;

	private bool shootingForCoin;

	public GameObject coin;

	[HideInInspector]
	public bool firstPhase = true;

	public float knockOutHealth;

	public bool slideOnly;

	public bool dontEnrage;

	public bool alwaysAimAtGround;

	public Vector3 forceSlideDirection;

	private bool cowardPattern;

	public UltrakillEvent onKnockout;

	private float flashTimer;

	private List<Coin> coins = new List<Coin>();

	private bool bossVersion = true;

	private float coinsInSightCooldown;

	private EnemyTarget target => eid.target;

	public bool isEnraged => enraged;

	public string alterKey => "v2";

	public string alterCategoryName => "V2";

	public AlterOption<bool>[] options => new AlterOption<bool>[1]
	{
		new AlterOption<bool>
		{
			value = isEnraged,
			callback = delegate(bool value)
			{
				if (value)
				{
					Enrage();
				}
				else
				{
					UnEnrage();
				}
			},
			key = "enraged",
			name = "Enraged"
		}
	};

	private void Awake()
	{
		anim = GetComponentInChildren<Animator>();
		bhb = GetComponent<BossHealthBar>();
		mac = GetComponent<Machine>();
		rb = GetComponent<Rigidbody>();
		gc = GetComponentInChildren<GroundCheckEnemy>();
	}

	private void Start()
	{
		if (alwaysAimAtGround)
		{
			aimAtGround = true;
		}
		ensims = GetComponentsInChildren<EnemySimplifier>();
		if ((bool)MonoSingleton<StatueIntroChecker>.Instance && MonoSingleton<StatueIntroChecker>.Instance.beenSeen)
		{
			longIntro = false;
		}
		if (!intro)
		{
			active = true;
			if ((bool)bhb)
			{
				bhb.enabled = true;
			}
		}
		else
		{
			inIntro = true;
			rb.AddForce(base.transform.forward * 20f, ForceMode.VelocityChange);
			anim.SetBool("InAir", value: true);
			if (anim.layerCount > 1)
			{
				anim.SetLayerWeight(1, 1f);
				anim.SetLayerWeight(2, 0f);
			}
			if (longIntro)
			{
				eidids = GetComponentsInChildren<EnemyIdentifierIdentifier>();
				EnemyIdentifierIdentifier[] array = eidids;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].GetComponent<Collider>().enabled = false;
				}
				if ((bool)bhb)
				{
					bhb.enabled = false;
				}
			}
			else if ((bool)bhb)
			{
				bhb.enabled = true;
			}
		}
		SetSpeed();
		running = true;
		aiming = true;
		inPattern = true;
		wingTrails = GetComponentsInChildren<TrailRenderer>();
		drags = GetComponentsInChildren<DragBehind>();
		ChangeDirection(Random.Range(-90f, 90f));
		SwitchPattern(0);
		shootCooldown = 1f;
		altShootCooldown = 5f;
		if (!weapons[currentWeapon].activeInHierarchy)
		{
			GameObject[] array2 = weapons;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].SetActive(value: false);
			}
			weapons[currentWeapon].SetActive(value: true);
		}
		if (!bhb)
		{
			bossVersion = false;
		}
		if (secondEncounter)
		{
			SlowUpdate();
		}
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (!nma)
		{
			nma = GetComponent<NavMeshAgent>();
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (originalMovementSpeed != 0f)
		{
			movementSpeed = originalMovementSpeed;
		}
		if (difficulty >= 4)
		{
			movementSpeed *= 1.5f;
		}
		else if (difficulty == 2)
		{
			movementSpeed *= 0.85f;
		}
		else if (difficulty == 1)
		{
			movementSpeed *= 0.75f;
		}
		else if (difficulty == 0)
		{
			movementSpeed *= 0.65f;
		}
		movementSpeed *= eid.totalSpeedModifier;
		originalMovementSpeed = movementSpeed;
		if (enraged)
		{
			movementSpeed *= 2f;
		}
		if ((bool)nma)
		{
			nma.speed = originalMovementSpeed;
		}
		GameObject[] array = weapons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].transform.GetChild(0).SendMessage("UpdateBuffs", eid, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void Update()
	{
		if (target == null)
		{
			if (gc.onGround)
			{
				rb.velocity = Vector3.zero;
			}
			if (anim.layerCount > 1)
			{
				anim.SetLayerWeight(1, 0f);
				anim.SetLayerWeight(2, 0f);
			}
			if (sliding)
			{
				StopSlide();
			}
		}
		if (active && !escaping && target != null)
		{
			if (!sliding && slideOnly && gc.onGround && !dodging)
			{
				if (eid.enemyType != EnemyType.BigJohnator)
				{
					anim.Play("Slide");
				}
				base.transform.LookAt(new Vector3(base.transform.position.x + forceSlideDirection.x, base.transform.position.y + forceSlideDirection.y, base.transform.position.z + forceSlideDirection.z));
				Slide();
			}
			targetPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
			if (!slideOnly)
			{
				if (dodging)
				{
					anim.SetBool("InAir", value: true);
					if (anim.layerCount > 1)
					{
						anim.SetLayerWeight(1, 0f);
						anim.SetLayerWeight(2, 0f);
					}
					if (drags.Length != 0 && !drags[0].active)
					{
						DragBehind[] array = drags;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].active = true;
						}
					}
				}
				else if (!gc.onGround)
				{
					anim.SetBool("InAir", value: true);
					if (anim.layerCount > 1)
					{
						anim.SetLayerWeight(1, 0f);
						anim.SetLayerWeight(2, 0f);
					}
					if (drags.Length != 0 && !drags[0].active)
					{
						DragBehind[] array = drags;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].active = true;
						}
					}
				}
				else if (running && !sliding)
				{
					anim.SetBool("InAir", value: false);
					if (anim.layerCount > 1)
					{
						anim.SetLayerWeight(1, 1f);
					}
					if (anim.transform.rotation.eulerAngles.y > base.transform.rotation.eulerAngles.y)
					{
						anim.SetBool("RunningLeft", value: true);
					}
					else
					{
						anim.SetBool("RunningLeft", value: false);
					}
					float num = Quaternion.Angle(anim.transform.rotation, base.transform.rotation);
					if (num > 90f)
					{
						anim.SetBool("RunningBack", value: true);
					}
					else
					{
						anim.SetBool("RunningBack", value: false);
					}
					if (anim.layerCount > 2)
					{
						if (num <= 90f)
						{
							anim.SetLayerWeight(2, num / 90f);
						}
						else
						{
							anim.SetLayerWeight(2, Mathf.Abs(-180f + num) / 90f);
						}
					}
					if (drags.Length != 0 && drags[0].active)
					{
						DragBehind[] array = drags;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].active = false;
						}
					}
				}
				else
				{
					anim.SetBool("InAir", value: false);
					if (anim.layerCount > 1)
					{
						anim.SetLayerWeight(1, 0f);
						anim.SetLayerWeight(2, 0f);
					}
					if (sliding && drags.Length != 0 && !drags[0].active)
					{
						DragBehind[] array = drags;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].active = true;
						}
					}
					else if (!sliding && drags[0].active)
					{
						DragBehind[] array = drags;
						for (int i = 0; i < array.Length; i++)
						{
							array[i].active = false;
						}
					}
				}
			}
			if (eid.target == null)
			{
				running = false;
				if (mac.health <= knockOutHealth && knockOutHealth != 0f && firstPhase)
				{
					firstPhase = false;
					KnockedOut();
					eid.totalDamageTakenMultiplier = 0f;
				}
				return;
			}
			if (!sliding)
			{
				targetRot = Quaternion.LookRotation(targetPos - base.transform.position, Vector3.up);
				if (inPattern && currentPattern != 0)
				{
					if (cowardPattern)
					{
						base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(base.transform.position - targetPos, Vector3.up), Time.deltaTime * 350f * eid.totalSpeedModifier);
					}
					else if (currentPattern == 1 || Vector3.Distance(base.transform.position, targetPos) < 10f)
					{
						float num2 = 90f;
						if (Vector3.Distance(base.transform.position, targetPos) > 10f)
						{
							num2 = 80f;
						}
						else if (Vector3.Distance(base.transform.position, targetPos) < 5f)
						{
							num2 = 100f;
						}
						Quaternion rotation = targetRot;
						rotation.eulerAngles = new Vector3(rotation.eulerAngles.x, rotation.eulerAngles.y + num2 * (float)pattern1direction, rotation.eulerAngles.z);
						base.transform.rotation = rotation;
					}
					else
					{
						base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRot, Time.deltaTime * 350f * eid.totalSpeedModifier);
						if (base.transform.rotation == targetRot && playerInSight && gc.onGround && !jumping && ((difficulty <= 2 && MonoSingleton<NewMovement>.Instance.hp > 50 && Vector3.Distance(base.transform.position, targetPos) > 10f) || Vector3.Distance(base.transform.position, targetPos) > 20f))
						{
							Slide();
						}
					}
				}
				if (inPattern && currentPattern != 1 && !sliding && gc.onGround && difficulty >= 4 && (float)randomSlideCheck > 0.5f)
				{
					randomSlideCheck = 0f;
					if (Random.Range(0f, 1f) > 0.75f)
					{
						Slide();
					}
				}
				anim.transform.rotation = Quaternion.RotateTowards(anim.transform.rotation, targetRot, Time.deltaTime * 10f * Quaternion.Angle(anim.transform.rotation, targetRot) * eid.totalSpeedModifier);
			}
			else if (!slideOnly)
			{
				Quaternion a = Quaternion.LookRotation(base.transform.forward, Vector3.up);
				Quaternion b = Quaternion.LookRotation(targetPos - base.transform.position, Vector3.up);
				if ((bool)nma && !playerInSight)
				{
					StopSlide();
				}
				else if (Quaternion.Angle(a, b) > 90f || (distancePatience >= 5f && Quaternion.Angle(a, b) > 45f))
				{
					slideStopTimer = Mathf.MoveTowards(slideStopTimer, 0f, Time.deltaTime * eid.totalSpeedModifier);
					if (slideStopTimer <= 0f || enraged || (difficulty <= 2 && MonoSingleton<NewMovement>.Instance.hp < 50))
					{
						StopSlide();
					}
				}
			}
			else
			{
				anim.transform.localRotation = Quaternion.identity;
			}
			if (dodgeCooldown < 6f)
			{
				if (difficulty >= 4)
				{
					dodgeCooldown = Mathf.MoveTowards(dodgeCooldown, 6f, Time.deltaTime * eid.totalSpeedModifier);
				}
				else if (difficulty == 3)
				{
					dodgeCooldown = Mathf.MoveTowards(dodgeCooldown, 6f, Time.deltaTime * 0.5f * eid.totalSpeedModifier);
				}
				else
				{
					dodgeCooldown = Mathf.MoveTowards(dodgeCooldown, 6f, Time.deltaTime * 0.1f * eid.totalSpeedModifier);
				}
			}
			if (dodgeLeft > 0f)
			{
				dodgeLeft = Mathf.MoveTowards(dodgeLeft, 0f, Time.deltaTime * 3f * eid.totalSpeedModifier);
				if (dodgeLeft <= 0f)
				{
					dodging = false;
					eid.hookIgnore = false;
					inPattern = true;
					CheckPattern();
					if (currentPattern == 2 && !cowardPattern)
					{
						Quaternion rotation2 = anim.transform.rotation;
						base.transform.LookAt(targetPos);
						anim.transform.rotation = rotation2;
					}
				}
			}
			if (patternCooldown > 0f)
			{
				patternCooldown = Mathf.MoveTowards(patternCooldown, 0f, Time.deltaTime);
			}
			if (inPattern)
			{
				if (playerInSight)
				{
					_ = currentPattern;
					if (gc.onGround && !jumping)
					{
						if (Physics.Raycast(base.transform.position + Vector3.up, base.transform.forward, 4f, environmentMask) && !slideOnly)
						{
							Jump();
						}
					}
					else if (wc.onGround)
					{
						if (!gc.onGround && !jumping)
						{
							WallJump();
						}
						else if (gc.onGround)
						{
							ChangeDirection(Random.Range(100, 260));
						}
					}
				}
				if (Vector3.Distance(base.transform.position, target.position) > 15f || !playerInSight)
				{
					distancePatience = Mathf.MoveTowards(distancePatience, 12f, Time.deltaTime * eid.totalSpeedModifier);
					if ((distancePatience >= 4f || Vector3.Distance(base.transform.position, target.position) > 30f) && currentPattern != 2)
					{
						currentPattern = 2;
						SwitchPattern(2);
					}
					if (distancePatience == 12f && !enraged && !dontEnrage)
					{
						Enrage();
					}
				}
				else if (distancePatience > 0f)
				{
					if (!enraged)
					{
						distancePatience = Mathf.MoveTowards(distancePatience, 0f, Time.deltaTime * 2f * eid.totalSpeedModifier);
					}
					else
					{
						distancePatience = Mathf.MoveTowards(distancePatience, 0f, Time.deltaTime * eid.totalSpeedModifier);
					}
					if (enraged && distancePatience < 10f)
					{
						UnEnrage();
					}
				}
			}
			if (!slideOnly)
			{
				if ((currentPattern == 1 && !cowardPattern) || Vector3.Distance(base.transform.position, target.position) < 10f)
				{
					if (currentPattern == 1)
					{
						circleTimer = Mathf.MoveTowards(circleTimer, 0f, Time.deltaTime * eid.totalSpeedModifier);
					}
					else
					{
						circleTimer = Mathf.MoveTowards(circleTimer, 0f, Time.deltaTime * 1.5f * eid.totalSpeedModifier);
					}
					if (circleTimer <= 0f && !dodging && dodgeLeft <= 0f && !enraged && (MonoSingleton<NewMovement>.Instance.hp > 33 || difficulty >= 4))
					{
						circleTimer = 1f;
						ForceDodge(base.transform.position - targetPos);
						if (!cowardPattern && currentPattern != 1)
						{
							cowardPattern = true;
							SwitchPattern(3);
						}
					}
				}
				else
				{
					circleTimer = Mathf.MoveTowards(circleTimer, 5f, Time.deltaTime * eid.totalSpeedModifier);
					if (cowardPattern && circleTimer > 2f)
					{
						cowardPattern = false;
						CheckPattern();
						SwitchPattern(currentPattern);
					}
				}
			}
			float num3 = 1f;
			if (difficulty == 1)
			{
				num3 = 0.85f;
			}
			if (difficulty == 0)
			{
				num3 = 0.75f;
			}
			if (altShootCooldown > 0f)
			{
				altShootCooldown = Mathf.MoveTowards(altShootCooldown, 0f, Time.deltaTime * num3 * eid.totalSpeedModifier);
			}
			if (secondEncounter && !enraged && coinsToThrow <= 0)
			{
				if (coins.Count > 0)
				{
					Coin coin = null;
					float num4 = 60f;
					foreach (Coin coin2 in coins)
					{
						float num5 = Vector3.Distance(coin2.transform.position, aimAtTarget[1].position);
						if (!coin2.shot && Vector3.Distance(coin2.transform.position, base.transform.position) < num4 && !Physics.Raycast(aimAtTarget[1].position, coin2.transform.position - aimAtTarget[1].position, num5, LayerMaskDefaults.Get(LMD.Environment)))
						{
							num4 = num5;
							coin = coin2;
						}
						if (eid.difficultyOverride >= 0)
						{
							coin2.difficulty = eid.difficultyOverride;
						}
					}
					if (coin != null)
					{
						if (coinsInSightCooldown > 0f)
						{
							coinsInSightCooldown = Mathf.MoveTowards(coinsInSightCooldown, 0f, Time.deltaTime * eid.totalSpeedModifier);
						}
						else
						{
							overrideTarget = coin.transform;
							overrideTargetRb = coin.GetComponent<Rigidbody>();
							if (currentWeapon != 0 || !aboutToShoot || !shootingForCoin)
							{
								if (currentWeapon != 0 || !shootingForCoin)
								{
									CancelInvoke("ShootWeapon");
									CancelInvoke("AltShootWeapon");
									weapons[currentWeapon].transform.GetChild(0).SendMessage("CancelAltCharge", SendMessageOptions.DontRequireReceiver);
									if (currentWeapon != 0)
									{
										SwitchWeapon(0);
									}
								}
								shootCooldown = 1f;
								shootingForCoin = true;
								aboutToShoot = true;
								Object.Instantiate(gunFlash, aimAtTarget[1].transform.position, Quaternion.LookRotation(target.position - aimAtTarget[1].transform.position)).transform.localScale *= 20f;
								Invoke("ShootWeapon", 0.4f / eid.totalSpeedModifier);
							}
						}
					}
					else
					{
						if (shootingForCoin && aboutToShoot)
						{
							CancelInvoke("ShootWeapon");
						}
						shootingForCoin = false;
						overrideTarget = null;
					}
				}
				else if ((bool)overrideTarget)
				{
					if (shootingForCoin && aboutToShoot)
					{
						CancelInvoke("ShootWeapon");
					}
					shootingForCoin = false;
					overrideTarget = null;
				}
				else
				{
					shootingForCoin = false;
				}
			}
			else if ((bool)overrideTarget && enraged)
			{
				if (shootingForCoin && aboutToShoot)
				{
					CancelInvoke("ShootWeapon");
				}
				overrideTarget = null;
				shootingForCoin = false;
			}
			if (secondEncounter && (coins.Count == 0 || (aboutToShoot && shootingForCoin)))
			{
				if (difficulty > 3)
				{
					coinsInSightCooldown = 0f;
				}
				else
				{
					switch (difficulty)
					{
					case 3:
						coinsInSightCooldown = 0.2f;
						break;
					case 2:
						coinsInSightCooldown = 0.4f;
						break;
					case 1:
						coinsInSightCooldown = 0.6f;
						break;
					case 0:
						coinsInSightCooldown = 0.8f;
						break;
					}
				}
			}
			if (shootCooldown > 0f)
			{
				if (cowardPattern)
				{
					shootCooldown = Mathf.MoveTowards(shootCooldown, 0f, Time.deltaTime * num3 * 0.5f * eid.totalSpeedModifier);
				}
				else
				{
					shootCooldown = Mathf.MoveTowards(shootCooldown, 0f, Time.deltaTime * num3 * eid.totalSpeedModifier);
				}
			}
			else if (aiming && (!nma || playerInSight))
			{
				if (!aboutToShoot)
				{
					if ((weapons.Length < 2 && Vector3.Distance(target.position, base.transform.position) > 15f) || Vector3.Distance(target.position, base.transform.position) > 25f)
					{
						SwitchWeapon(0);
					}
					else if (weapons.Length > 2 && Vector3.Distance(target.position, base.transform.position) > 15f)
					{
						if (eid.stuckMagnets.Count <= 0)
						{
							SwitchWeapon(2);
						}
						else
						{
							SwitchWeapon(0);
						}
					}
					else
					{
						SwitchWeapon(1);
					}
				}
				if (!Physics.Raycast(base.transform.position + Vector3.up * 2f, target.position - base.transform.position, out rhit, Vector3.Distance(base.transform.position, target.position), environmentMask))
				{
					if (altShootCooldown <= 0f || (distancePatience >= 8f && currentWeapon == 0 && !dontEnrage))
					{
						if (currentWeapon == 0)
						{
							if (weapons.Length == 1)
							{
								aimAtGround = true;
							}
							predictAmount = 0.15f / eid.totalSpeedModifier;
						}
						else
						{
							aimAtGround = true;
							if (currentWeapon == 1 || difficulty > 2)
							{
								predictAmount = 0.25f / eid.totalSpeedModifier;
							}
							else
							{
								predictAmount = -0.25f / eid.totalSpeedModifier;
							}
						}
						if (difficulty > 2)
						{
							shootCooldown = Random.Range(1f, 2f);
						}
						else
						{
							shootCooldown = 2f;
						}
						altShootCooldown = 5f;
						aboutToShoot = true;
						if (!secondEncounter || Vector3.Distance(target.position, base.transform.position) < 8f || Random.Range(0f, 1f) < 0.5f || enraged)
						{
							chargingAlt = true;
							weapons[currentWeapon].transform.GetChild(0).SendMessage("PrepareAltFire");
							if (difficulty >= 2)
							{
								Invoke("AltShootWeapon", 1f / eid.totalSpeedModifier);
							}
							else if (difficulty == 1)
							{
								Invoke("AltShootWeapon", 1.25f / eid.totalSpeedModifier);
							}
							else
							{
								Invoke("AltShootWeapon", 1.5f / eid.totalSpeedModifier);
							}
						}
						else
						{
							SwitchWeapon(0);
							if (difficulty >= 2)
							{
								coinsToThrow = 3;
							}
							else
							{
								coinsToThrow = 1;
							}
							ThrowCoins();
						}
					}
					else
					{
						if (currentWeapon == 0)
						{
							if (distancePatience >= 4f)
							{
								shootCooldown = 1f;
							}
							if (difficulty > 2)
							{
								shootCooldown = Random.Range(1.5f, 2f);
							}
							else
							{
								shootCooldown = 2f;
							}
						}
						else
						{
							if (currentWeapon == 1 || difficulty > 2)
							{
								predictAmount = 0.15f / eid.totalSpeedModifier;
							}
							else
							{
								predictAmount = -0.25f / eid.totalSpeedModifier;
							}
							if (difficulty > 2)
							{
								shootCooldown = Random.Range(1.5f, 2f);
							}
							else
							{
								shootCooldown = 2f;
							}
						}
						weapons[currentWeapon].transform.GetChild(0).SendMessage("PrepareFire");
						aboutToShoot = true;
						if (currentWeapon == 0)
						{
							Object.Instantiate(gunFlash, aimAtTarget[aimAtTarget.Length - 1].transform.position, Quaternion.LookRotation(target.position - aimAtTarget[aimAtTarget.Length - 1].transform.position)).transform.localScale *= 20f;
							shootingForCoin = false;
							if (difficulty >= 2)
							{
								Invoke("ShootWeapon", 0.75f / eid.totalSpeedModifier);
							}
							if (difficulty >= 1)
							{
								Invoke("ShootWeapon", 0.95f / eid.totalSpeedModifier);
							}
							Invoke("ShootWeapon", 1.15f / eid.totalSpeedModifier);
						}
						else if (difficulty >= 2)
						{
							Invoke("ShootWeapon", 0.75f / eid.totalSpeedModifier);
						}
						else if (difficulty == 1)
						{
							Invoke("ShootWeapon", 1f / eid.totalSpeedModifier);
						}
						else
						{
							Invoke("ShootWeapon", 1.25f / eid.totalSpeedModifier);
						}
					}
				}
				else if (altShootCooldown <= 0f && rhit.transform != null && rhit.transform.gameObject.CompareTag("Breakable"))
				{
					predictAmount = 0f;
					if (!alwaysAimAtGround)
					{
						aimAtGround = false;
					}
					if (distancePatience >= 4f)
					{
						shootCooldown = 1f;
					}
					else if (difficulty > 2)
					{
						shootCooldown = Random.Range(1f, 2f);
					}
					else
					{
						shootCooldown = 2f;
					}
					altShootCooldown = 5f;
					weapons[currentWeapon].transform.GetChild(0).SendMessage("PrepareAltFire");
					aboutToShoot = true;
					chargingAlt = true;
					Invoke("AltShootWeapon", 1f / eid.totalSpeedModifier);
				}
			}
			if ((bool)eid)
			{
				if (eid.drillers.Count > 0)
				{
					slowMode = true;
					drilled = true;
				}
				else if (drilled)
				{
					slowMode = false;
					drilled = false;
				}
			}
		}
		else if (inIntro)
		{
			if (gc.onGround)
			{
				GameObject gameObject = null;
				if (longIntro)
				{
					rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
					if (!introHitGround)
					{
						if (eid.enemyType != EnemyType.BigJohnator)
						{
							anim.SetTrigger("Intro");
						}
						introHitGround = true;
						if (anim.layerCount > 1)
						{
							anim.SetLayerWeight(1, 0f);
							anim.SetLayerWeight(2, 0f);
						}
						gameObject = Object.Instantiate(shockwave, base.transform.position, Quaternion.identity);
					}
				}
				else
				{
					inIntro = false;
					active = true;
					if ((bool)bhb)
					{
						bhb.enabled = true;
					}
					gameObject = Object.Instantiate(shockwave, base.transform.position, Quaternion.identity);
				}
				if ((bool)gameObject && gameObject.TryGetComponent<PhysicalShockwave>(out var component))
				{
					component.enemyType = EnemyType.V2;
				}
			}
			if (staringAtPlayer)
			{
				targetPos = new Vector3(target.position.x, base.transform.position.y, target.position.z);
				targetRot = Quaternion.LookRotation(targetPos - base.transform.position, Vector3.up);
				anim.transform.rotation = Quaternion.RotateTowards(anim.transform.rotation, targetRot, Time.deltaTime * 10f * Quaternion.Angle(anim.transform.rotation, targetRot));
			}
		}
		if (mac.health <= knockOutHealth && knockOutHealth != 0f && firstPhase)
		{
			firstPhase = false;
			KnockedOut();
			eid.totalDamageTakenMultiplier = 0f;
		}
		if (!bhb)
		{
			return;
		}
		if (!enraged)
		{
			bhb.UpdateSecondaryBar(distancePatience / 12f);
		}
		else
		{
			bhb.UpdateSecondaryBar((distancePatience - 10f) / 2f);
		}
		if (enraged)
		{
			flashTimer = Mathf.MoveTowards(flashTimer, 1f, Time.deltaTime * 5f);
			if (flashTimer < 0.5f)
			{
				bhb.SetSecondaryBarColor(Color.red);
			}
			else
			{
				bhb.SetSecondaryBarColor(Color.black);
			}
			if (flashTimer >= 1f)
			{
				flashTimer = 0f;
			}
		}
		else if (distancePatience < 4f)
		{
			bhb.SetSecondaryBarColor(Color.green);
		}
		else if (distancePatience < 8f)
		{
			bhb.SetSecondaryBarColor(Color.yellow);
		}
		else
		{
			bhb.SetSecondaryBarColor(new Color(1f, 0.35f, 0f));
		}
	}

	private void SlowUpdate()
	{
		Invoke("SlowUpdate", 0.1f);
		coins = MonoSingleton<CoinList>.Instance.revolverCoinsList;
	}

	private void ThrowCoins()
	{
		if (coinsToThrow != 0)
		{
			GameObject gameObject = Object.Instantiate(coin, base.transform.position, base.transform.rotation);
			if (gameObject.TryGetComponent<Rigidbody>(out var component))
			{
				component.AddForce((target.position - anim.transform.position).normalized * 20f + Vector3.up * 30f, ForceMode.VelocityChange);
			}
			if (gameObject.TryGetComponent<Coin>(out var component2))
			{
				GameObject obj = Object.Instantiate(component2.flash, component2.transform.position, MonoSingleton<CameraController>.Instance.transform.rotation);
				obj.transform.localScale *= 2f;
				obj.transform.SetParent(gameObject.transform, worldPositionStays: true);
			}
			coinsToThrow--;
			if (coinsToThrow > 0)
			{
				Invoke("ThrowCoins", 0.2f / eid.totalSpeedModifier);
			}
			else
			{
				aboutToShoot = false;
			}
		}
	}

	private void FixedUpdate()
	{
		if (escaping && (bool)nma && nma.isOnNavMesh)
		{
			rb.isKinematic = true;
			nma.SetDestination(escapeTarget.position);
		}
		else if (escaping)
		{
			rb.isKinematic = false;
			targetPos = new Vector3(escapeTarget.position.x, base.transform.position.y, escapeTarget.position.z);
			if (Vector3.Distance(base.transform.position, targetPos) > 8f || (escapeTarget.position.y < base.transform.position.y + 5f && Vector3.Distance(base.transform.position, escapeTarget.position) > 1f))
			{
				aiming = false;
				inPattern = false;
				base.transform.LookAt(targetPos);
				anim.transform.LookAt(targetPos);
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed, rb.velocity.y, base.transform.forward.z * movementSpeed);
			}
			else
			{
				if (!jumping && gc.onGround && !slideOnly)
				{
					Jump();
				}
				rb.velocity = targetPos - base.transform.position + Vector3.up * 50f;
				GetComponent<Collider>().enabled = false;
			}
			if (base.transform.position.y > escapeTarget.position.y - 20f && spawnOnDeath != null)
			{
				spawnOnDeath.SetActive(value: true);
				spawnOnDeath.transform.position = base.transform.position;
				spawnOnDeath = null;
			}
		}
		else if (active && (inPattern || dodging) && target != null)
		{
			if ((bool)nma && Physics.Raycast(base.transform.position + Vector3.up, target.position - (base.transform.position + Vector3.up), Vector3.Distance(target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment)))
			{
				playerInSight = false;
			}
			else
			{
				playerInSight = true;
			}
			if (running)
			{
				Move();
			}
		}
	}

	private void ShootWeapon()
	{
		if (aiming)
		{
			shootingForCoin = false;
			IEnemyWeapon component = weapons[currentWeapon].transform.GetChild(0).GetComponent<IEnemyWeapon>();
			component?.UpdateTarget(target);
			component?.Fire();
			aboutToShoot = false;
			predictAmount = 0f;
			if (!alwaysAimAtGround)
			{
				aimAtGround = false;
			}
		}
	}

	private void AltShootWeapon()
	{
		if (aiming)
		{
			IEnemyWeapon component = weapons[currentWeapon].transform.GetChild(0).GetComponent<IEnemyWeapon>();
			component?.UpdateTarget(target);
			component?.AltFire();
			aboutToShoot = false;
			if (!enraged)
			{
				predictAmount = 0f;
			}
			if (!alwaysAimAtGround)
			{
				aimAtGround = false;
			}
			chargingAlt = false;
		}
	}

	private void Move()
	{
		if (eid.target == null)
		{
			return;
		}
		if ((bool)nma)
		{
			if (!nma.isOnOffMeshLink && (dodging || sliding || !gc.onGround || playerInSight))
			{
				nma.enabled = false;
			}
			else if (nma.isOnNavMesh)
			{
				nma.enabled = true;
				nma.SetDestination(target.position);
				if (distancePatience > 4f && !enraged)
				{
					nma.speed = movementSpeed * 1.5f;
				}
				else
				{
					nma.speed = movementSpeed;
				}
				return;
			}
		}
		rb.isKinematic = false;
		if (dodging)
		{
			rb.velocity = new Vector3(base.transform.forward.x * (movementSpeed * 5f * dodgeLeft), 0f, base.transform.forward.z * (movementSpeed * 5f * dodgeLeft));
		}
		else if (sliding)
		{
			if (slideOnly)
			{
				Vector3 vector = target.position + (base.transform.position - target.position).normalized * 10f;
				Vector3 normalized = new Vector3(vector.x - base.transform.position.x, 0f, vector.z - base.transform.position.z).normalized;
				float num = difficulty;
				rb.velocity = Vector3.MoveTowards(rb.velocity, normalized * movementSpeed * Mathf.Max(1f, num / 1.75f), Time.fixedDeltaTime * 75f);
				Quaternion to = Quaternion.LookRotation(forceSlideDirection, Vector3.up);
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 360f);
				if (difficulty >= 2)
				{
					if (Vector3.Distance(target.position, base.transform.position) < 8f)
					{
						circleTimer = Mathf.MoveTowards(circleTimer, 1f, Time.deltaTime * eid.totalSpeedModifier);
					}
					else
					{
						circleTimer = Mathf.MoveTowards(circleTimer, 0f, Time.deltaTime * eid.totalSpeedModifier);
					}
					if (circleTimer >= 1f)
					{
						circleTimer = 0.65f;
						ForceDodge((base.transform.position - targetPos).normalized + base.transform.right * Random.Range(-1f, 1f));
					}
				}
			}
			else if (distancePatience > 4f && !enraged)
			{
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed * 2f, rb.velocity.y, base.transform.forward.z * movementSpeed * 3f);
			}
			else
			{
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed * 2f, rb.velocity.y, base.transform.forward.z * movementSpeed * 2f);
			}
		}
		else if (gc.onGround)
		{
			if (distancePatience > 4f && !enraged)
			{
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed, rb.velocity.y, base.transform.forward.z * movementSpeed * 1.5f);
				return;
			}
			float num2 = 1f;
			if (MonoSingleton<NewMovement>.Instance.hp <= 33 && difficulty <= 3)
			{
				num2 -= 0.1f;
			}
			if (Vector3.Distance(base.transform.position, targetPos) < 10f && difficulty <= 2 && distancePatience < 4f)
			{
				num2 -= 0.1f;
			}
			if (slowMode)
			{
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed, rb.velocity.y, base.transform.forward.z * movementSpeed * num2 * 0.75f);
			}
			else
			{
				rb.velocity = new Vector3(base.transform.forward.x * movementSpeed, rb.velocity.y, base.transform.forward.z * movementSpeed * num2);
			}
		}
		else
		{
			bool flag = Vector3.Distance(base.transform.position, targetPos) < 10f && difficulty <= 2;
			Vector3 vector2 = ((slowMode || (flag && MonoSingleton<NewMovement>.Instance.hp <= 33 && !enraged)) ? ((!(distancePatience < 4f)) ? new Vector3(base.transform.forward.x * movementSpeed * Time.deltaTime * 1.25f, rb.velocity.y, base.transform.forward.z * movementSpeed * Time.deltaTime * 2f) : new Vector3(base.transform.forward.x * movementSpeed * Time.deltaTime * 1.25f, rb.velocity.y, base.transform.forward.z * movementSpeed * Time.deltaTime * 1.25f)) : ((flag && distancePatience < 4f) ? new Vector3(base.transform.forward.x * movementSpeed * Time.deltaTime * 1.25f, rb.velocity.y, base.transform.forward.z * movementSpeed * Time.deltaTime * 2f) : ((!(distancePatience > 4f) || enraged) ? new Vector3(base.transform.forward.x * movementSpeed * Time.deltaTime * 2.5f, rb.velocity.y, base.transform.forward.z * movementSpeed * Time.deltaTime * 2.5f) : new Vector3(base.transform.forward.x * movementSpeed * Time.deltaTime * 3f, rb.velocity.y, base.transform.forward.z * movementSpeed * Time.deltaTime * 3f))));
			Vector3 zero = Vector3.zero;
			if ((vector2.x > 0f && rb.velocity.x < vector2.x) || (vector2.x < 0f && rb.velocity.x > vector2.x))
			{
				zero.x = vector2.x;
			}
			else
			{
				zero.x = 0f;
			}
			if ((vector2.z > 0f && rb.velocity.z < vector2.z) || (vector2.z < 0f && rb.velocity.z > vector2.z))
			{
				zero.z = vector2.z;
			}
			else
			{
				zero.z = 0f;
			}
			rb.AddForce(zero.normalized * airAcceleration);
		}
	}

	private void LateUpdate()
	{
		if (target == null || ((!active || !aiming) && !escaping))
		{
			return;
		}
		if (difficulty <= 1)
		{
			predictAmount = 0f;
		}
		Vector3 position = target.position;
		Rigidbody rigidbody = eid.target.rigidbody;
		if (escaping)
		{
			predictAmount = 0f;
			position = escapeTarget.position;
		}
		else if ((bool)overrideTarget)
		{
			predictAmount = 0.05f * (Vector3.Distance(overrideTarget.position, base.transform.position) / 20f);
			position = overrideTarget.position;
			rigidbody = overrideTargetRb;
		}
		else if (Vector3.Distance(base.transform.position, targetPos) < 8f)
		{
			predictAmount *= 0.2f;
		}
		try
		{
			if (aimAtTarget.Length == 1 && aimAtGround)
			{
				aimAtTarget[0].LookAt(position + Vector3.down * 2.5f + rigidbody.velocity * (Vector3.Distance(position, aimAtTarget[0].position) * (predictAmount / 10f)));
			}
			else
			{
				aimAtTarget[0].LookAt(position + rigidbody.velocity * (Vector3.Distance(position, aimAtTarget[0].position) * (predictAmount / 10f)));
			}
		}
		catch
		{
			Debug.Log("aaa");
			throw;
		}
		aimAtTarget[0].Rotate(Vector3.right, 10f, Space.Self);
		if (aimAtTarget.Length > 1)
		{
			Quaternion quaternion = ((!aimAtGround) ? Quaternion.LookRotation(position + rigidbody.velocity * predictAmount - aimAtTarget[1].position, Vector3.up) : Quaternion.LookRotation(rigidbody.transform.position + rigidbody.velocity * predictAmount - aimAtTarget[1].position, Vector3.up));
			quaternion = Quaternion.Euler(quaternion.eulerAngles.x + 90f, quaternion.eulerAngles.y, quaternion.eulerAngles.z);
			aimAtTarget[1].rotation = quaternion;
			aimAtTarget[1].Rotate(Vector3.up, 180f, Space.Self);
		}
	}

	private void Jump()
	{
		jumping = true;
		if (anim.layerCount > 1)
		{
			anim.SetLayerWeight(1, 1f);
			anim.SetLayerWeight(2, 0f);
		}
		if (eid.enemyType != EnemyType.BigJohnator)
		{
			anim.SetTrigger("Jump");
		}
		Invoke("NotJumping", 0.25f);
		bool flag = slowMode || (Vector3.Distance(base.transform.position, targetPos) < 10f && difficulty <= 2 && MonoSingleton<NewMovement>.Instance.hp <= 33 && !enraged);
		if (sliding)
		{
			Object.Instantiate(jumpSound, base.transform.position, Quaternion.identity);
			if (flag)
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f);
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f * 2f);
			}
			StopSlide();
		}
		else if (dodging)
		{
			Object.Instantiate(dashJumpSound);
			if (flag)
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f * 0.75f);
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f * 1.5f);
			}
		}
		else
		{
			Object.Instantiate(jumpSound, base.transform.position, Quaternion.identity);
			if (flag)
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f * 1.25f);
			}
			else
			{
				rb.AddForce(Vector3.up * jumpPower * 1500f * 2.5f);
			}
		}
	}

	private void WallJump()
	{
		if (sliding)
		{
			StopSlide();
		}
		jumping = true;
		Invoke("NotJumping", 0.25f);
		Object.Instantiate(jumpSound, base.transform.position, Quaternion.identity).GetComponent<AudioSource>().pitch = 2f;
		Vector3 vector = base.transform.position - wc.ClosestPoint();
		rb.velocity = Vector3.zero;
		Vector3 vector2 = new Vector3(vector.normalized.x * 3f, 0.75f, vector.normalized.z * 3f);
		CheckPattern();
		if (currentPattern == 0)
		{
			Quaternion rotation = anim.transform.rotation;
			Vector3 forward = new Vector3(vector.normalized.x, 0f, vector.normalized.z);
			base.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
			anim.transform.rotation = rotation;
			ChangeDirection(Random.Range(-90, 90));
		}
		else if (currentPattern == 1)
		{
			if (pattern1direction < 0)
			{
				pattern1direction = 1;
			}
			else
			{
				pattern1direction = -1;
			}
		}
		else
		{
			Quaternion rotation2 = anim.transform.rotation;
			base.transform.LookAt(targetPos);
			anim.transform.rotation = rotation2;
		}
		float num = 2000f;
		bool flag = slowMode || (Vector3.Distance(base.transform.position, targetPos) < 10f && difficulty <= 2 && MonoSingleton<NewMovement>.Instance.hp <= 33 && !enraged);
		if (difficulty == 1 || flag)
		{
			num = 1000f;
		}
		else if (difficulty == 0)
		{
			num = 500f;
		}
		rb.AddForce(vector2 * wallJumpPower * num);
	}

	private void CheckPattern()
	{
		if (!(patternCooldown <= 0f) || !(distancePatience < 4f) || cowardPattern)
		{
			return;
		}
		int num = currentPattern;
		currentPattern = Random.Range(0, 3);
		if (num == currentPattern)
		{
			patternCooldown = Random.Range(0.5f, 1f);
			if (currentPattern == 1)
			{
				circleTimer += 1f;
			}
		}
		else
		{
			patternCooldown = Random.Range(2, 5);
			SwitchPattern(currentPattern);
		}
		if (currentPattern == 1 && Random.Range(0f, 1f) > 0.5f)
		{
			pattern1direction = -1;
		}
		else
		{
			pattern1direction = 1;
		}
	}

	private void ChangeDirection(float degrees)
	{
		Quaternion rotation = anim.transform.rotation;
		base.transform.Rotate(base.transform.up, degrees, Space.World);
		anim.transform.rotation = rotation;
	}

	public void Dodge(Transform projectile)
	{
		if (target == null || !active || !(dodgeLeft <= 0f) || chargingAlt || !(Vector3.Distance(base.transform.position, target.position) > 15f))
		{
			return;
		}
		if (sliding && !slideOnly)
		{
			StopSlide();
		}
		if (dodgeCooldown >= (float)(6 - difficulty))
		{
			dodgeCooldown -= 6 - difficulty;
			dodgeLeft = 1f;
			dodging = true;
			eid.hookIgnore = true;
			inPattern = false;
			Object.Instantiate(dodgeEffect, base.transform.position + Vector3.up * 2f, base.transform.rotation);
			Vector3 vector = new Vector3(base.transform.position.x - projectile.position.x, 0f, base.transform.position.z - projectile.position.z);
			if (currentPattern == 2)
			{
				vector = vector.normalized + (targetPos - base.transform.position).normalized;
			}
			base.transform.LookAt(base.transform.position + vector);
			if (Random.Range(0f, 1f) > 0.5f)
			{
				ChangeDirection(90f);
			}
			else
			{
				ChangeDirection(-90f);
			}
			if (!slideOnly && eid.enemyType != EnemyType.BigJohnator)
			{
				anim.SetTrigger("Jump");
			}
		}
		else
		{
			if (!gc.onGround || jumping || slideOnly)
			{
				return;
			}
			float num = ((difficulty <= 2) ? Random.Range(0f, 3f) : Random.Range(0f, 2f));
			if (num < 1f)
			{
				if (num > 0.75f || cowardPattern)
				{
					Jump();
				}
				else
				{
					Slide();
				}
			}
		}
	}

	public void ForceDodge(Vector3 direction)
	{
		if (sliding && !slideOnly)
		{
			StopSlide();
		}
		dodgeLeft = 1f;
		dodging = true;
		eid.hookIgnore = true;
		inPattern = false;
		Object.Instantiate(dodgeEffect, base.transform.position + Vector3.up * 2f, base.transform.rotation);
		direction = new Vector3(direction.x, 0f, direction.z);
		base.transform.LookAt(base.transform.position + direction);
		if (!slideOnly && eid.enemyType != EnemyType.BigJohnator)
		{
			anim.SetTrigger("Jump");
		}
	}

	private void NotJumping()
	{
		jumping = false;
	}

	private void Slide()
	{
		anim.SetBool("Sliding", value: true);
		sliding = true;
		slideEffect.SetActive(value: true);
		slideStopTimer = 0.2f;
	}

	private void StopSlide()
	{
		sliding = false;
		anim.SetBool("Sliding", value: false);
		slideEffect.SetActive(value: false);
		CheckPattern();
	}

	private void SwitchWeapon(int weapon)
	{
		if (currentWeapon != weapon && weapons.Length > weapon)
		{
			currentWeapon = weapon;
			GameObject[] array = weapons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			weapons[weapon].SetActive(value: true);
		}
	}

	public void SwitchPattern(int pattern)
	{
		if (currentWingChangeEffect != null)
		{
			Object.Destroy(currentWingChangeEffect);
		}
		EnemySimplifier[] array = ensims;
		foreach (EnemySimplifier enemySimplifier in array)
		{
			if (enemySimplifier.matList != null && enemySimplifier.matList.Length > 1)
			{
				enemySimplifier.matList[1].mainTexture = wingTextures[pattern];
			}
		}
		currentWingChangeEffect = Object.Instantiate(wingChangeEffect, base.transform.position + Vector3.up * 2f, Quaternion.identity);
		currentWingChangeEffect.GetComponent<Light>().color = wingColors[pattern];
		TrailRenderer[] array2 = wingTrails;
		foreach (TrailRenderer trailRenderer in array2)
		{
			if ((bool)trailRenderer)
			{
				trailRenderer.startColor = new Color(wingColors[pattern].r, wingColors[pattern].g, wingColors[pattern].b, 0.5f);
			}
		}
		switch (pattern)
		{
		case 0:
			currentWingChangeEffect.GetComponent<AudioSource>().pitch = 1.5f;
			break;
		case 1:
			currentWingChangeEffect.GetComponent<AudioSource>().pitch = 1.25f;
			break;
		}
	}

	public void Die()
	{
		if (!dontDie || dead)
		{
			return;
		}
		dead = true;
		if (!bossVersion)
		{
			EnemyIdentifierIdentifier[] componentsInChildren = GetComponentsInChildren<EnemyIdentifierIdentifier>();
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
			{
				eid.DeliverDamage(enemyIdentifierIdentifier.gameObject, Vector3.zero, enemyIdentifierIdentifier.transform.position, 10f, tryForExplode: false);
			}
			base.gameObject.SetActive(value: false);
			Object.Destroy(base.gameObject);
		}
		else
		{
			MonoSingleton<MusicManager>.Instance.off = true;
			if (secondEncounter)
			{
				KnockedOut("Flailing");
			}
			else
			{
				KnockedOut();
			}
		}
	}

	public void KnockedOut(string triggerName = "KnockedDown")
	{
		active = false;
		inPattern = false;
		aiming = false;
		inIntro = false;
		anim.transform.LookAt(new Vector3(target.position.x, anim.transform.position.y, target.position.z));
		if (eid.enemyType != EnemyType.BigJohnator)
		{
			anim.SetTrigger(triggerName);
			anim.SetLayerWeight(1, 0f);
			anim.SetLayerWeight(2, 0f);
		}
		if (!secondEncounter || !dead)
		{
			rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
		}
		else
		{
			rb.constraints = RigidbodyConstraints.None;
			rb.velocity = new Vector3(0f, 15f, 0f);
			rb.AddTorque(-180f, Random.Range(-35, 35), Random.Range(-35, 35), ForceMode.VelocityChange);
			rb.useGravity = false;
		}
		if ((bool)KoScream)
		{
			Object.Instantiate(KoScream, base.transform.position, Quaternion.identity);
		}
		weapons[currentWeapon].transform.GetChild(0).SendMessage("CancelAltCharge", SendMessageOptions.DontRequireReceiver);
		eidids = GetComponentsInChildren<EnemyIdentifierIdentifier>();
		EnemyIdentifierIdentifier[] array = eidids;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Collider>().enabled = false;
		}
		onKnockout.Invoke();
		UnEnrage();
		if ((bool)nma)
		{
			mac.StopKnockBack();
			nma.speed = 25f;
		}
	}

	public void Undie()
	{
		active = true;
		inPattern = true;
		aiming = true;
		eid.totalDamageTakenMultiplier = 1f;
		EnemyIdentifierIdentifier[] array = eidids;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Collider>().enabled = true;
		}
	}

	public void IntroEnd()
	{
		inIntro = false;
		active = true;
		staringAtPlayer = false;
		EnemyIdentifierIdentifier[] array = eidids;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Collider>().enabled = true;
		}
		if ((bool)bhb)
		{
			bhb.enabled = true;
		}
		longIntro = false;
		MonoSingleton<StatueIntroChecker>.Instance.beenSeen = true;
	}

	public void StareAtPlayer()
	{
		staringAtPlayer = true;
	}

	public void BeginEscape()
	{
		escaping = true;
		anim.SetLayerWeight(1, 1f);
		anim.SetLayerWeight(2, 0f);
		anim.SetBool("RunningBack", value: false);
		anim.SetBool("InAir", value: false);
		base.transform.LookAt(new Vector3(target.position.x, base.transform.position.y, target.position.z));
		anim.transform.LookAt(new Vector3(target.position.x, anim.transform.position.y, target.position.z));
		if (gc.onGround && (bool)nma && !mac.knockedBack)
		{
			nma.enabled = true;
		}
	}

	public void InstaEnrage()
	{
		distancePatience = 12f;
		Enrage();
	}

	public void Enrage()
	{
		if (!enraged)
		{
			enraged = true;
			currentEnrageEffect = Object.Instantiate(enrageEffect, mac.chest.transform.position, base.transform.rotation);
			currentEnrageEffect.transform.SetParent(mac.chest.transform, worldPositionStays: true);
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = true;
			}
			movementSpeed = originalMovementSpeed * 2f;
		}
	}

	public void UnEnrage()
	{
		if (enraged)
		{
			if (currentEnrageEffect != null)
			{
				Object.Destroy(currentEnrageEffect);
			}
			enraged = false;
			EnemySimplifier[] array = ensims;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enraged = false;
			}
			movementSpeed = originalMovementSpeed;
		}
	}

	public void SlideOnly(bool value)
	{
		slideOnly = value;
		if (value)
		{
			rb.constraints = (RigidbodyConstraints)116;
			anim.Play("Slide", 0, 0f);
		}
		else
		{
			rb.constraints = RigidbodyConstraints.FreezeRotation;
		}
	}
}



public class V2AnimationController : MonoBehaviour
{
	private V2 v2;

	private void Start()
	{
		v2 = GetComponentInParent<V2>();
	}

	public void IntroEnd()
	{
		v2.IntroEnd();
	}

	public void StareAtPlayer()
	{
		v2.StareAtPlayer();
	}

	public void BeginEscape()
	{
		v2.BeginEscape();
	}

	public void WingsOpen()
	{
		v2.SwitchPattern(0);
	}
}



public class Vacuum : MonoBehaviour
{
	private readonly struct StuckObject
	{
		public readonly Rigidbody rigidbody;

		private readonly float _maxAngularVelocity;

		private readonly RigidbodyInterpolation _interpolation;

		public void UndoPropertyModifications()
		{
			if (!(rigidbody == null))
			{
				rigidbody.maxAngularVelocity = _maxAngularVelocity;
				rigidbody.interpolation = _interpolation;
			}
		}

		public StuckObject(Rigidbody instance)
		{
			rigidbody = instance;
			_maxAngularVelocity = instance.maxAngularVelocity;
			_interpolation = instance.interpolation;
			instance.maxAngularVelocity = float.PositiveInfinity;
			instance.interpolation = RigidbodyInterpolation.Interpolate;
		}
	}

	[SerializeField]
	private float _suckStrength = 10f;

	[SerializeField]
	private float _stuckDistance = 0.5f;

	[SerializeField]
	private Transform _suckPoint;

	[SerializeField]
	private BoxCollider _suckBox;

	[SerializeField]
	private AudioSource _consumeSound;

	[SerializeField]
	private AudioSource _suckSound;

	[SerializeField]
	private ParticleSystem _suckSystem;

	[SerializeField]
	private ParticleSystem _blowSystem;

	private ArraySegment<Collider> _colliders = new ArraySegment<Collider>(new Collider[256], 0, 0);

	private bool _isSucking;

	private bool _isBlowing;

	private StuckObject _stuckObject;

	private Vector3 _lastCameraRotation;

	private bool musicStarted;

	[SerializeField]
	private GameObject music;

	[Header("Sound Effects")]
	[SerializeField]
	private AudioClip suckStartSound;

	[SerializeField]
	private AudioClip suckLoopSound;

	[SerializeField]
	private AudioClip suckStopSound;

	[SerializeField]
	private AudioClip suckStuckSound;

	[SerializeField]
	private AudioClip suckStuckLoopSound;

	[SerializeField]
	private AudioClip blowStartSound;

	[SerializeField]
	private AudioClip blowLoopSound;

	[SerializeField]
	private AudioClip blowStopSound;

	private void Update()
	{
		if (MonoSingleton<GunControl>.Instance.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			UpdateInput();
		}
		if (!_isSucking && !_isBlowing)
		{
			return;
		}
		if (!_suckSound.isPlaying || _suckSound.time > _suckSound.clip.length - 0.1f)
		{
			if (_stuckObject.rigidbody != null)
			{
				_suckSound.clip = suckStuckLoopSound;
			}
			else if (_isBlowing)
			{
				_suckSound.clip = blowLoopSound;
			}
			else
			{
				_suckSound.clip = suckLoopSound;
			}
			_suckSound.loop = true;
			_suckSound.Play();
		}
		float f = (float)((double)Time.time % 6.283185);
		_suckSound.pitch = 1.1f + Mathf.Sin(f) * 0.025f;
		SuckObjects();
	}

	private void FixedUpdate()
	{
		if (_isSucking)
		{
			UpdateStuckObject();
		}
	}

	private void UpdateInput()
	{
		if (!_isBlowing && MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed)
		{
			StartBlowing();
		}
		else if (_isBlowing && !MonoSingleton<InputManager>.Instance.InputSource.Fire2.IsPressed)
		{
			StopBlowing();
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed && !_isBlowing && !_isSucking)
		{
			StartVacuuming();
		}
		else if (_isSucking && !MonoSingleton<InputManager>.Instance.InputSource.Fire1.IsPressed)
		{
			StopVacuuming();
		}
	}

	private void UpdateStuckObject()
	{
		if (!(_stuckObject.rigidbody == null))
		{
			Vector3 vector = _suckPoint.position - _stuckObject.rigidbody.worldCenterOfMass;
			_stuckObject.rigidbody.velocity = vector / Time.fixedDeltaTime;
			float num = Camera.main.transform.eulerAngles.y - _lastCameraRotation.y;
			num *= (float)Math.PI / 180f;
			_stuckObject.rigidbody.angularVelocity = new Vector3(0f, num / Time.fixedDeltaTime, 0f);
			_lastCameraRotation = Camera.main.transform.eulerAngles;
		}
	}

	private void UpdateColliders()
	{
		int i = _colliders.Offset;
		for (int num = i + _colliders.Count; i < num; i++)
		{
			Collider collider = _colliders.Array[i];
			if (!(collider == null) && !(collider.attachedRigidbody == null) && collider.attachedRigidbody.TryGetComponent<Cork>(out var component))
			{
				component.insideSuckZone = false;
			}
		}
		Vector3 center = _suckBox.transform.TransformPoint(_suckBox.center);
		Vector3 halfExtents = Vector3.Scale(_suckBox.size, _suckBox.transform.lossyScale) * 0.5f;
		_colliders = new ArraySegment<Collider>(_colliders.Array, 0, Physics.OverlapBoxNonAlloc(center, halfExtents, _colliders.Array, _suckBox.transform.rotation));
		int j = _colliders.Offset;
		for (int num2 = j + _colliders.Count; j < num2; j++)
		{
			Collider collider2 = _colliders.Array[j];
			if (!(collider2 == null) && !(collider2.attachedRigidbody == null) && collider2.attachedRigidbody.TryGetComponent<Cork>(out var component2))
			{
				component2.insideSuckZone = true;
			}
		}
	}

	private void SuckObjects()
	{
		if ((!_isSucking && !_isBlowing) || _stuckObject.rigidbody != null)
		{
			return;
		}
		UpdateColliders();
		int i = _colliders.Offset;
		for (int num = i + _colliders.Count; i < num; i++)
		{
			Collider collider = _colliders.Array[i];
			if (collider == null || collider.attachedRigidbody == null || collider.attachedRigidbody.TryGetComponent<NewMovement>(out var _))
			{
				continue;
			}
			Rigidbody attachedRigidbody = collider.attachedRigidbody;
			if (_isSucking && attachedRigidbody.TryGetComponent<Cork>(out var component2))
			{
				component2.StartWiggle();
			}
			if (_isSucking && collider.TryGetComponent<TerribleTasteBook>(out var component3))
			{
				component3.ActivateBookShelf();
			}
			GhostDrone component4 = null;
			if (_isSucking && attachedRigidbody.TryGetComponent<GhostDrone>(out component4))
			{
				Vector3 vector = _suckPoint.position - attachedRigidbody.position;
				Vector3 vacuumVelocity = vector.normalized * Mathf.Max(1f / vector.sqrMagnitude, 2f);
				component4.vacuumVelocity = vacuumVelocity;
			}
			if (_isSucking)
			{
				attachedRigidbody.velocity = Vector3.Normalize(_suckPoint.position - attachedRigidbody.worldCenterOfMass) * _suckStrength;
			}
			else
			{
				attachedRigidbody.velocity = MonoSingleton<CameraController>.Instance.transform.forward.normalized * _suckStrength * 2f;
			}
			if (_isBlowing || Vector3.Distance(attachedRigidbody.worldCenterOfMass, _suckPoint.position) >= _stuckDistance)
			{
				continue;
			}
			if (!attachedRigidbody.TryGetComponent<GoreSplatter>(out var component5))
			{
				if ((bool)component4)
				{
					component4.KillGhost();
					continue;
				}
				SetStuckObject(attachedRigidbody);
				break;
			}
			if (!musicStarted)
			{
				if ((bool)music)
				{
					music.SetActive(value: true);
				}
				musicStarted = true;
			}
			_consumeSound.pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			_consumeSound.PlayOneShot(_consumeSound.clip);
			component5.Repool();
		}
	}

	private void StopCorkPull()
	{
		int i = _colliders.Offset;
		for (int num = i + _colliders.Count; i < num; i++)
		{
			Collider collider = _colliders.Array[i];
			if (!(collider == null) && !(collider.attachedRigidbody == null) && collider.attachedRigidbody.TryGetComponent<Cork>(out var component))
			{
				component.StopWiggle();
			}
		}
	}

	private void StartVacuuming()
	{
		if (_isBlowing)
		{
			StopBlowing();
		}
		_suckSystem.Play();
		_suckSound.clip = suckStartSound;
		_suckSound.loop = false;
		_suckSound.Play();
		_isSucking = true;
	}

	private void StopVacuuming()
	{
		_suckSystem.Stop();
		_suckSound.clip = suckStopSound;
		_suckSound.loop = false;
		_suckSound.Play();
		_isSucking = false;
		StopCorkPull();
		SetStuckObject(null);
	}

	private void StartBlowing()
	{
		if (_isSucking)
		{
			StopVacuuming();
		}
		_blowSystem.Play();
		_suckSound.clip = blowStartSound;
		_suckSound.loop = false;
		_suckSound.Play();
		_isBlowing = true;
		StopCorkPull();
		SetStuckObject(null);
	}

	private void StopBlowing()
	{
		_blowSystem.Stop();
		_suckSound.clip = blowStopSound;
		_suckSound.loop = false;
		_suckSound.Play();
		_isBlowing = false;
	}

	private void SetStuckObject(Rigidbody rigidbody)
	{
		if (_stuckObject.rigidbody != null)
		{
			_stuckObject.UndoPropertyModifications();
			_stuckObject.rigidbody.velocity = MonoSingleton<NewMovement>.Instance.rb.velocity;
			_stuckObject.rigidbody.angularVelocity = Vector3.zero;
			EnemyIdentifierIdentifier component2;
			if (_stuckObject.rigidbody.TryGetComponent<GoreSplatter>(out var component))
			{
				component.bloodAbsorberCount--;
			}
			else if (_stuckObject.rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out component2))
			{
				component2.bloodAbsorberCount--;
			}
		}
		if (rigidbody == null)
		{
			_stuckObject = default(StuckObject);
			return;
		}
		EnemyIdentifierIdentifier component4;
		if (rigidbody.TryGetComponent<GoreSplatter>(out var component3))
		{
			component3.bloodAbsorberCount++;
		}
		else if (rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out component4))
		{
			component4.bloodAbsorberCount++;
		}
		if (!musicStarted)
		{
			if ((bool)music)
			{
				music.SetActive(value: true);
			}
			musicStarted = true;
		}
		_suckSystem.Stop();
		_suckSound.loop = false;
		_suckSound.clip = suckStuckSound;
		_suckSound.Play();
		_stuckObject = new StuckObject(rigidbody);
		StopCorkPull();
	}
}


public enum VariantOption
{
	IfEquipped,
	ForceOn,
	ForceOff
}



[Serializable]
public class VariantSetting
{
	public VariantOption blueVariant;

	public VariantOption greenVariant;

	public VariantOption redVariant;
}



public class VariationInfo : MonoBehaviour
{
	public GameObject varPage;

	private int money;

	public int cost;

	public TMP_Text costText;

	public ShopButton buyButton;

	private TMP_Text buttonText;

	public GameObject buySound;

	public Button equipButton;

	private Image equipImage;

	public Sprite[] equipSprites;

	private int equipStatus;

	public bool alreadyOwned;

	public string weaponName;

	private GunSetter gs;

	private FistControl fc;

	private GameObject player;

	public GameObject orderButtons;

	private void Start()
	{
		player = MonoSingleton<NewMovement>.Instance.gameObject;
		buttonText = buyButton.GetComponentInChildren<TMP_Text>();
		buyButton.variationInfo = this;
		equipImage = equipButton.transform.GetChild(0).GetComponent<Image>();
		if (GameProgressSaver.CheckGear(weaponName) > 0)
		{
			alreadyOwned = true;
		}
		UpdateMoney();
	}

	private void OnEnable()
	{
		UpdateMoney();
	}

	public void UpdateMoney()
	{
		money = GameProgressSaver.GetMoney();
		MoneyText[] array = Object.FindObjectsOfType<MoneyText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateMoney();
		}
		if (!alreadyOwned && cost < 0 && GameProgressSaver.CheckGear(weaponName) > 0)
		{
			alreadyOwned = true;
		}
		if (!alreadyOwned)
		{
			if (cost < 0)
			{
				costText.text = "<color=red>UNAVAILABLE</color>";
				if (buttonText == null)
				{
					buttonText = buyButton.GetComponentInChildren<TMP_Text>();
				}
				buttonText.text = costText.text;
				buyButton.failure = true;
				buyButton.GetComponent<Button>().interactable = false;
				buyButton.GetComponent<Image>().color = Color.red;
				if (TryGetComponent<ShopButton>(out var component))
				{
					component.failure = true;
				}
			}
			else if (cost > money)
			{
				costText.text = "<color=red>" + MoneyText.DivideMoney(cost) + "P</color>";
				if (buttonText == null)
				{
					buttonText = buyButton.GetComponentInChildren<TMP_Text>();
				}
				buttonText.text = costText.text;
				buyButton.failure = true;
				buyButton.GetComponent<Button>().interactable = false;
				buyButton.GetComponent<Image>().color = Color.red;
			}
			else
			{
				costText.text = "<color=white>" + MoneyText.DivideMoney(cost) + "</color><color=orange>P</color>";
				if (buttonText == null)
				{
					buttonText = buyButton.GetComponentInChildren<TMP_Text>();
				}
				buttonText.text = costText.text;
				buyButton.failure = false;
				buyButton.GetComponent<Button>().interactable = true;
				buyButton.GetComponent<Image>().color = Color.white;
			}
			equipButton.gameObject.SetActive(value: false);
			return;
		}
		costText.text = "ALREADY OWNED";
		if (buttonText == null)
		{
			buttonText = buyButton.GetComponentInChildren<TMP_Text>();
		}
		buttonText.text = costText.text;
		buyButton.failure = true;
		buyButton.GetComponent<Button>().interactable = false;
		buyButton.GetComponent<Image>().color = Color.white;
		equipButton.gameObject.SetActive(value: true);
		equipButton.interactable = true;
		if (equipImage == null)
		{
			equipImage = equipButton.transform.GetChild(0).GetComponent<Image>();
		}
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + weaponName, 1);
		if (@int == 2 && GameProgressSaver.CheckGear(weaponName.Substring(0, weaponName.Length - 1) + "alt") > 0)
		{
			equipStatus = 2;
		}
		else if (@int > 0)
		{
			equipStatus = 1;
		}
		else
		{
			equipStatus = 0;
		}
		if ((bool)orderButtons)
		{
			if (equipStatus != 0)
			{
				orderButtons.SetActive(value: true);
			}
			else
			{
				orderButtons.SetActive(value: false);
			}
		}
		equipImage.sprite = equipSprites[equipStatus];
		if (cost < 0 && TryGetComponent<ShopButton>(out var component2))
		{
			component2.failure = false;
		}
	}

	public void WeaponBought()
	{
		alreadyOwned = true;
		Object.Instantiate(buySound);
		GameProgressSaver.AddMoney(cost * -1);
		GameProgressSaver.AddGear(weaponName);
		MonoSingleton<PrefsManager>.Instance.SetInt("weapon." + weaponName, 1);
		UpdateMoney();
		MoneyText[] array = Object.FindObjectsOfType<MoneyText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateMoney();
		}
		VariationInfo[] array2 = Object.FindObjectsOfType<VariationInfo>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].UpdateMoney();
		}
		if (PlayerPrefs.GetInt("FirVar", 1) == 1)
		{
			GetComponentInParent<ShopZone>().firstVariationBuy = true;
		}
		if (gs == null)
		{
			gs = player.GetComponentInChildren<GunSetter>();
		}
		gs.ResetWeapons();
		gs.ForceWeapon(weaponName);
		gs.gunc.NoWeapon();
		if (fc == null)
		{
			fc = player.GetComponentInChildren<FistControl>();
		}
		fc.ResetFists();
	}

	public void ChangeEquipment(int value)
	{
		int num = equipStatus;
		num = ((value <= 0) ? (num - 1) : (num + 1));
		int num2 = num;
		if (num < 0)
		{
			num2 = ((GameProgressSaver.CheckGear(weaponName.Substring(0, weaponName.Length - 1) + "alt") <= 0) ? 1 : 2);
		}
		else if (num == 2)
		{
			num2 = ((GameProgressSaver.CheckGear(weaponName.Substring(0, weaponName.Length - 1) + "alt") > 0) ? 2 : 0);
		}
		else if (num > 2)
		{
			num2 = 0;
		}
		equipStatus = num2;
		equipImage.sprite = equipSprites[num2];
		MonoSingleton<PrefsManager>.Instance.SetInt("weapon." + weaponName, num2);
		if ((bool)orderButtons)
		{
			if (equipStatus == 0)
			{
				orderButtons.SetActive(value: false);
			}
			else
			{
				orderButtons.SetActive(value: true);
			}
		}
		if (gs == null)
		{
			gs = player.GetComponentInChildren<GunSetter>();
		}
		gs.ResetWeapons();
		if (fc == null)
		{
			fc = player.GetComponentInChildren<FistControl>();
		}
		fc.ResetFists();
	}
}



public static class VectorUtility
{
	public static Vector3 SmoothStep(Vector3 from, Vector3 to, float t)
	{
		return new Vector3(Mathf.SmoothStep(from.x, to.x, t), Mathf.SmoothStep(from.y, to.y, t), Mathf.SmoothStep(from.z, to.z, t));
	}
}



public class Vibrate : MonoBehaviour
{
	public float intensity;

	private Vector3 origPos;

	public float speed;

	private Vector3 targetPos;

	private void Start()
	{
		origPos = base.transform.localPosition;
		targetPos = origPos;
	}

	private void Update()
	{
		if (speed == 0f)
		{
			base.transform.localPosition = new Vector3(origPos.x + Random.Range(0f - intensity, intensity), origPos.y + Random.Range(0f - intensity, intensity), origPos.z + Random.Range(0f - intensity, intensity));
		}
		else if (base.transform.localPosition == targetPos)
		{
			targetPos = new Vector3(origPos.x + Random.Range(0f - intensity, intensity), origPos.y + Random.Range(0f - intensity, intensity), origPos.z + Random.Range(0f - intensity, intensity));
		}
		else
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Time.deltaTime * speed);
		}
	}
}



public class ViewModelFlip : MonoBehaviour
{
	private void Start()
	{
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weaponHoldPosition") == 2)
		{
			Left();
		}
		else
		{
			Right();
		}
	}

	public void Left()
	{
		base.transform.localScale = new Vector3(-1f, 1f, 1f);
	}

	public void Right()
	{
		base.transform.localScale = new Vector3(1f, 1f, 1f);
	}
}



public class VirtueInsignia : MonoBehaviour
{
	public EnemyTarget target;

	public GameObject explosion;

	public int damage;

	private bool hasHitTarget;

	private float offset;

	private SpriteRenderer[] sprites;

	private bool activating;

	private float activationTime;

	private float currentDistance;

	public float windUpSpeedMultiplier = 1f;

	public float explosionLength;

	public int charges;

	private float explosionWidth;

	private AudioSource explAud;

	private Light lit;

	[HideInInspector]
	public Drone parentDrone;

	[HideInInspector]
	public Transform otherParent;

	public bool hadParent;

	public bool predictive;

	public bool noTracking;

	public Sprite predictiveVersion;

	public Sprite multiVersion;

	private void Start()
	{
		offset = Random.Range(-0.1f, 0.1f);
		sprites = GetComponentsInChildren<SpriteRenderer>();
		explosionWidth = explosion.transform.localScale.x;
		if ((bool)parentDrone)
		{
			parentDrone.childVi.Add(this);
			hadParent = true;
		}
		if ((bool)otherParent)
		{
			hadParent = true;
		}
		for (int i = 1; i < sprites.Length; i++)
		{
			sprites[i].gameObject.SetActive(value: false);
			sprites[i].transform.localPosition = Vector3.zero;
		}
		if ((charges > 1 && multiVersion != null && !predictive) || (predictiveVersion != null && predictive))
		{
			SpriteRenderer[] array = sprites;
			foreach (SpriteRenderer spriteRenderer in array)
			{
				if (predictive)
				{
					spriteRenderer.sprite = predictiveVersion;
				}
				else if (charges > 1)
				{
					spriteRenderer.sprite = multiVersion;
				}
			}
		}
		lit = GetComponent<Light>();
		if (!noTracking)
		{
			Invoke("Activating", 2f / windUpSpeedMultiplier);
		}
		else
		{
			Activating();
		}
	}

	private void Update()
	{
		if (!activating)
		{
			if (activationTime < 1f)
			{
				if (hadParent && !parentDrone && !otherParent)
				{
					Object.Destroy(base.gameObject);
				}
				base.transform.position = Vector3.MoveTowards(base.transform.position, target.position + Vector3.up * offset, Time.deltaTime * 50f + Time.deltaTime * Vector3.Distance(base.transform.position, target.position) * 100f);
				base.transform.Rotate(Vector3.up, Time.deltaTime * 180f, Space.Self);
				return;
			}
			explosionLength = Mathf.MoveTowards(explosionLength, 0f, Time.deltaTime);
			if (explosionLength <= 1f)
			{
				explosion.transform.localScale = new Vector3(explosionLength * explosionWidth, explosion.transform.localScale.y, explosionLength * explosionWidth);
				explAud.pitch = explosionLength;
				if (explosionLength <= 0f)
				{
					Object.Destroy(base.gameObject);
				}
			}
			return;
		}
		if (noTracking && hadParent && !parentDrone && (!otherParent || !otherParent.gameObject.activeSelf))
		{
			Object.Destroy(base.gameObject);
		}
		base.transform.Rotate(Vector3.up, Time.deltaTime * 720f, Space.Self);
		activationTime = Mathf.MoveTowards(activationTime, 1f, Time.deltaTime * windUpSpeedMultiplier);
		currentDistance = Mathf.MoveTowards(currentDistance, 1f, Time.deltaTime * (windUpSpeedMultiplier * 2f * (1f - currentDistance)));
		for (int i = 1; i < sprites.Length; i++)
		{
			if (i % 2 == 0)
			{
				sprites[i].transform.localPosition = Vector3.up * 3f * Mathf.Lerp(0f, i / 2 * -1, currentDistance);
			}
			else
			{
				sprites[i].transform.localPosition = Vector3.up * 3f * Mathf.Lerp(0f, (i + 1) / 2, currentDistance);
			}
		}
		if (activationTime >= 1f)
		{
			activating = false;
			explosionLength += 1f;
			Explode();
		}
	}

	private void Activating()
	{
		if (!noTracking && charges > 1)
		{
			charges--;
			Object.Instantiate(base.gameObject, base.transform.position, Quaternion.identity).GetComponent<VirtueInsignia>().target = target;
		}
		activating = true;
		if (predictive)
		{
			if (target != null)
			{
				float num = 1f / windUpSpeedMultiplier;
				Vector3 velocity = target.GetVelocity();
				if (target.isPlayer)
				{
					if ((bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
					{
						base.transform.position = target.PredictTargetPosition(num);
					}
					else
					{
						base.transform.position = target.position + Vector3.up * offset + new Vector3(velocity.x, 0f, velocity.z).normalized * 16.45f * (num - (base.transform.localScale.x - 1f) / 20f * num);
					}
				}
				else
				{
					base.transform.position = target.position + Vector3.up * offset + new Vector3(velocity.x, 0f, velocity.z) * (num - (base.transform.localScale.x - 1f) / 20f * num);
				}
			}
			else
			{
				base.transform.position = target.position + Vector3.up * offset;
			}
		}
		for (int i = 1; i < sprites.Length; i++)
		{
			sprites[i].gameObject.SetActive(value: true);
			sprites[i].transform.localPosition = Vector3.zero;
		}
		currentDistance = 0f;
		activationTime = 0f;
	}

	private void Explode()
	{
		if (noTracking && charges > 1 && (!hadParent || (bool)parentDrone || ((bool)otherParent && otherParent.gameObject.activeSelf)))
		{
			charges--;
			VirtueInsignia component = Object.Instantiate(base.gameObject, base.transform.position, Quaternion.identity).GetComponent<VirtueInsignia>();
			component.target = target;
			component.hadParent = hadParent;
			if ((bool)parentDrone)
			{
				component.parentDrone = parentDrone;
			}
			if ((bool)otherParent)
			{
				component.otherParent = otherParent;
			}
		}
		SpriteRenderer[] array = sprites;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
		explAud = explosion.GetComponent<AudioSource>();
		explosion.SetActive(value: true);
		MonoSingleton<CameraController>.Instance.CameraShake(1f);
		if ((bool)lit)
		{
			lit.enabled = false;
		}
		if ((bool)parentDrone)
		{
			parentDrone.childVi.Remove(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (target != null && !hasHitTarget && (!target.isPlayer || other.gameObject.CompareTag("Player")))
		{
			if (target.isPlayer)
			{
				hasHitTarget = true;
				if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.Platformer)
				{
					MonoSingleton<PlatformerMovement>.Instance.Burn();
				}
				else
				{
					MonoSingleton<NewMovement>.Instance.LaunchFromPoint(MonoSingleton<NewMovement>.Instance.transform.position, 200f, 5f);
					MonoSingleton<NewMovement>.Instance.GetHurt(damage, invincible: true);
				}
			}
			else
			{
				EnemyIdentifier enemyIdentifier = other.GetComponent<EnemyIdentifier>();
				if (enemyIdentifier == null)
				{
					EnemyIdentifierIdentifier component = other.GetComponent<EnemyIdentifierIdentifier>();
					if (component != null)
					{
						enemyIdentifier = component.eid;
					}
				}
				if (enemyIdentifier != null && target.enemyIdentifier == enemyIdentifier && other.TryGetComponent<Rigidbody>(out var component2))
				{
					hasHitTarget = true;
					component2.AddExplosionForce(1000f, base.transform.position, 10f);
					enemyIdentifier.SimpleDamage(damage);
				}
			}
		}
		Flammable component3 = other.GetComponent<Flammable>();
		if ((bool)component3 && !component3.playerOnly)
		{
			component3.Burn(10f);
		}
	}
}


public enum VoxelCheckingShape
{
	Box,
	VerticalBox,
	Pole,
	Cross
}



public class VoxelProxy : MonoBehaviour
{
	[HideInInspector]
	public bool isStatic;

	public StainVoxel voxel;

	[HideInInspector]
	public Transform parent;

	private BurningVoxel burningVoxel;

	private VoxelProxyDebug debug;

	private bool exploded;

	public bool isBurning
	{
		get
		{
			if (!(burningVoxel != null))
			{
				return exploded;
			}
			return true;
		}
	}

	public List<GasolineStain> stains { get; } = new List<GasolineStain>();


	private void Awake()
	{
		if (burningVoxel == null)
		{
			burningVoxel = GetComponent<BurningVoxel>();
		}
		if (debug == null)
		{
			debug = GetComponent<VoxelProxyDebug>();
		}
	}

	public void SetParent(Transform parent, bool isStatic)
	{
		this.isStatic = isStatic;
		this.parent = parent;
		Vector3 vector = ComputeCombinedHierarchyScale(parent);
		base.transform.SetParent(parent, worldPositionStays: true);
		base.transform.localScale = new Vector3(1f / vector.x, 1f / vector.y, 1f / vector.z);
		base.transform.localRotation = Quaternion.identity;
	}

	private Vector3 ComputeCombinedHierarchyScale(Transform parent)
	{
		Vector3 vector = Vector3.one;
		Transform transform = parent;
		while (transform != null)
		{
			vector = Vector3.Scale(vector, transform.localScale);
			transform = transform.parent;
		}
		return vector;
	}

	public void Add(GasolineStain stain)
	{
		stains.Add(stain);
		stain.transform.SetParent(base.transform, worldPositionStays: true);
	}

	public bool IsMatch(ProxySearchMode searchMode)
	{
		if (stains.Count == 0)
		{
			return false;
		}
		if (!base.gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!searchMode.HasFlag(ProxySearchMode.IncludeStatic) && isStatic)
		{
			return false;
		}
		if (!searchMode.HasFlag(ProxySearchMode.IncludeDynamic) && !isStatic)
		{
			return false;
		}
		if (!searchMode.HasFlag(ProxySearchMode.IncludeBurning) && isBurning)
		{
			return false;
		}
		if (!searchMode.HasFlag(ProxySearchMode.IncludeNotBurning) && !isBurning)
		{
			return false;
		}
		if (searchMode.HasFlag(ProxySearchMode.FloorOnly))
		{
			foreach (GasolineStain stain in stains)
			{
				if (stain.IsFloor)
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void DestroySelf()
	{
		Object.Destroy(base.gameObject);
	}

	public void StartBurningOrRefuel()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (burningVoxel != null)
			{
				burningVoxel.Refuel();
				return;
			}
			burningVoxel = base.gameObject.AddComponent<BurningVoxel>();
			burningVoxel.Initialize(this);
		}
	}

	public void ExplodeAndDestroy()
	{
		exploded = true;
		DestroySelf();
		GameObject gameObject = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.explosion, base.transform.position, Quaternion.identity);
		if (gameObject.TryGetComponent<ExplosionController>(out var component))
		{
			component.tryIgniteGasoline = false;
			component.forceSimple = true;
			Explosion[] componentsInChildren = gameObject.GetComponentsInChildren<Explosion>();
			foreach (Explosion obj in componentsInChildren)
			{
				obj.lowQuality = true;
				obj.HurtCooldownCollection = MonoSingleton<StainVoxelManager>.Instance.SharedHurtCooldownCollection;
			}
		}
	}

	private void Update()
	{
		if (debug == null && NapalmDebugVoxels.Enabled)
		{
			debug = base.gameObject.AddComponent<VoxelProxyDebug>();
		}
		if (!isStatic)
		{
			Vector3Int vector3Int = StainVoxelManager.WorldToVoxelPosition(base.transform.position);
			if (vector3Int != voxel.VoxelPosition)
			{
				MonoSingleton<StainVoxelManager>.Instance.UpdateProxyPosition(this, vector3Int);
			}
		}
	}

	private void OnDestroy()
	{
		if (debug != null)
		{
			Object.Destroy(debug);
		}
		if (base.gameObject.scene.isLoaded)
		{
			voxel.RemoveProxy(this);
		}
	}

	public void SetStainSize(float size)
	{
		foreach (GasolineStain stain in stains)
		{
			stain.SetSize(size);
		}
	}
}



public class VoxelProxyDebug : MonoBehaviour
{
	private VoxelProxy voxelProxy;

	private void Awake()
	{
		voxelProxy = GetComponent<VoxelProxy>();
	}

	private void OnDrawGizmos()
	{
		if (voxelProxy == null)
		{
			return;
		}
		if (!NapalmDebugVoxels.Enabled)
		{
			Object.Destroy(this);
			return;
		}
		Gizmos.color = (voxelProxy.isStatic ? Color.blue : Color.green);
		Gizmos.DrawWireCube(base.transform.position, Vector3.one * 2.75f);
		if (!voxelProxy.isStatic)
		{
			Gizmos.color = Color.magenta;
			Gizmos.DrawWireCube(voxelProxy.voxel.RoundedWorldPosition, Vector3.one * 2.75f);
		}
	}
}



public class WalkingBob : MonoBehaviour
{
	private NewMovement nmov;

	private Vector3 originalPos;

	private Vector3 rightPos;

	private Vector3 leftPos;

	private Vector3 target;

	private bool backToStart;

	private float speed;

	private void Awake()
	{
		nmov = GetComponentInParent<NewMovement>();
		originalPos = base.transform.localPosition;
		rightPos = new Vector3(originalPos.x + 0.08f, originalPos.y - 0.025f, originalPos.z);
		leftPos = new Vector3(originalPos.x - 0.08f, originalPos.y - 0.025f, originalPos.z);
		target = rightPos;
	}

	private void Update()
	{
		if (nmov.walking)
		{
			speed = Time.deltaTime * (2f - Vector3.Distance(base.transform.localPosition, originalPos) * 3f) * (Mathf.Min(nmov.rb.velocity.magnitude, 15f) / 15f);
			if (backToStart)
			{
				base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, originalPos, speed * 0.25f);
			}
			else
			{
				base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, target, speed * 0.25f);
			}
			if (base.transform.localPosition == originalPos)
			{
				backToStart = false;
			}
			else if (base.transform.localPosition == rightPos)
			{
				backToStart = true;
				target = leftPos;
			}
			else if (base.transform.localPosition == leftPos)
			{
				backToStart = true;
				target = rightPos;
			}
		}
		else if (base.transform.localPosition != originalPos)
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, originalPos, Time.deltaTime);
		}
	}
}



public class WallCheck : MonoBehaviour
{
	public bool onWall;

	public Vector3 poc;

	public List<Collider> cols = new List<Collider>();

	private List<Collider> colsToDelete = new List<Collider>();

	private List<Collider> enemyCols = new List<Collider>();

	private void Update()
	{
		if (onWall)
		{
			onWall = CheckForCols();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((other.gameObject.layer == 8 || other.gameObject.layer == 24 || other.gameObject.layer == 11) && !other.isTrigger && !other.gameObject.CompareTag("Slippery"))
		{
			onWall = true;
			cols.Add(other);
		}
		else if (other.gameObject.layer == 12)
		{
			enemyCols.Add(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == 8 || other.gameObject.layer == 17 || other.gameObject.layer == 24 || other.gameObject.layer == 11)
		{
			if (cols.Contains(other))
			{
				cols.Remove(other);
			}
		}
		else if (other.gameObject.layer == 12 && enemyCols.Contains(other))
		{
			enemyCols.Remove(other);
		}
	}

	public bool CheckForCols()
	{
		bool result = false;
		poc = Vector3.zero;
		float num = 100f;
		if (cols.Count > 1)
		{
			foreach (Collider col in cols)
			{
				if (col != null && col.enabled && col.gameObject.activeInHierarchy && (col.gameObject.layer == 8 || col.gameObject.layer == 24) && !col.isTrigger && !col.gameObject.CompareTag("Slippery"))
				{
					Vector3 a = ColliderUtility.FindClosestPoint(col, base.transform.position, ignoreVerticalTriangles: true);
					if (Vector3.Distance(a, base.transform.position) < num && Vector3.Distance(a, base.transform.position) < 5f)
					{
						num = Vector3.Distance(a, base.transform.position);
						poc = a;
						result = true;
					}
					else if (Vector3.Distance(a, base.transform.position) >= 5f)
					{
						colsToDelete.Add(col);
					}
				}
				else
				{
					colsToDelete.Add(col);
				}
			}
		}
		else if (cols.Count == 1 && cols[0] != null && cols[0].enabled && cols[0].gameObject.activeInHierarchy)
		{
			Vector3 a2 = ColliderUtility.FindClosestPoint(cols[0], base.transform.position, ignoreVerticalTriangles: true);
			if (Vector3.Distance(a2, base.transform.position) < 5f)
			{
				poc = a2;
			}
			result = true;
		}
		else if (cols.Count == 1 && (cols[0] == null || Vector3.Distance(ColliderUtility.FindClosestPoint(cols[0], base.transform.position, ignoreVerticalTriangles: true), base.transform.position) < 5f))
		{
			colsToDelete.Add(cols[0]);
		}
		if (colsToDelete.Count > 0)
		{
			foreach (Collider item in colsToDelete)
			{
				if (cols.Contains(item))
				{
					cols.Remove(item);
				}
				else if (enemyCols.Contains(item))
				{
					enemyCols.Remove(item);
				}
			}
		}
		colsToDelete.Clear();
		return result;
	}

	public bool CheckForEnemyCols()
	{
		if ((bool)MonoSingleton<NewMovement>.Instance.ridingRocket)
		{
			return false;
		}
		if (enemyCols.Count > 0)
		{
			bool result = false;
			foreach (Collider enemyCol in enemyCols)
			{
				if (enemyCol != null && enemyCol.enabled && enemyCol.gameObject.activeInHierarchy && Vector3.Distance(base.transform.position, enemyCol.transform.position) < 40f)
				{
					result = true;
				}
				else
				{
					colsToDelete.Add(enemyCol);
				}
			}
			if (colsToDelete.Count > 0)
			{
				foreach (Collider item in colsToDelete)
				{
					if (cols.Contains(item))
					{
						cols.Remove(item);
					}
					else if (enemyCols.Contains(item))
					{
						enemyCols.Remove(item);
					}
				}
				colsToDelete.Clear();
			}
			return result;
		}
		return false;
	}
}



public class Washer : MonoBehaviour
{
	private bool isSpraying;

	public ParticleSystem part;

	public List<ParticleCollisionEvent> collisionEvents;

	private InputManager inputManager;

	private AudioSource aud;

	[SerializeField]
	private AudioClip click;

	[SerializeField]
	private AudioClip triggerOn;

	[SerializeField]
	private AudioClip triggerOff;

	private ParticleSystem.ShapeModule shapeModule;

	private ParticleSystem.MainModule mainModule;

	[SerializeField]
	private GameObject[] nozzles;

	private bool musicStarted;

	[SerializeField]
	private GameObject music;

	private Vector3 defaultSprayPos;

	private Quaternion defaultSprayRot;

	private int nozzleMode;

	public CorrectCameraView correctCameraView;

	private void Start()
	{
		collisionEvents = new List<ParticleCollisionEvent>();
		defaultSprayPos = correctCameraView.transform.localPosition;
		defaultSprayRot = correctCameraView.transform.localRotation;
	}

	private void OnEnable()
	{
		part = GetComponent<ParticleSystem>();
		part.Stop();
		aud = GetComponent<AudioSource>();
		aud.Stop();
		inputManager = MonoSingleton<InputManager>.Instance;
	}

	private void Update()
	{
		Transform transform = MonoSingleton<CameraController>.Instance.transform;
		if (Physics.Raycast(transform.position, transform.forward, out var hitInfo, 50f, LayerMaskDefaults.Get(LMD.Environment)))
		{
			if (hitInfo.distance < 2.25f)
			{
				base.transform.position = transform.position;
				base.transform.rotation = transform.rotation;
				correctCameraView.canModifyTarget = false;
			}
			else
			{
				correctCameraView.canModifyTarget = true;
			}
		}
		if (MonoSingleton<GunControl>.Instance.activated && !GameStateManager.Instance.PlayerInputLocked)
		{
			if (inputManager.InputSource.Fire1.IsPressed && !isSpraying)
			{
				StartWashing();
			}
			else if (!inputManager.InputSource.Fire1.IsPressed && isSpraying)
			{
				StopWashing();
			}
			if (inputManager.InputSource.Fire2.WasPerformedThisFrame)
			{
				SwitchNozzle();
			}
		}
		float f = (float)((double)Time.time % 6.283185);
		aud.pitch = ((nozzleMode == 2) ? 2.1f : 1.1f) + Mathf.Sin(f) * 0.025f;
	}

	private void SwitchNozzle()
	{
		aud.pitch = Random.Range(0.9f, 1.1f);
		aud.PlayOneShot(click);
		nozzleMode = (nozzleMode + 1) % 3;
		Debug.Log(nozzleMode);
		for (int i = 0; i < nozzles.Length; i++)
		{
			nozzles[i].SetActive(i == nozzleMode);
		}
		shapeModule = part.shape;
		mainModule = part.main;
		ParticleSystem.EmissionModule emission = part.emission;
		if (nozzleMode == 0)
		{
			mainModule.startLifetime = 0.5f;
			mainModule.startSpeed = 100f;
			emission.rateOverTime = 1000f;
			shapeModule.angle = 11f;
			shapeModule.rotation = new Vector3(0f, 0f, 0f);
			shapeModule.scale = new Vector3(0.1f, 1f, 1f);
		}
		if (nozzleMode == 1)
		{
			mainModule.startLifetime = 0.5f;
			mainModule.startSpeed = 100f;
			emission.rateOverTime = 1000f;
			shapeModule.angle = 11f;
			shapeModule.rotation = new Vector3(0f, 0f, 90f);
			shapeModule.scale = new Vector3(0.1f, 1f, 1f);
		}
		if (nozzleMode == 2)
		{
			mainModule.startLifetime = 1.2f;
			mainModule.startSpeed = 100f;
			emission.rateOverTime = 700f;
			shapeModule.angle = 0.75f;
			shapeModule.scale = Vector3.one;
		}
	}

	private void StartWashing()
	{
		aud.pitch = Random.Range(0.9f, 1.1f);
		aud.PlayOneShot(triggerOn);
		isSpraying = true;
		part.Play();
		aud.Play();
	}

	private void StopWashing()
	{
		isSpraying = false;
		part.Stop();
		aud.Stop();
		aud.pitch = Random.Range(0.9f, 1.1f);
		aud.PlayOneShot(triggerOff);
	}

	private void OnParticleCollision(GameObject other)
	{
		BloodAbsorberChild component2;
		if (other.TryGetComponent<BloodAbsorber>(out var component))
		{
			if (!musicStarted)
			{
				if ((bool)music)
				{
					music.SetActive(value: true);
				}
				musicStarted = true;
			}
			Vector3 position = part.transform.position;
			part.GetCollisionEvents(other, collisionEvents);
			component.ProcessWasherSpray(ref collisionEvents, position);
		}
		else if (other.TryGetComponent<BloodAbsorberChild>(out component2))
		{
			if (!musicStarted)
			{
				if ((bool)music)
				{
					music.SetActive(value: true);
				}
				musicStarted = true;
			}
			Vector3 position2 = part.transform.position;
			part.GetCollisionEvents(other, collisionEvents);
			component2.ProcessWasherSpray(ref collisionEvents, position2);
			if (other.TryGetComponent<SpinFromForce>(out var component3))
			{
				component3.AddSpin(ref collisionEvents);
			}
		}
		GameObject gameObject = other.gameObject;
		if (gameObject.layer == 12 && gameObject.TryGetComponent<EnemyIdentifier>(out var component4) && component4.enemyType == EnemyType.Streetcleaner && !component4.dead)
		{
			component4.InstaKill();
		}
	}
}



public class Water : MonoBehaviour
{
	[HideInInspector]
	public Dictionary<Rigidbody, int> rbs = new Dictionary<Rigidbody, int>();

	private HashSet<Collider> contSplashables = new HashSet<Collider>();

	private HashSet<Rigidbody> rbsToRemove = new HashSet<Rigidbody>();

	private List<Collider> colsToRemove = new List<Collider>();

	private Dictionary<Collider, int> enemiesToCheck = new Dictionary<Collider, int>();

	private HashSet<Collider> enemiesToRemove = new HashSet<Collider>();

	private HashSet<GameObject> bubblesEffects = new HashSet<GameObject>();

	private Dictionary<Rigidbody, Collider> onDisableRemove = new Dictionary<Rigidbody, Collider>();

	public GameObject bubblesParticle;

	public GameObject splash;

	public GameObject smallSplash;

	private Dictionary<Collider, GameObject> colliderToSplashMap = new Dictionary<Collider, GameObject>();

	private Collider[] colliders;

	public Color clr = new Color(0f, 0.5f, 1f);

	[HideInInspector]
	public bool inWater;

	[HideInInspector]
	public bool playerTouchingWater;

	private int waterRequests;

	public bool notWet;

	private UnderwaterController currentUwc;

	public List<Collider> enteredColliders = new List<Collider>();

	[Header("Optional, for fishing")]
	public FishDB fishDB;

	public Transform overrideFishingPoint;

	public FishObject[] attractFish;

	public bool simplifyWaterProcessing;

	private DryZoneController dzc;

	private void Start()
	{
		dzc = MonoSingleton<DryZoneController>.Instance;
		Invoke("SlowUpdate", 5f);
		colliders = GetComponentsInChildren<Collider>();
		dzc.waters.Add(this);
		if ((bool)fishDB)
		{
			fishDB.SetupWater(this);
		}
	}

	private void OnDestroy()
	{
		Shader.DisableKeyword("ISUNDERWATER");
		if (base.gameObject.scene.isLoaded)
		{
			UnderwaterController instance = MonoSingleton<UnderwaterController>.Instance;
			if ((bool)instance && inWater)
			{
				instance.OutWater();
			}
			dzc.waters.Remove(this);
		}
	}

	private void FixedUpdate()
	{
		CheckEnemies();
		RigidBodyForces();
		CleanSplashables();
		UpdateSplashes();
	}

	private void CheckEnemies()
	{
		enemiesToRemove.Clear();
		foreach (Collider key in enemiesToCheck.Keys)
		{
			if (!key || !key.attachedRigidbody)
			{
				enemiesToRemove.Add(key);
				continue;
			}
			bool flag = false;
			Vector3 position = key.transform.position;
			Bounds bounds = key.bounds;
			Vector3 min = bounds.min;
			Vector3 max = bounds.max;
			for (int i = 0; i < colliders.Length; i++)
			{
				Collider collider = colliders[i];
				if (Vector3.Distance(collider.ClosestPoint(position), position) < 1f)
				{
					Vector3 origin = new Vector3(position.x, collider.bounds.max.y + 0.1f, position.z);
					if (Physics.Raycast(origin, Vector3.down, out var hitInfo, Mathf.Abs(origin.y - min.y), 16, QueryTriggerInteraction.Collide) && max.y - (max.y - min.y) / 3f < hitInfo.point.y)
					{
						flag = true;
						break;
					}
				}
			}
			Rigidbody attachedRigidbody = key.attachedRigidbody;
			int value;
			bool flag2 = rbs.TryGetValue(attachedRigidbody, out value);
			if (flag && !flag2)
			{
				AddRigidbody(attachedRigidbody, key);
				if (attachedRigidbody.TryGetComponent<EnemyIdentifier>(out var component))
				{
					component.underwater = true;
				}
			}
			else if (!flag && flag2 && value == 1)
			{
				RemoveRigidbody(attachedRigidbody, key);
				if (attachedRigidbody.TryGetComponent<EnemyIdentifier>(out var component2))
				{
					component2.underwater = false;
				}
			}
		}
		foreach (Collider item in enemiesToRemove)
		{
			enemiesToCheck.Remove(item);
		}
	}

	private void RigidBodyForces()
	{
		rbsToRemove.Clear();
		Vector3 gravity = Physics.gravity;
		float num = gravity.y * 0.2f;
		foreach (Rigidbody key in rbs.Keys)
		{
			GameObject gameObject;
			if (!key || !(gameObject = key.gameObject).activeInHierarchy)
			{
				rbsToRemove.Add(key);
			}
			else if (key.useGravity && !key.isKinematic)
			{
				int layer = gameObject.layer;
				Vector3 velocity = key.velocity;
				if (velocity.y < num)
				{
					key.velocity = Vector3.MoveTowards(target: new Vector3(velocity.x, num, velocity.z), current: velocity, maxDistanceDelta: Time.deltaTime * 10f * Mathf.Abs(velocity.y - num + 0.5f));
				}
				else if (layer == 10 || layer == 9)
				{
					key.AddForce(gravity * (key.mass * -0.45f));
				}
				else
				{
					key.AddForce(gravity * (key.mass * -0.75f));
				}
			}
		}
		foreach (Rigidbody item in rbsToRemove)
		{
			if (!item)
			{
				rbs.Remove(item);
				continue;
			}
			Collider componentInChildren = item.GetComponentInChildren<Collider>();
			if ((bool)componentInChildren)
			{
				RemoveRigidbody(item, componentInChildren);
			}
			else
			{
				rbs.Remove(item);
			}
		}
	}

	private void CleanSplashables()
	{
		contSplashables.RemoveWhere((Collider x) => x == null);
		foreach (KeyValuePair<Collider, GameObject> item in colliderToSplashMap)
		{
			Collider key = item.Key;
			if (!contSplashables.Contains(key))
			{
				GameObject value = item.Value;
				if (value != null)
				{
					value.SendMessage("DestroySoon");
				}
				colsToRemove.Add(key);
			}
		}
		foreach (Collider item2 in colsToRemove)
		{
			colliderToSplashMap.Remove(item2);
		}
		colsToRemove.Clear();
	}

	private void UpdateSplashes()
	{
		foreach (Collider contSplashable in contSplashables)
		{
			Bounds bounds = contSplashable.bounds;
			bool didHit;
			Vector3 closestPointOnSurface = GetClosestPointOnSurface(contSplashable, out didHit);
			GameObject value2;
			if (didHit)
			{
				if (!colliderToSplashMap.TryGetValue(contSplashable, out var value))
				{
					GameObject gameObject = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.continuousSplash, closestPointOnSurface, Quaternion.LookRotation(Vector3.up));
					gameObject.transform.localScale = 3f * bounds.size.magnitude * Vector3.one;
					if (enemiesToCheck.ContainsKey(contSplashable) && gameObject.TryGetComponent<SplashContinuous>(out var component) && contSplashable.TryGetComponent<NavMeshAgent>(out var component2))
					{
						component.nma = component2;
					}
					colliderToSplashMap.Add(contSplashable, gameObject);
				}
				else
				{
					value.transform.position = closestPointOnSurface;
				}
			}
			else if (colliderToSplashMap.TryGetValue(contSplashable, out value2))
			{
				if (value2 != null)
				{
					value2.SendMessage("DestroySoon");
				}
				colsToRemove.Add(contSplashable);
			}
		}
	}

	private void SlowUpdate()
	{
		if (bubblesEffects.Count > 0)
		{
			bubblesEffects.RemoveWhere((GameObject GameObject) => GameObject == null);
		}
		if (enteredColliders.Count > 0)
		{
			enteredColliders.RemoveAll((Collider Collider) => Collider == null);
		}
		Invoke("SlowUpdate", Random.Range(0.5f, 1f));
	}

	private void OnDisable()
	{
		if (!base.gameObject.scene.isLoaded)
		{
			return;
		}
		foreach (GameObject bubblesEffect in bubblesEffects)
		{
			if ((bool)bubblesEffect)
			{
				Object.Destroy(bubblesEffect);
			}
		}
		bubblesEffects.Clear();
		onDisableRemove.Clear();
		foreach (Rigidbody key in rbs.Keys)
		{
			if (key != null)
			{
				Collider componentInChildren = key.GetComponentInChildren<Collider>();
				if ((bool)componentInChildren)
				{
					onDisableRemove.Add(key, componentInChildren);
				}
			}
		}
		rbs.Clear();
		contSplashables.Clear();
		enemiesToCheck.Clear();
		foreach (GameObject value in colliderToSplashMap.Values)
		{
			Object.Destroy(value);
		}
		colliderToSplashMap.Clear();
		if (inWater)
		{
			inWater = false;
			waterRequests = 0;
			Shader.DisableKeyword("ISUNDERWATER");
			UnderwaterController instance = MonoSingleton<UnderwaterController>.Instance;
			if (instance != null)
			{
				instance.OutWater();
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!dzc.colliderCalls.ContainsKey(other))
		{
			Enter(other);
		}
		enteredColliders.Add(other);
	}

	private void Enter(Collider other)
	{
		if (other.TryGetComponent<UnderwaterController>(out var _))
		{
			if (currentUwc != null && MonoSingleton<UnderwaterController>.Instance != currentUwc)
			{
				waterRequests = 0;
			}
			Shader.EnableKeyword("ISUNDERWATER");
			inWater = true;
			GameObject gameObject = Object.Instantiate(bubblesParticle, MonoSingleton<PlayerTracker>.Instance.GetPlayer());
			gameObject.transform.forward = Vector3.up;
			bubblesEffects.Add(gameObject);
			waterRequests++;
			MonoSingleton<UnderwaterController>.Instance.InWater(clr);
			currentUwc = MonoSingleton<UnderwaterController>.Instance;
		}
		if (other.isTrigger)
		{
			return;
		}
		Rigidbody component2 = other.GetComponent<Rigidbody>();
		if (!component2)
		{
			return;
		}
		if (other.gameObject.layer == 12 && !rbs.ContainsKey(component2))
		{
			Collider component3 = other.gameObject.GetComponent<Collider>();
			if ((bool)component3 && !enemiesToCheck.ContainsKey(component3))
			{
				enemiesToCheck.Add(component3, 1);
				contSplashables.Add(component3);
				if (component2.TryGetComponent<EnemyIdentifier>(out var component4) && !component4.touchingWaters.Contains(this))
				{
					component4.touchingWaters.Add(this);
				}
			}
			else if ((bool)component3)
			{
				enemiesToCheck[component3]++;
			}
		}
		else if (!rbs.ContainsKey(component2))
		{
			AddRigidbody(component2, other);
		}
		else
		{
			rbs[component2]++;
		}
	}

	private void AddRigidbody(Rigidbody rb, Collider other)
	{
		rbs.Add(rb, 1);
		if (rb.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			playerTouchingWater = true;
		}
		Transform transform = other.transform;
		Vector3 position = transform.position;
		GameObject gameObject = other.gameObject;
		Vector3 vector = Vector3.positiveInfinity;
		float num = float.PositiveInfinity;
		for (int i = 0; i < colliders.Length; i++)
		{
			Collider collider = colliders[i];
			Vector3 position2 = new Vector3(position.x, collider.bounds.max.y, position.z);
			Vector3 vector2 = collider.ClosestPoint(position2);
			float num2 = Vector3.Distance(vector2, position);
			if (num2 < num)
			{
				vector = vector2;
				num = num2;
			}
		}
		GameObject gameObject2 = null;
		if (Vector3.Distance(vector, other.ClosestPoint(vector)) < 1f && rb != null)
		{
			if ((rb.velocity.y < -25f || gameObject.layer == 11) && rb.mass >= 1f && gameObject.layer != 10 && gameObject.layer != 9)
			{
				gameObject2 = Object.Instantiate(splash, vector, Quaternion.LookRotation(Vector3.up));
			}
			else if (!rb.isKinematic)
			{
				gameObject2 = Object.Instantiate(smallSplash, vector, Quaternion.LookRotation(Vector3.up));
			}
			if ((bool)gameObject2)
			{
				gameObject2.transform.localScale = 3f * other.bounds.size.magnitude * Vector3.one;
			}
		}
		if (gameObject.CompareTag("Player"))
		{
			if ((bool)gameObject2)
			{
				gameObject2.GetComponent<RandomPitch>().defaultPitch = 0.45f;
			}
			contSplashables.Add(other);
			return;
		}
		if (simplifyWaterProcessing)
		{
			GameObject gameObject3 = Object.Instantiate(bubblesParticle, position, Quaternion.identity);
			gameObject3.transform.SetParent(transform, worldPositionStays: true);
			gameObject3.transform.forward = Vector3.up;
			bubblesEffects.Add(gameObject3);
		}
		BloodUnderwaterChecker component;
		AudioSource[] array = ((gameObject.layer != 0 || !gameObject.TryGetComponent<BloodUnderwaterChecker>(out component)) ? other.GetComponentsInChildren<AudioSource>() : transform.parent.GetComponentsInChildren<AudioSource>());
		AudioSource[] array2 = array;
		foreach (AudioSource audioSource in array2)
		{
			if (!audioSource.TryGetComponent<AudioLowPassFilter>(out var component2))
			{
				component2 = audioSource.gameObject.AddComponent<AudioLowPassFilter>();
			}
			component2.cutoffFrequency = 1000f;
			component2.lowpassResonanceQ = 1f;
		}
		if (notWet)
		{
			return;
		}
		Flammable[] componentsInChildren = other.GetComponentsInChildren<Flammable>();
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].PutOut();
		}
		if (gameObject.layer != 10 && gameObject.layer != 9)
		{
			if (!other.TryGetComponent<Wet>(out var component3))
			{
				gameObject.AddComponent<Wet>();
			}
			else
			{
				component3.Refill();
			}
		}
		if (gameObject.layer == 12 && gameObject.TryGetComponent<EnemyIdentifier>(out var component4) && component4.enemyType == EnemyType.Streetcleaner && !component4.dead)
		{
			component4.InstaKill();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!dzc.colliderCalls.ContainsKey(other))
		{
			Exit(other);
		}
		enteredColliders.Remove(other);
	}

	public void Exit(Collider other)
	{
		if (other.TryGetComponent<UnderwaterController>(out var _))
		{
			Shader.DisableKeyword("ISUNDERWATER");
			waterRequests--;
			if (waterRequests <= 0)
			{
				waterRequests = 0;
				inWater = false;
			}
			MonoSingleton<UnderwaterController>.Instance.OutWater();
			ParticleSystem[] componentsInChildren = other.transform.parent.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				GameObject gameObject = componentsInChildren[i].gameObject;
				if (bubblesEffects.Remove(gameObject))
				{
					Object.Destroy(gameObject);
				}
			}
		}
		Rigidbody component2 = other.GetComponent<Rigidbody>();
		if (!component2)
		{
			return;
		}
		if (other.gameObject.layer == 12)
		{
			if (!enemiesToCheck.TryGetValue(other, out var value))
			{
				return;
			}
			value--;
			enemiesToCheck[other] = value;
			if (value <= 0)
			{
				enemiesToCheck.Remove(other);
				if (component2.TryGetComponent<EnemyIdentifier>(out var component3) && component3.touchingWaters.Contains(this))
				{
					component3.touchingWaters.Remove(this);
				}
				contSplashables.Remove(other);
				if (rbs.ContainsKey(component2))
				{
					rbs[component2] = 1;
					RemoveRigidbody(component2, other);
				}
			}
		}
		else
		{
			RemoveRigidbody(component2, other);
		}
	}

	private void RemoveRigidbody(Rigidbody rb, Collider other)
	{
		if (!rbs.ContainsKey(rb))
		{
			return;
		}
		rbs[rb]--;
		if (rbs[rb] > 0)
		{
			return;
		}
		rbs.Remove(rb);
		if (rb.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			playerTouchingWater = false;
		}
		if ((bool)other)
		{
			ParticleSystem[] componentsInChildren = other.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				GameObject gameObject = componentsInChildren[i].gameObject;
				if (bubblesEffects.Remove(gameObject))
				{
					Object.Destroy(gameObject);
				}
			}
		}
		if ((bool)other && other.gameObject.CompareTag("Player"))
		{
			contSplashables.Remove(other);
			return;
		}
		Transform transform = other.transform;
		GameObject gameObject2 = other.gameObject;
		Vector3 position = transform.position;
		int layer = other.gameObject.layer;
		AudioSource[] array = null;
		if ((bool)other)
		{
			array = ((layer != 0 || !gameObject2.TryGetComponent<BloodUnderwaterChecker>(out var _)) ? other.GetComponentsInChildren<AudioSource>() : transform.parent.GetComponentsInChildren<AudioSource>());
		}
		else if ((bool)rb)
		{
			array = rb.GetComponentsInChildren<AudioSource>();
		}
		AudioSource[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			AudioLowPassFilter component2 = array2[i].GetComponent<AudioLowPassFilter>();
			if ((bool)component2)
			{
				Object.Destroy(component2);
			}
		}
		if ((bool)other)
		{
			Vector3 vector = Vector3.positiveInfinity;
			float num = float.PositiveInfinity;
			for (int j = 0; j < colliders.Length; j++)
			{
				Collider collider = colliders[j];
				Vector3 position2 = new Vector3(position.x, collider.bounds.max.y, position.z);
				Vector3 vector2 = collider.ClosestPointOnBounds(position2);
				float num2 = Vector3.Distance(vector2, position);
				if (num2 < num)
				{
					vector = vector2;
					num = num2;
				}
			}
			if (Vector3.Distance(vector, other.ClosestPoint(vector)) < 1f)
			{
				if (rb.velocity.y > 25f && rb.mass >= 1f && base.gameObject.layer != 10)
				{
					Object.Instantiate(splash, vector + Vector3.up * 0.5f, Quaternion.LookRotation(Vector3.up));
				}
				else if (rb.velocity.y > 10f)
				{
					Object.Instantiate(smallSplash, vector + Vector3.up * 0.5f, Quaternion.LookRotation(Vector3.up));
				}
			}
			if (layer != 10 && layer != 9 && !notWet)
			{
				Wet component3 = other.GetComponent<Wet>();
				if (!component3)
				{
					gameObject2.AddComponent<Wet>();
				}
				else
				{
					component3.Dry();
				}
			}
		}
		else
		{
			if (!rb || notWet)
			{
				return;
			}
			GameObject gameObject3 = rb.gameObject;
			if (gameObject3.layer != 10 && gameObject3.layer != 9)
			{
				Wet component4 = rb.GetComponent<Wet>();
				if (!component4)
				{
					gameObject3.AddComponent<Wet>();
				}
				else
				{
					component4.Dry();
				}
			}
		}
	}

	public void EnterDryZone(Collider other)
	{
		if (enteredColliders.Contains(other))
		{
			Exit(other);
		}
	}

	public void ExitDryZone(Collider other)
	{
		if (enteredColliders.Contains(other))
		{
			Enter(other);
		}
	}

	public void UpdateColor(Color newColor)
	{
		clr = newColor;
		if (inWater)
		{
			MonoSingleton<UnderwaterController>.Instance.UpdateColor(newColor);
		}
	}

	private Vector3 GetClosestPointOnSurface(Collider target, out bool didHit)
	{
		didHit = false;
		_ = target.bounds;
		float y = target.bounds.min.y;
		float y2 = target.bounds.max.y;
		Vector3 position = target.transform.position;
		for (int i = 0; i < colliders.Length; i++)
		{
			Collider collider = colliders[i];
			if (Vector3.Distance(collider.ClosestPoint(position), position) < 1f)
			{
				Vector3 origin = position;
				origin.y = collider.bounds.max.y + 0.1f;
				if (y2 >= origin.y && Physics.Raycast(origin, Vector3.down, out var hitInfo, Mathf.Abs(origin.y - y), 16, QueryTriggerInteraction.Collide))
				{
					didHit = true;
					return hitInfo.point;
				}
			}
		}
		return Vector3.one * 9999f;
	}
}



public class WaterDryTracker
{
	public Transform transform;

	public Vector3 closestPosition;

	public WaterDryTracker(Transform tf, Vector3 clopo)
	{
		transform = tf;
		closestPosition = clopo;
	}
}



public class WaveMenu : MonoBehaviour
{
	[HideInInspector]
	public List<WaveSetter> setters = new List<WaveSetter>();

	private int highestWave = -1;

	private int currentWave;

	private void Start()
	{
		if (highestWave < 0)
		{
			GetHighestWave();
		}
	}

	public ButtonState CheckWaveAvailability(WaveSetter ws)
	{
		if (highestWave < 0)
		{
			GetHighestWave();
		}
		if (!setters.Contains(ws))
		{
			setters.Add(ws);
		}
		if (ws.wave == currentWave)
		{
			return ButtonState.Selected;
		}
		if (highestWave >= ws.wave * 2)
		{
			return ButtonState.Unselected;
		}
		return ButtonState.Locked;
	}

	private void GetHighestWave()
	{
		int @int = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		CyberRankData bestCyber = GameProgressSaver.GetBestCyber();
		if (bestCyber != null && bestCyber.preciseWavesByDifficulty.Length > @int)
		{
			highestWave = Mathf.FloorToInt(bestCyber.preciseWavesByDifficulty[@int]);
			int int2 = MonoSingleton<PrefsManager>.Instance.GetInt("cyberGrind.startingWave");
			if (highestWave >= int2 * 2)
			{
				currentWave = int2;
			}
			else
			{
				currentWave = 0;
			}
			MonoSingleton<EndlessGrid>.Instance.startWave = currentWave;
		}
	}

	public void SetCurrentWave(int wave)
	{
		if (wave * 2 > highestWave)
		{
			return;
		}
		currentWave = wave;
		MonoSingleton<EndlessGrid>.Instance.startWave = currentWave;
		MonoSingleton<PrefsManager>.Instance.SetInt("cyberGrind.startingWave", wave);
		foreach (WaveSetter setter in setters)
		{
			if (setter.wave != currentWave)
			{
				setter.Unselected();
			}
		}
	}
}



public class WaveSetter : MonoBehaviour
{
	public int wave;

	private WaveMenu wm;

	private ButtonState state;

	private ControllerPointer pointer;

	private bool prepared;

	[SerializeField]
	private GameObject buttonFail;

	[SerializeField]
	private GameObject buttonSuccess;

	[SerializeField]
	private Image buttonGraphic;

	[SerializeField]
	private TMP_Text buttonText;

	private void Awake()
	{
		if (!TryGetComponent<ControllerPointer>(out pointer))
		{
			pointer = base.gameObject.AddComponent<ControllerPointer>();
		}
		pointer.OnPressed.AddListener(OnPointerClick);
	}

	private void Start()
	{
		if (!prepared)
		{
			Prepare();
		}
	}

	private void OnPointerClick()
	{
		if (!prepared)
		{
			Prepare();
		}
		if (state == ButtonState.Locked)
		{
			Object.Instantiate(buttonFail);
			return;
		}
		Object.Instantiate(buttonSuccess);
		wm.SetCurrentWave(wave);
		Selected();
	}

	public void Selected()
	{
		if (state != ButtonState.Locked)
		{
			buttonGraphic.color = Color.white;
			buttonGraphic.fillCenter = true;
			buttonText.color = Color.black;
		}
	}

	public void Unselected()
	{
		if (state != ButtonState.Locked)
		{
			buttonGraphic.color = Color.white;
			buttonGraphic.fillCenter = false;
			buttonText.color = Color.white;
		}
	}

	public void Locked()
	{
		buttonGraphic.color = Color.red;
		buttonGraphic.fillCenter = false;
		buttonText.color = Color.red;
	}

	private void Prepare()
	{
		wm = GetComponentInParent<WaveMenu>();
		if (wave == 0)
		{
			buttonText.text = "1";
		}
		else
		{
			buttonText.text = wave.ToString();
		}
		if ((bool)wm)
		{
			prepared = true;
			state = wm.CheckWaveAvailability(this);
			if (state == ButtonState.Selected)
			{
				Selected();
			}
			else if (state == ButtonState.Locked)
			{
				Locked();
			}
		}
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class WeaponCharges : MonoSingleton<WeaponCharges>
{
	private GunControl gc;

	public float rev0charge = 100f;

	public bool rev0alt;

	public float rev1charge = 400f;

	public float rev2charge = 300f;

	public bool rev2alt;

	public float shoAltNadeCharge = 1f;

	public float shoSawCharge = 1f;

	public int shoSawAmount;

	[HideInInspector]
	public bool nai0set;

	public float naiHeatsinks = 2f;

	public float naiSawHeatsinks = 1f;

	public float naiheatUp;

	public float naiAmmo = 100f;

	public float naiSaws = 10f;

	public bool naiAmmoDontCharge;

	[HideInInspector]
	public List<Magnet> magnets = new List<Magnet>();

	public float naiMagnetCharge = 3f;

	public float naiZapperRecharge = 5f;

	public float raicharge = 5f;

	public GameObject railCannonFullChargeSound;

	public bool railChargePlayed;

	[HideInInspector]
	public bool rocketset;

	public float rocketcharge;

	[HideInInspector]
	public bool rocketFrozen;

	public float rocketFreezeTime = 5f;

	[HideInInspector]
	public RocketLauncher rocketLauncher;

	public int rocketCount;

	[HideInInspector]
	public bool canAutoUnfreeze;

	public TimeSince timeSinceIdleFrozen;

	public float rocketCannonballCharge = 1f;

	public float rocketNapalmFuel = 1f;

	[HideInInspector]
	public bool infiniteRocketRide;

	public float[] revaltpickupcharges = new float[3];

	public float[] shoaltcooldowns = new float[3];

	private void Update()
	{
		if (NoWeaponCooldown.NoCooldown)
		{
			MaxCharges();
		}
		else
		{
			Charge(Time.deltaTime);
		}
		if (rocketFrozen)
		{
			if (rocketCount > 0)
			{
				canAutoUnfreeze = true;
			}
			if (canAutoUnfreeze && rocketCount == 0 && (float)timeSinceIdleFrozen > 0.5f)
			{
				rocketLauncher.UnfreezeRockets();
			}
		}
	}

	public void Charge(float amount)
	{
		if (rev0charge < 100f)
		{
			if (rev0alt)
			{
				rev0charge = Mathf.MoveTowards(rev0charge, 100f, 20f * amount);
			}
			else
			{
				rev0charge = Mathf.MoveTowards(rev0charge, 100f, 40f * amount);
			}
		}
		if (rev1charge < 400f)
		{
			rev1charge = Mathf.MoveTowards(rev1charge, 400f, 25f * amount);
		}
		if (rev2charge < 300f)
		{
			if (rev2alt)
			{
				rev2charge = Mathf.MoveTowards(rev2charge, 300f, 35f * amount);
			}
			else
			{
				rev2charge = Mathf.MoveTowards(rev2charge, 300f, 15f * amount);
			}
		}
		if (shoAltNadeCharge < 1f)
		{
			shoAltNadeCharge = Mathf.MoveTowards(shoAltNadeCharge, 1f, amount * 0.5f);
		}
		if (shoSawCharge < 1f)
		{
			shoSawCharge = Mathf.MoveTowards(shoSawCharge, 1f, amount * ((shoSawAmount == 0) ? 0.25f : 0.125f));
		}
		if (naiHeatsinks < 2f)
		{
			naiHeatsinks = Mathf.MoveTowards(naiHeatsinks, 2f, amount * 0.125f);
		}
		if (naiSawHeatsinks < 1f)
		{
			naiSawHeatsinks = Mathf.MoveTowards(naiSawHeatsinks, 1f, amount * 0.125f);
		}
		if (naiheatUp > 0f)
		{
			naiheatUp = Mathf.MoveTowards(naiheatUp, 0f, amount * 0.3f);
		}
		if (naiZapperRecharge < 5f)
		{
			naiZapperRecharge = Mathf.MoveTowards(naiZapperRecharge, 5f, amount);
		}
		if (raicharge < 5f)
		{
			raicharge = Mathf.MoveTowards(raicharge, 5f, amount * 0.25f);
			if (raicharge >= 4f && (bool)railCannonFullChargeSound)
			{
				raicharge = 5f;
				PlayRailCharge();
			}
		}
		if (rocketcharge > 0f)
		{
			rocketcharge = Mathf.MoveTowards(rocketcharge, 0f, amount);
		}
		if (rocketCannonballCharge < 1f)
		{
			rocketCannonballCharge = Mathf.MoveTowards(rocketCannonballCharge, 1f, amount * 0.125f);
		}
		if (rocketNapalmFuel < 1f)
		{
			rocketNapalmFuel = Mathf.MoveTowards(rocketNapalmFuel, 1f, amount * 0.125f);
		}
		for (int i = 0; i < revaltpickupcharges.Length; i++)
		{
			if (revaltpickupcharges[i] > 0f)
			{
				revaltpickupcharges[i] = Mathf.MoveTowards(revaltpickupcharges[i], 0f, amount);
			}
		}
		for (int j = 0; j < shoaltcooldowns.Length; j++)
		{
			if (shoaltcooldowns[j] > 0f)
			{
				shoaltcooldowns[j] = Mathf.MoveTowards(shoaltcooldowns[j], 0f, amount);
			}
		}
		if (!naiAmmoDontCharge)
		{
			naiAmmo = Mathf.MoveTowards(naiAmmo, 100f, amount * 5f);
			naiSaws = Mathf.MoveTowards(naiSaws, 10f, amount * 0.5f);
		}
		if (magnets.Count > 0)
		{
			for (int num = magnets.Count - 1; num >= 0; num--)
			{
				if (magnets[num] == null)
				{
					magnets.RemoveAt(num);
				}
			}
			if (magnets.Count < 3 && naiMagnetCharge < (float)(3 - magnets.Count))
			{
				naiMagnetCharge = Mathf.MoveTowards(naiMagnetCharge, 3 - magnets.Count, amount * 3f);
			}
		}
		else if (naiMagnetCharge < 3f)
		{
			naiMagnetCharge = Mathf.MoveTowards(naiMagnetCharge, 3f, amount * 3f);
		}
		rocketFreezeTime = Mathf.MoveTowards(rocketFreezeTime, (!rocketFrozen) ? 5 : 0, rocketFrozen ? Time.deltaTime : (amount / 2f));
		if (rocketFrozen && (bool)rocketLauncher && (bool)rocketLauncher.currentTimerTickSound)
		{
			rocketLauncher.currentTimerTickSound.pitch = Mathf.Lerp(0.75f, 1f, rocketFreezeTime / 5f);
		}
		if (rocketFrozen && rocketFreezeTime <= 0f)
		{
			rocketLauncher.UnfreezeRockets();
		}
	}

	public void MaxCharges()
	{
		rev0charge = 100f;
		rev1charge = 400f;
		rev2charge = 300f;
		shoAltNadeCharge = 1f;
		shoSawCharge = 1f;
		naiHeatsinks = 2f;
		naiSawHeatsinks = 1f;
		naiheatUp = 0f;
		rocketcharge = 0f;
		for (int i = 0; i < revaltpickupcharges.Length; i++)
		{
			revaltpickupcharges[i] = 0f;
		}
		for (int j = 0; j < shoaltcooldowns.Length; j++)
		{
			shoaltcooldowns[j] = 0f;
		}
		naiAmmo = 100f;
		naiSaws = 10f;
		magnets.Clear();
		naiMagnetCharge = 3f;
		naiZapperRecharge = 5f;
		if (raicharge < 5f)
		{
			raicharge = 5f;
			PlayRailCharge();
		}
		rocketFreezeTime = 5f;
		rocketCannonballCharge = 1f;
		rocketNapalmFuel = 1f;
		if (!gc)
		{
			gc = GetComponent<GunControl>();
		}
		if ((bool)gc && (bool)gc.currentWeapon)
		{
			gc.currentWeapon.SendMessage("MaxCharge", SendMessageOptions.DontRequireReceiver);
		}
	}

	public void PlayRailCharge()
	{
		railChargePlayed = true;
		Object.Instantiate(railCannonFullChargeSound);
	}
}



[CreateAssetMenu(fileName = "Weapon Descriptor", menuName = "ULTRAKILL/Weapon Descriptor")]
public class WeaponDescriptor : ScriptableObject
{
	public string weaponName;

	[FormerlySerializedAs("weaponIcon")]
	public Sprite icon;

	public Sprite glowIcon;

	public WeaponVariant variationColor;
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class WeaponHUD : MonoSingleton<WeaponHUD>
{
	private Image img;

	private Image glowImg;

	protected override void Awake()
	{
		base.Awake();
		WeaponIcon weaponIcon = Object.FindObjectOfType<WeaponIcon>();
		if ((bool)weaponIcon)
		{
			weaponIcon.UpdateIcon();
		}
	}

	public void UpdateImage(Sprite icon, Sprite glowIcon, int variation)
	{
		if (img == null)
		{
			img = GetComponent<Image>();
		}
		if (glowImg == null)
		{
			glowImg = base.transform.GetChild(0).GetComponent<Image>();
		}
		img.sprite = icon;
		img.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation];
		glowImg.sprite = glowIcon;
		glowImg.color = MonoSingleton<ColorBlindSettings>.Instance.variationColors[variation];
	}
}



public class WeaponIcon : MonoBehaviour
{
	[FormerlySerializedAs("descriptor")]
	public WeaponDescriptor weaponDescriptor;

	[SerializeField]
	private Renderer[] variationColoredRenderers;

	[SerializeField]
	private Image[] variationColoredImages;

	private int variationColor
	{
		get
		{
			if (!(weaponDescriptor == null))
			{
				return (int)weaponDescriptor.variationColor;
			}
			return -1;
		}
	}

	private void Start()
	{
		UpdateIcon();
	}

	private void OnEnable()
	{
		MonoSingleton<GunControl>.Instance.currentWeaponIcons.Add(this);
		UpdateIcon();
	}

	private void OnDisable()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<GunControl>.Instance.currentWeaponIcons.Remove(this);
		}
	}

	private void OnDestroy()
	{
		if (base.gameObject.scene.isLoaded)
		{
			MonoSingleton<GunControl>.Instance.currentWeaponIcons.Remove(this);
		}
	}

	public void UpdateIcon()
	{
		if ((bool)MonoSingleton<WeaponHUD>.Instance)
		{
			MonoSingleton<WeaponHUD>.Instance.UpdateImage(weaponDescriptor.icon, weaponDescriptor.glowIcon, variationColor);
		}
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		Renderer[] array = variationColoredRenderers;
		foreach (Renderer obj in array)
		{
			obj.GetPropertyBlock(materialPropertyBlock);
			if (obj.sharedMaterial.HasProperty("_EmissiveColor"))
			{
				materialPropertyBlock.SetColor("_EmissiveColor", MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationColor]);
			}
			else
			{
				materialPropertyBlock.SetColor("_Color", MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationColor]);
			}
			obj.SetPropertyBlock(materialPropertyBlock);
		}
		Image[] array2 = variationColoredImages;
		foreach (Image image in array2)
		{
			image.color = new Color(MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationColor].r, MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationColor].g, MonoSingleton<ColorBlindSettings>.Instance.variationColors[variationColor].b, image.color.a);
		}
	}
}



public class WeaponIdentifier : MonoBehaviour
{
	public float delay;

	public float speedMultiplier;

	public bool duplicate;

	public Vector3 duplicateOffset;

	private void Start()
	{
		if (speedMultiplier == 0f)
		{
			speedMultiplier = 1f;
		}
	}
}



public class WeaponOrderController : MonoBehaviour
{
	private TMP_Text text;

	public int variationNumber;

	public string variationName;

	private string variationOrder;

	private int currentOrderNumber;

	public bool revolver;

	private void Start()
	{
		ResetValues();
	}

	private void OnEnable()
	{
		ResetValues();
	}

	public void ChangeOrderNumber(int additive)
	{
		int num = currentOrderNumber + additive;
		if (num <= 0 || num >= 4)
		{
			return;
		}
		for (int i = 0; i < variationOrder.Length; i++)
		{
			if (variationOrder[i] - 48 == num)
			{
				variationOrder = variationOrder.Replace(variationOrder[i], variationOrder[variationNumber]);
			}
		}
		variationOrder = variationOrder.Remove(variationNumber, 1);
		variationOrder = variationOrder.Insert(variationNumber, num.ToString());
		MonoSingleton<PrefsManager>.Instance.SetString("weapon." + variationName + ".order", variationOrder);
		WeaponOrderController[] componentsInChildren = base.transform.parent.parent.parent.GetComponentsInChildren<WeaponOrderController>();
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].ResetValues();
		}
		Object.FindObjectOfType<GunSetter>()?.ResetWeapons();
	}

	public void ResetValues()
	{
		if (!text)
		{
			text = GetComponentInChildren<TMP_Text>();
		}
		if (revolver)
		{
			variationOrder = MonoSingleton<PrefsManager>.Instance.GetString("weapon." + variationName + ".order", "1324");
		}
		else
		{
			variationOrder = MonoSingleton<PrefsManager>.Instance.GetString("weapon." + variationName + ".order", "1234");
		}
		currentOrderNumber = variationOrder[variationNumber] - 48;
		text.text = variationOrder[variationNumber].ToString() ?? "";
		Debug.Log("Order in WeaponOrderController: " + variationOrder);
	}
}



public class WeaponPickUp : MonoBehaviour
{
	public GameObject weapon;

	public int inventorySlot;

	private int tempSlot;

	public GunSetter gs;

	public string pPref;

	public bool arm;

	public GameObject activateOnPickup;

	private bool activated;

	private void Awake()
	{
		tempSlot = inventorySlot;
		if (!arm)
		{
			tempSlot--;
		}
	}

	private void OnDisable()
	{
		Debug.Log("Deactivated!");
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag("Player") && !activated)
		{
			GotActivated();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player") && !activated)
		{
			GotActivated();
		}
	}

	private void GotActivated()
	{
		activated = true;
		bool flag = false;
		if (pPref != "")
		{
			flag = GameProgressSaver.CheckGear(pPref) != 0 && MonoSingleton<PrefsManager>.Instance.GetInt("weapon." + pPref) != 0;
			if (!flag)
			{
				MonoSingleton<PrefsManager>.Instance.SetInt("weapon." + pPref, 1);
				if (!SceneHelper.IsPlayingCustom)
				{
					GameProgressSaver.AddGear(pPref);
				}
			}
		}
		if (!arm)
		{
			MonoSingleton<GunControl>.Instance.noWeapons = false;
			if (gs != null)
			{
				gs.enabled = true;
				gs.ResetWeapons();
			}
			if (!flag)
			{
				for (int i = 0; i < MonoSingleton<GunControl>.Instance.slots[tempSlot].Count; i++)
				{
					if (MonoSingleton<GunControl>.Instance.slots[tempSlot][i].name == weapon.name + "(Clone)")
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				GameObject item = Object.Instantiate(weapon, MonoSingleton<GunControl>.Instance.transform);
				MonoSingleton<GunControl>.Instance.slots[tempSlot].Add(item);
				MonoSingleton<GunControl>.Instance.ForceWeapon(weapon);
				MonoSingleton<GunControl>.Instance.noWeapons = false;
				MonoSingleton<GunControl>.Instance.UpdateWeaponList();
			}
			else if (SceneHelper.IsPlayingCustom)
			{
				for (int j = 0; j < MonoSingleton<GunControl>.Instance.slots[tempSlot].Count; j++)
				{
					if (MonoSingleton<GunControl>.Instance.slots[tempSlot][j].name == weapon.name + "(Clone)")
					{
						MonoSingleton<GunControl>.Instance.ForceWeapon(weapon);
						MonoSingleton<GunControl>.Instance.noWeapons = false;
						MonoSingleton<GunControl>.Instance.UpdateWeaponList();
					}
				}
			}
		}
		else
		{
			MonoSingleton<HookArm>.Instance?.Cancel();
			MonoSingleton<FistControl>.Instance.ResetFists();
			MonoSingleton<FistControl>.Instance.ForceArm(tempSlot, animation: true);
		}
		if (activateOnPickup != null)
		{
			activateOnPickup.SetActive(value: true);
		}
		base.gameObject.SetActive(value: false);
	}
}



public class WeaponPos : MonoBehaviour
{
	private bool ready;

	public Vector3 currentDefault;

	private Vector3 defaultPos;

	private Vector3 defaultRot;

	private Vector3 defaultScale;

	public Vector3 middlePos;

	public Vector3 middleRot;

	public Vector3 middleScale;

	public Transform[] moveOnMiddlePos;

	public Vector3[] middlePosValues;

	private List<Vector3> defaultPosValues = new List<Vector3>();

	public Vector3[] middleRotValues;

	private List<Vector3> defaultRotValues = new List<Vector3>();

	private void Start()
	{
		CheckPosition();
	}

	private void OnEnable()
	{
		CheckPosition();
	}

	public void CheckPosition()
	{
		if (!ready)
		{
			ready = true;
			defaultPos = base.transform.localPosition;
			defaultRot = base.transform.localRotation.eulerAngles;
			defaultScale = base.transform.localScale;
			if (middleScale == Vector3.zero)
			{
				middleScale = defaultScale;
			}
			if (middleRot == Vector3.zero)
			{
				middleRot = defaultRot;
			}
			if (moveOnMiddlePos != null && moveOnMiddlePos.Length != 0)
			{
				for (int i = 0; i < moveOnMiddlePos.Length; i++)
				{
					defaultPosValues.Add(moveOnMiddlePos[i].localPosition);
					defaultRotValues.Add(moveOnMiddlePos[i].localEulerAngles);
					if (middleRotValues[i] == Vector3.zero)
					{
						middleRotValues[i] = moveOnMiddlePos[i].localEulerAngles;
					}
				}
			}
		}
		if (MonoSingleton<PrefsManager>.Instance.GetInt("weaponHoldPosition") == 1 && (!MonoSingleton<PowerUpMeter>.Instance || MonoSingleton<PowerUpMeter>.Instance.juice <= 0f))
		{
			base.transform.localPosition = middlePos;
			base.transform.localRotation = Quaternion.Euler(middleRot);
			base.transform.localScale = middleScale;
			if (moveOnMiddlePos != null && moveOnMiddlePos.Length != 0)
			{
				for (int j = 0; j < moveOnMiddlePos.Length; j++)
				{
					moveOnMiddlePos[j].localPosition = middlePosValues[j];
					moveOnMiddlePos[j].localEulerAngles = middleRotValues[j];
				}
			}
		}
		else
		{
			base.transform.localPosition = defaultPos;
			base.transform.localRotation = Quaternion.Euler(defaultRot);
			base.transform.localScale = defaultScale;
			if (moveOnMiddlePos != null && moveOnMiddlePos.Length != 0)
			{
				for (int k = 0; k < moveOnMiddlePos.Length; k++)
				{
					moveOnMiddlePos[k].localPosition = defaultPosValues[k];
					moveOnMiddlePos[k].localEulerAngles = defaultRotValues[k];
				}
			}
		}
		currentDefault = base.transform.localPosition;
	}
}



public class WeaponStalenessLocker : MonoBehaviour
{
	public LockerType type;

	public int slot;

	public float minValue;

	public float maxValue;

	public StyleFreshnessState minState;

	public StyleFreshnessState maxState;

	public bool oneTime;

	private bool beenActivated;

	private bool colliderless;

	private void Start()
	{
		if (GetComponent<Collider>() == null && GetComponent<Rigidbody>() == null)
		{
			colliderless = true;
			Activate();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == MonoSingleton<NewMovement>.Instance.gameObject)
		{
			Activate();
		}
	}

	public void Activate()
	{
		if (!beenActivated || !oneTime)
		{
			beenActivated = true;
			switch (type)
			{
			case LockerType.Unlocker:
				MonoSingleton<StyleHUD>.Instance.UnlockFreshness(slot);
				break;
			case LockerType.State:
				MonoSingleton<StyleHUD>.Instance.LockFreshness(slot, minState, maxState);
				break;
			case LockerType.Value:
				MonoSingleton<StyleHUD>.Instance.LockFreshness(slot, minValue, maxValue);
				break;
			}
		}
	}
}



public class WeaponStateZone : MonoBehaviour
{
	public bool allowWeaponsOnEnter;

	public bool allowWeaponsOnExit = true;

	public bool allowArmOnEnter = true;

	public bool allowArmOnExit = true;

	private GunControl gc;

	private void OnTriggerEnter(Collider other)
	{
		if (!other.gameObject.CompareTag("Player"))
		{
			return;
		}
		gc = MonoSingleton<GunControl>.Instance;
		if (gc == null)
		{
			gc = other.GetComponentInChildren<GunControl>();
		}
		if ((bool)gc)
		{
			if (allowWeaponsOnEnter)
			{
				gc.YesWeapon();
			}
			else
			{
				gc.NoWeapon();
			}
			FistControl instance = MonoSingleton<FistControl>.Instance;
			if (allowArmOnEnter)
			{
				instance.YesFist();
			}
			else
			{
				instance.NoFist();
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!other.gameObject.CompareTag("Player"))
		{
			return;
		}
		if (gc == null)
		{
			gc = other.GetComponentInChildren<GunControl>();
		}
		if ((bool)gc)
		{
			if (allowWeaponsOnExit)
			{
				gc.YesWeapon();
			}
			else
			{
				gc.NoWeapon();
			}
			FistControl instance = MonoSingleton<FistControl>.Instance;
			if (allowArmOnExit)
			{
				instance.YesFist();
			}
			else
			{
				instance.NoFist();
			}
		}
	}
}



public class WeaponTrail : MonoBehaviour
{
	private GameObject trailTemplate;

	private GameObject currentTrail;

	private void Awake()
	{
		if (!trailTemplate)
		{
			trailTemplate = base.transform.GetChild(0).gameObject;
			trailTemplate.SetActive(value: false);
		}
	}

	public void AddTrail()
	{
		if (!trailTemplate)
		{
			trailTemplate = base.transform.GetChild(0).gameObject;
			trailTemplate.SetActive(value: false);
		}
		if (!currentTrail)
		{
			currentTrail = Object.Instantiate(trailTemplate, base.transform);
			currentTrail.SetActive(value: true);
		}
	}

	public void RemoveTrail()
	{
		if ((bool)currentTrail)
		{
			currentTrail.AddComponent<RemoveOnTime>().time = 5f;
			currentTrail.transform.parent = null;
			currentTrail = null;
		}
	}
}


public enum WeaponVariant
{
	BlueVariant,
	GreenVariant,
	RedVariant,
	GoldVariant
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class WeaponWheel : MonoSingleton<WeaponWheel>
{
	private List<WheelSegment> segments;

	public int segmentCount;

	public GameObject clickSound;

	public GameObject background;

	private int selectedSegment;

	private int lastSelectedSegment;

	private Vector2 direction;

	private void Start()
	{
		base.gameObject.SetActive(value: false);
		background.SetActive(value: true);
	}

	private new void OnEnable()
	{
		if (!(MonoSingleton<InputManager>.Instance == null))
		{
			Time.timeScale = 0.25f;
			MonoSingleton<TimeController>.Instance.timeScaleModifier = 0.25f;
			selectedSegment = -1;
			direction = Vector2.zero;
			GameStateManager.Instance.RegisterState(new GameState("weapon-wheel", base.gameObject)
			{
				timerModifier = 4f,
				cameraInputLock = LockMode.Lock
			});
		}
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<TimeController>.Instance)
		{
			MonoSingleton<TimeController>.Instance.timeScaleModifier = 1f;
			MonoSingleton<TimeController>.Instance.RestoreTime();
		}
		if ((bool)MonoSingleton<FistControl>.Instance)
		{
			MonoSingleton<FistControl>.Instance.RefreshArm();
		}
	}

	private void Update()
	{
		if (!MonoSingleton<GunControl>.Instance || !MonoSingleton<GunControl>.Instance.activated || MonoSingleton<OptionsManager>.Instance.paused || MonoSingleton<NewMovement>.Instance.dead || GameStateManager.Instance.PlayerInputLocked)
		{
			base.gameObject.SetActive(value: false);
		}
		else if (MonoSingleton<InputManager>.Instance.InputSource.NextWeapon.WasCanceledThisFrame || MonoSingleton<InputManager>.Instance.InputSource.PrevWeapon.WasCanceledThisFrame || MonoSingleton<InputManager>.Instance.InputSource.LastWeapon.WasCanceledThisFrame || MonoSingleton<InputManager>.Instance.InputSource.PreviousVariation.WasCanceledThisFrame)
		{
			if (selectedSegment != -1)
			{
				int target = segments[selectedSegment].slotIndex + 1;
				MonoSingleton<GunControl>.Instance.SwitchWeapon(target);
			}
			base.gameObject.SetActive(value: false);
		}
		else
		{
			if (segments == null || segments.Count == 0)
			{
				return;
			}
			direction = Vector2.ClampMagnitude(direction + MonoSingleton<InputManager>.Instance.InputSource.WheelLook.ReadValue<Vector2>(), 1f);
			float num = Mathf.Repeat(Mathf.Atan2(direction.x, direction.y) * 57.29578f + 90f, 360f);
			if (Mathf.Approximately(num, 360f))
			{
				num = 0f;
			}
			selectedSegment = ((direction.sqrMagnitude > 0f) ? ((int)(num / (360f / (float)segmentCount))) : selectedSegment);
			for (int i = 0; i < segments.Count; i++)
			{
				if (i == selectedSegment)
				{
					segments[i].SetActive(active: true);
				}
				else
				{
					segments[i].SetActive(active: false);
				}
			}
			if (selectedSegment != lastSelectedSegment)
			{
				UnityEngine.Object.Instantiate(clickSound);
				lastSelectedSegment = selectedSegment;
				if ((bool)MonoSingleton<RumbleManager>.Instance)
				{
					MonoSingleton<RumbleManager>.Instance.SetVibration(RumbleProperties.WeaponWheelTick);
				}
			}
		}
	}

	public void Show()
	{
		if (!base.gameObject.activeSelf)
		{
			lastSelectedSegment = -1;
			base.gameObject.SetActive(value: true);
		}
	}

	public void SetSegments(WeaponDescriptor[] weaponDescriptors, int[] slotIndexes)
	{
		int num = weaponDescriptors.Length;
		if (num == segmentCount)
		{
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (!(segments[i].descriptor == weaponDescriptors[i]) || segments[i].slotIndex != slotIndexes[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		segmentCount = num;
		lastSelectedSegment = -1;
		if (segments == null)
		{
			segments = new List<WheelSegment>(segmentCount);
		}
		foreach (WheelSegment segment in segments)
		{
			segment.DestroySegment();
		}
		segments.Clear();
		for (int j = 0; j < segmentCount; j++)
		{
			UICircle uICircle = new GameObject().AddComponent<UICircle>();
			uICircle.name = "Segment " + j;
			uICircle.Arc = 1f / (float)segmentCount - 0.005f;
			uICircle.ArcRotation = (int)(360f * ((float)j / (float)segmentCount) + 1.8f);
			uICircle.Fill = false;
			uICircle.transform.SetParent(base.transform, worldPositionStays: false);
			uICircle.rectTransform.anchorMin = Vector2.zero;
			uICircle.rectTransform.anchorMax = Vector2.one;
			uICircle.rectTransform.anchoredPosition = Vector2.zero;
			uICircle.rectTransform.sizeDelta = Vector2.zero;
			Outline outline = uICircle.gameObject.AddComponent<Outline>();
			outline.effectDistance = new Vector2(2f, -2f);
			outline.effectColor = Color.white;
			UICircle uICircle2 = new GameObject().AddComponent<UICircle>();
			uICircle2.name = "Segment Divider " + j;
			uICircle2.Arc = 0.005f;
			uICircle2.ArcRotation = (int)(360f * ((float)j / (float)segmentCount) + 1.8f - 0.9f);
			uICircle2.Fill = false;
			uICircle2.transform.SetParent(base.transform, worldPositionStays: false);
			uICircle2.rectTransform.anchorMin = Vector2.zero;
			uICircle2.rectTransform.anchorMax = Vector2.one;
			uICircle2.rectTransform.sizeDelta = new Vector2(256f, 256f);
			uICircle2.Thickness = 128f;
			Image image = new GameObject().AddComponent<Image>();
			image.name = "Icon " + j;
			image.sprite = weaponDescriptors[j].icon;
			image.transform.SetParent(uICircle.transform, worldPositionStays: false);
			float num2 = (float)j * 360f / (float)segmentCount;
			float num3 = uICircle.Arc * 360f / 2f;
			float num4 = num2 + num3;
			float f = num4 * ((float)Math.PI / 180f);
			float num5 = 112f;
			Vector2 vector = new Vector2(0f - Mathf.Cos(f), Mathf.Sin(f)) * num5;
			image.transform.localPosition = vector;
			float num6 = num4 + 180f;
			image.transform.localRotation = Quaternion.Euler(0f, 0f, 0f - num6);
			Vector2 size = image.sprite.rect.size;
			image.rectTransform.sizeDelta = new Vector2(size.x, size.y) * 0.12f;
			Image image2 = new GameObject().AddComponent<Image>();
			image2.name = "Icon Outline " + j;
			image2.sprite = weaponDescriptors[j].glowIcon;
			image2.transform.SetParent(uICircle.transform, worldPositionStays: false);
			image2.transform.localPosition = image.transform.localPosition;
			image2.transform.localRotation = image.transform.localRotation;
			image2.rectTransform.sizeDelta = image.rectTransform.sizeDelta;
			image2.transform.SetAsFirstSibling();
			WheelSegment wheelSegment = new WheelSegment
			{
				segment = uICircle,
				icon = image,
				iconGlow = image2,
				descriptor = weaponDescriptors[j],
				divider = uICircle2,
				slotIndex = slotIndexes[j]
			};
			segments.Add(wheelSegment);
			wheelSegment.SetActive(active: false);
		}
	}
}



public class WebButton : MonoBehaviour
{
	public string url;

	public void OpenURL()
	{
		if (!SceneHelper.IsPlayingCustom)
		{
			Application.OpenURL(url);
		}
	}
}



public class Wet : MonoBehaviour
{
	private GameObject currentWetEffect;

	public float wetness;

	private bool drying;

	private void Start()
	{
		wetness = 5f;
	}

	private void Update()
	{
		if (!drying)
		{
			return;
		}
		if (wetness > 0f)
		{
			wetness = Mathf.MoveTowards(wetness, 0f, Time.deltaTime);
			return;
		}
		Flammable[] componentsInChildren = GetComponentsInChildren<Flammable>();
		if (componentsInChildren != null)
		{
			Flammable[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].wet = false;
			}
		}
		Object.Destroy(this);
	}

	public void Dry()
	{
		drying = true;
		if (MonoSingleton<DefaultReferenceManager>.Instance != null)
		{
			currentWetEffect = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.wetParticle, base.transform.position, Quaternion.identity);
			currentWetEffect.transform.SetParent(base.transform, worldPositionStays: true);
		}
	}

	public void Refill()
	{
		drying = false;
		wetness = 5f;
		if ((bool)currentWetEffect)
		{
			Object.Destroy(currentWetEffect);
		}
	}

	private void OnDestroy()
	{
		if ((bool)currentWetEffect)
		{
			Object.Destroy(currentWetEffect);
		}
	}
}



public class WheelSegment
{
	public WeaponDescriptor descriptor;

	public int slotIndex;

	public UICircle segment;

	public UICircle divider;

	public Image icon;

	public Image iconGlow;

	public void SetActive(bool active)
	{
		segment.color = (active ? Color.red : Color.black);
		icon.color = (active ? Color.red : Color.white);
		Color color = (active ? Color.red : Color.black);
		color.a = 0.7f;
		iconGlow.color = color;
	}

	public void DestroySegment()
	{
		Object.Destroy(segment.gameObject);
		Object.Destroy(divider.gameObject);
	}
}



public class Wicked : MonoBehaviour
{
	public Transform[] patrolPoints;

	public Transform targetPoint;

	private GameObject player;

	public LayerMask lmask;

	public float playerSpotTime;

	private AudioSource aud;

	private NavMeshAgent nma;

	public GameObject hitSound;

	private bool lineOfSight;

	private EnemyIdentifier eid;

	private void Start()
	{
		player = MonoSingleton<PlayerTracker>.Instance.GetPlayer().gameObject;
		nma = GetComponent<NavMeshAgent>();
		aud = GetComponent<AudioSource>();
		eid = GetComponent<EnemyIdentifier>();
		if (targetPoint == null)
		{
			targetPoint = patrolPoints[Random.Range(0, patrolPoints.Length)];
		}
	}

	private void Update()
	{
		if (playerSpotTime > 0f)
		{
			nma.speed = 22f * eid.totalSpeedModifier;
		}
		else
		{
			nma.speed = 8f * eid.totalSpeedModifier;
		}
		Debug.DrawRay(base.transform.position + Vector3.up * 2f, player.transform.position + Vector3.up * 2f - base.transform.position + Vector3.up * 2f, Color.red);
		if (!Physics.Raycast(base.transform.position + Vector3.up * 2f, player.transform.position - base.transform.position + Vector3.up * 2f, Vector3.Distance(base.transform.position + Vector3.up * 2f, player.transform.position), lmask))
		{
			if (!lineOfSight && !aud.isPlaying)
			{
				aud.Play();
			}
			lineOfSight = true;
			playerSpotTime = 5f;
		}
		else
		{
			lineOfSight = false;
			if (playerSpotTime != 0f)
			{
				playerSpotTime = Mathf.MoveTowards(playerSpotTime, 0f, Time.deltaTime);
			}
		}
		if (playerSpotTime <= 0f)
		{
			if (Vector3.Distance(base.transform.position, targetPoint.position) < 1f)
			{
				targetPoint = patrolPoints[Random.Range(0, patrolPoints.Length)];
			}
			nma.SetDestination(targetPoint.position);
		}
		else
		{
			nma.SetDestination(player.transform.position);
		}
	}

	public void GetHit()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		Object.Instantiate(hitSound, base.transform.position, Quaternion.identity);
		Vector3 position = patrolPoints[0].position;
		float num = 0f;
		for (int i = 0; i < patrolPoints.Length; i++)
		{
			if (Vector3.Distance(patrolPoints[i].position, player.transform.position) > num)
			{
				num = Vector3.Distance(patrolPoints[i].position, player.transform.position);
				position = patrolPoints[i].position;
			}
		}
		if ((bool)eid && eid.hooked)
		{
			Debug.Log("Hooked");
			MonoSingleton<HookArm>.Instance.StopThrow(1f, sparks: true);
		}
		MonoSingleton<BestiaryData>.Instance.SetEnemy(EnemyType.Wicked);
		if (aud.isPlaying)
		{
			aud.Stop();
		}
		nma.Warp(position);
		playerSpotTime = 0f;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag("Player"))
		{
			if (MonoSingleton<PlayerTracker>.Instance.playerType == PlayerType.FPS)
			{
				MonoSingleton<NewMovement>.Instance.GetHurt(Mathf.RoundToInt(999f * eid.totalDamageModifier), invincible: false);
			}
			else
			{
				MonoSingleton<PlatformerMovement>.Instance.Explode();
			}
		}
		GetHit();
	}
}



public class Wobble : MonoBehaviour
{
	public Vector3[] rotations;

	private int targetRotation;

	public float speed;

	private void Update()
	{
		Quaternion b = Quaternion.Euler(rotations[rotations.Length - 1]);
		if (targetRotation > 0)
		{
			b = Quaternion.Euler(rotations[targetRotation - 1]);
		}
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.Euler(rotations[targetRotation]), (Mathf.Min(speed, Quaternion.Angle(base.transform.rotation, Quaternion.Euler(rotations[targetRotation])), Quaternion.Angle(base.transform.rotation, b)) + 0.1f) * Time.deltaTime);
		if (Quaternion.Angle(base.transform.rotation, Quaternion.Euler(rotations[targetRotation])) < 0.1f)
		{
			if (targetRotation + 1 < rotations.Length)
			{
				targetRotation++;
			}
			else
			{
				targetRotation = 0;
			}
		}
	}
}



public static class WorkshopHelper
{
	public static async Task<Item?> GetWorkshopItemInfo(ulong itemId)
	{
		return await SteamUGC.QueryFileAsync(itemId);
	}

	public static async Task<Item?> DownloadWorkshopMap(ulong itemId, [CanBeNull] Action promptForUpdate = null)
	{
		Item? item = await Item.GetAsync(itemId);
		if (!item.HasValue)
		{
			Debug.LogError("Failed to get workshop item info for " + itemId);
			return null;
		}
		Debug.Log("Title: " + item?.Title);
		Debug.Log($"IsInstalled: {item?.IsInstalled}");
		Debug.Log($"IsDownloading: {item?.IsDownloading}");
		Debug.Log($"IsDownloadPending: {item?.IsDownloadPending}");
		Debug.Log($"IsSubscribed: {item?.IsSubscribed}");
		Debug.Log($"NeedsUpdate: {item?.NeedsUpdate}");
		Debug.Log("Description: " + item?.Description);
		if (promptForUpdate != null && (item?.NeedsUpdate).Value)
		{
			promptForUpdate();
			return null;
		}
		if (!item.Value.IsInstalled)
		{
			Debug.Log($"Downloading workshop map {itemId}");
			if (!(await item.Value.DownloadAsync()))
			{
				Debug.LogError($"Failed to download workshop map {itemId}");
				return null;
			}
			Debug.Log($"Workshop map {itemId} downloaded successfully");
			item = await Item.GetAsync(itemId);
			if (!item.HasValue)
			{
				Debug.LogError("Failed to get workshop item info for " + itemId);
				return null;
			}
		}
		else
		{
			Debug.LogWarning($"Workshop map {itemId} was already downloaded");
		}
		return item;
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class WorkshopMapEndLinks : MonoSingleton<WorkshopMapEndLinks>
{
	[SerializeField]
	private AuthorLinkRow baseRow;

	[SerializeField]
	private GameObject container;

	public void Show()
	{
		AdditionalMapDetails additionalMapDetails = MonoSingleton<AdditionalMapDetails>.Instance;
		bool flag = (bool)additionalMapDetails && additionalMapDetails.hasAuthorLinks;
		container.SetActive(flag);
		if (flag)
		{
			AuthorLink[] authorLinks = additionalMapDetails.authorLinks;
			foreach (AuthorLink authorLink in authorLinks)
			{
				baseRow.Instantiate(authorLink.platform.ToString(), authorLink.username, authorLink.displayName, GetColor(authorLink.platform), GetLink(authorLink.platform, authorLink.username), authorLink.description);
			}
			GameStateManager.Instance.RegisterState(new GameState("workshop-map-credits", container)
			{
				cursorLock = LockMode.Unlock
			});
		}
	}

	public static string GetLink(LinkPlatform platform, string username)
	{
		username = username.Replace(" ", "");
		username = username.Replace(".", "");
		username = Regex.Replace(username, "[^a-zA-Z0-9_]", "");
		switch (platform)
		{
		case LinkPlatform.YouTube:
			if (!username.StartsWith("@"))
			{
				username = "@" + username;
			}
			return "https://www.youtube.com/" + username;
		case LinkPlatform.Twitch:
			return "https://twitch.tv/" + username;
		case LinkPlatform.Twitter:
			return "https://twitter.com/" + username;
		case LinkPlatform.Steam:
			return "https://steamcommunity.com/id/" + username;
		case LinkPlatform.SoundCloud:
			return "https://soundcloud.com/" + username;
		case LinkPlatform.KoFi:
			return "https://ko-fi.com/" + username;
		case LinkPlatform.Patreon:
			return "https://www.patreon.com/" + username;
		case LinkPlatform.Bandcamp:
			return "https://" + username + ".bandcamp.com";
		case LinkPlatform.PayPalMe:
			return "https://www.paypal.me/" + username;
		default:
			return string.Empty;
		}
	}

	public static Color GetColor(LinkPlatform platform)
	{
		return platform switch
		{
			LinkPlatform.YouTube => new Color(1f, 0.4392157f, 0.4392157f), 
			LinkPlatform.Twitch => new Color(48f / 85f, 0.34901962f, 82f / 85f), 
			LinkPlatform.Twitter => new Color(32f / 51f, 0.85490197f, 1f), 
			LinkPlatform.Steam => new Color(0.6039216f, 0.64705884f, 0.81960785f), 
			LinkPlatform.SoundCloud => new Color(1f, 0.7f, 0.47f), 
			LinkPlatform.KoFi => new Color(0.65f, 0.95f, 1f), 
			LinkPlatform.Patreon => new Color(1f, 0.6f, 0.44f), 
			LinkPlatform.Bandcamp => new Color(0.6f, 0.97f, 1f), 
			LinkPlatform.PayPalMe => new Color(0.63f, 0.77f, 1f), 
			_ => Color.white, 
		};
	}

	public void Continue()
	{
		MonoSingleton<AdditionalMapDetails>.Instance.hasAuthorLinks = false;
		container.SetActive(value: false);
		MonoSingleton<FinalRank>.Instance.LevelChange();
	}
}



[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class WorkshopMapEndRating : MonoSingleton<WorkshopMapEndRating>
{
	[SerializeField]
	private GameObject container;

	[SerializeField]
	private TMP_Text mapName;

	[SerializeField]
	private Button voteUpButton;

	[SerializeField]
	private GameObject votedUpObject;

	[SerializeField]
	private Button voteDownButton;

	[SerializeField]
	private GameObject votedDownObject;

	[SerializeField]
	private Texture2D placeholderThumbnail;

	[SerializeField]
	private RawImage thumbnail;

	[SerializeField]
	private PersistentColors nameColors;

	public void VoteUp()
	{
	}

	public void VoteDown()
	{
	}

	public void LeaveAComment()
	{
	}

	public void ToggleFavorite()
	{
	}

	public void JustContinue()
	{
		MonoSingleton<FinalRank>.Instance.LevelChange(force: true);
	}
}



[Serializable]
internal enum WorkshopTab
{
	Subscribed,
	Favorite,
	YourUploads,
	Trending,
	BestVoted,
	Latest,
	TotalLifetimePlaytime,
	AveragePlaytime,
	Campaigns
}



public class WorldOptions : MonoBehaviour
{
	[SerializeField]
	private Image borderIcon;

	[SerializeField]
	private TMP_Text borderStatus;

	[SerializeField]
	private TMP_Text buttonText;

	[Space]
	[SerializeField]
	private GameObject border;

	private bool isBorderOn = true;

	public const string BorderEnabledKey = "border_enabled";

	private void Start()
	{
		if (MonoSingleton<MapVarManager>.Instance.GetBool("border_enabled") ?? false)
		{
			SetBorderOn(state: true);
		}
	}

	public void ToggleBorder()
	{
		SetBorderOn(!isBorderOn);
	}

	public void SetBorderOn(bool state)
	{
		isBorderOn = state;
		border.SetActive(state);
		borderIcon.color = (state ? Color.white : new Color(1f, 1f, 1f, 0.3f));
		borderStatus.text = (state ? "ENABLED" : "DISABLED");
		buttonText.text = (state ? "DISABLE" : "ENABLE");
		MonoSingleton<MapVarManager>.Instance.SetBool("border_enabled", state, persistent: true);
	}
}



public class Zappable : MonoBehaviour
{
	private void OnEnable()
	{
		MonoSingleton<ObjectTracker>.Instance.AddZappable(this);
	}

	private void OnDisable()
	{
		if ((bool)MonoSingleton<ObjectTracker>.Instance)
		{
			MonoSingleton<ObjectTracker>.Instance.RemoveZappable(this);
		}
	}

	public IEnumerator Zap(List<GameObject> alreadyHitObjects, float damage = 1f, GameObject sourceWeapon = null)
	{
		alreadyHitObjects.Add(base.gameObject);
		yield return new WaitForSeconds(0.25f);
		EnemyIdentifier.Zap(base.transform.position, damage, alreadyHitObjects, sourceWeapon);
	}
}



public class Zapper : MonoBehaviour
{
	private LineRenderer lr;

	private Rigidbody rb;

	private AudioSource aud;

	[HideInInspector]
	public float damage = 10f;

	[HideInInspector]
	public GameObject sourceWeapon;

	public Transform lineStartTransform;

	public Rigidbody connectedRB;

	private ConfigurableJoint joint;

	[SerializeField]
	private GameObject openProngs;

	[SerializeField]
	private GameObject closedProngs;

	public float maxDistance;

	[HideInInspector]
	public float distance;

	[HideInInspector]
	public float charge;

	[HideInInspector]
	public float breakTimer;

	[HideInInspector]
	public bool raycastBlocked;

	private bool broken;

	public bool attached;

	public EnemyIdentifier attachedEnemy;

	public EnemyIdentifierIdentifier hitLimb;

	[SerializeField]
	private GameObject attachSound;

	[SerializeField]
	private Transform lightningPulseOrb;

	private LineRenderer pulseLine;

	[SerializeField]
	private GameObject zapParticle;

	[SerializeField]
	private AudioSource[] distanceWarningSounds;

	[SerializeField]
	private AudioSource cableSnap;

	[SerializeField]
	private AudioSource boostSound;

	[SerializeField]
	private GameObject breakParticle;

	private void Awake()
	{
		lr = GetComponent<LineRenderer>();
		joint = GetComponent<ConfigurableJoint>();
		rb = GetComponent<Rigidbody>();
		aud = GetComponent<AudioSource>();
		pulseLine = lightningPulseOrb.GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)joint)
		{
			joint.connectedBody = connectedRB;
			SoftJointLimit linearLimit = joint.linearLimit;
			linearLimit.limit = maxDistance - 5f;
			joint.linearLimit = linearLimit;
		}
	}

	private void OnDisable()
	{
		if ((bool)attachedEnemy && !broken)
		{
			attachedEnemy.StartCoroutine(ZapNextFrame());
		}
	}

	private IEnumerator ZapNextFrame()
	{
		yield return null;
		Zap();
	}

	private void Update()
	{
		lr.SetPosition(0, lineStartTransform.position);
		lr.SetPosition(1, base.transform.position);
		distance = Vector3.Distance(base.transform.position, connectedRB.position);
		Color color = new Color(0.5f, 0.5f, 0.5f);
		if (breakTimer > 0f)
		{
			color = ((breakTimer % 0.1f > 0.05f) ? Color.black : Color.white);
		}
		else if (distance > maxDistance - 10f)
		{
			color = Color.Lerp(Color.red, color, (maxDistance - distance) / 10f);
		}
		lr.startColor = color;
		lr.endColor = color;
		if (attached)
		{
			charge = Mathf.MoveTowards(charge, 5f, Time.deltaTime);
			aud.pitch = 1f + charge / 5f;
			lightningPulseOrb.position = Vector3.Lerp(lineStartTransform.position, base.transform.position, charge % (0.25f / (charge / 4f)) * charge);
			pulseLine.SetPosition(0, lightningPulseOrb.position);
			pulseLine.SetPosition(1, lineStartTransform.position);
			if (charge >= 5f || attachedEnemy.dead)
			{
				Zap();
			}
		}
	}

	private void FixedUpdate()
	{
		if (!attached)
		{
			return;
		}
		raycastBlocked = Physics.Raycast(base.transform.position, connectedRB.position - base.transform.position, distance, LayerMaskDefaults.Get(LMD.Environment));
		if (distance > maxDistance || raycastBlocked)
		{
			AudioSource[] array = distanceWarningSounds;
			foreach (AudioSource audioSource in array)
			{
				if (breakTimer == 0f)
				{
					audioSource.Play();
				}
				audioSource.pitch = ((!raycastBlocked) ? 1 : 2);
			}
			breakTimer = Mathf.MoveTowards(breakTimer, 1f, Time.fixedDeltaTime * (float)((!raycastBlocked) ? 1 : 2));
			if (breakTimer >= 1f)
			{
				Break();
			}
			return;
		}
		if (breakTimer != 0f)
		{
			AudioSource[] array = distanceWarningSounds;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Stop();
			}
		}
		breakTimer = 0f;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!attached && !broken)
		{
			CheckAttach(other, Vector3.zero);
		}
	}

	private void OnCollisionEnter(Collision other)
	{
		if (attached || broken)
		{
			return;
		}
		if (other.gameObject.layer == 8 || other.gameObject.layer == 24)
		{
			if (other.gameObject.CompareTag("Moving") && other.gameObject.TryGetComponent<Tram>(out var component) && (bool)component.controller)
			{
				component.controller.Zap();
			}
			Break();
		}
		else
		{
			CheckAttach(other.collider, other.contacts[0].point);
		}
	}

	private void CheckAttach(Collider other, Vector3 position)
	{
		if (other.gameObject.layer != 10 && other.gameObject.layer != 11)
		{
			return;
		}
		AttributeChecker component2;
		if (other.gameObject.TryGetComponent<EnemyIdentifierIdentifier>(out hitLimb) && (bool)hitLimb.eid && !hitLimb.eid.dead)
		{
			attached = true;
			attachedEnemy = hitLimb.eid;
			attachedEnemy.zapperer = this;
			base.transform.SetParent(other.attachedRigidbody ? other.attachedRigidbody.transform : other.transform, worldPositionStays: true);
			if (!attachedEnemy.bigEnemy)
			{
				base.transform.position = other.bounds.center;
			}
			else
			{
				if (position == Vector3.zero)
				{
					position = ((!Physics.Raycast(base.transform.position - (other.bounds.center - base.transform.position).normalized, other.bounds.center - base.transform.position, out var hitInfo, Vector3.Distance(other.bounds.center, base.transform.position) + 1f, LayerMaskDefaults.Get(LMD.Enemies))) ? other.bounds.center : hitInfo.point);
				}
				base.transform.LookAt(position);
				base.transform.position = position;
			}
			rb.useGravity = false;
			rb.isKinematic = true;
			aud.Play();
			Object.Instantiate(attachSound, base.transform.position, Quaternion.identity);
			Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
			lightningPulseOrb.position = lineStartTransform.position;
			lightningPulseOrb.gameObject.SetActive(value: true);
			openProngs.SetActive(value: false);
			closedProngs.SetActive(value: true);
			joint.connectedBody = null;
			Object.Destroy(joint);
			if (attachedEnemy.enemyType == EnemyType.Ferryman && attachedEnemy.TryGetComponent<Ferryman>(out var component) && (bool)component.currentWindup)
			{
				component.GotParried();
			}
		}
		else if (other.gameObject.TryGetComponent<AttributeChecker>(out component2) && component2.targetAttribute == HitterAttribute.Electricity)
		{
			Object.Instantiate(zapParticle, component2.transform.position, Quaternion.identity);
			component2.Activate();
		}
	}

	private void Zap()
	{
		if ((bool)attachedEnemy)
		{
			attachedEnemy.hitter = "zapper";
			attachedEnemy.hitterAttributes.Add(HitterAttribute.Electricity);
			attachedEnemy.DeliverDamage(hitLimb.gameObject, Vector3.up * 100000f, broken ? hitLimb.transform.position : base.transform.position, damage, tryForExplode: true, 0f, sourceWeapon);
			MonoSingleton<WeaponCharges>.Instance.naiZapperRecharge = 0f;
			EnemyIdentifierIdentifier[] componentsInChildren = attachedEnemy.GetComponentsInChildren<EnemyIdentifierIdentifier>();
			foreach (EnemyIdentifierIdentifier enemyIdentifierIdentifier in componentsInChildren)
			{
				if (enemyIdentifierIdentifier != hitLimb && enemyIdentifierIdentifier.gameObject != attachedEnemy.gameObject)
				{
					attachedEnemy.DeliverDamage(enemyIdentifierIdentifier.gameObject, Vector3.zero, enemyIdentifierIdentifier.transform.position, Mathf.Epsilon, tryForExplode: false);
				}
				Object.Instantiate(zapParticle, enemyIdentifierIdentifier.transform.position, Quaternion.identity).transform.localScale *= 0.5f;
			}
		}
		Break(successful: true);
	}

	public void Break(bool successful = false)
	{
		if (!broken)
		{
			broken = true;
			Object.Instantiate(breakParticle, base.transform.position, Quaternion.identity);
			if (attached && !successful)
			{
				Object.Instantiate(cableSnap, base.transform.position, Quaternion.identity);
			}
			if ((bool)attachedEnemy)
			{
				attachedEnemy.zapperer = this;
			}
			Object.Destroy(base.gameObject);
		}
	}

	public void ChargeBoost(float amount)
	{
		charge += amount;
		LineRenderer lineRenderer = Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.electricLine, base.transform.position, Quaternion.identity);
		lineRenderer.SetPosition(0, base.transform.position);
		lineRenderer.SetPosition(1, lineStartTransform.position);
		Object.Instantiate(boostSound, base.transform.position, Quaternion.identity);
		if (lineRenderer.TryGetComponent<ElectricityLine>(out var component))
		{
			component.minWidth = 8f;
			component.maxWidth = 15f;
		}
	}
}



public class Zombie : MonoBehaviour
{
	public float health;

	private int difficulty = -1;

	private Rigidbody[] rbs;

	public bool limp;

	public NavMeshAgent nma;

	public Animator anim;

	private float currentSpeed;

	private Rigidbody rb;

	private ZombieMelee zm;

	[HideInInspector]
	public ZombieProjectiles zp;

	private AudioSource aud;

	public AudioClip[] hurtSounds;

	public float hurtSoundVol;

	public AudioClip deathSound;

	public float deathSoundVol;

	public AudioClip scream;

	private GroundCheckEnemy gc;

	public bool grounded;

	private float defaultSpeed;

	private StyleCalculator scalc;

	private EnemyIdentifier eid;

	private GoreZone gz;

	public Material deadMaterial;

	public Renderer smr;

	private Material originalMaterial;

	public GameObject chest;

	private float chestHP = 3f;

	public bool chestExploding;

	public bool attacking;

	public LayerMask lmask;

	private LayerMask lmaskWater;

	private bool noheal;

	private float speedMultiplier = 1f;

	public bool stopped;

	public bool knockedBack;

	private float knockBackCharge;

	public float brakes;

	public float juggleWeight;

	public bool falling;

	public bool noFallDamage;

	public bool musicRequested;

	private float fallSpeed;

	private float fallTime;

	private float reduceFallTime;

	private BloodsplatterManager bsm;

	public bool variableSpeed;

	private bool chestExploded;

	private int parryFramesLeft;

	public bool isOnOffNavmeshLink;

	private void Awake()
	{
		eid = GetComponent<EnemyIdentifier>();
		nma = GetComponent<NavMeshAgent>();
		anim = GetComponent<Animator>();
		if (aud == null)
		{
			aud = GetComponent<AudioSource>();
		}
	}

	private GoreZone GetGoreZone()
	{
		if ((bool)gz)
		{
			return gz;
		}
		gz = GoreZone.ResolveGoreZone(base.transform);
		return gz;
	}

	private void UpdateBuff()
	{
		SetSpeed();
	}

	private void SetSpeed()
	{
		if (limp)
		{
			return;
		}
		if (!eid)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (!nma)
		{
			nma = GetComponent<NavMeshAgent>();
		}
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		if (difficulty < 0)
		{
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
		}
		if (difficulty >= 4)
		{
			speedMultiplier = 1.5f;
		}
		else if (difficulty == 3)
		{
			speedMultiplier = 1.25f;
		}
		else if (difficulty == 2)
		{
			speedMultiplier = 1f;
		}
		else if (difficulty == 1)
		{
			speedMultiplier = 0.75f;
		}
		else if (difficulty == 0)
		{
			speedMultiplier = 0.5f;
		}
		if ((bool)zm)
		{
			if (difficulty >= 4)
			{
				nma.acceleration = 120f;
				nma.angularSpeed = 9000f;
				nma.speed = 20f;
			}
			else if (difficulty == 3)
			{
				nma.acceleration = 60f;
				nma.angularSpeed = 2600f;
				nma.speed = 20f;
			}
			else if (difficulty == 2)
			{
				nma.acceleration = 30f;
				nma.angularSpeed = 800f;
				nma.speed = 20f;
			}
			else if (difficulty == 1)
			{
				nma.acceleration = 30f;
				nma.angularSpeed = 400f;
				nma.speed = 15f;
			}
			else if (difficulty == 0)
			{
				nma.acceleration = 15f;
				nma.angularSpeed = 400f;
				nma.speed = 10f;
			}
		}
		else if (eid.enemyType == EnemyType.Soldier)
		{
			float num = 15f;
			if (difficulty == 4)
			{
				num = 17.5f;
			}
			else if (difficulty == 5)
			{
				num = 20f;
			}
			nma.speed = num * speedMultiplier;
			float num2 = 1f;
			if (difficulty == 5)
			{
				num2 = 1.75f;
			}
			anim.SetFloat("RunSpeed", num2 * speedMultiplier);
			nma.angularSpeed = 480f;
			nma.acceleration = 480f;
		}
		else
		{
			nma.speed = 10f * speedMultiplier;
			nma.angularSpeed = 800f;
			nma.acceleration = 30f;
		}
		nma.acceleration *= eid.totalSpeedModifier;
		nma.angularSpeed *= eid.totalSpeedModifier;
		nma.speed *= eid.totalSpeedModifier;
		if ((bool)nma)
		{
			defaultSpeed = nma.speed;
		}
		if ((bool)anim)
		{
			if (variableSpeed)
			{
				anim.speed = 1f * speedMultiplier;
			}
			else if (difficulty >= 2)
			{
				anim.speed = 1f * eid.totalSpeedModifier;
			}
			else if (difficulty == 1)
			{
				anim.speed = 0.875f * eid.totalSpeedModifier;
			}
			else if (difficulty == 0)
			{
				anim.speed = 0.75f * eid.totalSpeedModifier;
			}
		}
	}

	private void Start()
	{
		rbs = GetComponentsInChildren<Rigidbody>();
		rb = GetComponent<Rigidbody>();
		zm = GetComponent<ZombieMelee>();
		zp = GetComponent<ZombieProjectiles>();
		gc = GetComponentInChildren<GroundCheckEnemy>();
		if ((bool)gc && gc.onGround && (bool)nma && NavMesh.SamplePosition(base.transform.position, out var _, 5f, nma.areaMask))
		{
			nma.enabled = true;
		}
		if (!smr)
		{
			smr = GetComponentInChildren<SkinnedMeshRenderer>();
		}
		if ((bool)smr)
		{
			originalMaterial = smr.sharedMaterial;
		}
		if (limp)
		{
			noheal = true;
		}
		SetSpeed();
		lmaskWater = lmask;
		lmaskWater = (int)lmaskWater | 0x10;
	}

	private void OnEnable()
	{
		attacking = false;
	}

	private void Update()
	{
		if (knockBackCharge > 0f)
		{
			knockBackCharge = Mathf.MoveTowards(knockBackCharge, 0f, Time.deltaTime);
		}
		if (falling && !limp)
		{
			fallTime += Time.deltaTime;
			if (gc.onGround)
			{
				if (gc.fallSuppressed && !eid.unbounceable)
				{
					return;
				}
				if (fallSpeed <= -50f && !InvincibleEnemies.Enabled && !noFallDamage && !eid.blessed && !gc.fallSuppressed)
				{
					if (eid == null)
					{
						eid = GetComponent<EnemyIdentifier>();
					}
					eid.Splatter();
				}
				else if (!Physics.CheckSphere(base.transform.position + Vector3.up * 1.5f, 0.1f, LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore))
				{
					fallSpeed = 0f;
					if (aud.clip == scream && aud.isPlaying)
					{
						aud.Stop();
					}
					rb.isKinematic = true;
					rb.useGravity = false;
					if (NavMesh.SamplePosition(base.transform.position, out var hit, 4f, nma.areaMask))
					{
						nma.updatePosition = true;
						nma.updateRotation = true;
						nma.enabled = true;
						nma.Warp(hit.position);
					}
					falling = false;
					if ((bool)zm && zm.diving)
					{
						zm.JumpEnd();
					}
					anim.SetBool("Falling", value: false);
				}
			}
			else if (eid.underwater && aud.clip == scream && aud.isPlaying)
			{
				aud.Stop();
			}
			else if (fallTime > 0.05f && rb.velocity.y < fallSpeed)
			{
				fallSpeed = rb.velocity.y;
				reduceFallTime = 0.5f;
				if (!aud.isPlaying && !limp && !eid.underwater && (!Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, float.PositiveInfinity, lmaskWater, QueryTriggerInteraction.Collide) || ((hitInfo.distance > 32f || rb.velocity.y < -50f) && hitInfo.transform.gameObject.layer != 4)))
				{
					aud.clip = scream;
					aud.volume = 1f;
					aud.priority = 78;
					aud.pitch = Random.Range(0.8f, 1.2f);
					aud.Play();
				}
			}
			else if (fallTime > 0.05f && rb.velocity.y > fallSpeed)
			{
				reduceFallTime = Mathf.MoveTowards(reduceFallTime, 0f, Time.deltaTime);
				if (reduceFallTime <= 0f)
				{
					fallSpeed = rb.velocity.y;
				}
			}
			else if (rb.velocity.y > 0f)
			{
				fallSpeed = 0f;
			}
		}
		else if (fallTime > 0f)
		{
			fallTime = 0f;
		}
	}

	private void FixedUpdate()
	{
		if (parryFramesLeft > 0)
		{
			parryFramesLeft--;
		}
		if (limp)
		{
			return;
		}
		if (knockedBack && knockBackCharge <= 0f && rb.velocity.magnitude < 1f && gc.onGround)
		{
			StopKnockBack();
		}
		else if (knockedBack)
		{
			if (eid.useBrakes || gc.onGround)
			{
				if (knockBackCharge <= 0f && gc.onGround)
				{
					brakes = Mathf.MoveTowards(brakes, 0f, 0.0005f * brakes);
				}
				rb.velocity = new Vector3(rb.velocity.x * 0.95f * brakes, rb.velocity.y - juggleWeight, rb.velocity.z * 0.95f * brakes);
			}
			else if (!eid.useBrakes)
			{
				brakes = 1f;
			}
			nma.updatePosition = false;
			nma.updateRotation = false;
			nma.enabled = false;
			rb.isKinematic = false;
			rb.useGravity = true;
		}
		if (grounded && nma != null && nma.enabled && variableSpeed && nma.isOnNavMesh)
		{
			if (nma.isStopped || nma.velocity == Vector3.zero || stopped)
			{
				anim.SetFloat("RunSpeed", 1f);
			}
			else
			{
				anim.SetFloat("RunSpeed", nma.velocity.magnitude / nma.speed);
			}
		}
		else if (!grounded && gc.onGround)
		{
			grounded = true;
			nma.speed = defaultSpeed;
		}
		isOnOffNavmeshLink = nma.isOnOffMeshLink;
		if (!gc.onGround && !falling && !nma.isOnOffMeshLink)
		{
			grounded = false;
			rb.isKinematic = false;
			rb.useGravity = true;
			nma.enabled = false;
			falling = true;
			anim.SetBool("Falling", value: true);
			anim.SetTrigger("StartFalling");
			if (zp != null)
			{
				zp.CancelAttack();
			}
			if (zm != null && !zm.diving)
			{
				zm.CancelAttack();
			}
		}
	}

	public void KnockBack(Vector3 force)
	{
		if ((bool)rb)
		{
			nma.enabled = false;
			rb.isKinematic = false;
			rb.useGravity = true;
			if (!knockedBack || (!gc.onGround && rb.velocity.y < 0f))
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			}
			if (!gc.onGround)
			{
				rb.AddForce(Vector3.up, ForceMode.VelocityChange);
			}
			rb.AddForce(force / 10f, ForceMode.VelocityChange);
			knockedBack = true;
			knockBackCharge = Mathf.Min(knockBackCharge + force.magnitude / 1500f, 0.35f);
			brakes = 1f;
		}
	}

	public void StopKnockBack()
	{
		if (!(nma != null))
		{
			return;
		}
		if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, lmask))
		{
			_ = Vector3.zero;
			if (NavMesh.SamplePosition(hitInfo.point, out var hit, 8f, nma.areaMask))
			{
				knockedBack = false;
				nma.updatePosition = true;
				nma.updateRotation = true;
				nma.enabled = true;
				rb.isKinematic = true;
				juggleWeight = 0f;
				eid.pulledByMagnet = false;
				nma.Warp(hit.position);
			}
			else if (gc.onGround)
			{
				rb.isKinematic = true;
				knockedBack = false;
				juggleWeight = 0f;
				eid.pulledByMagnet = false;
			}
			else
			{
				knockBackCharge = 0.5f;
			}
		}
		else
		{
			knockBackCharge = 0.5f;
		}
	}

	public void GetHurt(GameObject target, Vector3 force, float multiplier, float critMultiplier, GameObject sourceWeapon = null, bool fromExplosion = false)
	{
		string hitLimb = "";
		bool flag = false;
		bool flag2 = false;
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if ((bool)gc && !gc.onGround && eid.hitter != "fire")
		{
			multiplier *= 1.5f;
		}
		if (force != Vector3.zero && !limp)
		{
			KnockBack(force / 100f);
			if (eid.hitter == "heavypunch" || (eid.hitter == "cannonball" && (bool)gc && !gc.onGround))
			{
				eid.useBrakes = false;
			}
			else
			{
				eid.useBrakes = true;
			}
		}
		if (chestExploding && health <= 0f && (target.gameObject.CompareTag("Limb") || target.gameObject.CompareTag("EndLimb")) && target.GetComponentInParent<EnemyIdentifier>() != null)
		{
			ChestExplodeEnd();
		}
		GameObject gameObject = null;
		if (bsm == null)
		{
			bsm = MonoSingleton<BloodsplatterManager>.Instance;
		}
		if ((bool)zm && zm.diving)
		{
			zm.CancelAttack();
		}
		if (eid.hitter == "punch")
		{
			if (attacking)
			{
				if (!InvincibleEnemies.Enabled && !eid.blessed)
				{
					health -= ((parryFramesLeft > 0) ? 4 : 5);
				}
				attacking = false;
				MonoSingleton<FistControl>.Instance.currentPunch.Parry(hook: false, eid);
			}
			else
			{
				parryFramesLeft = MonoSingleton<FistControl>.Instance.currentPunch.activeFrames;
			}
		}
		if (target.gameObject.CompareTag("Head"))
		{
			float num = 1f * multiplier + multiplier * critMultiplier;
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				gameObject = ((!(num >= 1f) && !(health <= 0f)) ? bsm.GetGore(GoreType.Small, eid, fromExplosion) : bsm.GetGore(GoreType.Head, eid, fromExplosion));
			}
			_ = (target.transform.position - base.transform.position).normalized;
			if (!limp)
			{
				flag2 = true;
				hitLimb = "head";
			}
			if (health <= 0f)
			{
				if (!limp)
				{
					GoLimp();
				}
				if (eid.hitter != "fire" && eid.hitter != "sawblade")
				{
					float num2 = 1f;
					if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone")
					{
						num2 = 0.5f;
					}
					else if (eid.hitter == "Explosion")
					{
						num2 = 0.25f;
					}
					if (target.transform.parent != null && target.transform.parent.GetComponentInParent<Rigidbody>() != null)
					{
						target.transform.parent.GetComponentInParent<Rigidbody>().AddForce(force * 10f);
					}
					if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && eid.hitter != "harpoon")
					{
						GameObject gameObject2 = null;
						GetGoreZone();
						for (int i = 0; (float)i < 6f * num2; i++)
						{
							gameObject2 = bsm.GetGib(BSType.skullChunk);
							ReadyGib(gameObject2, target);
						}
						for (int j = 0; (float)j < 4f * num2; j++)
						{
							gameObject2 = bsm.GetGib(BSType.brainChunk);
							ReadyGib(gameObject2, target);
						}
						for (int k = 0; (float)k < 2f * num2; k++)
						{
							gameObject2 = bsm.GetGib(BSType.eyeball);
							ReadyGib(gameObject2, target);
							gameObject2 = bsm.GetGib(BSType.jawChunk);
							ReadyGib(gameObject2, target);
						}
					}
				}
			}
		}
		else if (target.gameObject.CompareTag("Limb") || target.gameObject.CompareTag("EndLimb"))
		{
			if (eid == null)
			{
				eid = GetComponent<EnemyIdentifier>();
			}
			float num = 1f * multiplier + 0.5f * multiplier * critMultiplier;
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				if (eid.hitter == "hammer")
				{
					gameObject = bsm.GetGore(GoreType.Head, eid, fromExplosion);
				}
				else if (((num >= 1f || health <= 0f) && eid.hitter != "explosion") || (eid.hitter == "explosion" && target.gameObject.CompareTag("EndLimb")))
				{
					gameObject = bsm.GetGore(GoreType.Limb, eid, fromExplosion);
				}
				else if (eid.hitter != "explosion")
				{
					gameObject = bsm.GetGore(GoreType.Small, eid, fromExplosion);
				}
			}
			_ = (target.transform.position - base.transform.position).normalized;
			if (!limp)
			{
				flag2 = true;
				hitLimb = "limb";
			}
			if (health <= 0f)
			{
				if (!limp)
				{
					GoLimp();
				}
				if (eid.hitter == "sawblade")
				{
					if (!chestExploded && target.transform.position.y > chest.transform.position.y - 1f)
					{
						ChestExplosion(cut: true);
					}
				}
				else if (eid.hitter != "fire" && eid.hitter != "harpoon")
				{
					if (MonoSingleton<BloodsplatterManager>.Instance.goreOn && eid.hitter != "explosion" && target.gameObject.CompareTag("Limb"))
					{
						float num3 = 1f;
						GetGoreZone();
						if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone")
						{
							num3 = 0.5f;
						}
						for (int l = 0; (float)l < 4f * num3; l++)
						{
							GameObject gib = bsm.GetGib(BSType.gib);
							ReadyGib(gib, target);
						}
					}
					else
					{
						target.transform.localScale = Vector3.zero;
						target.SetActive(value: false);
					}
				}
			}
		}
		else
		{
			float num = multiplier;
			if (eid == null)
			{
				eid = GetComponent<EnemyIdentifier>();
			}
			if (eid.hitter == "shotgunzone" || eid.hitter == "hammerzone")
			{
				if (!attacking && (target.gameObject != chest || health - num > 0f))
				{
					num = 0f;
				}
				else if (attacking && (target.gameObject == chest || eid.target.GetVelocity().magnitude > 18f))
				{
					if (!InvincibleEnemies.Enabled && !eid.blessed)
					{
						num *= 2f;
					}
					MonoSingleton<NewMovement>.Instance.Parry(eid);
				}
			}
			if (!eid.blessed && !InvincibleEnemies.Enabled)
			{
				health -= num;
			}
			if (eid.hitter != "fire" && num > 0f)
			{
				gameObject = ((eid.hitter == "hammer") ? bsm.GetGore(GoreType.Head, eid, fromExplosion) : ((!(num >= 1f) && !(health <= 0f)) ? bsm.GetGore(GoreType.Small, eid, fromExplosion) : bsm.GetGore(GoreType.Body, eid, fromExplosion)));
			}
			if (health <= 0f && target.gameObject == chest && eid.hitter != "fire")
			{
				if (eid.hitter == "shotgunzone" || eid.hitter == "hammerzone" || eid.hitter == "sawblade")
				{
					chestHP = 0f;
				}
				else
				{
					chestHP -= num;
				}
				if (chestHP <= 0f && eid.hitter != "harpoon")
				{
					ChestExplosion(eid.hitter == "sawblade", fromExplosion);
				}
			}
			if (!limp)
			{
				flag2 = true;
				hitLimb = "body";
			}
			if (health <= 0f)
			{
				if (!limp)
				{
					GoLimp();
				}
				if (eid.hitter != "sawblade" && target.GetComponentInParent<Rigidbody>() != null)
				{
					target.GetComponentInParent<Rigidbody>().AddForce(force * 10f);
				}
			}
		}
		if (gameObject != null)
		{
			GetGoreZone();
			gameObject.transform.position = target.transform.position;
			if (eid.hitter == "drill")
			{
				gameObject.transform.localScale *= 2f;
			}
			if (gz != null && gz.goreZone != null)
			{
				gameObject.transform.SetParent(gz.goreZone, worldPositionStays: true);
			}
			Bloodsplatter component = gameObject.GetComponent<Bloodsplatter>();
			if ((bool)component)
			{
				ParticleSystem.CollisionModule collision = component.GetComponent<ParticleSystem>().collision;
				if (eid.hitter == "shotgun" || eid.hitter == "shotgunzone" || eid.hitter == "explosion")
				{
					if (Random.Range(0f, 1f) > 0.5f)
					{
						collision.enabled = false;
					}
					component.hpAmount = 3;
				}
				else if (eid.hitter == "nail")
				{
					component.hpAmount = 1;
					component.GetComponent<AudioSource>().volume *= 0.8f;
				}
				if (!noheal)
				{
					component.GetReady();
				}
			}
		}
		if (health <= 0f)
		{
			if (eid.hitter == "sawblade")
			{
				Cut(target);
			}
			else if (eid.hitter != "harpoon" && eid.hitter != "fire")
			{
				if (target.gameObject.CompareTag("Limb"))
				{
					if (target.transform.childCount > 0)
					{
						Transform child = target.transform.GetChild(0);
						CharacterJoint[] componentsInChildren = target.GetComponentsInChildren<CharacterJoint>();
						GetGoreZone();
						if (componentsInChildren.Length != 0)
						{
							CharacterJoint[] array = componentsInChildren;
							foreach (CharacterJoint characterJoint in array)
							{
								if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
								{
									component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
								}
								characterJoint.transform.SetParent(gz.transform);
								Object.Destroy(characterJoint);
							}
						}
						CharacterJoint component3 = target.GetComponent<CharacterJoint>();
						if (component3 != null)
						{
							component3.connectedBody = null;
							Object.Destroy(component3);
						}
						target.transform.position = child.position;
						target.transform.SetParent(child);
						child.SetParent(gz.transform, worldPositionStays: true);
						Object.Destroy(target.GetComponent<Rigidbody>());
					}
					Object.Destroy(target.GetComponent<Collider>());
					target.transform.localScale = Vector3.zero;
					target.gameObject.SetActive(value: false);
				}
				else if (target.gameObject.CompareTag("EndLimb") || target.gameObject.CompareTag("Head"))
				{
					target.transform.localScale = Vector3.zero;
					target.gameObject.SetActive(value: false);
				}
			}
		}
		if (health > 0f && !limp && hurtSounds.Length != 0 && !eid.blessed && eid.hitter != "blocked")
		{
			aud.clip = hurtSounds[Random.Range(0, hurtSounds.Length)];
			aud.volume = hurtSoundVol;
			aud.pitch = Random.Range(0.85f, 1.35f);
			aud.priority = 12;
			aud.Play();
		}
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (multiplier == 0f || eid.puppet)
		{
			flag2 = false;
		}
		if (!flag2 || !(eid.hitter != "enemy"))
		{
			return;
		}
		if (scalc == null)
		{
			scalc = MonoSingleton<StyleCalculator>.Instance;
		}
		if (health <= 0f)
		{
			flag = true;
			if ((bool)gc && !gc.onGround)
			{
				if (eid.hitter == "explosion" || eid.hitter == "ffexplosion" || eid.hitter == "railcannon")
				{
					scalc.shud.AddPoints(120, "ultrakill.fireworks", sourceWeapon, eid);
				}
				else if (eid.hitter == "ground slam")
				{
					scalc.shud.AddPoints(160, "ultrakill.airslam", sourceWeapon, eid);
				}
				else if (eid.hitter != "deathzone")
				{
					scalc.shud.AddPoints(50, "ultrakill.airshot", sourceWeapon, eid);
				}
			}
		}
		if (eid.hitter != "secret" && (bool)scalc)
		{
			scalc.HitCalculator(eid.hitter, "zombie", hitLimb, flag, eid, sourceWeapon);
		}
		if (flag && eid.hitter != "fire")
		{
			Flammable componentInChildren = GetComponentInChildren<Flammable>();
			if ((bool)componentInChildren && componentInChildren.burning && (bool)scalc)
			{
				scalc.shud.AddPoints(50, "ultrakill.finishedoff", sourceWeapon, eid);
			}
		}
	}

	public void GoLimp()
	{
		if (limp)
		{
			return;
		}
		if (smr != null)
		{
			(smr as SkinnedMeshRenderer).updateWhenOffscreen = true;
		}
		gz = GetGoreZone();
		attacking = false;
		Invoke("StopHealing", 1f);
		health = 0f;
		if (eid == null)
		{
			eid = GetComponent<EnemyIdentifier>();
		}
		if (!eid.dontCountAsKills)
		{
			if (gz != null && gz.checkpoint != null)
			{
				gz.AddDeath();
				gz.checkpoint.sm.kills++;
			}
			else
			{
				MonoSingleton<StatsManager>.Instance.kills++;
			}
		}
		EnemySimplifier[] componentsInChildren = GetComponentsInChildren<EnemySimplifier>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Begone();
		}
		if (deadMaterial != null)
		{
			if ((bool)smr)
			{
				smr.sharedMaterial = deadMaterial;
			}
			else if ((bool)smr)
			{
				smr.sharedMaterial = originalMaterial;
			}
		}
		if (zm != null)
		{
			zm.track = false;
			if (!chestExploding)
			{
				anim.StopPlayback();
			}
			if (zm.biteTrail != null)
			{
				zm.biteTrail.enabled = false;
			}
			if (zm.diveTrail != null)
			{
				zm.diveTrail.enabled = false;
			}
			Object.Destroy(zm.swingCheck.gameObject);
			Object.Destroy(zm.diveSwingCheck.gameObject);
			Object.Destroy(zm);
		}
		if (zp != null)
		{
			zp.DamageEnd();
			if (!chestExploding)
			{
				anim.StopPlayback();
			}
			if (zp.hasMelee)
			{
				zp.MeleeDamageEnd();
			}
			Object.Destroy(zp);
			Projectile componentInChildren = GetComponentInChildren<Projectile>();
			if (componentInChildren != null)
			{
				Object.Destroy(componentInChildren.gameObject);
			}
		}
		if (nma != null)
		{
			Object.Destroy(nma);
		}
		if (!chestExploding)
		{
			Object.Destroy(anim);
		}
		Object.Destroy(base.gameObject.GetComponent<Collider>());
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		Object.Destroy(rb);
		if (deathSound != null)
		{
			aud.clip = deathSound;
			if (eid.hitter != "fire")
			{
				aud.volume = deathSoundVol;
			}
			else
			{
				aud.volume = 0.5f;
			}
			aud.pitch = Random.Range(0.85f, 1.35f);
			aud.priority = 11;
			aud.Play();
		}
		if (!limp && !chestExploding)
		{
			rbs = GetComponentsInChildren<Rigidbody>();
			Rigidbody[] array = rbs;
			foreach (Rigidbody rigidbody in array)
			{
				rigidbody.isKinematic = false;
				rigidbody.useGravity = true;
				if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
				{
					component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
				}
				if ((bool)MonoSingleton<ComponentsDatabase>.Instance && MonoSingleton<ComponentsDatabase>.Instance.scrollers.Count > 0)
				{
					CheckForScroller checkForScroller = rigidbody.gameObject.AddComponent<CheckForScroller>();
					checkForScroller.checkOnStart = false;
					checkForScroller.checkOnCollision = true;
					checkForScroller.asRigidbody = true;
				}
			}
		}
		if (!limp)
		{
			if (!eid.dontCountAsKills)
			{
				ActivateNextWave componentInParent = GetComponentInParent<ActivateNextWave>();
				if (componentInParent != null)
				{
					componentInParent.AddDeadEnemy();
				}
			}
			if (gz != null && gz.transform != null)
			{
				base.transform.SetParent(gz.transform, worldPositionStays: true);
			}
		}
		if (musicRequested)
		{
			musicRequested = false;
			MonoSingleton<MusicManager>.Instance.PlayCleanMusic();
		}
		limp = true;
	}

	public void ChestExplodeEnd()
	{
		anim.enabled = false;
		anim.StopPlayback();
		Object.Destroy(anim);
		rbs = GetComponentsInChildren<Rigidbody>();
		Rigidbody[] array = rbs;
		foreach (Rigidbody rigidbody in array)
		{
			if (rigidbody != null)
			{
				rigidbody.isKinematic = false;
				rigidbody.useGravity = true;
				if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && rigidbody.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
				{
					component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
				}
			}
		}
		chestExploding = false;
	}

	public void StopHealing()
	{
		noheal = true;
	}

	private void ReadyGib(GameObject tempGib, GameObject target)
	{
		tempGib.transform.SetPositionAndRotation(target.transform.position, Random.rotation);
		gz.SetGoreZone(tempGib);
	}

	public void ChestExplosion(bool cut = false, bool fromExplosion = false)
	{
		if (chestExploded)
		{
			return;
		}
		GetGoreZone();
		if (!cut)
		{
			CharacterJoint[] componentsInChildren = chest.GetComponentsInChildren<CharacterJoint>();
			if (componentsInChildren.Length != 0)
			{
				CharacterJoint[] array = componentsInChildren;
				foreach (CharacterJoint characterJoint in array)
				{
					if (characterJoint.transform.parent.parent == chest.transform)
					{
						Rigidbody[] componentsInChildren2 = characterJoint.transform.GetComponentsInChildren<Rigidbody>();
						foreach (Rigidbody obj in componentsInChildren2)
						{
							obj.isKinematic = false;
							obj.useGravity = true;
						}
						if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && characterJoint.TryGetComponent<EnemyIdentifierIdentifier>(out var component))
						{
							component.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
						}
						Object.Destroy(characterJoint);
					}
					else if (characterJoint.transform == chest.transform)
					{
						if (characterJoint.TryGetComponent<Collider>(out var component2))
						{
							Object.Destroy(component2);
						}
						Object.Destroy(characterJoint);
					}
				}
			}
			if (chest.TryGetComponent<Rigidbody>(out var component3))
			{
				Object.Destroy(component3);
			}
			if (!limp && !eid.exploded && !eid.dead)
			{
				if (gc.onGround)
				{
					rb.isKinematic = true;
					knockedBack = false;
				}
				anim.Rebind();
				anim.SetTrigger("ChestExplosion");
				chestExploding = true;
			}
		}
		GetGoreZone();
		if (MonoSingleton<BloodsplatterManager>.Instance.forceOn || MonoSingleton<BloodsplatterManager>.Instance.forceGibs || MonoSingleton<PrefsManager>.Instance.GetBoolLocal("bloodEnabled"))
		{
			GetGoreZone();
			for (int k = 0; k < 6; k++)
			{
				GameObject gib = bsm.GetGib((k < 2) ? BSType.jawChunk : BSType.gib);
				ReadyGib(gib, chest);
			}
			if (!eid.sandified)
			{
				GameObject fromQueue = bsm.GetFromQueue(BSType.chestExplosion);
				gz.SetGoreZone(fromQueue);
				fromQueue.transform.SetPositionAndRotation(chest.transform.parent.position, chest.transform.parent.rotation);
				fromQueue.transform.SetParent(chest.transform.parent, worldPositionStays: true);
			}
		}
		EnemyIdentifierIdentifier[] componentsInChildren3 = chest.GetComponentsInChildren<EnemyIdentifierIdentifier>();
		for (int l = 0; l < componentsInChildren3.Length; l++)
		{
			if (!componentsInChildren3[l])
			{
				continue;
			}
			GoreType got;
			switch (componentsInChildren3[l].gameObject.tag)
			{
			case "Head":
				got = GoreType.Head;
				break;
			case "EndLimb":
			case "Limb":
				got = GoreType.Limb;
				break;
			default:
				got = GoreType.Body;
				break;
			}
			GameObject gore = MonoSingleton<BloodsplatterManager>.Instance.GetGore(got, eid, fromExplosion);
			if ((bool)gore)
			{
				gore.transform.position = chest.transform.position;
				Bloodsplatter component4 = gore.GetComponent<Bloodsplatter>();
				if ((bool)component4)
				{
					component4.hpAmount = 10;
				}
				if (gz != null && gz.goreZone != null)
				{
					gore.transform.SetParent(gz.goreZone, worldPositionStays: true);
				}
				if (!noheal && (bool)component4)
				{
					component4.GetReady();
				}
			}
		}
		if (!cut)
		{
			chest.transform.localScale = Vector3.zero;
		}
		else
		{
			if (!limp)
			{
				MonoSingleton<StyleHUD>.Instance.AddPoints(50, "ultrakill.halfoff", null, eid);
			}
			Cut(chest);
		}
		chestExploded = true;
	}

	public void Cut(GameObject target)
	{
		if (target.TryGetComponent<CharacterJoint>(out var component))
		{
			if (StockMapInfo.Instance.removeGibsWithoutAbsorbers && component.TryGetComponent<EnemyIdentifierIdentifier>(out var component2))
			{
				component2.Invoke("DestroyLimbIfNotTouchedBloodAbsorber", StockMapInfo.Instance.gibRemoveTime);
			}
			Object.Destroy(component);
			target.transform.SetParent(gz.transform, worldPositionStays: true);
			Rigidbody[] componentsInChildren = target.transform.GetComponentsInChildren<Rigidbody>();
			foreach (Rigidbody obj in componentsInChildren)
			{
				obj.isKinematic = false;
				obj.useGravity = true;
				obj.angularDrag = 0.001f;
				obj.maxAngularVelocity = float.PositiveInfinity;
				obj.velocity = Vector3.zero;
				obj.AddForce(Vector3.up * (target.CompareTag("Head") ? 250 : 25), ForceMode.VelocityChange);
				obj.AddTorque(target.transform.right * 1f, ForceMode.VelocityChange);
			}
		}
	}

	public void ParryableCheck()
	{
		attacking = true;
		if (parryFramesLeft > 0)
		{
			eid.hitter = "punch";
			eid.DeliverDamage(base.gameObject, MonoSingleton<CameraController>.Instance.transform.forward * 25000f, base.transform.position, 1f, tryForExplode: false);
			parryFramesLeft = 0;
		}
	}

	public void Jump(Vector3 vector)
	{
		gc.ForceOff();
		rb.isKinematic = false;
		rb.useGravity = true;
		eid.useBrakes = false;
		rb.AddForce(vector, ForceMode.VelocityChange);
		Invoke("Jumped", 0.5f);
	}

	public void Jumped()
	{
		gc.StopForceOff();
	}
}



public class ZombieIgnorizer : MonoBehaviour
{
	public EnemyIdentifier[] eids;

	private void Start()
	{
		EnemyIdentifier[] array = eids;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ignoredByEnemies = true;
		}
	}
}



public class ZombieMelee : MonoBehaviour, IHitTargetCallback
{
	public bool harmless;

	public bool damaging;

	public TrailRenderer biteTrail;

	public TrailRenderer diveTrail;

	public bool track;

	public float coolDown;

	public Zombie zmb;

	private NavMeshAgent nma;

	private Animator anim;

	private EnemyIdentifier eid;

	private bool customStart;

	private bool musicRequested;

	private int difficulty = -1;

	private float defaultCoolDown = 0.5f;

	public GameObject swingSound;

	public LayerMask lmask;

	private Rigidbody rb;

	[HideInInspector]
	public SwingCheck2 swingCheck;

	[HideInInspector]
	public SwingCheck2 diveSwingCheck;

	[HideInInspector]
	public bool diving;

	private bool inAction;

	[SerializeField]
	private Transform modelTransform;

	private TimeSince randomJumpChanceCooldown;

	private bool aboutToDive;

	[SerializeField]
	private GameObject hitGroundParticle;

	[SerializeField]
	private GameObject pullOutParticle;

	private EnemySimplifier ensim;

	public Material originalMaterial;

	public Material biteMaterial;

	private void Awake()
	{
		zmb = GetComponent<Zombie>();
		eid = GetComponent<EnemyIdentifier>();
		rb = GetComponent<Rigidbody>();
	}

	private void Start()
	{
		if (eid.difficultyOverride >= 0)
		{
			difficulty = eid.difficultyOverride;
		}
		else
		{
			difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
		}
		if (difficulty != 2)
		{
			if (difficulty >= 3)
			{
				defaultCoolDown = 0.25f;
			}
			else if (difficulty == 1)
			{
				defaultCoolDown = 0.75f;
			}
			else if (difficulty == 0)
			{
				defaultCoolDown = 1f;
			}
		}
		if (!musicRequested && !eid.IgnorePlayer)
		{
			musicRequested = true;
			zmb.musicRequested = true;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if ((bool)instance)
			{
				instance.PlayBattleMusic();
			}
		}
		ensim = GetComponentInChildren<EnemySimplifier>();
		nma = zmb.nma;
		anim = zmb.anim;
		TrackTick();
	}

	private void Update()
	{
		if (diving)
		{
			modelTransform.LookAt(base.transform.position + base.transform.forward + Vector3.up * rb.velocity.normalized.y * 5f);
			modelTransform.Rotate(Vector3.right * 90f, Space.Self);
		}
		else
		{
			modelTransform.localRotation = Quaternion.identity;
		}
		if (!diving && damaging)
		{
			rb.isKinematic = false;
			float num = 1f;
			if (difficulty >= 4)
			{
				num = 1.25f;
			}
			rb.velocity = base.transform.forward * 40f * num * anim.speed;
		}
		if (track && eid.target != null)
		{
			if (difficulty > 1)
			{
				base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
			}
			else
			{
				float num2 = 720f;
				if (difficulty == 0)
				{
					num2 = 360f;
				}
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z) - base.transform.position), Time.deltaTime * num2 * eid.totalSpeedModifier);
			}
		}
		float num3 = 3f;
		if (eid.target != null && !eid.target.isPlayer)
		{
			num3 = 4f;
		}
		if (coolDown != 0f)
		{
			if (coolDown - Time.deltaTime > 0f)
			{
				coolDown -= Time.deltaTime / 2.5f * eid.totalSpeedModifier;
			}
			else
			{
				coolDown = 0f;
			}
		}
		else
		{
			if (eid.target == null || !zmb.grounded || nma.isOnOffMeshLink || aboutToDive || inAction)
			{
				return;
			}
			if (difficulty >= 4)
			{
				float num4 = Vector3.Distance(eid.target.position, base.transform.position);
				if (eid.target.position.y > base.transform.position.y + 5f && num4 < 20f && !Physics.Raycast(base.transform.position + Vector3.up, eid.target.position - (base.transform.position + Vector3.up), Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment)))
				{
					aboutToDive = true;
					Invoke("JumpAttack", Random.Range(0f, 0.5f));
				}
				else if (num4 < num3 && !damaging)
				{
					Swing();
				}
				else if (num4 < 20f && num4 > 10f && (float)randomJumpChanceCooldown > 1f)
				{
					if (Random.Range(0f, 1f) > 0.8f && !Physics.Raycast(base.transform.position + Vector3.up, eid.target.position - (base.transform.position + Vector3.up), Vector3.Distance(eid.target.position, base.transform.position + Vector3.up), LayerMaskDefaults.Get(LMD.Environment)))
					{
						JumpAttack();
					}
					randomJumpChanceCooldown = 0f;
				}
			}
			else if (Vector3.Distance(eid.target.position, base.transform.position) < num3 && !damaging)
			{
				Swing();
			}
		}
	}

	private void OnEnable()
	{
		if (zmb == null)
		{
			zmb = GetComponent<Zombie>();
		}
		if (!musicRequested && !eid.IgnorePlayer)
		{
			musicRequested = true;
			zmb.musicRequested = true;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if ((bool)instance)
			{
				instance.PlayBattleMusic();
			}
		}
		CancelAttack();
		if (zmb.grounded && (bool)rb)
		{
			rb.velocity = Vector3.zero;
			rb.isKinematic = true;
		}
	}

	private void OnDisable()
	{
		if (musicRequested && !eid.IgnorePlayer && !zmb.limp)
		{
			musicRequested = false;
			zmb.musicRequested = false;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if ((bool)instance)
			{
				instance.PlayCleanMusic();
			}
		}
	}

	private void FixedUpdate()
	{
		if (zmb.grounded && nma != null && nma.enabled && nma.isOnNavMesh)
		{
			if (nma.isStopped || nma.velocity == Vector3.zero)
			{
				anim.SetBool("Running", value: false);
			}
			else
			{
				anim.SetBool("Running", value: true);
			}
		}
	}

	public void JumpAttack()
	{
		aboutToDive = false;
		if (!nma.isOnOffMeshLink)
		{
			anim.Play("JumpStart");
			coolDown = defaultCoolDown;
			inAction = true;
			zmb.stopped = true;
			nma.enabled = false;
		}
	}

	public void JumpStart()
	{
		Vector3 vector = eid.target.position;
		if (eid.target.isPlayer)
		{
			vector = MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(0.5f);
		}
		base.transform.LookAt(new Vector3(vector.x, base.transform.position.y, vector.z));
		zmb.Jump(Vector3.up * 25f + Vector3.ClampMagnitude(new Vector3((vector.x - base.transform.position.x) * 2f, 0f, (vector.z - base.transform.position.z) * 2f), 25f));
		Object.Instantiate(swingSound, base.transform);
		diving = true;
		DamageStart();
		zmb.ParryableCheck();
		Invoke("CheckThatJumpStarted", 1f);
	}

	private void CheckThatJumpStarted()
	{
		if (diving && !zmb.falling)
		{
			JumpEnd();
		}
	}

	public void JumpEnd()
	{
		CancelInvoke("CheckThatJumpStarted");
		anim.Play("JumpEnd");
		DamageEnd();
		diving = false;
		zmb.attacking = false;
		Object.Instantiate(hitGroundParticle, base.transform.position, Quaternion.identity);
	}

	public void PullOut()
	{
		Object.Instantiate(pullOutParticle, base.transform.position, Quaternion.identity);
	}

	public void JumpEndEnd()
	{
		inAction = false;
	}

	public void Swing()
	{
		if (!damaging && !harmless && eid.target != null)
		{
			GetComponentInChildren<SwingCheck2>().OverrideEnemyIdentifier(eid);
			zmb.stopped = true;
			track = true;
			coolDown = defaultCoolDown;
			nma.enabled = false;
			anim.SetTrigger("Swing");
			Object.Instantiate(swingSound, base.transform);
		}
	}

	public void SwingEnd()
	{
		if (zmb.grounded)
		{
			nma.enabled = true;
		}
		zmb.stopped = false;
	}

	public void DamageStart()
	{
		if (!harmless)
		{
			damaging = true;
			if (diving)
			{
				diveTrail.emitting = true;
				diveSwingCheck.DamageStart();
			}
			else
			{
				biteTrail.enabled = true;
				swingCheck.DamageStart();
				MouthClose();
			}
		}
	}

	public void TargetBeenHit()
	{
		MouthClose();
	}

	public void DamageEnd()
	{
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		damaging = false;
		zmb.attacking = false;
		rb.velocity = Vector3.zero;
		rb.isKinematic = true;
		biteTrail.enabled = false;
		diveTrail.emitting = false;
		diving = false;
		swingCheck.DamageStop();
		diveSwingCheck.DamageStop();
	}

	public void StopTracking()
	{
		track = false;
		if (difficulty >= 4 && eid.target.isPlayer)
		{
			Vector3 vector = MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(0.2f);
			base.transform.LookAt(new Vector3(vector.x, base.transform.position.y, vector.z));
		}
		zmb.ParryableCheck();
	}

	public void CancelAttack()
	{
		damaging = false;
		zmb.attacking = false;
		inAction = false;
		biteTrail.enabled = false;
		diveTrail.emitting = false;
		diving = false;
		zmb.stopped = false;
		track = false;
		coolDown = defaultCoolDown;
		swingCheck.DamageStop();
	}

	public void TrackTick()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (nma == null)
			{
				nma = zmb.nma;
			}
			if (zmb.grounded && !inAction && nma != null && nma.enabled && nma.isOnNavMesh && eid.target != null)
			{
				if (Physics.Raycast(eid.target.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, lmask))
				{
					nma.SetDestination(hitInfo.point);
				}
				else
				{
					nma.SetDestination(eid.target.position);
				}
			}
		}
		Invoke("TrackTick", 0.1f);
	}

	public void MouthClose()
	{
		if (!eid.puppet)
		{
			if ((bool)ensim)
			{
				ensim.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, biteMaterial);
			}
			CancelInvoke("MouthOpen");
			Invoke("MouthOpen", 0.75f);
		}
	}

	private void MouthOpen()
	{
		if (!eid.puppet && (bool)ensim)
		{
			ensim.ChangeMaterialNew(EnemySimplifier.MaterialState.normal, originalMaterial);
		}
	}
}



public class ZombieProjectiles : MonoBehaviour
{
	public bool stationary;

	public bool alwaysStationary;

	public bool smallRay;

	public bool wanderer;

	public bool afraid;

	public bool chaser;

	public bool hasMelee;

	private Zombie zmb;

	private GameObject player;

	private GameObject camObj;

	private NavMeshAgent nma;

	private NavMeshPath nmp;

	private NavMeshHit hit;

	private Animator anim;

	private Rigidbody rb;

	public Vector3 targetPosition;

	private float coolDown = 1f;

	private AudioSource aud;

	public TrailRenderer tr;

	public GameObject projectile;

	private GameObject currentProjectile;

	public Transform shootPos;

	public GameObject head;

	public bool playerSpotted;

	private RaycastHit rhit;

	private RaycastHit bhit;

	public LayerMask lookForPlayerMask;

	public bool seekingPlayer = true;

	private Vector3 wanderTarget;

	private float raySize = 1f;

	private bool musicRequested;

	public GameObject decProjectileSpawner;

	public GameObject decProjectile;

	private GameObject currentDecProjectile;

	public bool swinging;

	[HideInInspector]
	public bool blocking;

	[HideInInspector]
	public int difficulty;

	private float coolDownReduce;

	private EnemyIdentifier eid;

	private GameObject origWP;

	public Transform aimer;

	private Quaternion aimerDefaultRotation;

	private bool aiming;

	private Quaternion origRotation;

	private float aimEase;

	private Vector3 predictedPosition;

	private float predictionLerp;

	private bool predictionLerping;

	private bool moveForward;

	private float forwardSpeed;

	private SwingCheck2[] swingChecks;

	private float lengthOfStop;

	private Vector3 spawnPos;

	private bool valuesSet;

	private void Awake()
	{
		zmb = GetComponent<Zombie>();
		nma = GetComponent<NavMeshAgent>();
		anim = GetComponent<Animator>();
		eid = GetComponent<EnemyIdentifier>();
		rb = GetComponent<Rigidbody>();
	}

	private void SetValues()
	{
		if (!valuesSet)
		{
			valuesSet = true;
			player = MonoSingleton<PlayerTracker>.Instance.GetPlayer().gameObject;
			camObj = MonoSingleton<PlayerTracker>.Instance.GetTarget().gameObject;
			if ((bool)aimer)
			{
				aimerDefaultRotation = Quaternion.Inverse(base.transform.rotation) * aimer.rotation;
			}
			nmp = new NavMeshPath();
			if (hasMelee && (swingChecks == null || swingChecks.Length == 0))
			{
				swingChecks = GetComponentsInChildren<SwingCheck2>();
			}
			if (eid.difficultyOverride >= 0)
			{
				difficulty = eid.difficultyOverride;
			}
			else
			{
				difficulty = MonoSingleton<PrefsManager>.Instance.GetInt("difficulty");
			}
			origWP = eid.weakPoint;
			spawnPos = base.transform.position;
			if (alwaysStationary)
			{
				stationary = true;
			}
			if (stationary || smallRay)
			{
				raySize = 0.25f;
			}
			if (difficulty >= 3)
			{
				coolDownReduce = 1f;
			}
		}
	}

	private void Start()
	{
		SetValues();
		if (!stationary && wanderer && eid.target != null)
		{
			Invoke("Wander", 0.5f);
		}
		SlowUpdate();
	}

	private void OnEnable()
	{
		SetValues();
		if (!musicRequested && playerSpotted && (bool)zmb && !eid.IgnorePlayer)
		{
			musicRequested = true;
			zmb.musicRequested = true;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if (instance != null)
			{
				instance.PlayBattleMusic();
			}
		}
		if (hasMelee)
		{
			MeleeDamageEnd();
		}
		if (tr != null)
		{
			tr.emitting = false;
		}
		if (currentDecProjectile != null)
		{
			Object.Destroy(currentDecProjectile);
			eid.weakPoint = origWP;
		}
		swinging = false;
	}

	private void OnDisable()
	{
		if (musicRequested && !eid.IgnorePlayer && !zmb.limp)
		{
			musicRequested = false;
			zmb.musicRequested = false;
			MusicManager instance = MonoSingleton<MusicManager>.Instance;
			if (instance != null)
			{
				instance.PlayCleanMusic();
			}
		}
		coolDown = Random.Range(1f, 2.5f) - coolDownReduce;
	}

	private void SlowUpdate()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (zmb.grounded && (bool)nma && !zmb.limp && eid.target != null && !swinging)
			{
				Vector3 vector = eid.target.position - base.transform.position;
				Vector3 normalized = (eid.target.headPosition - head.transform.position).normalized;
				float num = Vector3.Distance(eid.target.position, base.transform.position);
				if (afraid && !swinging && num < 15f && nma.enabled)
				{
					nma.updateRotation = true;
					targetPosition = new Vector3(base.transform.position.x + vector.normalized.x * -10f, base.transform.position.y, base.transform.position.z + vector.normalized.z * -10f);
					if (nma.enabled && nma.isOnNavMesh)
					{
						if (NavMesh.SamplePosition(targetPosition, out hit, 1f, nma.areaMask))
						{
							SetDestination(targetPosition);
						}
						else if (NavMesh.FindClosestEdge(targetPosition, out hit, nma.areaMask))
						{
							targetPosition = hit.position;
							SetDestination(targetPosition);
						}
					}
					if (nma.velocity.magnitude < 1f)
					{
						lengthOfStop += 0.5f;
					}
					else
					{
						lengthOfStop = 0f;
					}
				}
				if (num > 15f || lengthOfStop > 0.75f || !afraid)
				{
					lengthOfStop = 0f;
					if (playerSpotted && (!chaser || Vector3.Distance(base.transform.position, eid.target.position) < 3f || coolDown == 0f) && (Vector3.Distance(base.transform.position, eid.target.position) < 30f || (Vector3.Distance(base.transform.position, eid.target.position) < 60f && coolDown == 0f) || stationary || (nmp.status != 0 && (nmp.corners.Length == 0 || Vector3.Distance(base.transform.position, nmp.corners[nmp.corners.Length - 1]) < 3f))) && !Physics.Raycast(head.transform.position, normalized, out bhit, Vector3.Distance(eid.target.headPosition, head.transform.position), lookForPlayerMask))
					{
						seekingPlayer = false;
						if (!wanderer)
						{
							SetDestination(base.transform.position);
						}
						else if (wanderer && !chaser && coolDown <= 0f)
						{
							SetDestination(base.transform.position);
						}
						if (hasMelee && Vector3.Distance(base.transform.position, eid.target.position) <= 3f)
						{
							Melee();
						}
						else if (coolDown <= 0f && (!nma.enabled || nma.velocity.magnitude <= 2.5f))
						{
							Swing();
						}
						else if (wanderer && coolDown > 0f && nma.velocity.magnitude < 1f)
						{
							Wander();
						}
					}
					else if (!stationary && nma.enabled)
					{
						if (chaser)
						{
							if (nma == null)
							{
								nma = zmb.nma;
							}
							if (zmb.grounded && nma != null && nma.enabled && nma.isOnNavMesh && eid.target != null)
							{
								if (Physics.Raycast(eid.target.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, float.PositiveInfinity, lookForPlayerMask))
								{
									SetDestination(hitInfo.point);
								}
								else
								{
									SetDestination(eid.target.position);
								}
							}
						}
						else if ((bool)nma && nma.enabled && nma.isOnNavMesh)
						{
							seekingPlayer = true;
							nma.updateRotation = true;
							if (Physics.Raycast(eid.target.position + Vector3.up * 0.1f, Vector3.down, out rhit, float.PositiveInfinity, lookForPlayerMask))
							{
								SetDestination(rhit.point);
							}
							else
							{
								SetDestination(eid.target.position);
							}
						}
					}
				}
			}
			if (stationary && !alwaysStationary && Vector3.Distance(base.transform.position, spawnPos) > 5f)
			{
				stationary = false;
			}
		}
		if (!eid.dead)
		{
			if (chaser || eid.enemyType == EnemyType.Soldier)
			{
				Invoke("SlowUpdate", 0.1f);
			}
			else
			{
				Invoke("SlowUpdate", 0.5f);
			}
		}
	}

	private void Update()
	{
		if (!zmb.grounded || zmb.limp)
		{
			return;
		}
		if (coolDown > 0f)
		{
			coolDown = Mathf.MoveTowards(coolDown, 0f, Time.deltaTime * eid.totalSpeedModifier);
		}
		if (!playerSpotted && eid.target != null)
		{
			Vector3 normalized = (eid.target.headPosition - head.transform.position).normalized;
			if (!Physics.Raycast(head.transform.position, normalized, out rhit, Vector3.Distance(eid.target.headPosition, head.transform.position), lookForPlayerMask))
			{
				seekingPlayer = false;
				playerSpotted = true;
				coolDown = (float)Random.Range(1, 2) - coolDownReduce / 2f;
				if (eid.target.isPlayer && !musicRequested)
				{
					musicRequested = true;
					zmb.musicRequested = true;
					MusicManager instance = MonoSingleton<MusicManager>.Instance;
					if (instance != null)
					{
						instance.PlayBattleMusic();
					}
				}
			}
		}
		if (eid.target == null)
		{
			if (!nma.enabled || nma.velocity.magnitude <= 2.5f)
			{
				anim.SetBool("Running", value: false);
				nma.updateRotation = false;
			}
		}
		else if ((!nma.enabled || nma.velocity.magnitude <= 2.5f) && playerSpotted && !seekingPlayer && (!wanderer || !swinging || chaser))
		{
			anim.SetBool("Running", value: false);
			nma.updateRotation = false;
			base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		}
		else if (nma.enabled && nma.velocity.magnitude > 2.5f)
		{
			anim.SetBool("Running", value: true);
			nma.updateRotation = true;
		}
		else
		{
			if ((nma.enabled && !(nma.velocity.magnitude <= 2.5f)) || !playerSpotted || seekingPlayer || !wanderer || !swinging)
			{
				return;
			}
			anim.SetBool("Running", value: false);
			nma.updateRotation = false;
			if (difficulty >= 2)
			{
				Vector3 vector = new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z);
				Quaternion b = Quaternion.LookRotation((vector - base.transform.position).normalized);
				if (difficulty == 2)
				{
					base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * 3.5f * eid.totalSpeedModifier);
				}
				else if (difficulty == 3)
				{
					base.transform.LookAt(vector);
				}
				else if (difficulty > 3)
				{
					base.transform.LookAt(vector);
				}
			}
		}
	}

	private void LateUpdate()
	{
		if (aimer != null && aiming && eid.target != null)
		{
			Vector3 vector = eid.target.headPosition;
			if (predictionLerping)
			{
				predictionLerp = Mathf.MoveTowards(predictionLerp, 1f, Time.deltaTime * 0.75f * anim.speed * eid.totalSpeedModifier);
				vector = Vector3.Lerp(vector, predictedPosition, predictionLerp);
			}
			Quaternion quaternion = Quaternion.LookRotation((vector - aimer.position).normalized);
			Quaternion quaternion2 = Quaternion.Inverse(base.transform.rotation * aimerDefaultRotation) * aimer.rotation;
			aimer.rotation = quaternion * quaternion2;
			if (aimEase < 1f)
			{
				aimEase = Mathf.MoveTowards(aimEase, 1f, Time.deltaTime * (20f - aimEase * 20f) * eid.totalSpeedModifier);
			}
			aimer.rotation = Quaternion.Slerp(origRotation, quaternion, aimEase);
		}
	}

	private void FixedUpdate()
	{
		if (moveForward)
		{
			float num = forwardSpeed * anim.speed * eid.totalSpeedModifier;
			forwardSpeed /= 1f + Time.fixedDeltaTime * forwardSpeed / 3f;
			if (Physics.Raycast(base.transform.position + Vector3.up + base.transform.forward * 2.5f, Vector3.down, out var hitInfo, (eid.target == null) ? 11f : Mathf.Max(11f, base.transform.position.y - eid.target.position.y + 2.5f), LayerMaskDefaults.Get(LMD.Environment), QueryTriggerInteraction.Ignore) && Vector3.Dot(base.transform.up, hitInfo.normal) > 0.25f)
			{
				rb.velocity = new Vector3(base.transform.forward.x * num, Mathf.Min(0f, rb.velocity.y), base.transform.forward.z * num);
			}
			else
			{
				rb.velocity = new Vector3(0f, rb.velocity.y, 0f);
			}
		}
	}

	public void MoveForward(float speed)
	{
		forwardSpeed = speed * 10f;
		if ((bool)nma)
		{
			nma.enabled = false;
		}
		moveForward = true;
		rb.isKinematic = false;
	}

	private void StopMoveForward()
	{
		moveForward = false;
		if (zmb.grounded)
		{
			if ((bool)nma)
			{
				nma.enabled = true;
			}
			rb.isKinematic = true;
		}
	}

	private void SetDestination(Vector3 position)
	{
		if ((bool)nma && nma.isOnNavMesh)
		{
			NavMesh.CalculatePath(base.transform.position, position, nma.areaMask, nmp);
			nma.SetPath(nmp);
		}
	}

	public void Melee()
	{
		swinging = true;
		seekingPlayer = false;
		nma.updateRotation = false;
		base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		nma.enabled = false;
		if (tr == null)
		{
			tr = GetComponentInChildren<TrailRenderer>();
		}
		tr.GetComponent<AudioSource>().Play();
		anim.SetTrigger("Melee");
	}

	public void MeleePrep()
	{
		zmb.ParryableCheck();
	}

	public void MeleeDamageStart()
	{
		if (tr == null)
		{
			tr = GetComponentInChildren<TrailRenderer>();
		}
		if (tr != null)
		{
			tr.enabled = true;
			tr.emitting = true;
		}
		SwingCheck2[] array = swingChecks;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DamageStart();
		}
	}

	public void MeleeDamageEnd()
	{
		if (tr != null)
		{
			tr.emitting = false;
		}
		SwingCheck2[] array = swingChecks;
		foreach (SwingCheck2 swingCheck in array)
		{
			if ((bool)swingCheck)
			{
				swingCheck.DamageStop();
			}
		}
		zmb.attacking = false;
	}

	public void Swing()
	{
		swinging = true;
		seekingPlayer = false;
		nma.updateRotation = false;
		base.transform.LookAt(new Vector3(eid.target.position.x, base.transform.position.y, eid.target.position.z));
		nma.enabled = false;
		if (difficulty >= 4 && eid.enemyType == EnemyType.Schism)
		{
			aiming = true;
			predictionLerp = 0f;
			predictionLerping = false;
			anim.SetFloat("AttackType", 0f);
		}
		else if (eid.target.position.y - 5f > base.transform.position.y || eid.target.position.y + 5f < base.transform.position.y)
		{
			anim.SetFloat("AttackType", 1f);
		}
		else
		{
			anim.SetFloat("AttackType", Random.Range(0, 2));
		}
		if (!stationary && zmb.grounded && eid.enemyType == EnemyType.Soldier && difficulty >= 4)
		{
			MoveForward(25f);
			anim.Play("RollShoot", -1, 0f);
		}
		else
		{
			anim.SetTrigger("Swing");
		}
		coolDown = 99f;
	}

	public void SwingEnd()
	{
		swinging = false;
		aiming = false;
		if (zmb.grounded)
		{
			nma.enabled = true;
		}
		coolDown = Random.Range(1f, 2.5f) - coolDownReduce;
		if (wanderer)
		{
			if (difficulty >= 4 && eid.enemyType == EnemyType.Soldier && Random.Range(0f, 1f) > 0.66f)
			{
				chaser = true;
				coolDown = 1f;
			}
			else
			{
				chaser = false;
				Wander();
				coolDown = Mathf.Max(Random.Range(0.5f, 2f) - coolDownReduce, 0.5f);
			}
		}
		if (blocking)
		{
			coolDown = 0f;
		}
		blocking = false;
		moveForward = false;
		if (tr != null)
		{
			tr.enabled = false;
		}
	}

	public void SpawnProjectile()
	{
		if (swinging)
		{
			currentDecProjectile = Object.Instantiate(decProjectile, decProjectileSpawner.transform.position, decProjectileSpawner.transform.rotation);
			currentDecProjectile.transform.SetParent(decProjectileSpawner.transform, worldPositionStays: true);
			currentDecProjectile.GetComponentInChildren<Breakable>().interruptEnemy = eid;
			eid.weakPoint = currentDecProjectile;
		}
	}

	public void DamageStart()
	{
		if (!hasMelee)
		{
			if (tr == null)
			{
				tr = GetComponentInChildren<TrailRenderer>();
			}
			if (tr != null)
			{
				tr.enabled = true;
			}
		}
		zmb.ParryableCheck();
		if (aimer != null && (eid.enemyType != EnemyType.Schism || difficulty >= 4))
		{
			origRotation = aimer.rotation;
			aiming = true;
		}
	}

	public void ThrowProjectile()
	{
		if (currentDecProjectile != null)
		{
			Object.Destroy(currentDecProjectile);
			eid.weakPoint = origWP;
		}
		currentProjectile = Object.Instantiate(projectile, shootPos.position, base.transform.rotation);
		Projectile componentInChildren = currentProjectile.GetComponentInChildren<Projectile>();
		if (componentInChildren != null)
		{
			componentInChildren.target = eid.target;
			componentInChildren.safeEnemyType = EnemyType.Stray;
			if (difficulty > 2)
			{
				componentInChildren.speed *= 1.35f;
			}
			else if (difficulty == 1)
			{
				componentInChildren.speed *= 0.75f;
			}
			else if (difficulty == 0)
			{
				componentInChildren.speed *= 0.5f;
			}
			componentInChildren.damage *= eid.totalDamageModifier;
		}
		Vector3 worldPosition = currentProjectile.transform.position + base.transform.forward;
		EnemyTarget target = eid.target;
		if (target != null && target.isPlayer)
		{
			worldPosition = ((difficulty < 4) ? camObj.transform.position : MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(Vector3.Distance(currentProjectile.transform.position, camObj.transform.position) / (float)((difficulty == 5) ? 90 : Random.Range(110, 180)), aimAtHead: true));
		}
		else if (eid.target != null)
		{
			EnemyIdentifierIdentifier componentInChildren2 = eid.target.targetTransform.GetComponentInChildren<EnemyIdentifierIdentifier>();
			worldPosition = ((!componentInChildren2) ? eid.target.position : componentInChildren2.transform.position);
		}
		currentProjectile.transform.LookAt(worldPosition);
		ProjectileSpread componentInChildren3 = currentProjectile.GetComponentInChildren<ProjectileSpread>();
		if (!componentInChildren3)
		{
			return;
		}
		componentInChildren3.target = eid.target;
		if (difficulty <= 2)
		{
			if (difficulty == 2)
			{
				componentInChildren3.spreadAmount = 5f;
			}
			else if (difficulty == 1)
			{
				componentInChildren3.spreadAmount = 3f;
			}
			else if (difficulty == 0)
			{
				componentInChildren3.spreadAmount = 2f;
			}
			componentInChildren3.projectileAmount = 3;
		}
	}

	public void ShootProjectile(int skipOnEasy)
	{
		if (skipOnEasy > 0 && difficulty < 2)
		{
			return;
		}
		swinging = true;
		if (difficulty >= 4 && eid.enemyType == EnemyType.Schism && !predictionLerping && eid.target != null)
		{
			predictedPosition = (eid.target.isPlayer ? MonoSingleton<PlayerTracker>.Instance.PredictPlayerPosition(4f, aimAtHead: true, ignoreCollision: true) : eid.target.headPosition);
			if (eid.target.isPlayer)
			{
				predictedPosition.y = eid.target.headPosition.y;
			}
			predictionLerp = 0f;
			predictionLerping = true;
		}
		if (currentDecProjectile != null)
		{
			Object.Destroy(currentDecProjectile);
			eid.weakPoint = origWP;
		}
		currentProjectile = Object.Instantiate(projectile, decProjectileSpawner.transform.position, decProjectileSpawner.transform.rotation);
		Projectile component = currentProjectile.GetComponent<Projectile>();
		component.safeEnemyType = EnemyType.Schism;
		component.target = eid.target;
		if (difficulty > 2)
		{
			component.speed *= 1.25f;
		}
		else if (difficulty == 1)
		{
			component.speed *= 0.75f;
		}
		else if (difficulty == 0)
		{
			component.speed *= 0.5f;
		}
		component.damage *= eid.totalDamageModifier;
	}

	public void StopTracking()
	{
	}

	public void DamageEnd()
	{
		if (!hasMelee && tr != null)
		{
			tr.enabled = false;
		}
		if (currentDecProjectile != null)
		{
			Object.Destroy(currentDecProjectile);
			eid.weakPoint = origWP;
		}
		zmb.attacking = false;
		moveForward = false;
		if (aimer != null)
		{
			aimEase = 0f;
			aiming = false;
		}
	}

	public void CancelAttack()
	{
		swinging = false;
		blocking = false;
		aiming = false;
		coolDown = 0f;
		moveForward = false;
		if (currentDecProjectile != null)
		{
			Object.Destroy(currentDecProjectile);
			eid.weakPoint = origWP;
		}
		if (tr != null)
		{
			tr.enabled = false;
		}
		zmb.attacking = false;
	}

	private void Wander()
	{
		if (nma.isOnNavMesh)
		{
			Vector3 onUnitSphere = Random.onUnitSphere;
			onUnitSphere.y = 0f;
			if (Physics.Raycast(base.transform.position + Vector3.up, onUnitSphere, out var hitInfo, 15f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				wanderTarget = hitInfo.point;
			}
			else if (Physics.Raycast(base.transform.position + Vector3.up + onUnitSphere * 15f, Vector3.down, out hitInfo, 15f, LayerMaskDefaults.Get(LMD.Environment)))
			{
				wanderTarget = hitInfo.point;
			}
			else
			{
				wanderTarget = base.transform.position + onUnitSphere * 15f;
			}
			if (NavMesh.SamplePosition(wanderTarget, out var navMeshHit, 15f, 1))
			{
				wanderTarget = navMeshHit.position;
				SetDestination(navMeshHit.position);
			}
		}
	}

	public void Block(Vector3 attackPosition)
	{
		if (swinging)
		{
			CancelAttack();
		}
		swinging = true;
		blocking = true;
		aiming = false;
		seekingPlayer = false;
		nma.updateRotation = false;
		base.transform.LookAt(new Vector3(attackPosition.x, base.transform.position.y, attackPosition.z));
		zmb.KnockBack(base.transform.forward * -1f * 500f);
		Object.Instantiate(MonoSingleton<DefaultReferenceManager>.Instance.ineffectiveSound, base.transform.position, Quaternion.identity);
		nma.enabled = false;
		anim.Play("Block", -1, 0f);
	}
}


// Logic/BoolInputType.cs
namespace Logic{
public enum BoolInputType
{
	Set,
	Toggle
}
}

// Logic/BoolWatchMode.cs
namespace Logic{
public enum BoolWatchMode
{
	IsTrue,
	IsFalse,
	IsFalseOrNull,
	AnyValue
}
}

// Logic/FloatInputType.cs
namespace Logic{
public enum FloatInputType
{
	SetToNumber,
	AddNumber,
	RandomRange,
	RandomFromList,
	CopyDifferentVariable,
	MultiplyByNumber,
	MultiplyByVariable
}
}

// Logic/FloatWatchMode.cs
namespace Logic{
public enum FloatWatchMode
{
	GreaterThan,
	LessThan,
	EqualTo,
	NotEqualTo,
	AnyChange
}
}

// Logic/IntInputType.cs
namespace Logic{
public enum IntInputType
{
	SetToNumber,
	AddNumber,
	RandomRange,
	RandomFromList,
	CopyDifferentVariable
}
}

// Logic/IntWatchMode.cs
namespace Logic{
public enum IntWatchMode
{
	GreaterThan,
	LessThan,
	EqualTo,
	NotEqualTo,
	AnyChange
}
}

// Logic/MapBoolSetter.cs
namespace Logic{
public class MapBoolSetter : MapVarSetter
{
	public BoolInputType inputType;

	public bool value;

	public override void SetVar()
	{
		base.SetVar();
		switch (inputType)
		{
		case BoolInputType.Set:
			MonoSingleton<MapVarManager>.Instance.SetBool(variableName, value);
			break;
		case BoolInputType.Toggle:
		{
			bool flag = MonoSingleton<MapVarManager>.Instance.GetBool(variableName) ?? false;
			MonoSingleton<MapVarManager>.Instance.SetBool(variableName, !flag);
			break;
		}
		}
	}
}
}

// Logic/MapBoolWatcher.cs
namespace Logic{
[DefaultExecutionOrder(10)]
public class MapBoolWatcher : MapVarWatcher<bool?>
{
	[SerializeField]
	private BoolWatchMode watchMode;

	[SerializeField]
	private UnityEventBool onConditionMetWithValue;

	private bool? lastValue;

	private void OnEnable()
	{
		if (!registered)
		{
			if (MonoSingleton<MapVarManager>.Instance == null)
			{
				Debug.LogError("Unable to register MapBoolWatcher. Missing map variable manager.");
				return;
			}
			MonoSingleton<MapVarManager>.Instance.RegisterBoolWatcher(variableName, delegate(bool val)
			{
				ProcessEvent(val);
			});
			registered = true;
		}
		if (evaluateOnEnable)
		{
			ProcessEvent(MonoSingleton<MapVarManager>.Instance.GetBool(variableName));
		}
	}

	private void Update()
	{
		if (continuouslyActivateOnSuccess && lastState)
		{
			CallEvents();
		}
	}

	protected override void ProcessEvent(bool? value)
	{
		base.ProcessEvent(value);
		if (watchMode == BoolWatchMode.IsFalseOrNull || lastValue != value)
		{
			lastValue = value;
			bool flag = EvaluateState(value);
			if (flag != lastState)
			{
				lastState = flag;
				CallEvents();
			}
		}
	}

	protected override bool EvaluateState(bool? newValue)
	{
		switch (watchMode)
		{
		case BoolWatchMode.IsTrue:
			if (newValue.HasValue)
			{
				return newValue.Value;
			}
			return false;
		case BoolWatchMode.IsFalse:
			if (newValue.HasValue)
			{
				return !newValue.Value;
			}
			return false;
		case BoolWatchMode.IsFalseOrNull:
			if (newValue.HasValue)
			{
				return !newValue.Value;
			}
			return true;
		case BoolWatchMode.AnyValue:
			return newValue.HasValue;
		default:
			return false;
		}
	}

	protected override void CallEvents()
	{
		base.CallEvents();
		onConditionMetWithValue.Invoke(lastValue ?? false);
	}
}
}

// Logic/MapFloatSetter.cs
namespace Logic{
public class MapFloatSetter : MapVarSetter
{
	[SerializeField]
	private FloatInputType inputType;

	[SerializeField]
	private string sourceVariableName;

	[SerializeField]
	private float min;

	[SerializeField]
	private float max = 1f;

	[SerializeField]
	private float[] list;

	[SerializeField]
	private float number;

	public override void SetVar()
	{
		base.SetVar();
		switch (inputType)
		{
		case FloatInputType.SetToNumber:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, number);
			break;
		case FloatInputType.RandomRange:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, Random.Range(min, max));
			break;
		case FloatInputType.RandomFromList:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, list[Random.Range(0, list.Length)]);
			break;
		case FloatInputType.AddNumber:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, (MonoSingleton<MapVarManager>.Instance.GetFloat(variableName) ?? 0f) + number);
			break;
		case FloatInputType.CopyDifferentVariable:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, MonoSingleton<MapVarManager>.Instance.GetFloat(sourceVariableName) ?? 0f);
			break;
		case FloatInputType.MultiplyByNumber:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, (MonoSingleton<MapVarManager>.Instance.GetFloat(variableName) ?? 1f) * number);
			break;
		case FloatInputType.MultiplyByVariable:
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, (MonoSingleton<MapVarManager>.Instance.GetFloat(variableName) ?? 1f) * (MonoSingleton<MapVarManager>.Instance.GetFloat(sourceVariableName) ?? 1f));
			break;
		}
	}
}
}

// Logic/MapFloatWatcher.cs
namespace Logic{
[DefaultExecutionOrder(10)]
public class MapFloatWatcher : MapVarWatcher<float?>
{
	[SerializeField]
	private FloatWatchMode watchMode;

	[SerializeField]
	private UnityEventFloat onConditionMetWithValue;

	[SerializeField]
	private float targetValue = 3f;

	private float? lastValue;

	private void OnEnable()
	{
		if (!registered)
		{
			if (MonoSingleton<MapVarManager>.Instance == null)
			{
				Debug.LogError("Unable to register MapFloatWatcher. Missing map variable manager.");
				return;
			}
			MonoSingleton<MapVarManager>.Instance.RegisterFloatWatcher(variableName, delegate(float val)
			{
				ProcessEvent(val);
			});
			registered = true;
		}
		if (evaluateOnEnable)
		{
			ProcessEvent(MonoSingleton<MapVarManager>.Instance.GetFloat(variableName));
		}
	}

	private void Update()
	{
		if (continuouslyActivateOnSuccess && lastState)
		{
			CallEvents();
		}
	}

	protected override void ProcessEvent(float? value)
	{
		base.ProcessEvent(value);
		if (lastValue != value)
		{
			lastValue = value;
			bool flag = EvaluateState(value);
			if (watchMode == FloatWatchMode.AnyChange || flag != lastState)
			{
				lastState = flag;
				CallEvents();
			}
		}
	}

	protected override bool EvaluateState(float? newValue)
	{
		return watchMode switch
		{
			FloatWatchMode.AnyChange => newValue.HasValue, 
			FloatWatchMode.EqualTo => newValue == targetValue, 
			FloatWatchMode.GreaterThan => newValue > targetValue, 
			FloatWatchMode.LessThan => newValue < targetValue, 
			FloatWatchMode.NotEqualTo => newValue != targetValue, 
			_ => false, 
		};
	}

	protected override void CallEvents()
	{
		base.CallEvents();
		onConditionMetWithValue.Invoke(lastValue ?? (-1f));
	}
}
}

// Logic/MapIntSetter.cs
namespace Logic{
public class MapIntSetter : MapVarSetter
{
	[SerializeField]
	private IntInputType inputType;

	[SerializeField]
	private string sourceVariableName;

	[SerializeField]
	private int min;

	[SerializeField]
	private int max = 1;

	[SerializeField]
	private int[] list;

	[SerializeField]
	private int number;

	public override void SetVar()
	{
		base.SetVar();
		switch (inputType)
		{
		case IntInputType.SetToNumber:
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, number);
			break;
		case IntInputType.RandomRange:
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, Random.Range(min, max));
			break;
		case IntInputType.RandomFromList:
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, list[Random.Range(0, list.Length)]);
			break;
		case IntInputType.AddNumber:
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, number + (MonoSingleton<MapVarManager>.Instance.GetInt(variableName) ?? 0));
			break;
		case IntInputType.CopyDifferentVariable:
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, MonoSingleton<MapVarManager>.Instance.GetInt(sourceVariableName) ?? (-1));
			break;
		}
	}
}
}

// Logic/MapIntWatcher.cs
namespace Logic{
[DefaultExecutionOrder(10)]
public class MapIntWatcher : MapVarWatcher<int?>
{
	[SerializeField]
	private IntWatchMode watchMode;

	[SerializeField]
	private UnityEventInt onConditionMetWithValue;

	[SerializeField]
	private int targetValue;

	private int? lastValue;

	private void OnEnable()
	{
		if (!registered)
		{
			if (MonoSingleton<MapVarManager>.Instance == null)
			{
				Debug.LogError("Unable to register MapIntWatcher. Missing map variable manager.");
				return;
			}
			MonoSingleton<MapVarManager>.Instance.RegisterIntWatcher(variableName, delegate(int val)
			{
				ProcessEvent(val);
			});
			registered = true;
		}
		if (evaluateOnEnable)
		{
			ProcessEvent(MonoSingleton<MapVarManager>.Instance.GetInt(variableName));
		}
	}

	private void Update()
	{
		if (continuouslyActivateOnSuccess && lastState)
		{
			CallEvents();
		}
	}

	protected override void ProcessEvent(int? value)
	{
		base.ProcessEvent(value);
		if (lastValue != value)
		{
			lastValue = value;
			bool flag = EvaluateState(value);
			if (watchMode == IntWatchMode.AnyChange || flag != lastState)
			{
				lastState = flag;
				CallEvents();
			}
		}
	}

	protected override bool EvaluateState(int? newValue)
	{
		return watchMode switch
		{
			IntWatchMode.AnyChange => newValue.HasValue, 
			IntWatchMode.EqualTo => newValue == targetValue, 
			IntWatchMode.GreaterThan => newValue > targetValue, 
			IntWatchMode.LessThan => newValue < targetValue, 
			IntWatchMode.NotEqualTo => newValue != targetValue, 
			_ => false, 
		};
	}

	protected override void CallEvents()
	{
		base.CallEvents();
		onConditionMetWithValue.Invoke(lastValue ?? (-1));
	}
}
}

// Logic/MapStringSetter.cs
namespace Logic{
public class MapStringSetter : MapVarSetter
{
	[SerializeField]
	private StringInputType inputType;

	[SerializeField]
	private string sourceVariableName;

	[SerializeField]
	private VariableType sourceVariableType;

	[SerializeField]
	private string textValue;

	public override void SetVar()
	{
		base.SetVar();
		switch (inputType)
		{
		case StringInputType.JustText:
			MonoSingleton<MapVarManager>.Instance.SetString(variableName, textValue);
			break;
		case StringInputType.CopyDifferentVariable:
			if (sourceVariableType == VariableType.String)
			{
				MonoSingleton<MapVarManager>.Instance.SetString(variableName, MonoSingleton<MapVarManager>.Instance.GetString(sourceVariableName));
			}
			else if (sourceVariableType == VariableType.Int)
			{
				MonoSingleton<MapVarManager>.Instance.SetString(variableName, MonoSingleton<MapVarManager>.Instance.GetInt(sourceVariableName).ToString());
			}
			else if (sourceVariableType == VariableType.Float)
			{
				MonoSingleton<MapVarManager>.Instance.SetString(variableName, MonoSingleton<MapVarManager>.Instance.GetFloat(sourceVariableName).ToString());
			}
			else if (sourceVariableType == VariableType.Bool)
			{
				MonoSingleton<MapVarManager>.Instance.SetString(variableName, MonoSingleton<MapVarManager>.Instance.GetBool(sourceVariableName).ToString());
			}
			break;
		}
	}
}
}

// Logic/MapVarManager.cs
namespace Logic{
[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class MapVarManager : MonoSingleton<MapVarManager>
{
	private static readonly plog.Logger Log = new plog.Logger("MapVarManager");

	private VarStore currentStore = new VarStore();

	private VarStore stashedStore;

	private MapVarSaver saver = new MapVarSaver();

	private readonly Dictionary<string, List<UnityAction<int>>> intSubscribers = new Dictionary<string, List<UnityAction<int>>>();

	private readonly Dictionary<string, List<UnityAction<bool>>> boolSubscribers = new Dictionary<string, List<UnityAction<bool>>>();

	private readonly Dictionary<string, List<UnityAction<float>>> floatSubscribers = new Dictionary<string, List<UnityAction<float>>>();

	private readonly Dictionary<string, List<UnityAction<string>>> stringSubscribers = new Dictionary<string, List<UnityAction<string>>>();

	private readonly List<UnityAction<string, object>> globalSubscribers = new List<UnityAction<string, object>>();

	public static bool LoggingEnabled = false;

	public VarStore Store => currentStore;

	public bool HasStashedStore => stashedStore != null;

	private void Start()
	{
		if (Debug.isDebugBuild)
		{
			LoggingEnabled = true;
		}
	}

	public void ReloadMapVars()
	{
		ResetStores();
		RestorePersistent();
	}

	public void ResetStores()
	{
		if (LoggingEnabled)
		{
			Log.Info("Resetting MapVar stores");
		}
		currentStore.Clear();
		stashedStore = null;
		intSubscribers.Clear();
		boolSubscribers.Clear();
		floatSubscribers.Clear();
		stringSubscribers.Clear();
		LoggingEnabled = false;
	}

	private void RestorePersistent()
	{
		VarStore varStore = VarStore.LoadPersistentStore();
		if (varStore != null)
		{
			currentStore = varStore;
		}
	}

	public void StashStore()
	{
		if (currentStore.intStore.Count == 0 && currentStore.boolStore.Count == 0 && currentStore.floatStore.Count == 0 && currentStore.stringStore.Count == 0)
		{
			stashedStore = null;
			return;
		}
		stashedStore = currentStore.DuplicateStore();
		if (LoggingEnabled)
		{
			Log.Info("Stashed MapVar stores");
		}
	}

	public void RestoreStashedStore()
	{
		if (stashedStore == null)
		{
			if (LoggingEnabled)
			{
				Log.Info("No stashed store to restore");
			}
			return;
		}
		currentStore = stashedStore.DuplicateStore();
		if (LoggingEnabled)
		{
			Log.Info("Restored MapVar stores");
		}
	}

	public void RegisterIntWatcher(string key, UnityAction<int> callback)
	{
		if (LoggingEnabled)
		{
			Log.Info("Registering int watcher for " + key);
		}
		if (!intSubscribers.ContainsKey(key))
		{
			intSubscribers.Add(key, new List<UnityAction<int>>());
		}
		intSubscribers[key].Add(callback);
	}

	public void RegisterBoolWatcher(string key, UnityAction<bool> callback)
	{
		if (LoggingEnabled)
		{
			Log.Info("Registering bool watcher for " + key);
		}
		if (!boolSubscribers.ContainsKey(key))
		{
			boolSubscribers.Add(key, new List<UnityAction<bool>>());
		}
		boolSubscribers[key].Add(callback);
	}

	public void RegisterFloatWatcher(string key, UnityAction<float> callback)
	{
		if (LoggingEnabled)
		{
			Log.Info("Registering float watcher for " + key);
		}
		if (!floatSubscribers.ContainsKey(key))
		{
			floatSubscribers.Add(key, new List<UnityAction<float>>());
		}
		floatSubscribers[key].Add(callback);
	}

	public void RegisterStringWatcher(string key, UnityAction<string> callback)
	{
		if (LoggingEnabled)
		{
			Log.Info("Registering string watcher for " + key);
		}
		if (!stringSubscribers.ContainsKey(key))
		{
			stringSubscribers.Add(key, new List<UnityAction<string>>());
		}
		stringSubscribers[key].Add(callback);
	}

	public void RegisterGlobalWatcher(UnityAction<string, object> callback)
	{
		if (LoggingEnabled)
		{
			Log.Info("Registering global watcher");
		}
		globalSubscribers.Add(callback);
	}

	public void SetInt(string key, int value, bool persistent = false)
	{
		currentStore.intStore[key] = value;
		if (intSubscribers.ContainsKey(key))
		{
			if (LoggingEnabled)
			{
				Log.Info(string.Format("Notifying {0} int watcher{1} for {2}", intSubscribers[key].Count, (intSubscribers[key].Count == 1) ? "" : "s", key));
			}
			foreach (UnityAction<int> item in intSubscribers[key])
			{
				item?.Invoke(value);
			}
		}
		if (globalSubscribers.Count <= 0)
		{
			return;
		}
		if (LoggingEnabled)
		{
			Log.Info(string.Format("Notifying {0} global watcher{1} for {2}", globalSubscribers.Count, (globalSubscribers.Count == 1) ? "" : "s", key));
		}
		foreach (UnityAction<string, object> globalSubscriber in globalSubscribers)
		{
			globalSubscriber?.Invoke(key, value);
		}
	}

	public void AddInt(string key, int value, bool persistent = false)
	{
		int num = GetInt(key) ?? 0;
		SetInt(key, num + value, persistent);
	}

	public void SetBool(string key, bool value, bool persistent = false)
	{
		if (LoggingEnabled)
		{
			Log.Info($"SetBool: {key} - {value}");
		}
		currentStore.boolStore[key] = value;
		if (boolSubscribers.ContainsKey(key))
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {boolSubscribers[key].Count} bool watchers for {key}");
			}
			foreach (UnityAction<bool> item in boolSubscribers[key])
			{
				item?.Invoke(value);
			}
		}
		if (globalSubscribers.Count > 0)
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {globalSubscribers.Count} global watchers for {key}");
			}
			foreach (UnityAction<string, object> globalSubscriber in globalSubscribers)
			{
				globalSubscriber?.Invoke(key, value);
			}
		}
		if (persistent)
		{
			currentStore.persistentKeys.Add(key);
			saver.WritePersistent(currentStore);
		}
		else
		{
			currentStore.persistentKeys.Remove(key);
		}
	}

	public void SetFloat(string key, float value, bool persistent = false)
	{
		if (LoggingEnabled)
		{
			Log.Info($"SetFloat: {key} - {value}");
		}
		currentStore.floatStore[key] = value;
		if (floatSubscribers.ContainsKey(key))
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {floatSubscribers[key].Count} float watchers for {key}");
			}
			foreach (UnityAction<float> item in floatSubscribers[key])
			{
				item?.Invoke(value);
			}
		}
		if (globalSubscribers.Count > 0)
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {globalSubscribers.Count} global watchers for {key}");
			}
			foreach (UnityAction<string, object> globalSubscriber in globalSubscribers)
			{
				globalSubscriber?.Invoke(key, value);
			}
		}
		if (persistent)
		{
			currentStore.persistentKeys.Add(key);
			saver.WritePersistent(currentStore);
		}
		else
		{
			currentStore.persistentKeys.Remove(key);
		}
	}

	public void SetString(string key, string value, bool persistent = false)
	{
		if (LoggingEnabled)
		{
			Log.Info("SetString: " + key + " - " + value);
		}
		currentStore.stringStore[key] = value;
		if (stringSubscribers.ContainsKey(key))
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {stringSubscribers[key].Count} string watchers for {key}");
			}
			foreach (UnityAction<string> item in stringSubscribers[key])
			{
				item?.Invoke(value);
			}
		}
		if (globalSubscribers.Count > 0)
		{
			if (LoggingEnabled)
			{
				Log.Info($"Notifying {globalSubscribers.Count} global watchers for {key}");
			}
			foreach (UnityAction<string, object> globalSubscriber in globalSubscribers)
			{
				globalSubscriber?.Invoke(key, value);
			}
		}
		if (persistent)
		{
			currentStore.persistentKeys.Add(key);
			saver.WritePersistent(currentStore);
		}
		else
		{
			currentStore.persistentKeys.Remove(key);
		}
	}

	public int? GetInt(string key)
	{
		if (currentStore.intStore.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public bool? GetBool(string key)
	{
		if (currentStore.boolStore.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public float? GetFloat(string key)
	{
		if (currentStore.floatStore.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public string GetString(string key)
	{
		if (currentStore.stringStore.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public List<VariableSnapshot> GetAllVariables()
	{
		List<VariableSnapshot> list = new List<VariableSnapshot>();
		foreach (KeyValuePair<string, int> item in currentStore.intStore)
		{
			list.Add(new VariableSnapshot
			{
				type = typeof(int),
				name = item.Key,
				value = item.Value
			});
		}
		foreach (KeyValuePair<string, bool> item2 in currentStore.boolStore)
		{
			list.Add(new VariableSnapshot
			{
				type = typeof(bool),
				name = item2.Key,
				value = item2.Value
			});
		}
		foreach (KeyValuePair<string, float> item3 in currentStore.floatStore)
		{
			list.Add(new VariableSnapshot
			{
				type = typeof(float),
				name = item3.Key,
				value = item3.Value
			});
		}
		foreach (KeyValuePair<string, string> item4 in currentStore.stringStore)
		{
			list.Add(new VariableSnapshot
			{
				type = typeof(string),
				name = item4.Key,
				value = item4.Value
			});
		}
		return list;
	}
}
}

// Logic/MapVarSaver.cs
namespace Logic{
public class MapVarSaver
{
	public const string BuiltInPrefix = "ultrakill_";

	public static string MapVarDirectory => Path.Combine(GameProgressSaver.SavePath, "MapVars");

	public static string AssembleCurrentFilePath()
	{
		if (!Directory.Exists(MapVarDirectory))
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		if (!SceneHelper.IsPlayingCustom)
		{
			stringBuilder.Append("ultrakill_");
			stringBuilder.Append(SceneHelper.CurrentScene);
		}
		else
		{
			MapInfo instance = MapInfo.Instance;
			if (instance == null)
			{
				return null;
			}
			if (instance.uniqueId == null)
			{
				return null;
			}
			if (instance.uniqueId.StartsWith("ultrakill_"))
			{
				return null;
			}
			stringBuilder.Append(instance.uniqueId);
		}
		stringBuilder.Append(".vars.json");
		return Path.Combine(MapVarDirectory, stringBuilder.ToString());
	}

	public void WritePersistent(VarStore store)
	{
		List<SavedVariable> list = new List<SavedVariable>();
		foreach (string key in store.persistentKeys)
		{
			if (list.Any((SavedVariable var) => var.name == key))
			{
				return;
			}
			SavedValue value2;
			bool value3;
			float value4;
			if (store.intStore.TryGetValue(key, out var value))
			{
				value2 = new SavedValue
				{
					type = typeof(int).FullName,
					value = value.ToString()
				};
			}
			else if (store.boolStore.TryGetValue(key, out value3))
			{
				value2 = new SavedValue
				{
					type = typeof(bool).FullName,
					value = value3
				};
			}
			else if (store.floatStore.TryGetValue(key, out value4))
			{
				value2 = new SavedValue
				{
					type = typeof(float).FullName,
					value = value4.ToString(CultureInfo.InvariantCulture)
				};
			}
			else
			{
				if (!store.stringStore.TryGetValue(key, out var value5))
				{
					continue;
				}
				value2 = new SavedValue
				{
					type = typeof(string).FullName,
					value = value5
				};
			}
			list.Add(new SavedVariable
			{
				name = key,
				value = value2
			});
		}
		if (list.Count != 0)
		{
			if (!Directory.Exists(MapVarDirectory))
			{
				Directory.CreateDirectory(MapVarDirectory);
			}
			string text = AssembleCurrentFilePath();
			if (text != null)
			{
				string contents = JsonConvert.SerializeObject(new PersistentSavedStore
				{
					variables = list
				});
				File.WriteAllText(text, contents);
			}
		}
	}
}
}

// Logic/MapVarSetter.cs
namespace Logic{
public abstract class MapVarSetter : MonoBehaviour
{
	public string variableName;

	public VariablePersistence persistence;

	public bool setOnEnable = true;

	public bool setEveryFrame;

	private void OnEnable()
	{
		if (setOnEnable)
		{
			SetVar();
		}
	}

	private void Update()
	{
		if (setEveryFrame)
		{
			SetVar();
		}
	}

	public virtual void SetVar()
	{
	}
}
}

// Logic/MapVarStringBuilder.cs
namespace Logic{
public class MapVarStringBuilder : MonoBehaviour
{
	[Header("Input")]
	public StringPart[] stringParts;

	[Header("Output")]
	[SerializeField]
	private string stringVariableName;

	[SerializeField]
	private TextSetMethod textMethod;

	[SerializeField]
	private Text textTarget;

	[Header("Events")]
	[SerializeField]
	private bool buildOnEnable;

	[SerializeField]
	private bool buildOnUpdate;

	private void OnEnable()
	{
		if (buildOnEnable)
		{
			BuildString();
		}
	}

	private void Update()
	{
		if (buildOnUpdate)
		{
			BuildString();
		}
	}

	public void BuildString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		StringPart[] array = stringParts;
		foreach (StringPart stringPart in array)
		{
			stringBuilder.Append(stringPart.GetString());
		}
		if (textTarget != null)
		{
			if (textMethod == TextSetMethod.SetText)
			{
				textTarget.text = stringBuilder.ToString();
			}
			else if (textMethod == TextSetMethod.AppendText)
			{
				textTarget.text += stringBuilder.ToString();
			}
			else if (textMethod == TextSetMethod.PrependText)
			{
				textTarget.text = stringBuilder.ToString() + textTarget.text;
			}
		}
		if (!string.IsNullOrEmpty(stringVariableName))
		{
			MonoSingleton<MapVarManager>.Instance.SetString(stringVariableName, stringBuilder.ToString());
		}
	}
}
}

// Logic/MapVarWatcher.cs
namespace Logic{
public abstract class MapVarWatcher<T> : MonoBehaviour
{
	[SerializeField]
	protected string variableName;

	[Tooltip("If true, the watcher will check its state immediately after being enabled or spawned.")]
	[SerializeField]
	protected bool evaluateOnEnable = true;

	[Tooltip("The component will be disabled after the event is executed")]
	[SerializeField]
	protected bool onlyActivateOnce;

	[Tooltip("Call the event every frame if the conditions are met")]
	[SerializeField]
	protected bool continuouslyActivateOnSuccess;

	protected bool lastState;

	protected bool registered;

	[SerializeField]
	protected UltrakillEvent onConditionMet;

	protected virtual void ProcessEvent(T value)
	{
	}

	protected virtual bool EvaluateState(T newValue)
	{
		return false;
	}

	protected virtual void CallEvents()
	{
		if (lastState)
		{
			onConditionMet.Invoke();
		}
		else
		{
			onConditionMet.Revert();
		}
	}
}
}

// Logic/PersistentSavedStore.cs
namespace Logic{
public class PersistentSavedStore
{
	public List<SavedVariable> variables;
}
}

// Logic/SavedValue.cs
namespace Logic{
public class SavedValue
{
	public string type;

	public object value;
}
}

// Logic/SavedVariable.cs
namespace Logic{
public class SavedVariable
{
	public string name;

	public SavedValue value;
}
}

// Logic/StringInputType.cs
namespace Logic{
public enum StringInputType
{
	JustText,
	CopyDifferentVariable
}
}

// Logic/StringPart.cs
namespace Logic{
[Serializable]
public struct StringPart
{
	public StringPartType type;

	public VariableType variableType;

	public string value;

	public string GetString()
	{
		switch (type)
		{
		case StringPartType.Variable:
			switch (variableType)
			{
			case VariableType.Bool:
				return MonoSingleton<MapVarManager>.Instance.GetBool(value).ToString();
			case VariableType.Int:
				return MonoSingleton<MapVarManager>.Instance.GetInt(value).ToString();
			case VariableType.String:
				return MonoSingleton<MapVarManager>.Instance.GetString(value);
			case VariableType.Float:
				return MonoSingleton<MapVarManager>.Instance.GetFloat(value).ToString();
			}
			break;
		case StringPartType.NormalText:
			return value;
		case StringPartType.NewLine:
			return "\n";
		}
		return string.Empty;
	}
}
}

// Logic/StringPartType.cs
namespace Logic{
public enum StringPartType
{
	NormalText,
	NewLine,
	Variable
}
}

// Logic/TextSetMethod.cs
namespace Logic{
public enum TextSetMethod
{
	SetText,
	AppendText,
	PrependText
}
}

// Logic/UnityEventBool.cs
namespace Logic{
[Serializable]
public sealed class UnityEventBool : UnityEvent<bool>
{
}
}

// Logic/UnityEventFloat.cs
namespace Logic{
[Serializable]
public sealed class UnityEventFloat : UnityEvent<float>
{
}
}

// Logic/UnityEventInt.cs
namespace Logic{
[Serializable]
public sealed class UnityEventInt : UnityEvent<int>
{
}
}

// Logic/VariablePersistence.cs
namespace Logic{
public enum VariablePersistence
{
	Session,
	SavedAsMap,
	SavedAsCampaign
}
}

// Logic/VariableSnapshot.cs
namespace Logic{
public struct VariableSnapshot
{
	public Type type;

	public string name;

	public object value;
}
}

// Logic/VariableType.cs
namespace Logic{
public enum VariableType
{
	Bool,
	Int,
	String,
	Float
}
}

// Logic/VarStore.cs
namespace Logic{
public class VarStore
{
	private static readonly Logger Log = new Logger("VarStore");

	public HashSet<string> persistentKeys = new HashSet<string>();

	public Dictionary<string, int> intStore = new Dictionary<string, int>();

	public Dictionary<string, bool> boolStore = new Dictionary<string, bool>();

	public Dictionary<string, float> floatStore = new Dictionary<string, float>();

	public Dictionary<string, string> stringStore = new Dictionary<string, string>();

	public void Clear()
	{
		intStore.Clear();
		boolStore.Clear();
		floatStore.Clear();
		stringStore.Clear();
	}

	public VarStore DuplicateStore()
	{
		return new VarStore
		{
			intStore = new Dictionary<string, int>(intStore),
			boolStore = new Dictionary<string, bool>(boolStore),
			floatStore = new Dictionary<string, float>(floatStore),
			stringStore = new Dictionary<string, string>(stringStore)
		};
	}

	public static VarStore LoadPersistentStore()
	{
		VarStore varStore = new VarStore();
		string path = MapVarSaver.AssembleCurrentFilePath();
		if (!File.Exists(path))
		{
			return null;
		}
		string value = File.ReadAllText(path);
		if (string.IsNullOrEmpty(value))
		{
			return null;
		}
		PersistentSavedStore persistentSavedStore = JsonConvert.DeserializeObject<PersistentSavedStore>(value);
		if (persistentSavedStore == null)
		{
			return null;
		}
		if (persistentSavedStore.variables == null)
		{
			return null;
		}
		foreach (SavedVariable variable in persistentSavedStore.variables)
		{
			if (variable?.value != null && !string.IsNullOrEmpty(variable.value.type))
			{
				LoadVariable(variable, varStore);
				varStore.persistentKeys.Add(variable.name);
			}
		}
		return varStore;
	}

	public static void LoadVariable(SavedVariable variable, VarStore store)
	{
		Log.Info("Loading variable: $" + variable.name);
		if (variable.value.type == "System.String")
		{
			if (variable.value.type == "System.String")
			{
				store.stringStore[variable.value.type] = variable.value.value.ToString();
			}
		}
		else if (variable.value.type == "System.Boolean")
		{
			if (variable.value.type == "System.Boolean")
			{
				store.boolStore[variable.value.type] = (variable.value.value as bool?) ?? false;
			}
		}
		else if (variable.value.type == "System.Int32")
		{
			if (variable.value.type == "System.Int32")
			{
				store.intStore[variable.value.type] = int.Parse(variable.value.value.ToString());
			}
		}
		else if (variable.value.type == "System.Single")
		{
			if (variable.value.type == "System.Single")
			{
				store.floatStore[variable.value.type] = float.Parse(variable.value.value.ToString());
			}
		}
		else
		{
			Log.Warning("Unknown variable type: " + variable.value.type + ", on variable: " + variable.name);
		}
	}
}
}

// Train/ConnectedTram.cs
namespace Train{
public class ConnectedTram : MonoBehaviour
{
	public float offset = 10f;

	private Tram thisTram;

	private void Awake()
	{
		thisTram = GetComponent<Tram>();
	}

	public void UpdateTram(TramPath parentPath)
	{
		if (parentPath == null)
		{
			return;
		}
		thisTram.currentPath = new TramPath(parentPath.start, parentPath.end);
		float num = offset / parentPath.DistanceTotal;
		float num2 = parentPath.Progress - num;
		if (num2 < 0f)
		{
			float num3 = (0f - num2) * parentPath.DistanceTotal;
			TramPath tramPath = new TramPath(parentPath.start, parentPath.end);
			while (num3 > 0f && tramPath.start.GetDestination(forward: false) != null)
			{
				tramPath = new TramPath(tramPath.start.GetDestination(forward: false), tramPath.start);
				if (num3 <= tramPath.DistanceTotal)
				{
					thisTram.currentPath = tramPath;
					thisTram.currentPath.distanceTravelled = tramPath.DistanceTotal - num3;
					num3 = 0f;
				}
				else
				{
					num3 -= tramPath.DistanceTotal;
				}
			}
			thisTram.UpdateWorldRotation();
			thisTram.UpdateWorldPosition();
		}
		else
		{
			if (!thisTram.currentPath.Equals(parentPath))
			{
				thisTram.currentPath = new TramPath(parentPath.start, parentPath.end);
			}
			thisTram.currentPath.distanceTravelled = num2 * thisTram.currentPath.DistanceTotal;
			thisTram.UpdateWorldRotation();
			thisTram.UpdateWorldPosition();
		}
	}
}
}

// Train/PathInterpolation.cs
namespace Train{
public enum PathInterpolation
{
	Linear,
	SphericalManual,
	SphericalAutomatic
}
}

// Train/PathTools.cs
namespace Train{
public static class PathTools
{
	public static Vector3 InterpolateAlongCircle(Vector3 start, Vector3 end, Vector3 center, float t)
	{
		Vector3 a = start - center;
		Vector3 b = end - center;
		Vector3 vector = Vector3.Slerp(a, b, t);
		return center + vector;
	}

	public static Vector3 ComputeSphericalCurveCenter(Vector3 start, Vector3 end, bool reverse = false, float angle = 45f)
	{
		Vector3 vector = (start + end) * 0.5f;
		Vector3 vector2 = vector - start;
		Vector3 vector3 = end - start;
		bool flag = vector3.x * vector2.z - vector3.z * vector2.x < 0f;
		if (reverse)
		{
			flag = !flag;
		}
		Vector3 axis = (flag ? new Vector3(0f, -1f, 0f) : new Vector3(0f, 1f, 0f));
		return vector + (Quaternion.AngleAxis(90f, axis) * (start - vector)).normalized * (start - vector).magnitude / Mathf.Tan((float)Math.PI / 180f * angle / 2f);
	}
}
}

// Train/StopBehaviour.cs
namespace Train{
public enum StopBehaviour
{
	InstantClank,
	EaseOut
}
}

// Train/TrackCurveSettings.cs
namespace Train{
[Serializable]
public class TrackCurveSettings
{
	[HideInInspector]
	public PathInterpolation curve;

	[HideInInspector]
	public Transform handle;

	[HideInInspector]
	[Range(1f, 90f)]
	public float angle = 90f;

	[HideInInspector]
	public bool flipCurve;
}
}

// Train/TrainTrackPoint.cs
namespace Train{
public class TrainTrackPoint : MonoBehaviour
{
	[HideInInspector]
	public int instanceId;

	public List<TrainTrackPoint> forwardPoints;

	public List<TrainTrackPoint> backwardPoints;

	public StopBehaviour stopBehaviour;

	[HideInInspector]
	public int forwardPath;

	[HideInInspector]
	public int backwardPath;

	[HideInInspector]
	public TrackCurveSettings forwardCurveSettings;

	private static readonly Color ForwardActive = Color.green;

	private static readonly Color BackwardActive = new Color(0.4f, 0.6f, 0.5f);

	public TrainTrackPoint GetDestination(bool forward = true)
	{
		TrainTrackPoint trainTrackPoint;
		if (forward)
		{
			if (forwardPoints == null || forwardPoints.Count == 0 || forwardPoints.All((TrainTrackPoint point) => point == null))
			{
				return null;
			}
			trainTrackPoint = forwardPoints[forwardPath];
		}
		else
		{
			if (backwardPoints == null || backwardPoints.Count == 0 || backwardPoints.All((TrainTrackPoint point) => point == null))
			{
				return null;
			}
			trainTrackPoint = backwardPoints[backwardPath];
		}
		if (trainTrackPoint == null || !trainTrackPoint.gameObject.activeSelf)
		{
			return null;
		}
		return trainTrackPoint;
	}

	private void OnDrawGizmos()
	{
		_ = base.transform.position;
		DrawPaths(forwardPoints, forwardPath, backward: false);
		DrawPaths(backwardPoints, backwardPath, backward: true);
	}

	private void Update()
	{
		DrawPaths(forwardPoints, forwardPath, backward: false);
		DrawPaths(backwardPoints, backwardPath, backward: true);
	}

	private void DrawPaths(IReadOnlyList<TrainTrackPoint> points, int path, bool backward)
	{
		Vector3 position = base.transform.position;
		if (points == null)
		{
			return;
		}
		for (int i = 0; i < points.Count; i++)
		{
			TrainTrackPoint trainTrackPoint = points[i];
			if (trainTrackPoint == null)
			{
				continue;
			}
			Vector3 position2 = trainTrackPoint.transform.position;
			bool flag = !trainTrackPoint.gameObject.activeSelf;
			if (path != i || flag)
			{
				_ = Color.red;
			}
			else if (!backward)
			{
				_ = ForwardActive;
			}
			else
			{
				_ = BackwardActive;
			}
			TrackCurveSettings trackCurveSettings = (backward ? trainTrackPoint.forwardCurveSettings : forwardCurveSettings);
			if (trackCurveSettings.curve == PathInterpolation.Linear)
			{
				Vector3 b = Vector3.Lerp(position, position2, flag ? 1f : 0.5f);
				new Shape.Line(position, b);
			}
			else
			{
				if (trackCurveSettings.curve == PathInterpolation.SphericalManual && trackCurveSettings.handle == null)
				{
					continue;
				}
				int num = 16;
				TrainTrackPoint startPoint = (backward ? trainTrackPoint : this);
				TrainTrackPoint endPoint = (backward ? this : trainTrackPoint);
				for (int j = 0; j <= num; j++)
				{
					float num2 = (float)j / (float)num;
					if (!flag)
					{
						num2 *= 0.5f;
					}
					if (backward)
					{
						num2 = 1f - num2;
					}
					TramPath.GetPointOnSimulatedPath(num2, startPoint, endPoint);
				}
			}
		}
	}
}
}

// Train/Tram.cs
namespace Train{
public class Tram : MonoBehaviour
{
	public bool poweredOn = true;

	private AudioSource aud;

	public GameObject bonkSound;

	public GameObject deathZones;

	[HideInInspector]
	public float zapAmount;

	public float speed;

	public ConnectedTram[] connectedTrams;

	[Space]
	public TrainTrackPoint currentPoint;

	public TramPath currentPath;

	private ScreenZone[] screenActivators;

	[HideInInspector]
	public TramControl controller;

	public bool canGoForward { get; private set; }

	public bool canGoBackward { get; private set; }

	public TramMovementDirection movementDirection
	{
		get
		{
			if (!(speed > 0f))
			{
				if (!(speed < 0f))
				{
					return TramMovementDirection.None;
				}
				return TramMovementDirection.Backward;
			}
			return TramMovementDirection.Forward;
		}
	}

	public float directionMod => (speed > 0f) ? 1 : (-1);

	public float computedSpeed => speed * inheritedSpeedMultiplier;

	public float inheritedSpeedMultiplier
	{
		get
		{
			if (!(zapAmount > 0f))
			{
				return currentPath?.MaxSpeedMultiplier(movementDirection, speed) ?? 1f;
			}
			return Mathf.Lerp(currentPath?.MaxSpeedMultiplier(movementDirection, speed) ?? 1f, 2f, zapAmount);
		}
	}

	public float backwardOffset
	{
		get
		{
			if (connectedTrams != null && connectedTrams.Length != 0)
			{
				return connectedTrams.Sum((ConnectedTram tram) => tram.offset);
			}
			return 0f;
		}
	}

	public void TurnOn()
	{
		poweredOn = true;
		if (screenActivators != null && screenActivators.Length != 0)
		{
			ScreenZone[] array = screenActivators;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: true);
			}
		}
	}

	public void ShutDown()
	{
		poweredOn = false;
		if (screenActivators == null || screenActivators.Length == 0)
		{
			return;
		}
		ScreenZone[] array = screenActivators;
		foreach (ScreenZone screenZone in array)
		{
			ObjectActivator[] components = screenZone.GetComponents<ObjectActivator>();
			if (components != null && components.Length != 0)
			{
				ObjectActivator[] array2 = components;
				foreach (ObjectActivator objectActivator in array2)
				{
					if (objectActivator.events.toActivateObjects != null && objectActivator.events.toActivateObjects.Length != 0)
					{
						GameObject[] toActivateObjects = objectActivator.events.toActivateObjects;
						for (int k = 0; k < toActivateObjects.Length; k++)
						{
							toActivateObjects[k].SetActive(value: false);
						}
					}
				}
			}
			screenZone.gameObject.SetActive(value: false);
		}
	}

	public void StopAndTeleport(TrainTrackPoint point)
	{
		currentPoint = point;
		currentPath = null;
		speed = 0f;
		TrainTrackPoint destination = currentPoint.GetDestination();
		TrainTrackPoint destination2 = currentPoint.GetDestination(forward: false);
		TramPath tramPath = null;
		if ((bool)destination)
		{
			tramPath = new TramPath(currentPoint, destination);
		}
		else if ((bool)destination2)
		{
			tramPath = new TramPath(destination2, currentPoint);
			tramPath.distanceTravelled = tramPath.DistanceTotal;
		}
		if (tramPath != null)
		{
			currentPath = tramPath;
			UpdateWorldRotation();
			ConnectedTram[] array = connectedTrams;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateTram(currentPath);
			}
			currentPath = null;
		}
	}

	private void Awake()
	{
		aud = GetComponent<AudioSource>();
		screenActivators = GetComponentsInChildren<ScreenZone>();
	}

	private void Update()
	{
		UpdateAudio();
	}

	private void FixedUpdate()
	{
		if (currentPath == null && currentPoint != null)
		{
			base.transform.position = currentPoint.transform.position;
			canGoForward = currentPoint.GetDestination() != null;
			canGoBackward = currentPoint.GetDestination(forward: false) != null;
		}
		if (speed != 0f)
		{
			if (currentPath == null && currentPoint != null)
			{
				ReceiveNewPath();
			}
			if (currentPath != null)
			{
				TraversePath();
			}
			deathZones.SetActive(value: true);
		}
		else
		{
			deathZones.SetActive(value: false);
		}
		if (currentPath != null)
		{
			UpdateWorldPosition();
			if (movementDirection != TramMovementDirection.None)
			{
				UpdateWorldRotation();
			}
			DrawPathPreview();
			ConnectedTram[] array = connectedTrams;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateTram(currentPath);
			}
		}
	}

	private void DrawPathPreview()
	{
		if (Debug.isDebugBuild)
		{
			int num = 16;
			Vector3 vector = base.transform.position;
			for (int i = 0; i < num; i++)
			{
				float progress = currentPath.Progress + (float)i / (float)num * directionMod;
				Vector3 pointOnPath = currentPath.GetPointOnPath(progress);
				Vector3 vector2 = Vector3.up * 1f;
				new Shape.Line(vector + vector2, pointOnPath + vector2);
				Vector3 vector3 = vector2 + new Vector3(0f, 0.125f, 0f);
				new Shape.Line(vector + vector3, pointOnPath + vector3);
				vector = pointOnPath;
			}
		}
	}

	private void TraversePath()
	{
		currentPath.distanceTravelled += computedSpeed * Time.deltaTime;
		if (!IsAtEndOfPath())
		{
			canGoForward = true;
			canGoBackward = true;
			return;
		}
		float num = currentPath.distanceTravelled;
		if (movementDirection == TramMovementDirection.Forward)
		{
			num -= currentPath.DistanceTotal;
		}
		if (movementDirection == TramMovementDirection.Backward && backwardOffset != 0f && currentPath.IsDeadEnd(movementDirection))
		{
			speed = 0f;
			canGoBackward = false;
			Object.Instantiate(bonkSound, base.transform.position, Quaternion.identity);
			return;
		}
		currentPoint = ((movementDirection == TramMovementDirection.Forward) ? currentPath.end : currentPath.start);
		_ = currentPoint != null;
		currentPath = null;
		ReceiveNewPath();
		if (currentPath != null)
		{
			currentPath.distanceTravelled += num;
			if (movementDirection == TramMovementDirection.Forward)
			{
				canGoForward = true;
			}
			else
			{
				canGoBackward = true;
			}
			return;
		}
		if (currentPoint.stopBehaviour == StopBehaviour.InstantClank || zapAmount > 0f)
		{
			Object.Instantiate(bonkSound, base.transform.position, Quaternion.identity);
		}
		if (movementDirection == TramMovementDirection.Forward)
		{
			canGoForward = false;
		}
		else
		{
			canGoBackward = false;
		}
		speed = 0f;
	}

	private bool IsAtEndOfPath()
	{
		if (currentPath == null)
		{
			return false;
		}
		float distanceTotal = currentPath.DistanceTotal;
		float num = 0f;
		if (movementDirection == TramMovementDirection.Backward && backwardOffset != 0f && currentPath.start.GetDestination(forward: false) == null)
		{
			num += backwardOffset;
		}
		if (movementDirection != 0)
		{
			return currentPath.distanceTravelled <= num;
		}
		return currentPath.distanceTravelled >= distanceTotal;
	}

	public void UpdateWorldPosition()
	{
		if (currentPath != null)
		{
			Vector3 pointOnPath = currentPath.GetPointOnPath(currentPath.Progress);
			base.transform.position = pointOnPath;
		}
	}

	public void UpdateWorldRotation()
	{
		if (currentPath != null)
		{
			Quaternion rotation = Quaternion.LookRotation(currentPath.MovementDirection(), Vector3.up);
			base.transform.rotation = rotation;
		}
	}

	private void ReceiveNewPath()
	{
		if (currentPoint == null)
		{
			return;
		}
		bool flag = movementDirection == TramMovementDirection.Forward;
		TrainTrackPoint destination = currentPoint.GetDestination(flag);
		if (!(destination == null))
		{
			TrainTrackPoint start = (flag ? currentPoint : destination);
			TrainTrackPoint end = (flag ? destination : currentPoint);
			TramPath tramPath = new TramPath(start, end);
			if (!flag)
			{
				tramPath.distanceTravelled = tramPath.DistanceTotal;
			}
			currentPath = tramPath;
			currentPoint = null;
		}
	}

	private void UpdateAudio()
	{
		if (computedSpeed != 0f && !aud.isPlaying)
		{
			aud.Play();
		}
		else if (computedSpeed == 0f && aud.isPlaying)
		{
			aud.Stop();
		}
		float num = 0f;
		num = ((!(Mathf.Abs(computedSpeed) >= 50f)) ? (Mathf.Abs(computedSpeed) * 0.02f) : ((zapAmount > 0f) ? Mathf.Lerp(1f, 1.5f, zapAmount) : 1f));
		aud.volume = num;
		aud.pitch = num * 2f;
	}
}
}

// Train/TramMovementDirection.cs
namespace Train{
public enum TramMovementDirection
{
	Forward,
	Backward,
	None
}
}

// Train/TramPath.cs
namespace Train{
public class TramPath
{
	private const int CurveDistanceCalculationSteps = 16;

	private const float TramDirectionCalcStepLength = 0.05f;

	private const float MinSpeedMultiplier = 0.0125f;

	public readonly TrainTrackPoint start;

	public readonly TrainTrackPoint end;

	public float distanceTravelled;

	public float DistanceTotal { get; private set; }

	public float Progress
	{
		get
		{
			if (distanceTravelled != 0f || DistanceTotal != 0f)
			{
				return distanceTravelled / DistanceTotal;
			}
			return 0f;
		}
	}

	public TramPath(TrainTrackPoint start, bool forward)
	{
		this.start = start;
		end = start.GetDestination(forward);
		DistanceTotal = CalculateFullDistance();
	}

	public TramPath(TrainTrackPoint start, TrainTrackPoint end)
	{
		this.start = start;
		this.end = end;
		DistanceTotal = CalculateFullDistance();
	}

	private float CalculateFullDistance()
	{
		return CalculateFullDistance(start, end);
	}

	private float CalculateFullDistance(TrainTrackPoint startPoint, TrainTrackPoint endPoint)
	{
		switch (startPoint.forwardCurveSettings.curve)
		{
		case PathInterpolation.Linear:
			return Vector3.Distance(startPoint.transform.position, endPoint.transform.position);
		case PathInterpolation.SphericalManual:
		case PathInterpolation.SphericalAutomatic:
		{
			float num = 0f;
			Vector3 a = startPoint.transform.position;
			for (int i = 0; i < 16; i++)
			{
				Vector3 pointOnSimulatedPath = GetPointOnSimulatedPath((float)i / 16f, startPoint, endPoint);
				float num2 = Vector3.Distance(a, pointOnSimulatedPath);
				a = pointOnSimulatedPath;
				if (i > 0)
				{
					num += num2;
				}
			}
			return num;
		}
		default:
			return 0f;
		}
	}

	public Vector3 GetPointOnPath(float progress)
	{
		return GetPointOnSimulatedPath(progress, start, end);
	}

	public static Vector3 GetPointOnSimulatedPath(float progress, TrainTrackPoint startPoint, TrainTrackPoint endPoint)
	{
		Vector3 position = startPoint.transform.position;
		Vector3 position2 = endPoint.transform.position;
		TrackCurveSettings forwardCurveSettings = startPoint.forwardCurveSettings;
		switch (forwardCurveSettings.curve)
		{
		case PathInterpolation.SphericalAutomatic:
		{
			float angle = forwardCurveSettings.angle;
			bool flipCurve = forwardCurveSettings.flipCurve;
			float angle2 = angle;
			Vector3 center = PathTools.ComputeSphericalCurveCenter(position, position2, flipCurve, angle2);
			return PathTools.InterpolateAlongCircle(position, position2, center, progress);
		}
		case PathInterpolation.SphericalManual:
		{
			Transform handle = forwardCurveSettings.handle;
			return PathTools.InterpolateAlongCircle(position, position2, handle.position, progress);
		}
		default:
			return Vector3.Lerp(position, position2, progress);
		}
	}

	public float MaxSpeedMultiplier(TramMovementDirection direction, float speed)
	{
		if (IsDeadEnd(direction))
		{
			StopBehaviour stopBehaviour = GetNextPoint(direction).stopBehaviour;
			if (stopBehaviour == StopBehaviour.EaseOut)
			{
				float num = 1.5f;
				float p = 0.85f;
				float f = ((direction == TramMovementDirection.Forward) ? (DistanceTotal - distanceTravelled) : distanceTravelled);
				f = Mathf.Abs(f);
				if (f < speed * num)
				{
					return Mathf.Clamp(Mathf.Pow(f / (speed * num), p), 0.0125f, 1f);
				}
				return 1f;
			}
			return 1f;
		}
		return 1f;
	}

	private Vector3 CalculateCurrentMovementDirection()
	{
		float num = Progress + 0.05f / DistanceTotal;
		Vector3 vector;
		if (num > 1f)
		{
			TrainTrackPoint destination = end.GetDestination();
			if (destination != null)
			{
				float num2 = num - 1f;
				float num3 = CalculateFullDistance(end, destination);
				vector = GetPointOnSimulatedPath(num2 * DistanceTotal / num3, end, destination);
			}
			else
			{
				vector = GetPointOnPath(Mathf.Clamp01(num));
			}
		}
		else
		{
			vector = GetPointOnPath(num);
		}
		float num4 = Progress - 0.05f / DistanceTotal;
		Vector3 vector2;
		if (num4 < 0f)
		{
			TrainTrackPoint destination2 = start.GetDestination(forward: false);
			if (destination2 != null)
			{
				float num5 = 0f - num4;
				float num6 = CalculateFullDistance(destination2, start);
				float num7 = num5 * DistanceTotal / num6;
				vector2 = GetPointOnSimulatedPath(1f - num7, destination2, start);
			}
			else
			{
				vector2 = GetPointOnPath(Mathf.Clamp01(num4));
			}
		}
		else
		{
			vector2 = GetPointOnPath(num4);
		}
		return (vector - vector2).normalized;
	}

	public string PrintPathDirectional(TramMovementDirection direction)
	{
		return direction switch
		{
			TramMovementDirection.None => "(" + start.gameObject.name + ") --- (" + end.gameObject.name + ")", 
			TramMovementDirection.Forward => "(" + start.gameObject.name + ") --> (" + end.gameObject.name + ")", 
			_ => "(" + start.gameObject.name + ") <-- (" + end.gameObject.name + ")", 
		};
	}

	public bool IsDeadEnd(TramMovementDirection direction)
	{
		if (direction == TramMovementDirection.None)
		{
			return false;
		}
		return GetNextPoint(direction).GetDestination(direction == TramMovementDirection.Forward) == null;
	}

	public TrainTrackPoint GetNextPoint(TramMovementDirection direction)
	{
		return direction switch
		{
			TramMovementDirection.None => null, 
			TramMovementDirection.Forward => end, 
			_ => start, 
		};
	}

	public Vector3 MovementDirection()
	{
		return CalculateCurrentMovementDirection();
	}

	public override bool Equals(object obj)
	{
		if (obj is TramPath tramPath)
		{
			if (start == tramPath.start)
			{
				return end == tramPath.end;
			}
			return false;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (start, end).GetHashCode();
	}
}
}

// Discord/AchievementManager.cs
namespace Discord{
public class AchievementManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UserAchievementUpdateHandler(IntPtr ptr, ref UserAchievement userAchievement);

		internal UserAchievementUpdateHandler OnUserAchievementUpdate;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetUserAchievementCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetUserAchievementMethod(IntPtr methodsPtr, long achievementId, byte percentComplete, IntPtr callbackData, SetUserAchievementCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchUserAchievementsCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchUserAchievementsMethod(IntPtr methodsPtr, IntPtr callbackData, FetchUserAchievementsCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CountUserAchievementsMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetUserAchievementMethod(IntPtr methodsPtr, long userAchievementId, ref UserAchievement userAchievement);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetUserAchievementAtMethod(IntPtr methodsPtr, int index, ref UserAchievement userAchievement);

		internal SetUserAchievementMethod SetUserAchievement;

		internal FetchUserAchievementsMethod FetchUserAchievements;

		internal CountUserAchievementsMethod CountUserAchievements;

		internal GetUserAchievementMethod GetUserAchievement;

		internal GetUserAchievementAtMethod GetUserAchievementAt;
	}

	public delegate void SetUserAchievementHandler(Result result);

	public delegate void FetchUserAchievementsHandler(Result result);

	public delegate void UserAchievementUpdateHandler(ref UserAchievement userAchievement);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event UserAchievementUpdateHandler OnUserAchievementUpdate;

	internal AchievementManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnUserAchievementUpdate = OnUserAchievementUpdateImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	[MonoPInvokeCallback]
	private static void SetUserAchievementCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SetUserAchievementHandler obj = (SetUserAchievementHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SetUserAchievement(long achievementId, byte percentComplete, SetUserAchievementHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SetUserAchievement(MethodsPtr, achievementId, percentComplete, GCHandle.ToIntPtr(value), SetUserAchievementCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void FetchUserAchievementsCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		FetchUserAchievementsHandler obj = (FetchUserAchievementsHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void FetchUserAchievements(FetchUserAchievementsHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.FetchUserAchievements(MethodsPtr, GCHandle.ToIntPtr(value), FetchUserAchievementsCallbackImpl);
	}

	public int CountUserAchievements()
	{
		int count = 0;
		Methods.CountUserAchievements(MethodsPtr, ref count);
		return count;
	}

	public UserAchievement GetUserAchievement(long userAchievementId)
	{
		UserAchievement userAchievement = default(UserAchievement);
		Result result = Methods.GetUserAchievement(MethodsPtr, userAchievementId, ref userAchievement);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return userAchievement;
	}

	public UserAchievement GetUserAchievementAt(int index)
	{
		UserAchievement userAchievement = default(UserAchievement);
		Result result = Methods.GetUserAchievementAt(MethodsPtr, index, ref userAchievement);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return userAchievement;
	}

	[MonoPInvokeCallback]
	private static void OnUserAchievementUpdateImpl(IntPtr ptr, ref UserAchievement userAchievement)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.AchievementManagerInstance.OnUserAchievementUpdate != null)
		{
			discord.AchievementManagerInstance.OnUserAchievementUpdate(ref userAchievement);
		}
	}
}
}

// Discord/Activity.cs
namespace Discord{
public struct Activity
{
	public ActivityType Type;

	public long ApplicationId;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Name;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string State;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Details;

	public ActivityTimestamps Timestamps;

	public ActivityAssets Assets;

	public ActivityParty Party;

	public ActivitySecrets Secrets;

	public bool Instance;
}
}

// Discord/ActivityActionType.cs
namespace Discord{
public enum ActivityActionType
{
	Join = 1,
	Spectate
}
}

// Discord/ActivityAssets.cs
namespace Discord{
public struct ActivityAssets
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string LargeImage;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string LargeText;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string SmallImage;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string SmallText;
}
}

// Discord/ActivityJoinRequestReply.cs
namespace Discord{
public enum ActivityJoinRequestReply
{
	No,
	Yes,
	Ignore
}
}

// Discord/ActivityManager.cs
namespace Discord{
public class ActivityManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ActivityJoinHandler(IntPtr ptr, [MarshalAs(UnmanagedType.LPStr)] string secret);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ActivitySpectateHandler(IntPtr ptr, [MarshalAs(UnmanagedType.LPStr)] string secret);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ActivityJoinRequestHandler(IntPtr ptr, ref User user);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ActivityInviteHandler(IntPtr ptr, ActivityActionType type, ref User user, ref Activity activity);

		internal ActivityJoinHandler OnActivityJoin;

		internal ActivitySpectateHandler OnActivitySpectate;

		internal ActivityJoinRequestHandler OnActivityJoinRequest;

		internal ActivityInviteHandler OnActivityInvite;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result RegisterCommandMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string command);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result RegisterSteamMethod(IntPtr methodsPtr, uint steamId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateActivityCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateActivityMethod(IntPtr methodsPtr, ref Activity activity, IntPtr callbackData, UpdateActivityCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ClearActivityCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ClearActivityMethod(IntPtr methodsPtr, IntPtr callbackData, ClearActivityCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendRequestReplyCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendRequestReplyMethod(IntPtr methodsPtr, long userId, ActivityJoinRequestReply reply, IntPtr callbackData, SendRequestReplyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendInviteCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendInviteMethod(IntPtr methodsPtr, long userId, ActivityActionType type, [MarshalAs(UnmanagedType.LPStr)] string content, IntPtr callbackData, SendInviteCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void AcceptInviteCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void AcceptInviteMethod(IntPtr methodsPtr, long userId, IntPtr callbackData, AcceptInviteCallback callback);

		internal RegisterCommandMethod RegisterCommand;

		internal RegisterSteamMethod RegisterSteam;

		internal UpdateActivityMethod UpdateActivity;

		internal ClearActivityMethod ClearActivity;

		internal SendRequestReplyMethod SendRequestReply;

		internal SendInviteMethod SendInvite;

		internal AcceptInviteMethod AcceptInvite;
	}

	public delegate void UpdateActivityHandler(Result result);

	public delegate void ClearActivityHandler(Result result);

	public delegate void SendRequestReplyHandler(Result result);

	public delegate void SendInviteHandler(Result result);

	public delegate void AcceptInviteHandler(Result result);

	public delegate void ActivityJoinHandler(string secret);

	public delegate void ActivitySpectateHandler(string secret);

	public delegate void ActivityJoinRequestHandler(ref User user);

	public delegate void ActivityInviteHandler(ActivityActionType type, ref User user, ref Activity activity);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event ActivityJoinHandler OnActivityJoin;

	public event ActivitySpectateHandler OnActivitySpectate;

	public event ActivityJoinRequestHandler OnActivityJoinRequest;

	public event ActivityInviteHandler OnActivityInvite;

	public void RegisterCommand()
	{
		RegisterCommand(null);
	}

	internal ActivityManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnActivityJoin = OnActivityJoinImpl;
		events.OnActivitySpectate = OnActivitySpectateImpl;
		events.OnActivityJoinRequest = OnActivityJoinRequestImpl;
		events.OnActivityInvite = OnActivityInviteImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public void RegisterCommand(string command)
	{
		Result result = Methods.RegisterCommand(MethodsPtr, command);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void RegisterSteam(uint steamId)
	{
		Result result = Methods.RegisterSteam(MethodsPtr, steamId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void UpdateActivityCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		UpdateActivityHandler obj = (UpdateActivityHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void UpdateActivity(Activity activity, UpdateActivityHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.UpdateActivity(MethodsPtr, ref activity, GCHandle.ToIntPtr(value), UpdateActivityCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void ClearActivityCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ClearActivityHandler obj = (ClearActivityHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void ClearActivity(ClearActivityHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ClearActivity(MethodsPtr, GCHandle.ToIntPtr(value), ClearActivityCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void SendRequestReplyCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SendRequestReplyHandler obj = (SendRequestReplyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SendRequestReply(long userId, ActivityJoinRequestReply reply, SendRequestReplyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SendRequestReply(MethodsPtr, userId, reply, GCHandle.ToIntPtr(value), SendRequestReplyCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void SendInviteCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SendInviteHandler obj = (SendInviteHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SendInvite(long userId, ActivityActionType type, string content, SendInviteHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SendInvite(MethodsPtr, userId, type, content, GCHandle.ToIntPtr(value), SendInviteCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void AcceptInviteCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		AcceptInviteHandler obj = (AcceptInviteHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void AcceptInvite(long userId, AcceptInviteHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.AcceptInvite(MethodsPtr, userId, GCHandle.ToIntPtr(value), AcceptInviteCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OnActivityJoinImpl(IntPtr ptr, string secret)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.ActivityManagerInstance.OnActivityJoin != null)
		{
			discord.ActivityManagerInstance.OnActivityJoin(secret);
		}
	}

	[MonoPInvokeCallback]
	private static void OnActivitySpectateImpl(IntPtr ptr, string secret)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.ActivityManagerInstance.OnActivitySpectate != null)
		{
			discord.ActivityManagerInstance.OnActivitySpectate(secret);
		}
	}

	[MonoPInvokeCallback]
	private static void OnActivityJoinRequestImpl(IntPtr ptr, ref User user)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.ActivityManagerInstance.OnActivityJoinRequest != null)
		{
			discord.ActivityManagerInstance.OnActivityJoinRequest(ref user);
		}
	}

	[MonoPInvokeCallback]
	private static void OnActivityInviteImpl(IntPtr ptr, ActivityActionType type, ref User user, ref Activity activity)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.ActivityManagerInstance.OnActivityInvite != null)
		{
			discord.ActivityManagerInstance.OnActivityInvite(type, ref user, ref activity);
		}
	}
}
}

// Discord/ActivityParty.cs
namespace Discord{
public struct ActivityParty
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Id;

	public PartySize Size;
}
}

// Discord/ActivitySecrets.cs
namespace Discord{
public struct ActivitySecrets
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Match;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Join;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Spectate;
}
}

// Discord/ActivityTimestamps.cs
namespace Discord{
public struct ActivityTimestamps
{
	public long Start;

	public long End;
}
}

// Discord/ActivityType.cs
namespace Discord{
public enum ActivityType
{
	Playing,
	Streaming,
	Listening,
	Watching
}
}

// Discord/ApplicationManager.cs
namespace Discord{
public class ApplicationManager
{
	internal struct FFIEvents
	{
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ValidateOrExitCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ValidateOrExitMethod(IntPtr methodsPtr, IntPtr callbackData, ValidateOrExitCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetCurrentLocaleMethod(IntPtr methodsPtr, StringBuilder locale);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetCurrentBranchMethod(IntPtr methodsPtr, StringBuilder branch);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetOAuth2TokenCallback(IntPtr ptr, Result result, ref OAuth2Token oauth2Token);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetOAuth2TokenMethod(IntPtr methodsPtr, IntPtr callbackData, GetOAuth2TokenCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetTicketCallback(IntPtr ptr, Result result, [MarshalAs(UnmanagedType.LPStr)] ref string data);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetTicketMethod(IntPtr methodsPtr, IntPtr callbackData, GetTicketCallback callback);

		internal ValidateOrExitMethod ValidateOrExit;

		internal GetCurrentLocaleMethod GetCurrentLocale;

		internal GetCurrentBranchMethod GetCurrentBranch;

		internal GetOAuth2TokenMethod GetOAuth2Token;

		internal GetTicketMethod GetTicket;
	}

	public delegate void ValidateOrExitHandler(Result result);

	public delegate void GetOAuth2TokenHandler(Result result, ref OAuth2Token oauth2Token);

	public delegate void GetTicketHandler(Result result, ref string data);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	internal ApplicationManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	[MonoPInvokeCallback]
	private static void ValidateOrExitCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ValidateOrExitHandler obj = (ValidateOrExitHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void ValidateOrExit(ValidateOrExitHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ValidateOrExit(MethodsPtr, GCHandle.ToIntPtr(value), ValidateOrExitCallbackImpl);
	}

	public string GetCurrentLocale()
	{
		StringBuilder stringBuilder = new StringBuilder(128);
		Methods.GetCurrentLocale(MethodsPtr, stringBuilder);
		return stringBuilder.ToString();
	}

	public string GetCurrentBranch()
	{
		StringBuilder stringBuilder = new StringBuilder(4096);
		Methods.GetCurrentBranch(MethodsPtr, stringBuilder);
		return stringBuilder.ToString();
	}

	[MonoPInvokeCallback]
	private static void GetOAuth2TokenCallbackImpl(IntPtr ptr, Result result, ref OAuth2Token oauth2Token)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		GetOAuth2TokenHandler obj = (GetOAuth2TokenHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref oauth2Token);
	}

	public void GetOAuth2Token(GetOAuth2TokenHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.GetOAuth2Token(MethodsPtr, GCHandle.ToIntPtr(value), GetOAuth2TokenCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void GetTicketCallbackImpl(IntPtr ptr, Result result, ref string data)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		GetTicketHandler obj = (GetTicketHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref data);
	}

	public void GetTicket(GetTicketHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.GetTicket(MethodsPtr, GCHandle.ToIntPtr(value), GetTicketCallbackImpl);
	}
}
}

// Discord/Constants.cs
namespace Discord{
internal static class Constants
{
	public const string DllName = "discord_game_sdk";
}
}

// Discord/CreateFlags.cs
namespace Discord{
public enum CreateFlags
{
	Default,
	NoRequireDiscord
}
}

// Discord/Discord.cs
namespace Discord{
public class Discord : IDisposable
{
	internal struct FFIEvents
	{
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DestroyHandler(IntPtr MethodsPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result RunCallbacksMethod(IntPtr methodsPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetLogHookCallback(IntPtr ptr, LogLevel level, [MarshalAs(UnmanagedType.LPStr)] string message);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetLogHookMethod(IntPtr methodsPtr, LogLevel minLevel, IntPtr callbackData, SetLogHookCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetApplicationManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetUserManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetImageManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetActivityManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetRelationshipManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetLobbyManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetNetworkManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetOverlayManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetStorageManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetStoreManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetVoiceManagerMethod(IntPtr discordPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate IntPtr GetAchievementManagerMethod(IntPtr discordPtr);

		internal DestroyHandler Destroy;

		internal RunCallbacksMethod RunCallbacks;

		internal SetLogHookMethod SetLogHook;

		internal GetApplicationManagerMethod GetApplicationManager;

		internal GetUserManagerMethod GetUserManager;

		internal GetImageManagerMethod GetImageManager;

		internal GetActivityManagerMethod GetActivityManager;

		internal GetRelationshipManagerMethod GetRelationshipManager;

		internal GetLobbyManagerMethod GetLobbyManager;

		internal GetNetworkManagerMethod GetNetworkManager;

		internal GetOverlayManagerMethod GetOverlayManager;

		internal GetStorageManagerMethod GetStorageManager;

		internal GetStoreManagerMethod GetStoreManager;

		internal GetVoiceManagerMethod GetVoiceManager;

		internal GetAchievementManagerMethod GetAchievementManager;
	}

	internal struct FFICreateParams
	{
		internal long ClientId;

		internal ulong Flags;

		internal IntPtr Events;

		internal IntPtr EventData;

		internal IntPtr ApplicationEvents;

		internal uint ApplicationVersion;

		internal IntPtr UserEvents;

		internal uint UserVersion;

		internal IntPtr ImageEvents;

		internal uint ImageVersion;

		internal IntPtr ActivityEvents;

		internal uint ActivityVersion;

		internal IntPtr RelationshipEvents;

		internal uint RelationshipVersion;

		internal IntPtr LobbyEvents;

		internal uint LobbyVersion;

		internal IntPtr NetworkEvents;

		internal uint NetworkVersion;

		internal IntPtr OverlayEvents;

		internal uint OverlayVersion;

		internal IntPtr StorageEvents;

		internal uint StorageVersion;

		internal IntPtr StoreEvents;

		internal uint StoreVersion;

		internal IntPtr VoiceEvents;

		internal uint VoiceVersion;

		internal IntPtr AchievementEvents;

		internal uint AchievementVersion;
	}

	public delegate void SetLogHookHandler(LogLevel level, string message);

	private GCHandle SelfHandle;

	private IntPtr EventsPtr;

	private FFIEvents Events;

	private IntPtr ApplicationEventsPtr;

	private ApplicationManager.FFIEvents ApplicationEvents;

	internal ApplicationManager ApplicationManagerInstance;

	private IntPtr UserEventsPtr;

	private UserManager.FFIEvents UserEvents;

	internal UserManager UserManagerInstance;

	private IntPtr ImageEventsPtr;

	private ImageManager.FFIEvents ImageEvents;

	internal ImageManager ImageManagerInstance;

	private IntPtr ActivityEventsPtr;

	private ActivityManager.FFIEvents ActivityEvents;

	internal ActivityManager ActivityManagerInstance;

	private IntPtr RelationshipEventsPtr;

	private RelationshipManager.FFIEvents RelationshipEvents;

	internal RelationshipManager RelationshipManagerInstance;

	private IntPtr LobbyEventsPtr;

	private LobbyManager.FFIEvents LobbyEvents;

	internal LobbyManager LobbyManagerInstance;

	private IntPtr NetworkEventsPtr;

	private NetworkManager.FFIEvents NetworkEvents;

	internal NetworkManager NetworkManagerInstance;

	private IntPtr OverlayEventsPtr;

	private OverlayManager.FFIEvents OverlayEvents;

	internal OverlayManager OverlayManagerInstance;

	private IntPtr StorageEventsPtr;

	private StorageManager.FFIEvents StorageEvents;

	internal StorageManager StorageManagerInstance;

	private IntPtr StoreEventsPtr;

	private StoreManager.FFIEvents StoreEvents;

	internal StoreManager StoreManagerInstance;

	private IntPtr VoiceEventsPtr;

	private VoiceManager.FFIEvents VoiceEvents;

	internal VoiceManager VoiceManagerInstance;

	private IntPtr AchievementEventsPtr;

	private AchievementManager.FFIEvents AchievementEvents;

	internal AchievementManager AchievementManagerInstance;

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private GCHandle? setLogHook;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	[DllImport("discord_game_sdk", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
	private static extern Result DiscordCreate(uint version, ref FFICreateParams createParams, out IntPtr manager);

	public Discord(long clientId, ulong flags)
	{
		FFICreateParams createParams = default(FFICreateParams);
		createParams.ClientId = clientId;
		createParams.Flags = flags;
		Events = default(FFIEvents);
		EventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(Events));
		createParams.Events = EventsPtr;
		SelfHandle = GCHandle.Alloc(this);
		createParams.EventData = GCHandle.ToIntPtr(SelfHandle);
		ApplicationEvents = default(ApplicationManager.FFIEvents);
		ApplicationEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ApplicationEvents));
		createParams.ApplicationEvents = ApplicationEventsPtr;
		createParams.ApplicationVersion = 1u;
		UserEvents = default(UserManager.FFIEvents);
		UserEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(UserEvents));
		createParams.UserEvents = UserEventsPtr;
		createParams.UserVersion = 1u;
		ImageEvents = default(ImageManager.FFIEvents);
		ImageEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ImageEvents));
		createParams.ImageEvents = ImageEventsPtr;
		createParams.ImageVersion = 1u;
		ActivityEvents = default(ActivityManager.FFIEvents);
		ActivityEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ActivityEvents));
		createParams.ActivityEvents = ActivityEventsPtr;
		createParams.ActivityVersion = 1u;
		RelationshipEvents = default(RelationshipManager.FFIEvents);
		RelationshipEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(RelationshipEvents));
		createParams.RelationshipEvents = RelationshipEventsPtr;
		createParams.RelationshipVersion = 1u;
		LobbyEvents = default(LobbyManager.FFIEvents);
		LobbyEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(LobbyEvents));
		createParams.LobbyEvents = LobbyEventsPtr;
		createParams.LobbyVersion = 1u;
		NetworkEvents = default(NetworkManager.FFIEvents);
		NetworkEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(NetworkEvents));
		createParams.NetworkEvents = NetworkEventsPtr;
		createParams.NetworkVersion = 1u;
		OverlayEvents = default(OverlayManager.FFIEvents);
		OverlayEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(OverlayEvents));
		createParams.OverlayEvents = OverlayEventsPtr;
		createParams.OverlayVersion = 1u;
		StorageEvents = default(StorageManager.FFIEvents);
		StorageEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(StorageEvents));
		createParams.StorageEvents = StorageEventsPtr;
		createParams.StorageVersion = 1u;
		StoreEvents = default(StoreManager.FFIEvents);
		StoreEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(StoreEvents));
		createParams.StoreEvents = StoreEventsPtr;
		createParams.StoreVersion = 1u;
		VoiceEvents = default(VoiceManager.FFIEvents);
		VoiceEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(VoiceEvents));
		createParams.VoiceEvents = VoiceEventsPtr;
		createParams.VoiceVersion = 1u;
		AchievementEvents = default(AchievementManager.FFIEvents);
		AchievementEventsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(AchievementEvents));
		createParams.AchievementEvents = AchievementEventsPtr;
		createParams.AchievementVersion = 1u;
		InitEvents(EventsPtr, ref Events);
		Result result = DiscordCreate(2u, ref createParams, out MethodsPtr);
		if (result != 0)
		{
			Dispose();
			throw new ResultException(result);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public void Dispose()
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Methods.Destroy(MethodsPtr);
		}
		SelfHandle.Free();
		Marshal.FreeHGlobal(EventsPtr);
		Marshal.FreeHGlobal(ApplicationEventsPtr);
		Marshal.FreeHGlobal(UserEventsPtr);
		Marshal.FreeHGlobal(ImageEventsPtr);
		Marshal.FreeHGlobal(ActivityEventsPtr);
		Marshal.FreeHGlobal(RelationshipEventsPtr);
		Marshal.FreeHGlobal(LobbyEventsPtr);
		Marshal.FreeHGlobal(NetworkEventsPtr);
		Marshal.FreeHGlobal(OverlayEventsPtr);
		Marshal.FreeHGlobal(StorageEventsPtr);
		Marshal.FreeHGlobal(StoreEventsPtr);
		Marshal.FreeHGlobal(VoiceEventsPtr);
		Marshal.FreeHGlobal(AchievementEventsPtr);
		if (setLogHook.HasValue)
		{
			setLogHook.Value.Free();
		}
	}

	public void RunCallbacks()
	{
		Result result = Methods.RunCallbacks(MethodsPtr);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void SetLogHookCallbackImpl(IntPtr ptr, LogLevel level, string message)
	{
		((SetLogHookHandler)GCHandle.FromIntPtr(ptr).Target)(level, message);
	}

	public void SetLogHook(LogLevel minLevel, SetLogHookHandler callback)
	{
		if (setLogHook.HasValue)
		{
			setLogHook.Value.Free();
		}
		setLogHook = GCHandle.Alloc(callback);
		Methods.SetLogHook(MethodsPtr, minLevel, GCHandle.ToIntPtr(setLogHook.Value), SetLogHookCallbackImpl);
	}

	public ApplicationManager GetApplicationManager()
	{
		if (ApplicationManagerInstance == null)
		{
			ApplicationManagerInstance = new ApplicationManager(Methods.GetApplicationManager(MethodsPtr), ApplicationEventsPtr, ref ApplicationEvents);
		}
		return ApplicationManagerInstance;
	}

	public UserManager GetUserManager()
	{
		if (UserManagerInstance == null)
		{
			UserManagerInstance = new UserManager(Methods.GetUserManager(MethodsPtr), UserEventsPtr, ref UserEvents);
		}
		return UserManagerInstance;
	}

	public ImageManager GetImageManager()
	{
		if (ImageManagerInstance == null)
		{
			ImageManagerInstance = new ImageManager(Methods.GetImageManager(MethodsPtr), ImageEventsPtr, ref ImageEvents);
		}
		return ImageManagerInstance;
	}

	public ActivityManager GetActivityManager()
	{
		if (ActivityManagerInstance == null)
		{
			ActivityManagerInstance = new ActivityManager(Methods.GetActivityManager(MethodsPtr), ActivityEventsPtr, ref ActivityEvents);
		}
		return ActivityManagerInstance;
	}

	public RelationshipManager GetRelationshipManager()
	{
		if (RelationshipManagerInstance == null)
		{
			RelationshipManagerInstance = new RelationshipManager(Methods.GetRelationshipManager(MethodsPtr), RelationshipEventsPtr, ref RelationshipEvents);
		}
		return RelationshipManagerInstance;
	}

	public LobbyManager GetLobbyManager()
	{
		if (LobbyManagerInstance == null)
		{
			LobbyManagerInstance = new LobbyManager(Methods.GetLobbyManager(MethodsPtr), LobbyEventsPtr, ref LobbyEvents);
		}
		return LobbyManagerInstance;
	}

	public NetworkManager GetNetworkManager()
	{
		if (NetworkManagerInstance == null)
		{
			NetworkManagerInstance = new NetworkManager(Methods.GetNetworkManager(MethodsPtr), NetworkEventsPtr, ref NetworkEvents);
		}
		return NetworkManagerInstance;
	}

	public OverlayManager GetOverlayManager()
	{
		if (OverlayManagerInstance == null)
		{
			OverlayManagerInstance = new OverlayManager(Methods.GetOverlayManager(MethodsPtr), OverlayEventsPtr, ref OverlayEvents);
		}
		return OverlayManagerInstance;
	}

	public StorageManager GetStorageManager()
	{
		if (StorageManagerInstance == null)
		{
			StorageManagerInstance = new StorageManager(Methods.GetStorageManager(MethodsPtr), StorageEventsPtr, ref StorageEvents);
		}
		return StorageManagerInstance;
	}

	public StoreManager GetStoreManager()
	{
		if (StoreManagerInstance == null)
		{
			StoreManagerInstance = new StoreManager(Methods.GetStoreManager(MethodsPtr), StoreEventsPtr, ref StoreEvents);
		}
		return StoreManagerInstance;
	}

	public VoiceManager GetVoiceManager()
	{
		if (VoiceManagerInstance == null)
		{
			VoiceManagerInstance = new VoiceManager(Methods.GetVoiceManager(MethodsPtr), VoiceEventsPtr, ref VoiceEvents);
		}
		return VoiceManagerInstance;
	}

	public AchievementManager GetAchievementManager()
	{
		if (AchievementManagerInstance == null)
		{
			AchievementManagerInstance = new AchievementManager(Methods.GetAchievementManager(MethodsPtr), AchievementEventsPtr, ref AchievementEvents);
		}
		return AchievementManagerInstance;
	}
}
}

// Discord/Entitlement.cs
namespace Discord{
public struct Entitlement
{
	public long Id;

	public EntitlementType Type;

	public long SkuId;
}
}

// Discord/EntitlementType.cs
namespace Discord{
public enum EntitlementType
{
	Purchase = 1,
	PremiumSubscription,
	DeveloperGift,
	TestModePurchase,
	FreePurchase,
	UserGift,
	PremiumPurchase
}
}

// Discord/FileStat.cs
namespace Discord{
public struct FileStat
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
	public string Filename;

	public ulong Size;

	public ulong LastModified;
}
}

// Discord/ImageDimensions.cs
namespace Discord{
public struct ImageDimensions
{
	public uint Width;

	public uint Height;
}
}

// Discord/ImageHandle.cs
namespace Discord{
public struct ImageHandle
{
	public ImageType Type;

	public long Id;

	public uint Size;

	public static ImageHandle User(long id)
	{
		return User(id, 128u);
	}

	public static ImageHandle User(long id, uint size)
	{
		ImageHandle result = default(ImageHandle);
		result.Type = ImageType.User;
		result.Id = id;
		result.Size = size;
		return result;
	}
}
}

// Discord/ImageManager.cs
namespace Discord{
public class ImageManager
{
	internal struct FFIEvents
	{
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchCallback(IntPtr ptr, Result result, ImageHandle handleResult);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchMethod(IntPtr methodsPtr, ImageHandle handle, bool refresh, IntPtr callbackData, FetchCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetDimensionsMethod(IntPtr methodsPtr, ImageHandle handle, ref ImageDimensions dimensions);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetDataMethod(IntPtr methodsPtr, ImageHandle handle, byte[] data, int dataLen);

		internal FetchMethod Fetch;

		internal GetDimensionsMethod GetDimensions;

		internal GetDataMethod GetData;
	}

	public delegate void FetchHandler(Result result, ImageHandle handleResult);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	internal ImageManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	[MonoPInvokeCallback]
	private static void FetchCallbackImpl(IntPtr ptr, Result result, ImageHandle handleResult)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		FetchHandler obj = (FetchHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, handleResult);
	}

	public void Fetch(ImageHandle handle, bool refresh, FetchHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.Fetch(MethodsPtr, handle, refresh, GCHandle.ToIntPtr(value), FetchCallbackImpl);
	}

	public ImageDimensions GetDimensions(ImageHandle handle)
	{
		ImageDimensions dimensions = default(ImageDimensions);
		Result result = Methods.GetDimensions(MethodsPtr, handle, ref dimensions);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return dimensions;
	}

	public void GetData(ImageHandle handle, byte[] data)
	{
		Result result = Methods.GetData(MethodsPtr, handle, data, data.Length);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void Fetch(ImageHandle handle, FetchHandler callback)
	{
		Fetch(handle, refresh: false, callback);
	}

	public byte[] GetData(ImageHandle handle)
	{
		ImageDimensions dimensions = GetDimensions(handle);
		byte[] array = new byte[dimensions.Width * dimensions.Height * 4];
		GetData(handle, array);
		return array;
	}

	public Texture2D GetTexture(ImageHandle handle)
	{
		ImageDimensions dimensions = GetDimensions(handle);
		Texture2D texture2D = new Texture2D((int)dimensions.Width, (int)dimensions.Height, TextureFormat.RGBA32, mipChain: false, linear: true);
		texture2D.LoadRawTextureData(GetData(handle));
		texture2D.Apply();
		return texture2D;
	}
}
}

// Discord/ImageType.cs
namespace Discord{
public enum ImageType
{
	User
}
}

// Discord/InputMode.cs
namespace Discord{
public struct InputMode
{
	public InputModeType Type;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	public string Shortcut;
}
}

// Discord/InputModeType.cs
namespace Discord{
public enum InputModeType
{
	VoiceActivity,
	PushToTalk
}
}

// Discord/Lobby.cs
namespace Discord{
public struct Lobby
{
	public long Id;

	public LobbyType Type;

	public long OwnerId;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Secret;

	public uint Capacity;

	public bool Locked;
}
}

// Discord/LobbyManager.cs
namespace Discord{
public class LobbyManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void LobbyUpdateHandler(IntPtr ptr, long lobbyId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void LobbyDeleteHandler(IntPtr ptr, long lobbyId, uint reason);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void MemberConnectHandler(IntPtr ptr, long lobbyId, long userId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void MemberUpdateHandler(IntPtr ptr, long lobbyId, long userId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void MemberDisconnectHandler(IntPtr ptr, long lobbyId, long userId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void LobbyMessageHandler(IntPtr ptr, long lobbyId, long userId, IntPtr dataPtr, int dataLen);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SpeakingHandler(IntPtr ptr, long lobbyId, long userId, bool speaking);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void NetworkMessageHandler(IntPtr ptr, long lobbyId, long userId, byte channelId, IntPtr dataPtr, int dataLen);

		internal LobbyUpdateHandler OnLobbyUpdate;

		internal LobbyDeleteHandler OnLobbyDelete;

		internal MemberConnectHandler OnMemberConnect;

		internal MemberUpdateHandler OnMemberUpdate;

		internal MemberDisconnectHandler OnMemberDisconnect;

		internal LobbyMessageHandler OnLobbyMessage;

		internal SpeakingHandler OnSpeaking;

		internal NetworkMessageHandler OnNetworkMessage;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyCreateTransactionMethod(IntPtr methodsPtr, ref IntPtr transaction);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyUpdateTransactionMethod(IntPtr methodsPtr, long lobbyId, ref IntPtr transaction);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMemberUpdateTransactionMethod(IntPtr methodsPtr, long lobbyId, long userId, ref IntPtr transaction);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CreateLobbyCallback(IntPtr ptr, Result result, ref Lobby lobby);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CreateLobbyMethod(IntPtr methodsPtr, IntPtr transaction, IntPtr callbackData, CreateLobbyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateLobbyCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateLobbyMethod(IntPtr methodsPtr, long lobbyId, IntPtr transaction, IntPtr callbackData, UpdateLobbyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DeleteLobbyCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DeleteLobbyMethod(IntPtr methodsPtr, long lobbyId, IntPtr callbackData, DeleteLobbyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectLobbyCallback(IntPtr ptr, Result result, ref Lobby lobby);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectLobbyMethod(IntPtr methodsPtr, long lobbyId, [MarshalAs(UnmanagedType.LPStr)] string secret, IntPtr callbackData, ConnectLobbyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectLobbyWithActivitySecretCallback(IntPtr ptr, Result result, ref Lobby lobby);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectLobbyWithActivitySecretMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string activitySecret, IntPtr callbackData, ConnectLobbyWithActivitySecretCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DisconnectLobbyCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DisconnectLobbyMethod(IntPtr methodsPtr, long lobbyId, IntPtr callbackData, DisconnectLobbyCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyMethod(IntPtr methodsPtr, long lobbyId, ref Lobby lobby);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyActivitySecretMethod(IntPtr methodsPtr, long lobbyId, StringBuilder secret);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyMetadataValueMethod(IntPtr methodsPtr, long lobbyId, [MarshalAs(UnmanagedType.LPStr)] string key, StringBuilder value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyMetadataKeyMethod(IntPtr methodsPtr, long lobbyId, int index, StringBuilder key);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result LobbyMetadataCountMethod(IntPtr methodsPtr, long lobbyId, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result MemberCountMethod(IntPtr methodsPtr, long lobbyId, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMemberUserIdMethod(IntPtr methodsPtr, long lobbyId, int index, ref long userId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMemberUserMethod(IntPtr methodsPtr, long lobbyId, long userId, ref User user);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMemberMetadataValueMethod(IntPtr methodsPtr, long lobbyId, long userId, [MarshalAs(UnmanagedType.LPStr)] string key, StringBuilder value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMemberMetadataKeyMethod(IntPtr methodsPtr, long lobbyId, long userId, int index, StringBuilder key);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result MemberMetadataCountMethod(IntPtr methodsPtr, long lobbyId, long userId, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateMemberCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void UpdateMemberMethod(IntPtr methodsPtr, long lobbyId, long userId, IntPtr transaction, IntPtr callbackData, UpdateMemberCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendLobbyMessageCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SendLobbyMessageMethod(IntPtr methodsPtr, long lobbyId, byte[] data, int dataLen, IntPtr callbackData, SendLobbyMessageCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetSearchQueryMethod(IntPtr methodsPtr, ref IntPtr query);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SearchCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SearchMethod(IntPtr methodsPtr, IntPtr query, IntPtr callbackData, SearchCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void LobbyCountMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLobbyIdMethod(IntPtr methodsPtr, int index, ref long lobbyId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectVoiceCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ConnectVoiceMethod(IntPtr methodsPtr, long lobbyId, IntPtr callbackData, ConnectVoiceCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DisconnectVoiceCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void DisconnectVoiceMethod(IntPtr methodsPtr, long lobbyId, IntPtr callbackData, DisconnectVoiceCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result ConnectNetworkMethod(IntPtr methodsPtr, long lobbyId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result DisconnectNetworkMethod(IntPtr methodsPtr, long lobbyId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result FlushNetworkMethod(IntPtr methodsPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result OpenNetworkChannelMethod(IntPtr methodsPtr, long lobbyId, byte channelId, bool reliable);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SendNetworkMessageMethod(IntPtr methodsPtr, long lobbyId, long userId, byte channelId, byte[] data, int dataLen);

		internal GetLobbyCreateTransactionMethod GetLobbyCreateTransaction;

		internal GetLobbyUpdateTransactionMethod GetLobbyUpdateTransaction;

		internal GetMemberUpdateTransactionMethod GetMemberUpdateTransaction;

		internal CreateLobbyMethod CreateLobby;

		internal UpdateLobbyMethod UpdateLobby;

		internal DeleteLobbyMethod DeleteLobby;

		internal ConnectLobbyMethod ConnectLobby;

		internal ConnectLobbyWithActivitySecretMethod ConnectLobbyWithActivitySecret;

		internal DisconnectLobbyMethod DisconnectLobby;

		internal GetLobbyMethod GetLobby;

		internal GetLobbyActivitySecretMethod GetLobbyActivitySecret;

		internal GetLobbyMetadataValueMethod GetLobbyMetadataValue;

		internal GetLobbyMetadataKeyMethod GetLobbyMetadataKey;

		internal LobbyMetadataCountMethod LobbyMetadataCount;

		internal MemberCountMethod MemberCount;

		internal GetMemberUserIdMethod GetMemberUserId;

		internal GetMemberUserMethod GetMemberUser;

		internal GetMemberMetadataValueMethod GetMemberMetadataValue;

		internal GetMemberMetadataKeyMethod GetMemberMetadataKey;

		internal MemberMetadataCountMethod MemberMetadataCount;

		internal UpdateMemberMethod UpdateMember;

		internal SendLobbyMessageMethod SendLobbyMessage;

		internal GetSearchQueryMethod GetSearchQuery;

		internal SearchMethod Search;

		internal LobbyCountMethod LobbyCount;

		internal GetLobbyIdMethod GetLobbyId;

		internal ConnectVoiceMethod ConnectVoice;

		internal DisconnectVoiceMethod DisconnectVoice;

		internal ConnectNetworkMethod ConnectNetwork;

		internal DisconnectNetworkMethod DisconnectNetwork;

		internal FlushNetworkMethod FlushNetwork;

		internal OpenNetworkChannelMethod OpenNetworkChannel;

		internal SendNetworkMessageMethod SendNetworkMessage;
	}

	public delegate void CreateLobbyHandler(Result result, ref Lobby lobby);

	public delegate void UpdateLobbyHandler(Result result);

	public delegate void DeleteLobbyHandler(Result result);

	public delegate void ConnectLobbyHandler(Result result, ref Lobby lobby);

	public delegate void ConnectLobbyWithActivitySecretHandler(Result result, ref Lobby lobby);

	public delegate void DisconnectLobbyHandler(Result result);

	public delegate void UpdateMemberHandler(Result result);

	public delegate void SendLobbyMessageHandler(Result result);

	public delegate void SearchHandler(Result result);

	public delegate void ConnectVoiceHandler(Result result);

	public delegate void DisconnectVoiceHandler(Result result);

	public delegate void LobbyUpdateHandler(long lobbyId);

	public delegate void LobbyDeleteHandler(long lobbyId, uint reason);

	public delegate void MemberConnectHandler(long lobbyId, long userId);

	public delegate void MemberUpdateHandler(long lobbyId, long userId);

	public delegate void MemberDisconnectHandler(long lobbyId, long userId);

	public delegate void LobbyMessageHandler(long lobbyId, long userId, byte[] data);

	public delegate void SpeakingHandler(long lobbyId, long userId, bool speaking);

	public delegate void NetworkMessageHandler(long lobbyId, long userId, byte channelId, byte[] data);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event LobbyUpdateHandler OnLobbyUpdate;

	public event LobbyDeleteHandler OnLobbyDelete;

	public event MemberConnectHandler OnMemberConnect;

	public event MemberUpdateHandler OnMemberUpdate;

	public event MemberDisconnectHandler OnMemberDisconnect;

	public event LobbyMessageHandler OnLobbyMessage;

	public event SpeakingHandler OnSpeaking;

	public event NetworkMessageHandler OnNetworkMessage;

	internal LobbyManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnLobbyUpdate = OnLobbyUpdateImpl;
		events.OnLobbyDelete = OnLobbyDeleteImpl;
		events.OnMemberConnect = OnMemberConnectImpl;
		events.OnMemberUpdate = OnMemberUpdateImpl;
		events.OnMemberDisconnect = OnMemberDisconnectImpl;
		events.OnLobbyMessage = OnLobbyMessageImpl;
		events.OnSpeaking = OnSpeakingImpl;
		events.OnNetworkMessage = OnNetworkMessageImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public LobbyTransaction GetLobbyCreateTransaction()
	{
		LobbyTransaction result = default(LobbyTransaction);
		Result result2 = Methods.GetLobbyCreateTransaction(MethodsPtr, ref result.MethodsPtr);
		if (result2 != 0)
		{
			throw new ResultException(result2);
		}
		return result;
	}

	public LobbyTransaction GetLobbyUpdateTransaction(long lobbyId)
	{
		LobbyTransaction result = default(LobbyTransaction);
		Result result2 = Methods.GetLobbyUpdateTransaction(MethodsPtr, lobbyId, ref result.MethodsPtr);
		if (result2 != 0)
		{
			throw new ResultException(result2);
		}
		return result;
	}

	public LobbyMemberTransaction GetMemberUpdateTransaction(long lobbyId, long userId)
	{
		LobbyMemberTransaction result = default(LobbyMemberTransaction);
		Result result2 = Methods.GetMemberUpdateTransaction(MethodsPtr, lobbyId, userId, ref result.MethodsPtr);
		if (result2 != 0)
		{
			throw new ResultException(result2);
		}
		return result;
	}

	[MonoPInvokeCallback]
	private static void CreateLobbyCallbackImpl(IntPtr ptr, Result result, ref Lobby lobby)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		CreateLobbyHandler obj = (CreateLobbyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref lobby);
	}

	public void CreateLobby(LobbyTransaction transaction, CreateLobbyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.CreateLobby(MethodsPtr, transaction.MethodsPtr, GCHandle.ToIntPtr(value), CreateLobbyCallbackImpl);
		transaction.MethodsPtr = IntPtr.Zero;
	}

	[MonoPInvokeCallback]
	private static void UpdateLobbyCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		UpdateLobbyHandler obj = (UpdateLobbyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void UpdateLobby(long lobbyId, LobbyTransaction transaction, UpdateLobbyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.UpdateLobby(MethodsPtr, lobbyId, transaction.MethodsPtr, GCHandle.ToIntPtr(value), UpdateLobbyCallbackImpl);
		transaction.MethodsPtr = IntPtr.Zero;
	}

	[MonoPInvokeCallback]
	private static void DeleteLobbyCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		DeleteLobbyHandler obj = (DeleteLobbyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void DeleteLobby(long lobbyId, DeleteLobbyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.DeleteLobby(MethodsPtr, lobbyId, GCHandle.ToIntPtr(value), DeleteLobbyCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void ConnectLobbyCallbackImpl(IntPtr ptr, Result result, ref Lobby lobby)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ConnectLobbyHandler obj = (ConnectLobbyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref lobby);
	}

	public void ConnectLobby(long lobbyId, string secret, ConnectLobbyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ConnectLobby(MethodsPtr, lobbyId, secret, GCHandle.ToIntPtr(value), ConnectLobbyCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void ConnectLobbyWithActivitySecretCallbackImpl(IntPtr ptr, Result result, ref Lobby lobby)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ConnectLobbyWithActivitySecretHandler obj = (ConnectLobbyWithActivitySecretHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref lobby);
	}

	public void ConnectLobbyWithActivitySecret(string activitySecret, ConnectLobbyWithActivitySecretHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ConnectLobbyWithActivitySecret(MethodsPtr, activitySecret, GCHandle.ToIntPtr(value), ConnectLobbyWithActivitySecretCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void DisconnectLobbyCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		DisconnectLobbyHandler obj = (DisconnectLobbyHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void DisconnectLobby(long lobbyId, DisconnectLobbyHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.DisconnectLobby(MethodsPtr, lobbyId, GCHandle.ToIntPtr(value), DisconnectLobbyCallbackImpl);
	}

	public Lobby GetLobby(long lobbyId)
	{
		Lobby lobby = default(Lobby);
		Result result = Methods.GetLobby(MethodsPtr, lobbyId, ref lobby);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return lobby;
	}

	public string GetLobbyActivitySecret(long lobbyId)
	{
		StringBuilder stringBuilder = new StringBuilder(128);
		Result result = Methods.GetLobbyActivitySecret(MethodsPtr, lobbyId, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public string GetLobbyMetadataValue(long lobbyId, string key)
	{
		StringBuilder stringBuilder = new StringBuilder(4096);
		Result result = Methods.GetLobbyMetadataValue(MethodsPtr, lobbyId, key, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public string GetLobbyMetadataKey(long lobbyId, int index)
	{
		StringBuilder stringBuilder = new StringBuilder(256);
		Result result = Methods.GetLobbyMetadataKey(MethodsPtr, lobbyId, index, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public int LobbyMetadataCount(long lobbyId)
	{
		int count = 0;
		Result result = Methods.LobbyMetadataCount(MethodsPtr, lobbyId, ref count);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return count;
	}

	public int MemberCount(long lobbyId)
	{
		int count = 0;
		Result result = Methods.MemberCount(MethodsPtr, lobbyId, ref count);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return count;
	}

	public long GetMemberUserId(long lobbyId, int index)
	{
		long userId = 0L;
		Result result = Methods.GetMemberUserId(MethodsPtr, lobbyId, index, ref userId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return userId;
	}

	public User GetMemberUser(long lobbyId, long userId)
	{
		User user = default(User);
		Result result = Methods.GetMemberUser(MethodsPtr, lobbyId, userId, ref user);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return user;
	}

	public string GetMemberMetadataValue(long lobbyId, long userId, string key)
	{
		StringBuilder stringBuilder = new StringBuilder(4096);
		Result result = Methods.GetMemberMetadataValue(MethodsPtr, lobbyId, userId, key, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public string GetMemberMetadataKey(long lobbyId, long userId, int index)
	{
		StringBuilder stringBuilder = new StringBuilder(256);
		Result result = Methods.GetMemberMetadataKey(MethodsPtr, lobbyId, userId, index, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public int MemberMetadataCount(long lobbyId, long userId)
	{
		int count = 0;
		Result result = Methods.MemberMetadataCount(MethodsPtr, lobbyId, userId, ref count);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return count;
	}

	[MonoPInvokeCallback]
	private static void UpdateMemberCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		UpdateMemberHandler obj = (UpdateMemberHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void UpdateMember(long lobbyId, long userId, LobbyMemberTransaction transaction, UpdateMemberHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.UpdateMember(MethodsPtr, lobbyId, userId, transaction.MethodsPtr, GCHandle.ToIntPtr(value), UpdateMemberCallbackImpl);
		transaction.MethodsPtr = IntPtr.Zero;
	}

	[MonoPInvokeCallback]
	private static void SendLobbyMessageCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SendLobbyMessageHandler obj = (SendLobbyMessageHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SendLobbyMessage(long lobbyId, byte[] data, SendLobbyMessageHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SendLobbyMessage(MethodsPtr, lobbyId, data, data.Length, GCHandle.ToIntPtr(value), SendLobbyMessageCallbackImpl);
	}

	public LobbySearchQuery GetSearchQuery()
	{
		LobbySearchQuery result = default(LobbySearchQuery);
		Result result2 = Methods.GetSearchQuery(MethodsPtr, ref result.MethodsPtr);
		if (result2 != 0)
		{
			throw new ResultException(result2);
		}
		return result;
	}

	[MonoPInvokeCallback]
	private static void SearchCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SearchHandler obj = (SearchHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void Search(LobbySearchQuery query, SearchHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.Search(MethodsPtr, query.MethodsPtr, GCHandle.ToIntPtr(value), SearchCallbackImpl);
		query.MethodsPtr = IntPtr.Zero;
	}

	public int LobbyCount()
	{
		int count = 0;
		Methods.LobbyCount(MethodsPtr, ref count);
		return count;
	}

	public long GetLobbyId(int index)
	{
		long lobbyId = 0L;
		Result result = Methods.GetLobbyId(MethodsPtr, index, ref lobbyId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return lobbyId;
	}

	[MonoPInvokeCallback]
	private static void ConnectVoiceCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ConnectVoiceHandler obj = (ConnectVoiceHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void ConnectVoice(long lobbyId, ConnectVoiceHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ConnectVoice(MethodsPtr, lobbyId, GCHandle.ToIntPtr(value), ConnectVoiceCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void DisconnectVoiceCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		DisconnectVoiceHandler obj = (DisconnectVoiceHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void DisconnectVoice(long lobbyId, DisconnectVoiceHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.DisconnectVoice(MethodsPtr, lobbyId, GCHandle.ToIntPtr(value), DisconnectVoiceCallbackImpl);
	}

	public void ConnectNetwork(long lobbyId)
	{
		Result result = Methods.ConnectNetwork(MethodsPtr, lobbyId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void DisconnectNetwork(long lobbyId)
	{
		Result result = Methods.DisconnectNetwork(MethodsPtr, lobbyId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void FlushNetwork()
	{
		Result result = Methods.FlushNetwork(MethodsPtr);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void OpenNetworkChannel(long lobbyId, byte channelId, bool reliable)
	{
		Result result = Methods.OpenNetworkChannel(MethodsPtr, lobbyId, channelId, reliable);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void SendNetworkMessage(long lobbyId, long userId, byte channelId, byte[] data)
	{
		Result result = Methods.SendNetworkMessage(MethodsPtr, lobbyId, userId, channelId, data, data.Length);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void OnLobbyUpdateImpl(IntPtr ptr, long lobbyId)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnLobbyUpdate != null)
		{
			discord.LobbyManagerInstance.OnLobbyUpdate(lobbyId);
		}
	}

	[MonoPInvokeCallback]
	private static void OnLobbyDeleteImpl(IntPtr ptr, long lobbyId, uint reason)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnLobbyDelete != null)
		{
			discord.LobbyManagerInstance.OnLobbyDelete(lobbyId, reason);
		}
	}

	[MonoPInvokeCallback]
	private static void OnMemberConnectImpl(IntPtr ptr, long lobbyId, long userId)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnMemberConnect != null)
		{
			discord.LobbyManagerInstance.OnMemberConnect(lobbyId, userId);
		}
	}

	[MonoPInvokeCallback]
	private static void OnMemberUpdateImpl(IntPtr ptr, long lobbyId, long userId)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnMemberUpdate != null)
		{
			discord.LobbyManagerInstance.OnMemberUpdate(lobbyId, userId);
		}
	}

	[MonoPInvokeCallback]
	private static void OnMemberDisconnectImpl(IntPtr ptr, long lobbyId, long userId)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnMemberDisconnect != null)
		{
			discord.LobbyManagerInstance.OnMemberDisconnect(lobbyId, userId);
		}
	}

	[MonoPInvokeCallback]
	private static void OnLobbyMessageImpl(IntPtr ptr, long lobbyId, long userId, IntPtr dataPtr, int dataLen)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnLobbyMessage != null)
		{
			byte[] array = new byte[dataLen];
			Marshal.Copy(dataPtr, array, 0, dataLen);
			discord.LobbyManagerInstance.OnLobbyMessage(lobbyId, userId, array);
		}
	}

	[MonoPInvokeCallback]
	private static void OnSpeakingImpl(IntPtr ptr, long lobbyId, long userId, bool speaking)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnSpeaking != null)
		{
			discord.LobbyManagerInstance.OnSpeaking(lobbyId, userId, speaking);
		}
	}

	[MonoPInvokeCallback]
	private static void OnNetworkMessageImpl(IntPtr ptr, long lobbyId, long userId, byte channelId, IntPtr dataPtr, int dataLen)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.LobbyManagerInstance.OnNetworkMessage != null)
		{
			byte[] array = new byte[dataLen];
			Marshal.Copy(dataPtr, array, 0, dataLen);
			discord.LobbyManagerInstance.OnNetworkMessage(lobbyId, userId, channelId, array);
		}
	}

	public IEnumerable<User> GetMemberUsers(long lobbyID)
	{
		int num = MemberCount(lobbyID);
		List<User> list = new List<User>();
		for (int i = 0; i < num; i++)
		{
			list.Add(GetMemberUser(lobbyID, GetMemberUserId(lobbyID, i)));
		}
		return list;
	}

	public void SendLobbyMessage(long lobbyID, string data, SendLobbyMessageHandler handler)
	{
		SendLobbyMessage(lobbyID, Encoding.UTF8.GetBytes(data), handler);
	}
}
}

// Discord/LobbyMemberTransaction.cs
namespace Discord{
public struct LobbyMemberTransaction
{
	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetMetadataMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.LPStr)] string value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result DeleteMetadataMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key);

		internal SetMetadataMethod SetMetadata;

		internal DeleteMetadataMethod DeleteMetadata;
	}

	internal IntPtr MethodsPtr;

	internal object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public void SetMetadata(string key, string value)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetMetadata(MethodsPtr, key, value);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void DeleteMetadata(string key)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.DeleteMetadata(MethodsPtr, key);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}
}
}

// Discord/LobbySearchCast.cs
namespace Discord{
public enum LobbySearchCast
{
	String = 1,
	Number
}
}

// Discord/LobbySearchComparison.cs
namespace Discord{
public enum LobbySearchComparison
{
	LessThanOrEqual = -2,
	LessThan,
	Equal,
	GreaterThan,
	GreaterThanOrEqual,
	NotEqual
}
}

// Discord/LobbySearchDistance.cs
namespace Discord{
public enum LobbySearchDistance
{
	Local,
	Default,
	Extended,
	Global
}
}

// Discord/LobbySearchQuery.cs
namespace Discord{
public struct LobbySearchQuery
{
	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result FilterMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key, LobbySearchComparison comparison, LobbySearchCast cast, [MarshalAs(UnmanagedType.LPStr)] string value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SortMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key, LobbySearchCast cast, [MarshalAs(UnmanagedType.LPStr)] string value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result LimitMethod(IntPtr methodsPtr, uint limit);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result DistanceMethod(IntPtr methodsPtr, LobbySearchDistance distance);

		internal FilterMethod Filter;

		internal SortMethod Sort;

		internal LimitMethod Limit;

		internal DistanceMethod Distance;
	}

	internal IntPtr MethodsPtr;

	internal object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public void Filter(string key, LobbySearchComparison comparison, LobbySearchCast cast, string value)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.Filter(MethodsPtr, key, comparison, cast, value);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void Sort(string key, LobbySearchCast cast, string value)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.Sort(MethodsPtr, key, cast, value);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void Limit(uint limit)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.Limit(MethodsPtr, limit);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void Distance(LobbySearchDistance distance)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.Distance(MethodsPtr, distance);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}
}
}

// Discord/LobbyTransaction.cs
namespace Discord{
public struct LobbyTransaction
{
	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetTypeMethod(IntPtr methodsPtr, LobbyType type);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetOwnerMethod(IntPtr methodsPtr, long ownerId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetCapacityMethod(IntPtr methodsPtr, uint capacity);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetMetadataMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.LPStr)] string value);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result DeleteMetadataMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string key);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetLockedMethod(IntPtr methodsPtr, bool locked);

		internal SetTypeMethod SetType;

		internal SetOwnerMethod SetOwner;

		internal SetCapacityMethod SetCapacity;

		internal SetMetadataMethod SetMetadata;

		internal DeleteMetadataMethod DeleteMetadata;

		internal SetLockedMethod SetLocked;
	}

	internal IntPtr MethodsPtr;

	internal object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public void SetType(LobbyType type)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetType(MethodsPtr, type);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void SetOwner(long ownerId)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetOwner(MethodsPtr, ownerId);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void SetCapacity(uint capacity)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetCapacity(MethodsPtr, capacity);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void SetMetadata(string key, string value)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetMetadata(MethodsPtr, key, value);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void DeleteMetadata(string key)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.DeleteMetadata(MethodsPtr, key);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}

	public void SetLocked(bool locked)
	{
		if (MethodsPtr != IntPtr.Zero)
		{
			Result result = Methods.SetLocked(MethodsPtr, locked);
			if (result != 0)
			{
				throw new ResultException(result);
			}
		}
	}
}
}

// Discord/LobbyType.cs
namespace Discord{
public enum LobbyType
{
	Private = 1,
	Public
}
}

// Discord/LogLevel.cs
namespace Discord{
public enum LogLevel
{
	Error = 1,
	Warn,
	Info,
	Debug
}
}

// Discord/MonoPInvokeCallbackAttribute.cs
namespace Discord{
internal class MonoPInvokeCallbackAttribute : Attribute
{
}
}

// Discord/NetworkManager.cs
namespace Discord{
public class NetworkManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void MessageHandler(IntPtr ptr, ulong peerId, byte channelId, IntPtr dataPtr, int dataLen);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void RouteUpdateHandler(IntPtr ptr, [MarshalAs(UnmanagedType.LPStr)] string routeData);

		internal MessageHandler OnMessage;

		internal RouteUpdateHandler OnRouteUpdate;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetPeerIdMethod(IntPtr methodsPtr, ref ulong peerId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result FlushMethod(IntPtr methodsPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result OpenPeerMethod(IntPtr methodsPtr, ulong peerId, [MarshalAs(UnmanagedType.LPStr)] string routeData);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result UpdatePeerMethod(IntPtr methodsPtr, ulong peerId, [MarshalAs(UnmanagedType.LPStr)] string routeData);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result ClosePeerMethod(IntPtr methodsPtr, ulong peerId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result OpenChannelMethod(IntPtr methodsPtr, ulong peerId, byte channelId, bool reliable);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result CloseChannelMethod(IntPtr methodsPtr, ulong peerId, byte channelId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SendMessageMethod(IntPtr methodsPtr, ulong peerId, byte channelId, byte[] data, int dataLen);

		internal GetPeerIdMethod GetPeerId;

		internal FlushMethod Flush;

		internal OpenPeerMethod OpenPeer;

		internal UpdatePeerMethod UpdatePeer;

		internal ClosePeerMethod ClosePeer;

		internal OpenChannelMethod OpenChannel;

		internal CloseChannelMethod CloseChannel;

		internal SendMessageMethod SendMessage;
	}

	public delegate void MessageHandler(ulong peerId, byte channelId, byte[] data);

	public delegate void RouteUpdateHandler(string routeData);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event MessageHandler OnMessage;

	public event RouteUpdateHandler OnRouteUpdate;

	internal NetworkManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnMessage = OnMessageImpl;
		events.OnRouteUpdate = OnRouteUpdateImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public ulong GetPeerId()
	{
		ulong peerId = 0uL;
		Methods.GetPeerId(MethodsPtr, ref peerId);
		return peerId;
	}

	public void Flush()
	{
		Result result = Methods.Flush(MethodsPtr);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void OpenPeer(ulong peerId, string routeData)
	{
		Result result = Methods.OpenPeer(MethodsPtr, peerId, routeData);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void UpdatePeer(ulong peerId, string routeData)
	{
		Result result = Methods.UpdatePeer(MethodsPtr, peerId, routeData);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void ClosePeer(ulong peerId)
	{
		Result result = Methods.ClosePeer(MethodsPtr, peerId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void OpenChannel(ulong peerId, byte channelId, bool reliable)
	{
		Result result = Methods.OpenChannel(MethodsPtr, peerId, channelId, reliable);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void CloseChannel(ulong peerId, byte channelId)
	{
		Result result = Methods.CloseChannel(MethodsPtr, peerId, channelId);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public void SendMessage(ulong peerId, byte channelId, byte[] data)
	{
		Result result = Methods.SendMessage(MethodsPtr, peerId, channelId, data, data.Length);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void OnMessageImpl(IntPtr ptr, ulong peerId, byte channelId, IntPtr dataPtr, int dataLen)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.NetworkManagerInstance.OnMessage != null)
		{
			byte[] array = new byte[dataLen];
			Marshal.Copy(dataPtr, array, 0, dataLen);
			discord.NetworkManagerInstance.OnMessage(peerId, channelId, array);
		}
	}

	[MonoPInvokeCallback]
	private static void OnRouteUpdateImpl(IntPtr ptr, string routeData)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.NetworkManagerInstance.OnRouteUpdate != null)
		{
			discord.NetworkManagerInstance.OnRouteUpdate(routeData);
		}
	}
}
}

// Discord/OAuth2Token.cs
namespace Discord{
public struct OAuth2Token
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string AccessToken;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1024)]
	public string Scopes;

	public long Expires;
}
}

// Discord/OverlayManager.cs
namespace Discord{
public class OverlayManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ToggleHandler(IntPtr ptr, bool locked);

		internal ToggleHandler OnToggle;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void IsEnabledMethod(IntPtr methodsPtr, ref bool enabled);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void IsLockedMethod(IntPtr methodsPtr, ref bool locked);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetLockedCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetLockedMethod(IntPtr methodsPtr, bool locked, IntPtr callbackData, SetLockedCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenActivityInviteCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenActivityInviteMethod(IntPtr methodsPtr, ActivityActionType type, IntPtr callbackData, OpenActivityInviteCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenGuildInviteCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenGuildInviteMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string code, IntPtr callbackData, OpenGuildInviteCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenVoiceSettingsCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OpenVoiceSettingsMethod(IntPtr methodsPtr, IntPtr callbackData, OpenVoiceSettingsCallback callback);

		internal IsEnabledMethod IsEnabled;

		internal IsLockedMethod IsLocked;

		internal SetLockedMethod SetLocked;

		internal OpenActivityInviteMethod OpenActivityInvite;

		internal OpenGuildInviteMethod OpenGuildInvite;

		internal OpenVoiceSettingsMethod OpenVoiceSettings;
	}

	public delegate void SetLockedHandler(Result result);

	public delegate void OpenActivityInviteHandler(Result result);

	public delegate void OpenGuildInviteHandler(Result result);

	public delegate void OpenVoiceSettingsHandler(Result result);

	public delegate void ToggleHandler(bool locked);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event ToggleHandler OnToggle;

	internal OverlayManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnToggle = OnToggleImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public bool IsEnabled()
	{
		bool enabled = false;
		Methods.IsEnabled(MethodsPtr, ref enabled);
		return enabled;
	}

	public bool IsLocked()
	{
		bool locked = false;
		Methods.IsLocked(MethodsPtr, ref locked);
		return locked;
	}

	[MonoPInvokeCallback]
	private static void SetLockedCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SetLockedHandler obj = (SetLockedHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SetLocked(bool locked, SetLockedHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SetLocked(MethodsPtr, locked, GCHandle.ToIntPtr(value), SetLockedCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OpenActivityInviteCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		OpenActivityInviteHandler obj = (OpenActivityInviteHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void OpenActivityInvite(ActivityActionType type, OpenActivityInviteHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.OpenActivityInvite(MethodsPtr, type, GCHandle.ToIntPtr(value), OpenActivityInviteCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OpenGuildInviteCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		OpenGuildInviteHandler obj = (OpenGuildInviteHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void OpenGuildInvite(string code, OpenGuildInviteHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.OpenGuildInvite(MethodsPtr, code, GCHandle.ToIntPtr(value), OpenGuildInviteCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OpenVoiceSettingsCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		OpenVoiceSettingsHandler obj = (OpenVoiceSettingsHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void OpenVoiceSettings(OpenVoiceSettingsHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.OpenVoiceSettings(MethodsPtr, GCHandle.ToIntPtr(value), OpenVoiceSettingsCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OnToggleImpl(IntPtr ptr, bool locked)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.OverlayManagerInstance.OnToggle != null)
		{
			discord.OverlayManagerInstance.OnToggle(locked);
		}
	}
}
}

// Discord/PartySize.cs
namespace Discord{
public struct PartySize
{
	public int CurrentSize;

	public int MaxSize;
}
}

// Discord/PremiumType.cs
namespace Discord{
public enum PremiumType
{
	None,
	Tier1,
	Tier2
}
}

// Discord/Presence.cs
namespace Discord{
public struct Presence
{
	public Status Status;

	public Activity Activity;
}
}

// Discord/Relationship.cs
namespace Discord{
public struct Relationship
{
	public RelationshipType Type;

	public User User;

	public Presence Presence;
}
}

// Discord/RelationshipManager.cs
namespace Discord{
public class RelationshipManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void RefreshHandler(IntPtr ptr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void RelationshipUpdateHandler(IntPtr ptr, ref Relationship relationship);

		internal RefreshHandler OnRefresh;

		internal RelationshipUpdateHandler OnRelationshipUpdate;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate bool FilterCallback(IntPtr ptr, ref Relationship relationship);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FilterMethod(IntPtr methodsPtr, IntPtr callbackData, FilterCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result CountMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetMethod(IntPtr methodsPtr, long userId, ref Relationship relationship);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetAtMethod(IntPtr methodsPtr, uint index, ref Relationship relationship);

		internal FilterMethod Filter;

		internal CountMethod Count;

		internal GetMethod Get;

		internal GetAtMethod GetAt;
	}

	public delegate bool FilterHandler(ref Relationship relationship);

	public delegate void RefreshHandler();

	public delegate void RelationshipUpdateHandler(ref Relationship relationship);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event RefreshHandler OnRefresh;

	public event RelationshipUpdateHandler OnRelationshipUpdate;

	internal RelationshipManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnRefresh = OnRefreshImpl;
		events.OnRelationshipUpdate = OnRelationshipUpdateImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	[MonoPInvokeCallback]
	private static bool FilterCallbackImpl(IntPtr ptr, ref Relationship relationship)
	{
		return ((FilterHandler)GCHandle.FromIntPtr(ptr).Target)(ref relationship);
	}

	public void Filter(FilterHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.Filter(MethodsPtr, GCHandle.ToIntPtr(value), FilterCallbackImpl);
		value.Free();
	}

	public int Count()
	{
		int count = 0;
		Result result = Methods.Count(MethodsPtr, ref count);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return count;
	}

	public Relationship Get(long userId)
	{
		Relationship relationship = default(Relationship);
		Result result = Methods.Get(MethodsPtr, userId, ref relationship);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return relationship;
	}

	public Relationship GetAt(uint index)
	{
		Relationship relationship = default(Relationship);
		Result result = Methods.GetAt(MethodsPtr, index, ref relationship);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return relationship;
	}

	[MonoPInvokeCallback]
	private static void OnRefreshImpl(IntPtr ptr)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.RelationshipManagerInstance.OnRefresh != null)
		{
			discord.RelationshipManagerInstance.OnRefresh();
		}
	}

	[MonoPInvokeCallback]
	private static void OnRelationshipUpdateImpl(IntPtr ptr, ref Relationship relationship)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.RelationshipManagerInstance.OnRelationshipUpdate != null)
		{
			discord.RelationshipManagerInstance.OnRelationshipUpdate(ref relationship);
		}
	}
}
}

// Discord/RelationshipType.cs
namespace Discord{
public enum RelationshipType
{
	None,
	Friend,
	Blocked,
	PendingIncoming,
	PendingOutgoing,
	Implicit
}
}

// Discord/Result.cs
namespace Discord{
public enum Result
{
	Ok,
	ServiceUnavailable,
	InvalidVersion,
	LockFailed,
	InternalError,
	InvalidPayload,
	InvalidCommand,
	InvalidPermissions,
	NotFetched,
	NotFound,
	Conflict,
	InvalidSecret,
	InvalidJoinSecret,
	NoEligibleActivity,
	InvalidInvite,
	NotAuthenticated,
	InvalidAccessToken,
	ApplicationMismatch,
	InvalidDataUrl,
	InvalidBase64,
	NotFiltered,
	LobbyFull,
	InvalidLobbySecret,
	InvalidFilename,
	InvalidFileSize,
	InvalidEntitlement,
	NotInstalled,
	NotRunning,
	InsufficientBuffer,
	PurchaseCanceled,
	InvalidGuild,
	InvalidEvent,
	InvalidChannel,
	InvalidOrigin,
	RateLimited,
	OAuth2Error,
	SelectChannelTimeout,
	GetGuildTimeout,
	SelectVoiceForceRequired,
	CaptureShortcutAlreadyListening,
	UnauthorizedForAchievement,
	InvalidGiftCode,
	PurchaseError,
	TransactionAborted
}
}

// Discord/ResultException.cs
namespace Discord{
public class ResultException : Exception
{
	public readonly Result Result;

	public ResultException(Result result)
		: base(result.ToString())
	{
	}
}
}

// Discord/Sku.cs
namespace Discord{
public struct Sku
{
	public long Id;

	public SkuType Type;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	public string Name;

	public SkuPrice Price;
}
}

// Discord/SkuPrice.cs
namespace Discord{
public struct SkuPrice
{
	public uint Amount;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
	public string Currency;
}
}

// Discord/SkuType.cs
namespace Discord{
public enum SkuType
{
	Application = 1,
	DLC,
	Consumable,
	Bundle
}
}

// Discord/Status.cs
namespace Discord{
public enum Status
{
	Offline,
	Online,
	Idle,
	DoNotDisturb
}
}

// Discord/StorageManager.cs
namespace Discord{
public class StorageManager
{
	internal struct FFIEvents
	{
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result ReadMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, byte[] data, int dataLen, ref uint read);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ReadAsyncCallback(IntPtr ptr, Result result, IntPtr dataPtr, int dataLen);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ReadAsyncMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, IntPtr callbackData, ReadAsyncCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ReadAsyncPartialCallback(IntPtr ptr, Result result, IntPtr dataPtr, int dataLen);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void ReadAsyncPartialMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, ulong offset, ulong length, IntPtr callbackData, ReadAsyncPartialCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result WriteMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, byte[] data, int dataLen);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void WriteAsyncCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void WriteAsyncMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, byte[] data, int dataLen, IntPtr callbackData, WriteAsyncCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result DeleteMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result ExistsMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, ref bool exists);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CountMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result StatMethod(IntPtr methodsPtr, [MarshalAs(UnmanagedType.LPStr)] string name, ref FileStat stat);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result StatAtMethod(IntPtr methodsPtr, int index, ref FileStat stat);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetPathMethod(IntPtr methodsPtr, StringBuilder path);

		internal ReadMethod Read;

		internal ReadAsyncMethod ReadAsync;

		internal ReadAsyncPartialMethod ReadAsyncPartial;

		internal WriteMethod Write;

		internal WriteAsyncMethod WriteAsync;

		internal DeleteMethod Delete;

		internal ExistsMethod Exists;

		internal CountMethod Count;

		internal StatMethod Stat;

		internal StatAtMethod StatAt;

		internal GetPathMethod GetPath;
	}

	public delegate void ReadAsyncHandler(Result result, byte[] data);

	public delegate void ReadAsyncPartialHandler(Result result, byte[] data);

	public delegate void WriteAsyncHandler(Result result);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	internal StorageManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public uint Read(string name, byte[] data)
	{
		uint read = 0u;
		Result result = Methods.Read(MethodsPtr, name, data, data.Length, ref read);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return read;
	}

	[MonoPInvokeCallback]
	private static void ReadAsyncCallbackImpl(IntPtr ptr, Result result, IntPtr dataPtr, int dataLen)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ReadAsyncHandler obj = (ReadAsyncHandler)gCHandle.Target;
		gCHandle.Free();
		byte[] array = new byte[dataLen];
		Marshal.Copy(dataPtr, array, 0, dataLen);
		obj(result, array);
	}

	public void ReadAsync(string name, ReadAsyncHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ReadAsync(MethodsPtr, name, GCHandle.ToIntPtr(value), ReadAsyncCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void ReadAsyncPartialCallbackImpl(IntPtr ptr, Result result, IntPtr dataPtr, int dataLen)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		ReadAsyncPartialHandler obj = (ReadAsyncPartialHandler)gCHandle.Target;
		gCHandle.Free();
		byte[] array = new byte[dataLen];
		Marshal.Copy(dataPtr, array, 0, dataLen);
		obj(result, array);
	}

	public void ReadAsyncPartial(string name, ulong offset, ulong length, ReadAsyncPartialHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.ReadAsyncPartial(MethodsPtr, name, offset, length, GCHandle.ToIntPtr(value), ReadAsyncPartialCallbackImpl);
	}

	public void Write(string name, byte[] data)
	{
		Result result = Methods.Write(MethodsPtr, name, data, data.Length);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void WriteAsyncCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		WriteAsyncHandler obj = (WriteAsyncHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void WriteAsync(string name, byte[] data, WriteAsyncHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.WriteAsync(MethodsPtr, name, data, data.Length, GCHandle.ToIntPtr(value), WriteAsyncCallbackImpl);
	}

	public void Delete(string name)
	{
		Result result = Methods.Delete(MethodsPtr, name);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public bool Exists(string name)
	{
		bool exists = false;
		Result result = Methods.Exists(MethodsPtr, name, ref exists);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return exists;
	}

	public int Count()
	{
		int count = 0;
		Methods.Count(MethodsPtr, ref count);
		return count;
	}

	public FileStat Stat(string name)
	{
		FileStat stat = default(FileStat);
		Result result = Methods.Stat(MethodsPtr, name, ref stat);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stat;
	}

	public FileStat StatAt(int index)
	{
		FileStat stat = default(FileStat);
		Result result = Methods.StatAt(MethodsPtr, index, ref stat);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stat;
	}

	public string GetPath()
	{
		StringBuilder stringBuilder = new StringBuilder(4096);
		Result result = Methods.GetPath(MethodsPtr, stringBuilder);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return stringBuilder.ToString();
	}

	public IEnumerable<FileStat> Files()
	{
		int num = Count();
		List<FileStat> list = new List<FileStat>();
		for (int i = 0; i < num; i++)
		{
			list.Add(StatAt(i));
		}
		return list;
	}
}
}

// Discord/StoreManager.cs
namespace Discord{
public class StoreManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void EntitlementCreateHandler(IntPtr ptr, ref Entitlement entitlement);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void EntitlementDeleteHandler(IntPtr ptr, ref Entitlement entitlement);

		internal EntitlementCreateHandler OnEntitlementCreate;

		internal EntitlementDeleteHandler OnEntitlementDelete;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchSkusCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchSkusMethod(IntPtr methodsPtr, IntPtr callbackData, FetchSkusCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CountSkusMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetSkuMethod(IntPtr methodsPtr, long skuId, ref Sku sku);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetSkuAtMethod(IntPtr methodsPtr, int index, ref Sku sku);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchEntitlementsCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void FetchEntitlementsMethod(IntPtr methodsPtr, IntPtr callbackData, FetchEntitlementsCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CountEntitlementsMethod(IntPtr methodsPtr, ref int count);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetEntitlementMethod(IntPtr methodsPtr, long entitlementId, ref Entitlement entitlement);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetEntitlementAtMethod(IntPtr methodsPtr, int index, ref Entitlement entitlement);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result HasSkuEntitlementMethod(IntPtr methodsPtr, long skuId, ref bool hasEntitlement);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void StartPurchaseCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void StartPurchaseMethod(IntPtr methodsPtr, long skuId, IntPtr callbackData, StartPurchaseCallback callback);

		internal FetchSkusMethod FetchSkus;

		internal CountSkusMethod CountSkus;

		internal GetSkuMethod GetSku;

		internal GetSkuAtMethod GetSkuAt;

		internal FetchEntitlementsMethod FetchEntitlements;

		internal CountEntitlementsMethod CountEntitlements;

		internal GetEntitlementMethod GetEntitlement;

		internal GetEntitlementAtMethod GetEntitlementAt;

		internal HasSkuEntitlementMethod HasSkuEntitlement;

		internal StartPurchaseMethod StartPurchase;
	}

	public delegate void FetchSkusHandler(Result result);

	public delegate void FetchEntitlementsHandler(Result result);

	public delegate void StartPurchaseHandler(Result result);

	public delegate void EntitlementCreateHandler(ref Entitlement entitlement);

	public delegate void EntitlementDeleteHandler(ref Entitlement entitlement);

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event EntitlementCreateHandler OnEntitlementCreate;

	public event EntitlementDeleteHandler OnEntitlementDelete;

	internal StoreManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnEntitlementCreate = OnEntitlementCreateImpl;
		events.OnEntitlementDelete = OnEntitlementDeleteImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	[MonoPInvokeCallback]
	private static void FetchSkusCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		FetchSkusHandler obj = (FetchSkusHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void FetchSkus(FetchSkusHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.FetchSkus(MethodsPtr, GCHandle.ToIntPtr(value), FetchSkusCallbackImpl);
	}

	public int CountSkus()
	{
		int count = 0;
		Methods.CountSkus(MethodsPtr, ref count);
		return count;
	}

	public Sku GetSku(long skuId)
	{
		Sku sku = default(Sku);
		Result result = Methods.GetSku(MethodsPtr, skuId, ref sku);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return sku;
	}

	public Sku GetSkuAt(int index)
	{
		Sku sku = default(Sku);
		Result result = Methods.GetSkuAt(MethodsPtr, index, ref sku);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return sku;
	}

	[MonoPInvokeCallback]
	private static void FetchEntitlementsCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		FetchEntitlementsHandler obj = (FetchEntitlementsHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void FetchEntitlements(FetchEntitlementsHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.FetchEntitlements(MethodsPtr, GCHandle.ToIntPtr(value), FetchEntitlementsCallbackImpl);
	}

	public int CountEntitlements()
	{
		int count = 0;
		Methods.CountEntitlements(MethodsPtr, ref count);
		return count;
	}

	public Entitlement GetEntitlement(long entitlementId)
	{
		Entitlement entitlement = default(Entitlement);
		Result result = Methods.GetEntitlement(MethodsPtr, entitlementId, ref entitlement);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return entitlement;
	}

	public Entitlement GetEntitlementAt(int index)
	{
		Entitlement entitlement = default(Entitlement);
		Result result = Methods.GetEntitlementAt(MethodsPtr, index, ref entitlement);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return entitlement;
	}

	public bool HasSkuEntitlement(long skuId)
	{
		bool hasEntitlement = false;
		Result result = Methods.HasSkuEntitlement(MethodsPtr, skuId, ref hasEntitlement);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return hasEntitlement;
	}

	[MonoPInvokeCallback]
	private static void StartPurchaseCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		StartPurchaseHandler obj = (StartPurchaseHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void StartPurchase(long skuId, StartPurchaseHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.StartPurchase(MethodsPtr, skuId, GCHandle.ToIntPtr(value), StartPurchaseCallbackImpl);
	}

	[MonoPInvokeCallback]
	private static void OnEntitlementCreateImpl(IntPtr ptr, ref Entitlement entitlement)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.StoreManagerInstance.OnEntitlementCreate != null)
		{
			discord.StoreManagerInstance.OnEntitlementCreate(ref entitlement);
		}
	}

	[MonoPInvokeCallback]
	private static void OnEntitlementDeleteImpl(IntPtr ptr, ref Entitlement entitlement)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.StoreManagerInstance.OnEntitlementDelete != null)
		{
			discord.StoreManagerInstance.OnEntitlementDelete(ref entitlement);
		}
	}

	public IEnumerable<Entitlement> GetEntitlements()
	{
		int num = CountEntitlements();
		List<Entitlement> list = new List<Entitlement>();
		for (int i = 0; i < num; i++)
		{
			list.Add(GetEntitlementAt(i));
		}
		return list;
	}

	public IEnumerable<Sku> GetSkus()
	{
		int num = CountSkus();
		List<Sku> list = new List<Sku>();
		for (int i = 0; i < num; i++)
		{
			list.Add(GetSkuAt(i));
		}
		return list;
	}
}
}

// Discord/User.cs
namespace Discord{
public struct User
{
	public long Id;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	public string Username;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
	public string Discriminator;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string Avatar;

	public bool Bot;
}
}

// Discord/UserAchievement.cs
namespace Discord{
public struct UserAchievement
{
	public long UserId;

	public long AchievementId;

	public byte PercentComplete;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
	public string UnlockedAt;
}
}

// Discord/UserFlag.cs
namespace Discord{
public enum UserFlag
{
	Partner = 2,
	HypeSquadEvents = 4,
	HypeSquadHouse1 = 0x40,
	HypeSquadHouse2 = 0x80,
	HypeSquadHouse3 = 0x100
}
}

// Discord/UserManager.cs
namespace Discord{
public class UserManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void CurrentUserUpdateHandler(IntPtr ptr);

		internal CurrentUserUpdateHandler OnCurrentUserUpdate;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetCurrentUserMethod(IntPtr methodsPtr, ref User currentUser);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetUserCallback(IntPtr ptr, Result result, ref User user);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void GetUserMethod(IntPtr methodsPtr, long userId, IntPtr callbackData, GetUserCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetCurrentUserPremiumTypeMethod(IntPtr methodsPtr, ref PremiumType premiumType);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result CurrentUserHasFlagMethod(IntPtr methodsPtr, UserFlag flag, ref bool hasFlag);

		internal GetCurrentUserMethod GetCurrentUser;

		internal GetUserMethod GetUser;

		internal GetCurrentUserPremiumTypeMethod GetCurrentUserPremiumType;

		internal CurrentUserHasFlagMethod CurrentUserHasFlag;
	}

	public delegate void GetUserHandler(Result result, ref User user);

	public delegate void CurrentUserUpdateHandler();

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event CurrentUserUpdateHandler OnCurrentUserUpdate;

	internal UserManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnCurrentUserUpdate = OnCurrentUserUpdateImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public User GetCurrentUser()
	{
		User currentUser = default(User);
		Result result = Methods.GetCurrentUser(MethodsPtr, ref currentUser);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return currentUser;
	}

	[MonoPInvokeCallback]
	private static void GetUserCallbackImpl(IntPtr ptr, Result result, ref User user)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		GetUserHandler obj = (GetUserHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result, ref user);
	}

	public void GetUser(long userId, GetUserHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.GetUser(MethodsPtr, userId, GCHandle.ToIntPtr(value), GetUserCallbackImpl);
	}

	public PremiumType GetCurrentUserPremiumType()
	{
		PremiumType premiumType = PremiumType.None;
		Result result = Methods.GetCurrentUserPremiumType(MethodsPtr, ref premiumType);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return premiumType;
	}

	public bool CurrentUserHasFlag(UserFlag flag)
	{
		bool hasFlag = false;
		Result result = Methods.CurrentUserHasFlag(MethodsPtr, flag, ref hasFlag);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return hasFlag;
	}

	[MonoPInvokeCallback]
	private static void OnCurrentUserUpdateImpl(IntPtr ptr)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.UserManagerInstance.OnCurrentUserUpdate != null)
		{
			discord.UserManagerInstance.OnCurrentUserUpdate();
		}
	}
}
}

// Discord/VoiceManager.cs
namespace Discord{
public class VoiceManager
{
	internal struct FFIEvents
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SettingsUpdateHandler(IntPtr ptr);

		internal SettingsUpdateHandler OnSettingsUpdate;
	}

	internal struct FFIMethods
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetInputModeMethod(IntPtr methodsPtr, ref InputMode inputMode);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetInputModeCallback(IntPtr ptr, Result result);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void SetInputModeMethod(IntPtr methodsPtr, InputMode inputMode, IntPtr callbackData, SetInputModeCallback callback);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result IsSelfMuteMethod(IntPtr methodsPtr, ref bool mute);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetSelfMuteMethod(IntPtr methodsPtr, bool mute);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result IsSelfDeafMethod(IntPtr methodsPtr, ref bool deaf);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetSelfDeafMethod(IntPtr methodsPtr, bool deaf);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result IsLocalMuteMethod(IntPtr methodsPtr, long userId, ref bool mute);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetLocalMuteMethod(IntPtr methodsPtr, long userId, bool mute);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result GetLocalVolumeMethod(IntPtr methodsPtr, long userId, ref byte volume);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate Result SetLocalVolumeMethod(IntPtr methodsPtr, long userId, byte volume);

		internal GetInputModeMethod GetInputMode;

		internal SetInputModeMethod SetInputMode;

		internal IsSelfMuteMethod IsSelfMute;

		internal SetSelfMuteMethod SetSelfMute;

		internal IsSelfDeafMethod IsSelfDeaf;

		internal SetSelfDeafMethod SetSelfDeaf;

		internal IsLocalMuteMethod IsLocalMute;

		internal SetLocalMuteMethod SetLocalMute;

		internal GetLocalVolumeMethod GetLocalVolume;

		internal SetLocalVolumeMethod SetLocalVolume;
	}

	public delegate void SetInputModeHandler(Result result);

	public delegate void SettingsUpdateHandler();

	private IntPtr MethodsPtr;

	private object MethodsStructure;

	private FFIMethods Methods
	{
		get
		{
			if (MethodsStructure == null)
			{
				MethodsStructure = Marshal.PtrToStructure(MethodsPtr, typeof(FFIMethods));
			}
			return (FFIMethods)MethodsStructure;
		}
	}

	public event SettingsUpdateHandler OnSettingsUpdate;

	internal VoiceManager(IntPtr ptr, IntPtr eventsPtr, ref FFIEvents events)
	{
		if (eventsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
		InitEvents(eventsPtr, ref events);
		MethodsPtr = ptr;
		if (MethodsPtr == IntPtr.Zero)
		{
			throw new ResultException(Result.InternalError);
		}
	}

	private void InitEvents(IntPtr eventsPtr, ref FFIEvents events)
	{
		events.OnSettingsUpdate = OnSettingsUpdateImpl;
		Marshal.StructureToPtr(events, eventsPtr, fDeleteOld: false);
	}

	public InputMode GetInputMode()
	{
		InputMode inputMode = default(InputMode);
		Result result = Methods.GetInputMode(MethodsPtr, ref inputMode);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return inputMode;
	}

	[MonoPInvokeCallback]
	private static void SetInputModeCallbackImpl(IntPtr ptr, Result result)
	{
		GCHandle gCHandle = GCHandle.FromIntPtr(ptr);
		SetInputModeHandler obj = (SetInputModeHandler)gCHandle.Target;
		gCHandle.Free();
		obj(result);
	}

	public void SetInputMode(InputMode inputMode, SetInputModeHandler callback)
	{
		GCHandle value = GCHandle.Alloc(callback);
		Methods.SetInputMode(MethodsPtr, inputMode, GCHandle.ToIntPtr(value), SetInputModeCallbackImpl);
	}

	public bool IsSelfMute()
	{
		bool mute = false;
		Result result = Methods.IsSelfMute(MethodsPtr, ref mute);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return mute;
	}

	public void SetSelfMute(bool mute)
	{
		Result result = Methods.SetSelfMute(MethodsPtr, mute);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public bool IsSelfDeaf()
	{
		bool deaf = false;
		Result result = Methods.IsSelfDeaf(MethodsPtr, ref deaf);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return deaf;
	}

	public void SetSelfDeaf(bool deaf)
	{
		Result result = Methods.SetSelfDeaf(MethodsPtr, deaf);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public bool IsLocalMute(long userId)
	{
		bool mute = false;
		Result result = Methods.IsLocalMute(MethodsPtr, userId, ref mute);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return mute;
	}

	public void SetLocalMute(long userId, bool mute)
	{
		Result result = Methods.SetLocalMute(MethodsPtr, userId, mute);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	public byte GetLocalVolume(long userId)
	{
		byte volume = 0;
		Result result = Methods.GetLocalVolume(MethodsPtr, userId, ref volume);
		if (result != 0)
		{
			throw new ResultException(result);
		}
		return volume;
	}

	public void SetLocalVolume(long userId, byte volume)
	{
		Result result = Methods.SetLocalVolume(MethodsPtr, userId, volume);
		if (result != 0)
		{
			throw new ResultException(result);
		}
	}

	[MonoPInvokeCallback]
	private static void OnSettingsUpdateImpl(IntPtr ptr)
	{
		Discord discord = (Discord)GCHandle.FromIntPtr(ptr).Target;
		if (discord.VoiceManagerInstance.OnSettingsUpdate != null)
		{
			discord.VoiceManagerInstance.OnSettingsUpdate();
		}
	}
}
}

// Fishing/FishIconGlow.cs
namespace Fishing{
public class FishIconGlow : MonoBehaviour
{
	private Image image;

	private void Awake()
	{
		image = GetComponent<Image>();
	}

	public void Blink()
	{
		StartCoroutine(BlinkCoroutine());
	}

	private IEnumerator BlinkCoroutine()
	{
		Color color = Color.white;
		color.a = 0.7f;
		image.color = color;
		while (color.a < 1f)
		{
			color.a += Time.deltaTime;
			image.color = color;
			yield return null;
		}
		while (color.a > 0f)
		{
			color.a -= Time.deltaTime;
			image.color = color;
			yield return null;
		}
	}
}
}

// Sandbox/AlterMenuElements.cs
namespace Sandbox{
public class AlterMenuElements : MonoBehaviour
{
	public enum Axis
	{
		X,
		Y,
		Z
	}

	[SerializeField]
	private TooltipManager tooltipManager;

	[SerializeField]
	private Transform container;

	[Header("Templates")]
	[SerializeField]
	private GameObject titleTemplate;

	[SerializeField]
	private GameObject boolRowTemplate;

	[SerializeField]
	private GameObject floatRowTemplate;

	[SerializeField]
	private AlterMenuVector3Field vector3RowTemplate;

	[SerializeField]
	private GameObject dropdownRowTemplate;

	private readonly List<int> createdRows = new List<int>();

	private readonly Dictionary<int, Vector3> vector3ValueStore = new Dictionary<int, Vector3>();

	public void CreateTitle(string name)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(titleTemplate, container, worldPositionStays: false);
		gameObject.SetActive(value: true);
		gameObject.GetComponentInChildren<TMP_Text>().text = name;
		createdRows.Add(gameObject.GetInstanceID());
	}

	public void CreateBoolRow(string name, bool initialState, Action<bool> callback, string tooltipMessage = null)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(boolRowTemplate, container, worldPositionStays: false);
		gameObject.SetActive(value: true);
		gameObject.GetComponentInChildren<TMP_Text>().text = name;
		Toggle componentInChildren = gameObject.GetComponentInChildren<Toggle>();
		componentInChildren.SetIsOnWithoutNotify(initialState);
		componentInChildren.interactable = callback != null;
		if (callback != null)
		{
			componentInChildren.onValueChanged.AddListener(delegate(bool state)
			{
				callback(state);
			});
		}
		if (tooltipMessage != null)
		{
			CreateTooltip(gameObject, tooltipMessage);
		}
		createdRows.Add(gameObject.GetInstanceID());
	}

	public void CreateFloatRow(string name, float initialState, Action<float> callback, IConstraints constraints = null, string tooltipMessage = null)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(floatRowTemplate, container, worldPositionStays: false);
		gameObject.SetActive(value: true);
		gameObject.GetComponentInChildren<TMP_Text>().text = name;
		Slider componentInChildren = gameObject.GetComponentInChildren<Slider>();
		if (constraints is SliderConstraints sliderConstraints)
		{
			componentInChildren.minValue = sliderConstraints.min;
			componentInChildren.maxValue = sliderConstraints.max;
			componentInChildren.wholeNumbers = sliderConstraints.step % 1f == 0f;
			if (!componentInChildren.wholeNumbers)
			{
				gameObject.GetComponentInChildren<SliderLabel>().floor = false;
			}
		}
		componentInChildren.SetValueWithoutNotify(initialState);
		componentInChildren.interactable = callback != null;
		if (callback != null)
		{
			componentInChildren.onValueChanged.AddListener(delegate(float value)
			{
				callback(value);
			});
		}
		if (tooltipMessage != null)
		{
			CreateTooltip(gameObject, tooltipMessage);
		}
		createdRows.Add(gameObject.GetInstanceID());
	}

	public void CreateVector3Row(string name, Vector3 initialState, Action<Vector3> callback, string tooltipMessage = null)
	{
		AlterMenuVector3Field row = UnityEngine.Object.Instantiate(vector3RowTemplate, container, worldPositionStays: false);
		row.gameObject.SetActive(value: true);
		row.nameText.text = name;
		row.xField.SetTextWithoutNotify(initialState.x.ToString(CultureInfo.InvariantCulture));
		row.yField.SetTextWithoutNotify(initialState.y.ToString(CultureInfo.InvariantCulture));
		row.zField.SetTextWithoutNotify(initialState.z.ToString(CultureInfo.InvariantCulture));
		vector3ValueStore.Add(row.GetInstanceID(), initialState);
		row.xField.interactable = callback != null;
		row.yField.interactable = callback != null;
		row.zField.interactable = callback != null;
		if (callback != null)
		{
			row.xField.onValueChanged.AddListener(delegate(string value)
			{
				if (float.TryParse(value, out var result3))
				{
					UpdateVector3Value(row.GetInstanceID(), result3, Axis.X);
					callback(vector3ValueStore[row.GetInstanceID()]);
				}
			});
			row.yField.onValueChanged.AddListener(delegate(string value)
			{
				if (float.TryParse(value, out var result2))
				{
					UpdateVector3Value(row.GetInstanceID(), result2, Axis.Y);
					callback(vector3ValueStore[row.GetInstanceID()]);
				}
			});
			row.zField.onValueChanged.AddListener(delegate(string value)
			{
				if (float.TryParse(value, out var result))
				{
					UpdateVector3Value(row.GetInstanceID(), result, Axis.Z);
					callback(vector3ValueStore[row.GetInstanceID()]);
				}
			});
		}
		if (tooltipMessage != null)
		{
			CreateTooltip(row.gameObject, tooltipMessage);
		}
		createdRows.Add(row.gameObject.GetInstanceID());
	}

	public void UpdateVector3Value(int id, float value, Axis axis)
	{
		if (!vector3ValueStore.ContainsKey(id))
		{
			vector3ValueStore.Add(id, Vector3.zero);
		}
		Vector3 value2 = vector3ValueStore[id];
		switch (axis)
		{
		case Axis.X:
			value2.x = value;
			break;
		case Axis.Y:
			value2.y = value;
			break;
		case Axis.Z:
			value2.z = value;
			break;
		default:
			throw new ArgumentOutOfRangeException("axis", axis, null);
		}
		vector3ValueStore[id] = value2;
	}

	public void CreateEnumRow(string name, int initialState, Action<int> callback, Type type, string tooltipMessage = null)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(dropdownRowTemplate, container, worldPositionStays: false);
		gameObject.SetActive(value: true);
		gameObject.GetComponentInChildren<TMP_Text>().text = name;
		Dropdown componentInChildren = gameObject.GetComponentInChildren<Dropdown>();
		string[] names = Enum.GetNames(type);
		componentInChildren.ClearOptions();
		componentInChildren.AddOptions(new List<string>(names));
		componentInChildren.SetValueWithoutNotify(initialState);
		componentInChildren.interactable = callback != null;
		if (callback != null)
		{
			componentInChildren.onValueChanged.AddListener(delegate(int value)
			{
				callback(value);
			});
		}
		if (tooltipMessage != null)
		{
			CreateTooltip(gameObject, tooltipMessage);
		}
		createdRows.Add(gameObject.GetInstanceID());
	}

	public void Reset()
	{
		foreach (Transform item in container)
		{
			if (item.gameObject.activeSelf && !(item.gameObject == titleTemplate) && !(item.gameObject == boolRowTemplate) && !(item.gameObject == floatRowTemplate) && createdRows.Contains(item.gameObject.GetInstanceID()))
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		createdRows.Clear();
	}

	private void CreateTooltip(GameObject row, string message)
	{
		TooltipOnHover tooltipOnHover = row.AddComponent<TooltipOnHover>();
		tooltipOnHover.tooltipManager = tooltipManager;
		tooltipOnHover.text = message;
	}
}
}

// Sandbox/AlterOption.cs
namespace Sandbox{
[Serializable]
public class AlterOption<T>
{
	public string name;

	public string key;

	public string tooltip;

	public T value;

	public Type type;

	public Action<T> callback;

	public IConstraints constraints;
}
}

// Sandbox/EnemyRadianceConfig.cs
namespace Sandbox{
[Serializable]
public class EnemyRadianceConfig
{
	public bool enabled;

	public float tier = 1f;

	public float damageBuff;

	public float speedBuff;

	public float healthBuff;

	public bool damageEnabled
	{
		get
		{
			if (enabled && tier > 0f)
			{
				return damageBuff > 0f;
			}
			return false;
		}
	}

	public bool speedEnabled
	{
		get
		{
			if (enabled && tier > 0f)
			{
				return speedBuff > 0f;
			}
			return false;
		}
	}

	public bool healthEnabled
	{
		get
		{
			if (enabled && tier > 0f)
			{
				return healthBuff > 0f;
			}
			return false;
		}
	}

	public EnemyRadianceConfig()
	{
	}

	public EnemyRadianceConfig(EnemyIdentifier enemyId)
	{
		damageBuff = enemyId.damageBuffModifier;
		speedBuff = enemyId.speedBuffModifier;
		healthBuff = enemyId.healthBuffModifier;
	}
}
}

// Sandbox/IAlter.cs
namespace Sandbox{
public interface IAlter
{
	string alterKey { get; }

	string alterCategoryName { get; }
}
}

// Sandbox/IAlterOptions.cs
namespace Sandbox{
public interface IAlterOptions<T>
{
	AlterOption<T>[] options { get; }
}
}

// Sandbox/IConstraints.cs
namespace Sandbox{
public interface IConstraints
{
}
}

// Sandbox/SandboxAlterMenu.cs
namespace Sandbox{
[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxAlterMenu : MonoSingleton<SandboxAlterMenu>
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxAlterMenu");

	[SerializeField]
	private GameObject shadow;

	[SerializeField]
	private GameObject menu;

	[Space]
	[SerializeField]
	private TMP_Text nameText;

	[Space]
	[SerializeField]
	private Toggle uniformSize;

	[SerializeField]
	private InputField sizeField;

	[SerializeField]
	private InputField sizeFieldX;

	[SerializeField]
	private InputField sizeFieldY;

	[SerializeField]
	private InputField sizeFieldZ;

	[Space]
	[SerializeField]
	private Toggle radianceEnabled;

	[SerializeField]
	private Slider radianceTier;

	[SerializeField]
	private Slider radianceHealth;

	[SerializeField]
	private Slider radianceDamage;

	[SerializeField]
	private Slider radianceSpeed;

	[Space]
	[SerializeField]
	private GameObject sizeContainer;

	[SerializeField]
	private GameObject uniformContainer;

	[SerializeField]
	private Toggle frozenCheckbox;

	[SerializeField]
	private Toggle disallowManipulationCheckbox;

	[SerializeField]
	private Toggle disallowFreezingCheckbox;

	[SerializeField]
	private GameObject splitContainer;

	[SerializeField]
	private GameObject enemyOptionsContainer;

	[SerializeField]
	private GameObject radianceSettings;

	[Space]
	[SerializeField]
	private GameObject scaleUpSound;

	[SerializeField]
	private GameObject scaleDownSound;

	[SerializeField]
	private GameObject scaleResetSound;

	[Space]
	[SerializeField]
	private AlterMenuElements elementManager;

	public SandboxSpawnableInstance editedObject;

	public AlterMode alterInstance;

	public Vector3 SafeSize(Vector3 originalSize)
	{
		float min = 0.00390625f;
		float max = 128f;
		float x = Mathf.Clamp(originalSize.x, min, max);
		float y = Mathf.Clamp(originalSize.y, min, max);
		float z = Mathf.Clamp(originalSize.z, min, max);
		return new Vector3(x, y, z);
	}

	protected override void Awake()
	{
		base.Awake();
		sizeFieldX.onValueChanged.AddListener(SetSizeX);
		sizeFieldY.onValueChanged.AddListener(SetSizeY);
		sizeFieldZ.onValueChanged.AddListener(SetSizeZ);
		sizeField.onValueChanged.AddListener(SetSize);
		sizeFieldX.onEndEdit.AddListener(delegate
		{
			UpdateSizeValues();
		});
		sizeFieldY.onEndEdit.AddListener(delegate
		{
			UpdateSizeValues();
		});
		sizeFieldZ.onEndEdit.AddListener(delegate
		{
			UpdateSizeValues();
		});
		sizeField.onEndEdit.AddListener(delegate
		{
			UpdateSizeValues();
		});
	}

	private void SetSizeX(string value)
	{
		if (!(editedObject == null))
		{
			Vector3 normalizedSize = editedObject.normalizedSize;
			if (float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
			{
				editedObject.SetSize(SafeSize(new Vector3(result, normalizedSize.y, normalizedSize.z)));
			}
		}
	}

	private void SetSizeY(string value)
	{
		if (!(editedObject == null))
		{
			Vector3 normalizedSize = editedObject.normalizedSize;
			Debug.Log(value);
			if (float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
			{
				editedObject.SetSize(SafeSize(new Vector3(normalizedSize.x, result, normalizedSize.z)));
			}
		}
	}

	private void SetSizeZ(string value)
	{
		if (!(editedObject == null))
		{
			Vector3 normalizedSize = editedObject.normalizedSize;
			if (float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
			{
				editedObject.SetSize(SafeSize(new Vector3(normalizedSize.x, normalizedSize.y, result)));
			}
		}
	}

	private void SetSize(string value)
	{
		if (!(editedObject == null) && float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
		{
			editedObject.SetSizeUniform(result);
		}
	}

	public void SetJumpPadPower(float value)
	{
		if (!(editedObject == null))
		{
			JumpPad componentInChildren = editedObject.GetComponentInChildren<JumpPad>();
			if (!(componentInChildren == null))
			{
				componentInChildren.force = value;
			}
		}
	}

	public void SetFrozen(bool frozen)
	{
		if ((bool)editedObject)
		{
			editedObject.frozen = frozen;
		}
	}

	public void SetDisallowManipulation(bool disallow)
	{
		if ((bool)editedObject)
		{
			editedObject.disallowManipulation = disallow;
		}
	}

	public void SetDisallowFreezing(bool disallow)
	{
		if ((bool)editedObject)
		{
			editedObject.disallowFreezing = disallow;
		}
	}

	public void SetRadianceTierSlider(float value)
	{
		SetRadianceTier(value / 2f);
	}

	public void SetRadianceTier(float value)
	{
		if (editedObject is SandboxEnemy sandboxEnemy)
		{
			sandboxEnemy.radiance.tier = value;
			sandboxEnemy.UpdateRadiance();
		}
	}

	public void SetHealthBuffSlider(float value)
	{
		SetHealthBuff(value / 2f);
	}

	public void SetHealthBuff(float value)
	{
		if (editedObject is SandboxEnemy sandboxEnemy)
		{
			sandboxEnemy.radiance.healthBuff = value;
			sandboxEnemy.UpdateRadiance();
		}
	}

	public void SetDamageBuffSlider(float value)
	{
		SetDamageBuff(value / 2f);
	}

	public void SetDamageBuff(float value)
	{
		if (editedObject is SandboxEnemy sandboxEnemy)
		{
			Debug.Log("Setting Damage Buff: " + value);
			sandboxEnemy.radiance.damageBuff = value;
			sandboxEnemy.UpdateRadiance();
		}
	}

	public void SetSpeedBuffSlider(float value)
	{
		SetSpeedBuff(value / 2f);
	}

	public void SetSpeedBuff(float value)
	{
		if (editedObject is SandboxEnemy sandboxEnemy)
		{
			sandboxEnemy.radiance.speedBuff = value;
			sandboxEnemy.UpdateRadiance();
		}
	}

	public void ShowRadianceOptions(bool value)
	{
		radianceSettings.SetActive(value);
		if (editedObject is SandboxEnemy sandboxEnemy)
		{
			if (sandboxEnemy.radiance == null)
			{
				sandboxEnemy.radiance = new EnemyRadianceConfig(sandboxEnemy.enemyId);
			}
			sandboxEnemy.radiance.enabled = value;
			if (value)
			{
				Debug.Log("Loading Damage Buff: " + sandboxEnemy.radiance.damageBuff);
				radianceEnabled.SetIsOnWithoutNotify(value: true);
				radianceTier.SetValueWithoutNotify(sandboxEnemy.radiance.tier * 2f);
				radianceDamage.SetValueWithoutNotify(sandboxEnemy.radiance.damageBuff * 2f);
				radianceHealth.SetValueWithoutNotify(sandboxEnemy.radiance.healthBuff * 2f);
				radianceSpeed.SetValueWithoutNotify(sandboxEnemy.radiance.speedBuff * 2f);
			}
			else
			{
				radianceEnabled.SetIsOnWithoutNotify(value: false);
			}
			sandboxEnemy.UpdateRadiance();
		}
	}

	public void ShowUniformSizeMenu(bool value)
	{
		uniformSize.SetIsOnWithoutNotify(value);
		uniformContainer.SetActive(value);
		splitContainer.SetActive(!value);
		sizeFieldX.interactable = !value;
		sizeFieldY.interactable = !value;
		sizeFieldZ.interactable = !value;
		sizeField.interactable = value;
		if (value)
		{
			editedObject.SetSizeUniform(editedObject.normalizedSize.x);
		}
		UpdateSizeValues();
	}

	public void DefaultSize()
	{
		if (!(editedObject == null))
		{
			editedObject.transform.localScale = editedObject.defaultSize;
			UpdateSizeValues();
			UnityEngine.Object.Instantiate(scaleResetSound, base.transform.position, Quaternion.identity);
		}
	}

	public void MultiplySize(float value)
	{
		if (!(editedObject == null))
		{
			Vector3 localScale = editedObject.transform.localScale;
			localScale *= value;
			localScale = SafeSize(localScale);
			editedObject.transform.localScale = localScale;
			ShowUniformSizeMenu(uniformContainer.activeSelf);
			UpdateSizeValues();
			UnityEngine.Object.Instantiate((value > 1f) ? scaleUpSound : scaleDownSound, editedObject.transform.position, Quaternion.identity);
		}
	}

	public void UpdateSizeValues()
	{
		Vector3 localScale = editedObject.transform.localScale;
		if (uniformContainer.activeSelf)
		{
			sizeField.SetTextWithoutNotify((localScale.x / editedObject.defaultSize.x).ToString(CultureInfo.InvariantCulture));
			return;
		}
		sizeFieldX.SetTextWithoutNotify((localScale.x / editedObject.defaultSize.x).ToString(CultureInfo.InvariantCulture));
		sizeFieldY.SetTextWithoutNotify((localScale.y / editedObject.defaultSize.y).ToString(CultureInfo.InvariantCulture));
		sizeFieldZ.SetTextWithoutNotify((localScale.z / editedObject.defaultSize.z).ToString(CultureInfo.InvariantCulture));
	}

	public void Show(SandboxSpawnableInstance prop, AlterMode instance)
	{
		Log.Info("Showing Sandbox Alter Menu for " + prop.name);
		prop.Pause(freeze: false);
		shadow.SetActive(value: true);
		elementManager.Reset();
		menu.SetActive(value: true);
		frozenCheckbox.SetIsOnWithoutNotify(prop.frozen);
		disallowManipulationCheckbox.SetIsOnWithoutNotify(prop.disallowManipulation);
		disallowFreezingCheckbox.SetIsOnWithoutNotify(prop.disallowFreezing);
		nameText.text = prop.name;
		editedObject = prop;
		alterInstance = instance;
		GameStateManager.Instance.RegisterState(new GameState("alter-menu", menu)
		{
			cursorLock = LockMode.Unlock,
			cameraInputLock = LockMode.Lock,
			playerInputLock = LockMode.Unlock
		});
		MonoSingleton<CameraController>.Instance.activated = false;
		MonoSingleton<GunControl>.Instance.activated = false;
		bool flag = !(prop is BrushBlock);
		sizeContainer.SetActive(flag);
		if (flag)
		{
			ShowUniformSizeMenu(prop.uniformSize);
		}
		if (prop is SandboxEnemy sandboxEnemy)
		{
			ShowRadianceOptions(sandboxEnemy.radiance.enabled);
			enemyOptionsContainer.SetActive(value: true);
		}
		else
		{
			enemyOptionsContainer.SetActive(value: false);
			radianceSettings.SetActive(value: false);
		}
		IAlter[] componentsInChildren = prop.GetComponentsInChildren<IAlter>();
		List<string> list = new List<string>();
		IAlter[] array = componentsInChildren;
		foreach (IAlter alter in array)
		{
			if (alter.alterKey != null)
			{
				if (list.Contains(alter.alterKey))
				{
					continue;
				}
				list.Add(alter.alterKey);
			}
			int num = 0;
			if (alter is IAlterOptions<bool> { options: not null } alterOptions)
			{
				num += alterOptions.options.Length;
			}
			if (alter is IAlterOptions<float> { options: not null } alterOptions2)
			{
				num += alterOptions2.options.Length;
			}
			if (alter is IAlterOptions<Vector3> { options: not null } alterOptions3)
			{
				num += alterOptions3.options.Length;
			}
			if (alter is IAlterOptions<int> { options: not null } alterOptions4)
			{
				num += alterOptions4.options.Length;
			}
			if (num == 0)
			{
				continue;
			}
			elementManager.CreateTitle(alter.alterCategoryName ?? alter.alterKey ?? string.Empty);
			if (alter is IAlterOptions<bool> alterOptions5)
			{
				if (alterOptions5.options == null)
				{
					continue;
				}
				AlterOption<bool>[] options = alterOptions5.options;
				foreach (AlterOption<bool> alterOption in options)
				{
					elementManager.CreateBoolRow(alterOption.name, alterOption.value, alterOption.callback, alterOption.tooltip);
				}
			}
			if (alter is IAlterOptions<float> alterOptions6)
			{
				if (alterOptions6.options == null)
				{
					continue;
				}
				AlterOption<float>[] options2 = alterOptions6.options;
				foreach (AlterOption<float> alterOption2 in options2)
				{
					elementManager.CreateFloatRow(alterOption2.name, alterOption2.value, alterOption2.callback, alterOption2.constraints, alterOption2.tooltip);
				}
			}
			if (alter is IAlterOptions<Vector3> alterOptions7)
			{
				if (alterOptions7.options == null)
				{
					continue;
				}
				AlterOption<Vector3>[] options3 = alterOptions7.options;
				foreach (AlterOption<Vector3> alterOption3 in options3)
				{
					elementManager.CreateVector3Row(alterOption3.name, alterOption3.value, alterOption3.callback, alterOption3.tooltip);
				}
			}
			if (!(alter is IAlterOptions<int> { options: not null, options: var options4 }))
			{
				continue;
			}
			foreach (AlterOption<int> alterOption4 in options4)
			{
				Type type = alterOption4.type;
				if (!(type == null) && type.IsEnum)
				{
					elementManager.CreateEnumRow(alterOption4.name, alterOption4.value, alterOption4.callback, type, alterOption4.tooltip);
				}
			}
		}
	}

	public void Close()
	{
		Log.Info("Closing Alter Menu");
		shadow.SetActive(value: false);
		menu.SetActive(value: false);
		editedObject = null;
		alterInstance?.EndSession();
		MonoSingleton<CameraController>.Instance.activated = true;
		MonoSingleton<GunControl>.Instance.activated = true;
	}

	private void Update()
	{
		if (editedObject == null && menu.activeSelf)
		{
			Close();
			MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("<color=red>Altered object was destroyed.</color>");
		}
		if (!menu.activeSelf && shadow.activeSelf)
		{
			alterInstance.EndSession();
			shadow.SetActive(value: false);
			editedObject = null;
		}
	}
}
}

// Sandbox/SandboxEnemy.cs
namespace Sandbox{
public class SandboxEnemy : SandboxSpawnableInstance
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxEnemy");

	public EnemyIdentifier enemyId;

	public EnemyRadianceConfig radiance;

	private bool lastSpeedBuffState;

	private bool lastDamageBuffState;

	private bool lastHealthBuffState;

	private bool lastKinematicState;

	public override void Awake()
	{
		base.Awake();
		enemyId = GetComponent<EnemyIdentifier>();
		if (enemyId == null)
		{
			enemyId = GetComponentInChildren<EnemyIdentifier>();
		}
		radiance = new EnemyRadianceConfig(enemyId);
	}

	public void RestoreRadiance(EnemyRadianceConfig config)
	{
		radiance = config;
		if (config != null)
		{
			UpdateRadiance();
		}
	}

	public void UpdateRadiance()
	{
		enemyId.radianceTier = radiance.tier;
		if (!lastSpeedBuffState && radiance.speedEnabled)
		{
			enemyId.SpeedBuff(radiance.speedBuff);
		}
		else if (lastSpeedBuffState && !radiance.speedEnabled)
		{
			enemyId.SpeedUnbuff();
		}
		enemyId.speedBuffModifier = radiance.speedBuff;
		if (!lastDamageBuffState && radiance.damageEnabled)
		{
			enemyId.DamageBuff(radiance.damageBuff);
		}
		else if (lastDamageBuffState && !radiance.damageEnabled)
		{
			enemyId.DamageUnbuff();
		}
		enemyId.damageBuffModifier = radiance.damageBuff;
		if (!lastHealthBuffState && radiance.healthEnabled)
		{
			enemyId.HealthBuff(radiance.healthBuff);
		}
		else if (lastHealthBuffState && !radiance.healthEnabled)
		{
			enemyId.HealthUnbuff();
		}
		enemyId.healthBuffModifier = radiance.healthBuff;
		lastSpeedBuffState = radiance.speedEnabled;
		lastDamageBuffState = radiance.damageEnabled;
		lastHealthBuffState = radiance.healthEnabled;
		enemyId.UpdateBuffs();
	}

	private void OnEnable()
	{
		enemyId = GetComponent<EnemyIdentifier>();
		if (!enemyId)
		{
			enemyId = GetComponentInChildren<EnemyIdentifier>();
		}
	}

	public SavedEnemy SaveEnemy()
	{
		if (!enemyId || enemyId.health < 0f || enemyId.dead)
		{
			return null;
		}
		SavedEnemy savedEnemy = new SavedEnemy
		{
			Radiance = radiance
		};
		SavedGeneric saveObject = savedEnemy;
		BaseSave(ref saveObject);
		if (enemyId.originalScale != Vector3.zero)
		{
			savedEnemy.Scale = SavedVector3.One;
		}
		return savedEnemy;
	}

	public override void Pause(bool freeze = true)
	{
		base.Pause(freeze);
		GameObject gameObject = collider.gameObject;
		EnemyIdentifier enemyIdentifier = null;
		if (collider.gameObject.TryGetComponent<EnemyIdentifier>(out var component))
		{
			enemyIdentifier = component;
			enemyIdentifier.enabled = false;
		}
		else
		{
			enemyIdentifier = collider.gameObject.GetComponentInChildren<EnemyIdentifier>();
			if (enemyIdentifier != null)
			{
				enemyIdentifier.enabled = false;
				gameObject = enemyIdentifier.gameObject;
			}
		}
		foreach (Behaviour enemyComponent in GetEnemyComponents(gameObject))
		{
			enemyComponent.enabled = false;
		}
		if (gameObject.TryGetComponent<NavMeshAgent>(out var component2))
		{
			component2.enabled = false;
		}
		if (gameObject.TryGetComponent<Animator>(out var component3))
		{
			component3.enabled = false;
		}
		if (gameObject.TryGetComponent<Rigidbody>(out var component4))
		{
			lastKinematicState = component4.isKinematic;
			if (component4.collisionDetectionMode == CollisionDetectionMode.ContinuousDynamic)
			{
				component4.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
			}
			component4.isKinematic = true;
		}
	}

	public override void Resume()
	{
		base.Resume();
		if (collider == null)
		{
			return;
		}
		foreach (Behaviour enemyComponent in GetEnemyComponents(collider.gameObject))
		{
			enemyComponent.enabled = true;
		}
		if (collider.gameObject.TryGetComponent<NavMeshAgent>(out var component))
		{
			component.enabled = true;
		}
		if (collider.gameObject.TryGetComponent<EnemyIdentifier>(out var component2))
		{
			component2.enabled = true;
		}
		if (collider.gameObject.TryGetComponent<Animator>(out var component3))
		{
			component3.enabled = true;
		}
		if (collider.gameObject.TryGetComponent<Rigidbody>(out var component4))
		{
			component4.isKinematic = lastKinematicState;
		}
	}

	private IEnumerable<Component> GetEnemyComponents(GameObject obj)
	{
		foreach (Type type in EnemyTypes.types)
		{
			Component component;
			if (sourceObject.fullEnemyComponent)
			{
				Component[] componentsInChildren = obj.GetComponentsInChildren(type);
				Component[] array = componentsInChildren;
				for (int i = 0; i < array.Length; i++)
				{
					yield return array[i];
				}
			}
			else if (obj.TryGetComponent(type, out component))
			{
				yield return component;
			}
		}
	}

	private void Update()
	{
		if (!(enemyId != null))
		{
			Log.Fine("Destroying sandbox enemy due to missing EnemyIdentifier component.");
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
}

// Sandbox/SandboxProp.cs
namespace Sandbox{
public class SandboxProp : SandboxSpawnableInstance
{
	[SerializeField]
	private PhysicsSounds.PhysMaterial physicsMaterial;

	[SerializeField]
	private bool enableImpactDamage;

	public bool forceFullWorldPreview;

	private TimeSince timeSinceLastImpact;

	private void Start()
	{
		timeSinceLastImpact = 0f;
	}

	private void OnCollisionEnter(Collision other)
	{
		if (!(rigidbody == null) && !rigidbody.isKinematic && !(other.impulse.magnitude < 3f) && !((float)timeSinceLastImpact < 0.1f))
		{
			timeSinceLastImpact = 0f;
			MonoSingleton<PhysicsSounds>.Instance.ImpactAt(other.GetContact(0).point, other.impulse.magnitude, physicsMaterial);
		}
	}

	public SavedProp SaveProp()
	{
		SavedGeneric saveObject;
		SavedGeneric result = (saveObject = new SavedProp());
		BaseSave(ref saveObject);
		return (SavedProp)result;
	}

	private void OnCollisionStay(Collision other)
	{
		OnCollisionEnter(other);
	}

	public override void Pause(bool freeze = true)
	{
		base.Pause(freeze);
		if (TryGetComponent<Rigidbody>(out var component))
		{
			component.isKinematic = true;
			component.velocity = Vector3.zero;
		}
		collider.gameObject.isStatic = true;
	}

	public override void Resume()
	{
		base.Resume();
		if (TryGetComponent<Rigidbody>(out var component))
		{
			component.isKinematic = false;
		}
		collider.gameObject.isStatic = false;
	}
}
}

// Sandbox/SandboxSpawnableInstance.cs
namespace Sandbox{
public class SandboxSpawnableInstance : MonoBehaviour
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxSpawnableInstance");

	public SpawnableObject sourceObject;

	public GameObject attachedParticles;

	public Collider collider;

	[NonSerialized]
	public bool alwaysFrozen;

	[NonSerialized]
	public Rigidbody rigidbody;

	public bool frozen;

	public bool disallowManipulation;

	public bool disallowFreezing;

	public bool uniformSize
	{
		get
		{
			Vector3 vector = normalizedSize;
			if (vector.x == vector.y)
			{
				return vector.y == vector.z;
			}
			return false;
		}
	}

	public Vector3 defaultSize { get; private set; }

	public Vector3 normalizedSize => new Vector3(base.transform.localScale.x / defaultSize.x, base.transform.localScale.y / defaultSize.y, base.transform.localScale.z / defaultSize.z);

	public virtual void Awake()
	{
		defaultSize = base.transform.localScale;
		rigidbody = GetComponent<Rigidbody>();
		if (collider == null)
		{
			collider = GetComponent<Collider>();
		}
		if (collider == null)
		{
			collider = base.transform.GetComponentInChildren<Collider>();
		}
		SandboxPropPart[] componentsInChildren = GetComponentsInChildren<SandboxPropPart>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].parent = this;
		}
	}

	public virtual void SetSize(Vector3 size)
	{
		base.transform.localScale = new Vector3(size.x * defaultSize.x, size.y * defaultSize.y, size.z * defaultSize.z);
	}

	public void SetSizeUniform(float size)
	{
		SetSize(Vector3.one * size);
	}

	public void BaseSave(ref SavedGeneric saveObject)
	{
		if (saveObject != null)
		{
			saveObject.ObjectIdentifier = sourceObject.identifier;
			saveObject.Position = new SavedVector3(base.transform.position);
			saveObject.Rotation = new SavedQuaternion(base.transform.rotation);
			saveObject.Scale = new SavedVector3(normalizedSize);
			if (saveObject is SavedPhysical savedPhysical)
			{
				savedPhysical.Kinematic = frozen;
			}
			saveObject.DisallowManipulation = disallowManipulation;
			saveObject.DisallowFreezing = disallowFreezing;
		}
		else
		{
			saveObject = new SavedGeneric
			{
				ObjectIdentifier = sourceObject.identifier,
				Position = new SavedVector3(base.transform.position),
				Rotation = new SavedQuaternion(base.transform.rotation),
				Scale = new SavedVector3(normalizedSize),
				DisallowManipulation = disallowManipulation,
				DisallowFreezing = disallowFreezing
			};
		}
		IAlter[] array = (from c in GetComponentsInChildren<IAlter>()
			where c.alterKey != null
			select c).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		saveObject.Data = new SavedAlterData[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			IAlter alter = array[i];
			List<SavedAlterOption> list = new List<SavedAlterOption>();
			if (alter is IAlterOptions<bool> alterOptions)
			{
				if (alterOptions.options != null)
				{
					list.AddRange(from o in alterOptions.options
						where o.key != null
						select o into b
						select new SavedAlterOption
						{
							BoolValue = b.value,
							Key = b.key
						});
				}
				Log.Fine("Saving <b>bool</b> data for <b>" + alter.alterKey + "</b>");
				Log.Fine((alterOptions.options == null) ? "No options available!" : ("Bool Options: " + string.Join(", ", alterOptions.options.Select((AlterOption<bool> o) => o.key ?? "(missing key!)"))));
			}
			if (alter is IAlterOptions<float> alterOptions2)
			{
				if (alterOptions2.options != null)
				{
					list.AddRange(from o in alterOptions2.options
						where o.key != null
						select o into b
						select new SavedAlterOption
						{
							FloatValue = b.value,
							Key = b.key
						});
				}
				Log.Fine("Saving <b>float</b> data for <b>" + alter.alterKey + "</b>");
				Log.Fine((alterOptions2.options == null) ? "No options available!" : ("Float Options: " + string.Join(", ", alterOptions2.options.Select((AlterOption<float> o) => o.key ?? "(missing key!)"))));
			}
			if (alter is IAlterOptions<Vector3> alterOptions3)
			{
				if (alterOptions3.options != null)
				{
					list.AddRange(from o in alterOptions3.options
						where o.key != null
						select o into b
						select new SavedAlterOption
						{
							VectorData = b.value,
							Key = b.key
						});
				}
				if (Debug.isDebugBuild)
				{
					Log.Fine("Saving <b>vector</b> data for <b>" + alter.alterKey + "</b>");
					Log.Fine((alterOptions3.options == null) ? "No options available!" : ("Vector Options: " + string.Join(", ", alterOptions3.options.Select((AlterOption<Vector3> o) => o.key ?? "(missing key!)"))));
				}
			}
			if (alter is IAlterOptions<int> alterOptions4)
			{
				if (alterOptions4.options != null)
				{
					list.AddRange(from o in alterOptions4.options
						where o.key != null
						select o into b
						select new SavedAlterOption
						{
							IntValue = b.value,
							Key = b.key
						});
				}
				Log.Fine("Saving <b>float</b> data for <b>" + alter.alterKey + "</b>");
				Log.Fine((alterOptions4.options == null) ? "No options available!" : ("Float Options: " + string.Join(", ", alterOptions4.options.Select((AlterOption<int> o) => o.key ?? "(missing key!)"))));
			}
			saveObject.Data[i] = new SavedAlterData
			{
				Key = array[i].alterKey,
				Options = list.ToArray()
			};
		}
	}

	public virtual void Pause(bool freeze = true)
	{
		if (freeze)
		{
			frozen = true;
		}
	}

	public virtual void Resume()
	{
		frozen = false;
	}

	public void ApplyAlterOptions(IEnumerable<AlterOption> requestedOptions)
	{
		IAlterOptions<bool>[] array = null;
		IAlterOptions<int>[] array2 = null;
		IAlterOptions<float>[] array3 = null;
		IAlterOptions<Vector3>[] array4 = null;
		foreach (AlterOption requestedOption in requestedOptions)
		{
			if (requestedOption.useBool)
			{
				if (array == null)
				{
					array = GetComponentsInChildren<IAlterOptions<bool>>(includeInactive: true);
				}
				IAlterOptions<bool>[] array5 = array;
				for (int i = 0; i < array5.Length; i++)
				{
					AlterOption<bool>[] options = array5[i].options;
					foreach (AlterOption<bool> alterOption in options)
					{
						if (!(alterOption.key != requestedOption.targetKey))
						{
							alterOption.callback(requestedOption.boolValue);
						}
					}
				}
			}
			if (requestedOption.useInt)
			{
				if (array2 == null)
				{
					array2 = GetComponentsInChildren<IAlterOptions<int>>(includeInactive: true);
				}
				IAlterOptions<int>[] array6 = array2;
				for (int i = 0; i < array6.Length; i++)
				{
					AlterOption<int>[] options2 = array6[i].options;
					foreach (AlterOption<int> alterOption2 in options2)
					{
						if (!(alterOption2.key != requestedOption.targetKey))
						{
							alterOption2.callback(requestedOption.intValue);
						}
					}
				}
			}
			if (requestedOption.useFloat)
			{
				if (array3 == null)
				{
					array3 = GetComponentsInChildren<IAlterOptions<float>>(includeInactive: true);
				}
				IAlterOptions<float>[] array7 = array3;
				for (int i = 0; i < array7.Length; i++)
				{
					AlterOption<float>[] options3 = array7[i].options;
					foreach (AlterOption<float> alterOption3 in options3)
					{
						if (!(alterOption3.key != requestedOption.targetKey))
						{
							alterOption3.callback(requestedOption.floatValue);
						}
					}
				}
			}
			if (!requestedOption.useVector)
			{
				continue;
			}
			if (array4 == null)
			{
				array4 = GetComponentsInChildren<IAlterOptions<Vector3>>(includeInactive: true);
			}
			IAlterOptions<Vector3>[] array8 = array4;
			for (int i = 0; i < array8.Length; i++)
			{
				AlterOption<Vector3>[] options4 = array8[i].options;
				foreach (AlterOption<Vector3> alterOption4 in options4)
				{
					if (!(alterOption4.key != requestedOption.targetKey))
					{
						alterOption4.callback(requestedOption.vectorValue);
					}
				}
			}
		}
	}
}
}

// Sandbox/SandboxStats.cs
namespace Sandbox{
public class SandboxStats
{
	public int brushesBuilt;

	public int propsSpawned;

	public int enemiesSpawned;

	public float hoursSpend;
}
}

// Sandbox/SliderConstraints.cs
namespace Sandbox{
public class SliderConstraints : IConstraints
{
	public float min;

	public float max;

	public float step = 1f;
}
}

// Sandbox/StatsDisplay.cs
namespace Sandbox{
public class StatsDisplay : MonoBehaviour
{
	[SerializeField]
	private TMP_Text textContent;

	private TimeSince timeSinceUpdate;

	private void UpdateDisplay()
	{
		if (!(SteamController.Instance == null) && SteamClient.IsValid)
		{
			SandboxStats sandboxStats = SteamController.Instance.GetSandboxStats();
			textContent.text = $"<color=orange>{sandboxStats.brushesBuilt}</color> - TOTAL BOXES BUILT\n" + $"<color=orange>{sandboxStats.propsSpawned}</color> - TOTAL PROPS PLACED\n" + $"<color=orange>{sandboxStats.enemiesSpawned}</color> - TOTAL ENEMIES SPAWNED\n" + $"<color=orange>{sandboxStats.hoursSpend:F1}h</color> - TOTAL TIME IN SANDBOX\n";
		}
	}

	private void OnEnable()
	{
		UpdateDisplay();
		timeSinceUpdate = 0f;
	}

	private void Update()
	{
		if ((float)timeSinceUpdate > 2f)
		{
			timeSinceUpdate = 0f;
			UpdateDisplay();
		}
	}
}
}

// NewBlood/AudioTypeEx.cs
namespace NewBlood{
public static class AudioTypeEx
{
	public const AudioType ASF = (AudioType)3;

	public const AudioType AT3 = (AudioType)4;

	public const AudioType CDDA = (AudioType)5;

	public const AudioType DLS = (AudioType)6;

	public const AudioType FLAC = (AudioType)7;

	public const AudioType FSB = (AudioType)8;

	public const AudioType GCADPCM = (AudioType)9;

	public const AudioType MIDI = (AudioType)11;

	public const AudioType PLAYLIST = (AudioType)15;

	public const AudioType RAW = (AudioType)16;

	public const AudioType SF2 = (AudioType)18;

	public const AudioType USER = (AudioType)19;

	public const AudioType XWMA = (AudioType)25;

	public const AudioType BCWAV = (AudioType)26;

	public const AudioType AT9 = (AudioType)27;

	public const AudioType PCM = (AudioType)28;

	public const AudioType ADPCM = (AudioType)29;
}
}

// NewBlood/ResourceLoader.cs
namespace NewBlood{
internal static class ResourceLoader
{
	public static IEnumerator LoadAudioClip(string path, AudioClipLoadType loadType, Action<AudioClip> onCompleted)
	{
		return LoadAudioClip(path, loadType, AudioType.UNKNOWN, onCompleted, delegate(Action<AudioClip> _, AudioClip clip)
		{
			onCompleted(clip);
		});
	}

	public static IEnumerator LoadAudioClip(string path, AudioClipLoadType loadType, AudioType audioType, Action<AudioClip> onCompleted)
	{
		return LoadAudioClip(path, loadType, audioType, onCompleted, delegate(Action<AudioClip> _, AudioClip clip)
		{
			onCompleted(clip);
		});
	}

	public static IEnumerator LoadAudioClip<TState>(string path, AudioClipLoadType loadType, TState state, Action<TState, AudioClip> onCompleted)
	{
		return LoadAudioClip(path, loadType, AudioType.UNKNOWN, state, onCompleted);
	}

	public static IEnumerator LoadAudioClip<TState>(string path, AudioClipLoadType loadType, AudioType audioType, TState state, Action<TState, AudioClip> onCompleted)
	{
		if (path == null)
		{
			throw new ArgumentNullException("path");
		}
		if (onCompleted == null)
		{
			throw new ArgumentNullException("onCompleted");
		}
		Uri fileUri = GetFileUri(path);
		UnityWebRequest request = UnityWebRequestMultimedia.GetAudioClip(fileUri, audioType);
		DownloadHandlerAudioClip handler = (DownloadHandlerAudioClip)request.downloadHandler;
		switch (loadType)
		{
		case AudioClipLoadType.Streaming:
			handler.streamAudio = true;
			break;
		case AudioClipLoadType.CompressedInMemory:
			handler.compressed = true;
			break;
		}
		UnityWebRequestAsyncOperation unityWebRequestAsyncOperation = request.SendWebRequest();
		DisposeAndThrowIfRequestFailed(request);
		if (loadType == AudioClipLoadType.Streaming)
		{
			try
			{
				onCompleted(state, handler.audioClip);
			}
			catch
			{
				request.Dispose();
				throw;
			}
		}
		yield return unityWebRequestAsyncOperation;
		DisposeAndThrowIfRequestFailed(request);
		if (loadType == AudioClipLoadType.Streaming)
		{
			request.Dispose();
			yield break;
		}
		using (request)
		{
			onCompleted(state, handler.audioClip);
		}
	}

	private static void DisposeAndThrowIfRequestFailed(UnityWebRequest request)
	{
		if (!request.isHttpError || !request.isNetworkError || !request.isDone)
		{
			return;
		}
		Exception exceptionForWebRequest = GetExceptionForWebRequest(request);
		request.Dispose();
		throw exceptionForWebRequest;
	}

	private static Exception GetExceptionForWebRequest(UnityWebRequest request)
	{
		if (request.responseCode == 404)
		{
			return new FileNotFoundException(null, request.uri.LocalPath);
		}
		return new Exception(request.error);
	}

	private static Uri GetFileUri(string path)
	{
		path = Path.GetFullPath(path);
		path = path.Replace('\\', '/');
		path = Uri.EscapeUriString(path);
		return new UriBuilder(Uri.UriSchemeFile, string.Empty, 0, path).Uri;
	}
}
}

// CustomRay/RaycastResult.cs
namespace CustomRay{
public class RaycastResult : IComparable<RaycastResult>
{
	public float distance;

	public Transform transform;

	public RaycastHit rrhit;

	public RaycastResult(RaycastHit hit)
	{
		distance = hit.distance;
		transform = hit.transform;
		rrhit = hit;
	}

	public int CompareTo(RaycastResult other)
	{
		return distance.CompareTo(other.distance);
	}
}
}

// GameConsole/Binds.cs
namespace GameConsole{
public class Binds
{
	public Dictionary<string, InputActionState> registeredBinds;

	public Dictionary<string, string> defaultBinds = new Dictionary<string, string>
	{
		{ "open", "/Keyboard/f8" },
		{ "submit", "/Keyboard/enter" },
		{ "command_history_up", "/Keyboard/upArrow" },
		{ "command_history_down", "/Keyboard/downArrow" },
		{ "scroll_up", "/Keyboard/pageUp" },
		{ "scroll_down", "/Keyboard/pageUp" },
		{ "scroll_to_bottom", "/Keyboard/home" },
		{ "scroll_to_top", "/Keyboard/end" },
		{ "autocomplete", "/Keyboard/tab" }
	};

	private Logger Log { get; } = new Logger("Binds");


	public bool OpenPressed => SafeWasPerformed("open");

	public bool SubmitPressed => SafeWasPerformed("submit");

	public bool AutocompletePressed => SafeWasPerformed("autocomplete");

	public bool CommandHistoryUpPressed => SafeWasPerformed("command_history_up");

	public bool CommandHistoryDownPressed => SafeWasPerformed("command_history_down");

	public bool ScrollUpPressed => SafeWasPerformed("scroll_up");

	public bool ScrollDownPressed => SafeWasPerformed("scroll_down");

	public bool ScrollToBottomPressed => SafeWasPerformed("scroll_to_bottom");

	public bool ScrollToTopPressed => SafeWasPerformed("scroll_to_top");

	public bool ScrollUpHeld => SafeIsHeld("scroll_up");

	public bool ScrollDownHeld => SafeIsHeld("scroll_down");

	private bool SafeWasPerformed(string key)
	{
		if (registeredBinds != null && registeredBinds.TryGetValue(key, out var value))
		{
			return value.WasPerformedThisFrame;
		}
		return false;
	}

	private bool SafeIsHeld(string key)
	{
		if (registeredBinds != null && registeredBinds.TryGetValue(key, out var value))
		{
			return value.IsPressed;
		}
		return false;
	}

	public void Initialize()
	{
		Log.Parent = Console.Log;
		registeredBinds = new Dictionary<string, InputActionState>();
		foreach (KeyValuePair<string, string> defaultBind in defaultBinds)
		{
			InputActionState inputActionState = new InputActionState(new InputAction(defaultBind.Key));
			registeredBinds.Add(defaultBind.Key, inputActionState);
			inputActionState.Action.AddBinding(MonoSingleton<PrefsManager>.Instance.GetString("consoleBinding." + defaultBind.Key, defaultBind.Value)).WithGroup("Keyboard");
			inputActionState.Action.Enable();
		}
	}

	public void Rebind(string key, string bind)
	{
		if (!defaultBinds.ContainsKey(key))
		{
			Log.Info("Invalid console bind key: " + key);
			return;
		}
		string key2 = "consoleBinding." + key;
		MonoSingleton<PrefsManager>.Instance.SetString(key2, bind);
		if (registeredBinds.TryGetValue(key, out var value))
		{
			value.Action.Disable();
			value.Action.Dispose();
		}
		value = new InputActionState(new InputAction(key));
		registeredBinds[key] = value;
		value.Action.AddBinding(bind).WithGroup("Keyboard");
		value.Action.Enable();
		MonoSingleton<Console>.Instance.UpdateDisplayString();
	}
}
}

// GameConsole/ClipboardStuff.cs
namespace GameConsole{
public class ClipboardStuff : MonoBehaviour
{
	public void TogglePopup()
	{
		base.gameObject.SetActive(!base.gameObject.activeSelf);
	}

	public void CopyToClipboard()
	{
		GUIUtility.systemCopyBuffer = string.Join("\n", MonoSingleton<Console>.Instance.logs.Select((ConsoleLog c) => $"[{c.log.Timestamp:HH:mm:ss.f}] [{c.log.Level}] {c.log.Message}\n{c.log.StackTrace}"));
	}

	public void OpenLogFile()
	{
		string text = Application.persistentDataPath + "/Player.log";
		Application.OpenURL("file://" + text);
	}
}
}

// GameConsole/CommandRoot.cs
namespace GameConsole{
public abstract class CommandRoot : ICommand
{
	private delegate bool ParseMyThing(string s, out object result);

	public class PrefReference
	{
		public string Key;

		public Type Type;

		public bool Local;

		public string Default;
	}

	private Branch root;

	private const string KeyColor = "#db872c";

	private const string TypeColor = "#879fff";

	private const string ValueColor = "#4ac246";

	public abstract string Name { get; }

	public abstract string Description { get; }

	public string Command => root.name;

	public Branch Root => root;

	protected abstract Branch BuildTree(Console con);

	public CommandRoot(Console con)
	{
		root = BuildTree(con);
	}

	public void Execute(Console con, string[] args)
	{
		Queue<string> args2 = new Queue<string>(args.Where((string arg) => arg != ""));
		var (text, branch) = FindLongestMatchingBranch(root, args2, con);
		if (text != null && branch != null && !TryFindCorrectLeaf(text, branch, args2, con))
		{
			PrintUsage(con, text, branch);
		}
	}

	private bool TryFindCorrectLeaf(string soFar, Branch branch, Queue<string> args, Console con)
	{
		bool result = false;
		Node[] children = branch.children;
		foreach (Node node in children)
		{
			if (node is Branch)
			{
				continue;
			}
			if (node.requireCheats && con.CheatBlocker())
			{
				return true;
			}
			Leaf leaf = node as Leaf;
			ParameterInfo[] parameters = leaf.onExecute.Method.GetParameters();
			Queue<string> queue = new Queue<string>(args);
			if (args.Count != parameters.Length)
			{
				continue;
			}
			Dictionary<ParameterInfo, object> dictionary = new Dictionary<ParameterInfo, object>();
			try
			{
				ParameterInfo[] array = parameters;
				foreach (ParameterInfo parameterInfo in array)
				{
					Type parameterType = parameterInfo.ParameterType;
					string text = queue.Dequeue();
					if (parameterType == typeof(bool))
					{
						dictionary[parameterInfo] = bool.Parse(text);
						continue;
					}
					if (parameterType == typeof(int))
					{
						dictionary[parameterInfo] = int.Parse(text);
						continue;
					}
					if (parameterType == typeof(float))
					{
						dictionary[parameterInfo] = float.Parse(text);
						continue;
					}
					if (parameterType == typeof(string))
					{
						dictionary[parameterInfo] = text;
						continue;
					}
					if (parameterType == typeof(string[]))
					{
						List<string> list = new List<string> { text };
						list.AddRange(args);
						dictionary[parameterInfo] = list.ToArray();
						break;
					}
					if (parameterType.IsSubclassOf(typeof(Enum)))
					{
						dictionary[parameterInfo] = Enum.Parse(parameterType, text);
						continue;
					}
					throw new ArgumentException($"{soFar} has an unsupported parameter type: {parameterType}");
				}
			}
			catch (FormatException)
			{
				dictionary.Clear();
				continue;
			}
			leaf.onExecute?.DynamicInvoke(dictionary.Values.ToArray());
			result = true;
			break;
		}
		return result;
	}

	private void PrintUsage(Console con, string soFar, Branch branch)
	{
		Console.Log.Info("Usage: " + soFar + " <subcommand>");
		Console.Log.Info("Subcommands:");
		Node[] children = branch.children;
		foreach (Node obj in children)
		{
			if (obj is Branch branch2)
			{
				Console.Log.Info("- " + soFar + " " + branch2.name);
			}
			if (obj is Leaf leaf)
			{
				Console.Log.Info(leaf.onExecute.Method.GetParameters().Aggregate("- " + soFar, (string acc, ParameterInfo param) => $"{acc} <{param.Name}: <color=grey>{param.ParameterType}</color>>"));
			}
		}
	}

	public (string soFar, Branch branch) FindLongestMatchingBranch(Branch root, Queue<string> args, Console con = null, Func<Branch, string, bool> matches = null)
	{
		string text = root.name;
		Branch branch = root;
		bool flag = false;
		while (!flag)
		{
			flag = true;
			if (args.Count == 0)
			{
				break;
			}
			Node[] children = branch.children;
			foreach (Node node in children)
			{
				if (!(node is Branch branch2))
				{
					continue;
				}
				bool num;
				if (matches == null)
				{
					if (matches != null)
					{
						continue;
					}
					num = branch2.name == args.Peek();
				}
				else
				{
					num = matches(branch2, args.Peek());
				}
				if (num)
				{
					if (con != null && node.requireCheats && con.CheatBlocker())
					{
						return (soFar: null, branch: null);
					}
					text = text + " " + args.Dequeue();
					branch = branch2;
					flag = false;
					break;
				}
			}
		}
		return (soFar: text, branch: branch);
	}

	public static Branch Branch(string name, params Node[] children)
	{
		return new Branch(name, children);
	}

	public static Branch Branch(string name, bool requireCheats, params Node[] children)
	{
		return new Branch(name, requireCheats, children);
	}

	public static Branch Leaf(string name, Action onExecute, bool requireCheats = false)
	{
		return new Branch(name, requireCheats, new Leaf(onExecute, requireCheats));
	}

	public static Leaf Leaf(Action onExecute, bool requireCheats = false)
	{
		return new Leaf(onExecute, requireCheats);
	}

	public static Branch Leaf<T>(string name, Action<T> onExecute, bool requireCheats = false)
	{
		return new Branch(name, requireCheats, new Leaf(onExecute, requireCheats));
	}

	public static Leaf Leaf<T>(Action<T> onExecute, bool requireCheats = false)
	{
		return new Leaf(onExecute, requireCheats);
	}

	public static Branch Leaf<T, U>(string name, Action<T, U> onExecute, bool requireCheats = false)
	{
		return new Branch(name, new Leaf(onExecute, requireCheats));
	}

	public static Leaf Leaf<T, U>(Action<T, U> onExecute, bool requireCheats = false)
	{
		return new Leaf(onExecute, requireCheats);
	}

	public static Branch Leaf<T, U, V>(string name, Action<T, U, V> onExecute, bool requireCheats = false)
	{
		return new Branch(name, new Leaf(onExecute, requireCheats));
	}

	public static Leaf Leaf<T, U, V>(Action<T, U, V> onExecute, bool requireCheats = false)
	{
		return new Leaf(onExecute, requireCheats);
	}

	public Branch BuildPrefsEditor(List<PrefReference> pref)
	{
		return Leaf("prefs", delegate
		{
			Console.Log.Info("Available prefs:");
			foreach (PrefReference item in pref)
			{
				string text = (item.Local ? "<color=red>LOCAL</color>" : string.Empty);
				if (item.Type == typeof(int))
				{
					string text2 = (MonoSingleton<PrefsManager>.Instance.HasKey(item.Key) ? (item.Local ? MonoSingleton<PrefsManager>.Instance.GetIntLocal(item.Key) : MonoSingleton<PrefsManager>.Instance.GetInt(item.Key)).ToString() : (string.IsNullOrEmpty(item.Default) ? "<color=red>NOT SET</color>" : item.Default));
					Console.Log.Info("- <color=#db872c>" + item.Key + "</color>: <color=#4ac246>" + text2 + "</color>   [<color=#879fff>int</color>] " + text);
				}
				else if (item.Type == typeof(float))
				{
					string text3 = (MonoSingleton<PrefsManager>.Instance.HasKey(item.Key) ? (item.Local ? MonoSingleton<PrefsManager>.Instance.GetFloatLocal(item.Key) : MonoSingleton<PrefsManager>.Instance.GetFloat(item.Key)).ToString(CultureInfo.InvariantCulture) : (string.IsNullOrEmpty(item.Default) ? "<color=red>NOT SET</color>" : item.Default));
					Console.Log.Info("- <color=#db872c>" + item.Key + "</color>: <color=#4ac246>" + text3 + "</color>   [<color=#879fff>float</color>] " + text);
				}
				else if (item.Type == typeof(bool))
				{
					string text4 = (MonoSingleton<PrefsManager>.Instance.HasKey(item.Key) ? ((item.Local ? MonoSingleton<PrefsManager>.Instance.GetBoolLocal(item.Key) : MonoSingleton<PrefsManager>.Instance.GetBool(item.Key)) ? "True" : "False") : (string.IsNullOrEmpty(item.Default) ? "<color=red>NOT SET</color>" : item.Default));
					Console.Log.Info("- <color=#db872c>" + item.Key + "</color>: <color=#4ac246>" + text4 + "</color>   [<color=#879fff>float</color>] " + text);
				}
				else if (item.Type == typeof(string))
				{
					string text5 = (item.Local ? MonoSingleton<PrefsManager>.Instance.GetStringLocal(item.Key) : MonoSingleton<PrefsManager>.Instance.GetString(item.Key));
					Console.Log.Info("- <color=#db872c>" + item.Key + "</color>: <color=#4ac246>\"" + (string.IsNullOrEmpty(text5) ? item.Default : text5) + "\"</color>   [<color=#879fff>float</color>] " + text);
				}
				else
				{
					Console.Log.Info("Pref " + item.Key + " is type " + item.Type.Name + " (Unrecognized)");
				}
			}
			Console.Log.Info("You can use `<color=#7df59d>prefs set <type> <value></color>` to change a pref");
			Console.Log.Info("or `<color=#7df59d>prefs set_local <type> <value></color>` to change a <color=#db872c>local</color> pref. (it matters)");
		});
	}

	public Branch BoolMenu(string commandKey, Func<bool> valueGetter, Action<bool> valueSetter, bool inverted = false, bool requireCheats = false)
	{
		return Branch(commandKey, requireCheats, Leaf("toggle", delegate
		{
			bool flag = !valueGetter();
			valueSetter(flag);
			Console.Log.Info("<color=#db872c>" + commandKey + "</color> is now <color=#4ac246>" + GetStateName(flag, inverted) + "</color>");
		}), Leaf("on", delegate
		{
			valueSetter(!inverted);
			Console.Log.Info("<color=#db872c>" + commandKey + "</color> is now <color=#4ac246>" + GetStateName(!inverted, inverted) + "</color>");
		}), Leaf("off", delegate
		{
			valueSetter(inverted);
			Console.Log.Info("<color=#db872c>" + commandKey + "</color> is now <color=#4ac246>" + GetStateName(inverted, inverted) + "</color>");
		}), Leaf("read", delegate
		{
			Console.Log.Info("The current value is <color=#4ac246>" + GetStateName(valueGetter(), inverted) + "</color>");
		}));
	}

	private string GetStateName(bool value, bool inverted)
	{
		if (!inverted)
		{
			if (!value)
			{
				return "off";
			}
			return "on";
		}
		if (!value)
		{
			return "on";
		}
		return "off";
	}
}
}

// GameConsole/Console.cs
namespace GameConsole{
[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class Console : MonoSingleton<Console>, plog.Handlers.ILogHandler
{
	[Serializable]
	public class AutocompletePanel
	{
		public TMP_Text text;

		public Image background;
	}

	public static readonly plog.Logger Log = new plog.Logger("Console");

	public bool pinned;

	public bool consoleOpen;

	public List<ConsoleLog> logs = new List<ConsoleLog>();

	public readonly HashSet<Level> logLevelFilter = new HashSet<Level>(Enum.GetValues(typeof(Level)).Cast<Level>());

	private int logLevelCount = Enum.GetValues(typeof(Level)).Length;

	public int errorCount;

	public int warningCount;

	public int infoCount;

	private readonly List<LogLine> logLinePool = new List<LogLine>();

	[SerializeField]
	private GameObject consoleContainer;

	[SerializeField]
	private CanvasGroup consoleBlocker;

	[SerializeField]
	private TMP_InputField consoleInput;

	[Space]
	[SerializeField]
	private LogLine logLine;

	[SerializeField]
	private GameObject logContainer;

	[Space]
	[SerializeField]
	private GameObject scroller;

	[SerializeField]
	private TMP_Text scrollText;

	[SerializeField]
	private TMP_Text openBindText;

	[SerializeField]
	private AutocompletePanel[] autocompletePanels;

	[Space]
	public ErrorBadge errorBadge;

	[Space]
	[SerializeField]
	private GameObject[] hideOnPin;

	[SerializeField]
	private GameObject[] hideOnPinNoReopen;

	[SerializeField]
	private Image[] backgrounds;

	[SerializeField]
	private CanvasGroup masterGroup;

	[Space]
	public ConsoleWindow consoleWindow;

	private const int MaxLogLines = 20;

	private bool openedDuringPause;

	private OptionsManager rememberedOptionsManager;

	public readonly Dictionary<string, ICommand> recognizedCommands = new Dictionary<string, ICommand>();

	public readonly HashSet<Type> registeredCommandTypes = new HashSet<Type>();

	private bool logsDirty;

	private int scrollState;

	private UnscaledTimeSince timeSincePgHeld;

	private UnscaledTimeSince timeSinceScrollTick;

	private List<string> commandHistory = new List<string>();

	private int commandHistoryIndex = -1;

	public Action onError;

	public Binds binds;

	private List<string> suggestions = new List<string>();

	private int selectedSuggestionIndex;

	private int suggestionStartIndex;

	private PconAdapter pconAdapter = new PconAdapter();

	private DebugLogProxy plogHandler = new DebugLogProxy();

	public static bool IsOpen
	{
		get
		{
			if (MonoSingleton<Console>.Instance != null && MonoSingleton<Console>.Instance.consoleContainer != null)
			{
				return MonoSingleton<Console>.Instance.consoleContainer.activeSelf;
			}
			return false;
		}
	}

	public bool ExtractStackTraces { get; private set; }

	private List<ConsoleLog> filteredLogs => logs.Where((ConsoleLog l) => logLevelFilter.Contains(l.log.Level)).ToList();

	protected override void Awake()
	{
		if (MonoSingleton<Console>.Instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		base.Awake();
		binds = new Binds();
		binds.Initialize();
		AutocompletePanel[] array = autocompletePanels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].background.transform.parent.gameObject.SetActive(value: true);
		}
		SelectSuggestion(0);
		if (binds.registeredBinds != null && binds.registeredBinds.ContainsKey("open") && binds.registeredBinds["open"].Action != null)
		{
			openBindText.text = binds.registeredBinds["open"].Action.GetBindingDisplayString();
		}
		RegisterCommands(new ICommand[4]
		{
			new Help(),
			new Clear(),
			new Echo(),
			new Exit()
		});
		RegisterCommands(new ICommand[9]
		{
			new Prefs(this),
			new Scenes(),
			new Scene(),
			new ConsoleCmd(this),
			new Style(this),
			new Buffs(this),
			new MapVar(this),
			new InputCommands(this),
			new Rumble(this)
		});
		if (UnityEngine.Debug.isDebugBuild)
		{
			RegisterCommand(new GameConsole.Commands.Debug(this));
			RegisterCommand(new Pcon(this));
		}
		for (int j = 0; j < 20; j++)
		{
			LogLine logLine = UnityEngine.Object.Instantiate(this.logLine, logContainer.transform, worldPositionStays: false);
			logLine.Wipe();
			logLine.gameObject.SetActive(value: false);
			logLinePool.Add(logLine);
		}
		this.logLine.gameObject.SetActive(value: false);
		Application.logMessageReceived += HandleUnityLog;
		RegisterPLogHandler();
		if (!Consts.CONSOLE_ERROR_BADGE)
		{
			errorBadge.SetEnabled(enabled: false);
		}
		if (UnityEngine.Debug.isDebugBuild && MonoSingleton<PrefsManager>.Instance.GetBoolLocal("pcon.autostart"))
		{
			StartPCon();
		}
		consoleInput.onValueChanged.AddListener(FindSuggestions);
	}

	private void Start()
	{
		ExtractStackTraces = UnityEngine.Debug.isDebugBuild || MonoSingleton<PrefsManager>.Instance.GetBoolLocal("forceStackTraceExtraction");
	}

	public void RegisterPLogHandler()
	{
		plog.Logger.Root.AddHandler(plogHandler);
		plog.Logger.Root.AddHandler(this);
	}

	public void StartPCon()
	{
		if (pconAdapter == null)
		{
			return;
		}
		if (!pconAdapter.PConLibraryExists())
		{
			pconAdapter = null;
			return;
		}
		pconAdapter.StartPConClient(ProcessInput, delegate
		{
			MonoSingleton<CheatsController>.Instance.ActivateCheats();
		});
	}

	public void UpdateDisplayString()
	{
		openBindText.text = binds.registeredBinds["open"].Action.GetBindingDisplayString();
	}

	public bool CheatBlocker()
	{
		if (MonoSingleton<CheatsController>.Instance == null && CheatsManager.KeepCheatsEnabled)
		{
			return false;
		}
		if (MonoSingleton<CheatsController>.Instance == null || !MonoSingleton<CheatsController>.Instance.cheatsEnabled)
		{
			Log.Error("Cheats aren't enabled!");
			return true;
		}
		return false;
	}

	public void RegisterCommands(IEnumerable<ICommand> commands)
	{
		foreach (ICommand command in commands)
		{
			RegisterCommand(command);
		}
	}

	public void RegisterCommand(ICommand command)
	{
		if (registeredCommandTypes.Contains(command.GetType()))
		{
			Log.Warning("Command " + command.GetType().Name + " already registered!");
			return;
		}
		recognizedCommands.Add(command.Command.ToLower(), command);
		registeredCommandTypes.Add(command.GetType());
		if (command is IConsoleLogger consoleLogger)
		{
			consoleLogger.Log.NotifyParent = false;
			consoleLogger.Log.AddHandler(this);
			consoleLogger.Log.AddHandler(plogHandler);
		}
	}

	public void Clear()
	{
		scrollState = 0;
		errorCount = 0;
		warningCount = 0;
		infoCount = 0;
		logs.Clear();
		RepopulateLogs();
		UpdateScroller();
		errorBadge.SetEnabled(enabled: false, hide: false);
	}

	private void IncrementCounters(Level type)
	{
		if (scrollState > 0)
		{
			scrollState++;
			UpdateScroller();
		}
		switch (type)
		{
		case Level.Error:
			errorCount++;
			break;
		case Level.Warning:
			warningCount++;
			break;
		default:
			infoCount++;
			break;
		case Level.CLI:
			break;
		}
	}

	public void UpdateFilters(bool showErrors, bool showWarnings, bool showLogs)
	{
		if (showErrors)
		{
			logLevelFilter.Add(Level.Error);
		}
		else
		{
			logLevelFilter.Remove(Level.Error);
		}
		if (showWarnings)
		{
			logLevelFilter.Add(Level.Warning);
		}
		else
		{
			logLevelFilter.Remove(Level.Warning);
		}
		if (showLogs)
		{
			logLevelFilter.Add(Level.Info);
			logLevelFilter.Add(Level.Fine);
			logLevelFilter.Add(Level.Finer);
			logLevelFilter.Add(Level.Finest);
		}
		else
		{
			logLevelFilter.Remove(Level.Info);
			logLevelFilter.Remove(Level.Fine);
			logLevelFilter.Remove(Level.Finer);
			logLevelFilter.Remove(Level.Finest);
		}
		RepopulateLogs();
	}

	public void SetForceStackTraceExtraction(bool value)
	{
		ExtractStackTraces = value;
		MonoSingleton<PrefsManager>.Instance.SetBoolLocal("forceStackTraceExtraction", value);
	}

	public string[] Parse(string text)
	{
		return text.Split(' ');
	}

	private void ProcessUserInput(string text)
	{
		if (!string.IsNullOrEmpty(text))
		{
			ProcessInput(text);
		}
	}

	public void ProcessInput(string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		string[] array = Parse(text);
		if (array.Length == 0)
		{
			return;
		}
		string text2 = array[0];
		text2 = text2.ToLower();
		Log.Log("> " + text, Level.CLI);
		if (text.ToLower() == "sv_cheats 1")
		{
			Log.Log("To enable cheats, you must enter the Konami code in-game.", Level.Warning);
			return;
		}
		if (recognizedCommands.TryGetValue(text2, out var value))
		{
			try
			{
				value.Execute(this, array.Skip(1).ToArray());
				return;
			}
			catch (Exception ex)
			{
				Log.Log("Command <b>'" + text2 + "'</b> failed.\n" + ex.Message, Level.Error, null, ex.StackTrace);
				return;
			}
		}
		Log.Log("Unknown command: '" + text2 + "'", Level.Warning);
	}

	private void ScrollUp()
	{
		timeSinceScrollTick = 0f;
		scrollState++;
		if (scrollState > logs.Count - 1)
		{
			scrollState = logs.Count - 1;
		}
		if (logs.Count == 0)
		{
			scrollState = 0;
		}
		UpdateScroller();
		RepopulateLogs();
	}

	private void ScrollDown()
	{
		timeSinceScrollTick = 0f;
		scrollState--;
		if (scrollState < 0)
		{
			scrollState = 0;
		}
		UpdateScroller();
		RepopulateLogs();
	}

	private void DefaultDevConsoleOff()
	{
	}

	private void OnGUI()
	{
		DefaultDevConsoleOff();
	}

	private void LateUpdate()
	{
		DefaultDevConsoleOff();
	}

	private void Update()
	{
		DefaultDevConsoleOff();
		bool activeSelf = consoleContainer.activeSelf;
		if (binds.OpenPressed || (consoleOpen && Input.GetKeyDown(KeyCode.Escape)))
		{
			consoleOpen = !consoleOpen;
			if (consoleOpen)
			{
				GameStateManager.Instance.RegisterState(new GameState("console", hideOnPin)
				{
					cursorLock = LockMode.Unlock,
					playerInputLock = LockMode.Lock,
					cameraInputLock = LockMode.Lock,
					priority = 100
				});
				if (logsDirty)
				{
					RepopulateLogs();
				}
			}
			else
			{
				GameStateManager.Instance.PopState("console");
			}
			if (pinned)
			{
				GameObject[] array = hideOnPin;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(consoleOpen);
				}
				if (!consoleOpen)
				{
					array = hideOnPinNoReopen;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
				}
				Image[] array2 = backgrounds;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].enabled = consoleOpen;
				}
			}
			else
			{
				consoleContainer.SetActive(consoleOpen);
			}
			masterGroup.interactable = consoleOpen;
			bool flag = activeSelf;
			if (pinned)
			{
				flag = !consoleOpen;
			}
			if (flag)
			{
				if ((bool)MonoSingleton<OptionsManager>.Instance && binds.OpenPressed && !openedDuringPause && MonoSingleton<OptionsManager>.Instance == rememberedOptionsManager && SceneHelper.CurrentScene != "Main Menu")
				{
					MonoSingleton<OptionsManager>.Instance.UnPause();
				}
				StopAllCoroutines();
			}
			else
			{
				if ((bool)MonoSingleton<OptionsManager>.Instance && SceneHelper.CurrentScene != "Main Menu")
				{
					openedDuringPause = MonoSingleton<OptionsManager>.Instance.paused;
					rememberedOptionsManager = MonoSingleton<OptionsManager>.Instance;
					MonoSingleton<OptionsManager>.Instance.Pause();
				}
				consoleBlocker.alpha = 0f;
				StartCoroutine(FadeBlockerIn());
				consoleInput.ActivateInputField();
				errorBadge.Dismiss();
			}
		}
		if (!consoleOpen)
		{
			return;
		}
		if (binds.ScrollUpPressed || Input.mouseScrollDelta.y > 0f)
		{
			timeSincePgHeld = 0f;
			ScrollUp();
		}
		if (binds.ScrollDownPressed || Input.mouseScrollDelta.y < 0f)
		{
			timeSincePgHeld = 0f;
			ScrollDown();
		}
		if ((binds.ScrollUpHeld || binds.ScrollDownHeld) && (float)timeSincePgHeld > 0.5f)
		{
			bool scrollUpHeld = binds.ScrollUpHeld;
			if ((float)timeSinceScrollTick > 0.05f)
			{
				if (scrollUpHeld)
				{
					ScrollUp();
				}
				else
				{
					ScrollDown();
				}
			}
		}
		if (binds.ScrollToTopPressed)
		{
			scrollState = logs.Count - 1;
			UpdateScroller();
			RepopulateLogs();
		}
		if (binds.ScrollToBottomPressed)
		{
			scrollState = 0;
			UpdateScroller();
			RepopulateLogs();
		}
		if (suggestions.Count > 0)
		{
			if (binds.AutocompletePressed || binds.SubmitPressed)
			{
				consoleInput.text = suggestions[selectedSuggestionIndex];
				consoleInput.caretPosition = consoleInput.text.Length;
				consoleInput.ActivateInputField();
			}
			if (binds.CommandHistoryUpPressed)
			{
				SelectSuggestion(selectedSuggestionIndex + 1, wrap: true);
				consoleInput.caretPosition = consoleInput.text.Length;
			}
			if (binds.CommandHistoryDownPressed)
			{
				SelectSuggestion(selectedSuggestionIndex - 1, wrap: true);
				consoleInput.caretPosition = consoleInput.text.Length;
			}
			return;
		}
		if (binds.CommandHistoryUpPressed)
		{
			commandHistoryIndex++;
			if (commandHistoryIndex > commandHistory.Count - 1)
			{
				commandHistoryIndex = commandHistory.Count - 1;
			}
			consoleInput.text = ((commandHistoryIndex == -1) ? "" : commandHistory[commandHistoryIndex]);
			consoleInput.caretPosition = consoleInput.text.Length;
		}
		if (binds.CommandHistoryDownPressed)
		{
			commandHistoryIndex--;
			if (commandHistoryIndex < -1)
			{
				commandHistoryIndex = -1;
			}
			consoleInput.text = ((commandHistoryIndex == -1) ? "" : commandHistory[commandHistoryIndex]);
			consoleInput.caretPosition = consoleInput.text.Length;
		}
		if (binds.SubmitPressed)
		{
			consoleInput.ActivateInputField();
			if (!string.IsNullOrEmpty(consoleInput.text))
			{
				ProcessUserInput(consoleInput.text);
				commandHistory = commandHistory.Prepend(consoleInput.text).ToList();
				commandHistoryIndex = -1;
				consoleInput.text = string.Empty;
			}
		}
	}

	private void UpdateScroller()
	{
		if (scrollState == 0)
		{
			scroller.SetActive(value: false);
			return;
		}
		scroller.SetActive(value: true);
		scrollText.text = $"{scrollState} lines below";
	}

	private IEnumerator FadeBlockerIn()
	{
		consoleBlocker.alpha = 0f;
		while (consoleBlocker.alpha < 1f)
		{
			consoleBlocker.alpha += 0.2f;
			yield return new WaitForSecondsRealtime(0.03f);
		}
		consoleBlocker.alpha = 1f;
	}

	private void SelectSuggestion(int newIndex, bool wrap = false)
	{
		if (suggestions.Count == 0)
		{
			AutocompletePanel[] array = autocompletePanels;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].background.gameObject.SetActive(value: false);
			}
			return;
		}
		int num = Mathf.Max(0, suggestions.Count);
		int num2 = newIndex;
		if (wrap)
		{
			int num3 = num2 % num;
			if (num3 < 0)
			{
				num3 += num;
			}
			num2 = num3;
		}
		else
		{
			num2 = Mathf.Clamp(num2, 0, num - 1);
		}
		selectedSuggestionIndex = num2;
		ShowSuggestions(num2);
	}

	private void ShowSuggestions(int selected)
	{
		int num = suggestionStartIndex + Mathf.Min(suggestions.Count, autocompletePanels.Length - 1);
		if (selected < suggestionStartIndex)
		{
			suggestionStartIndex = selected;
		}
		if (selected > num)
		{
			int num2 = selected - num;
			suggestionStartIndex += num2;
		}
		int num3 = suggestionStartIndex;
		suggestions.Skip(num3 - 1).Take(autocompletePanels.Length);
		for (int i = 0; i < autocompletePanels.Length; i++)
		{
			AutocompletePanel autocompletePanel = autocompletePanels[i];
			int num4 = num3 + i;
			if (num4 >= suggestions.Count)
			{
				autocompletePanel.background.gameObject.SetActive(value: false);
				continue;
			}
			autocompletePanel.text.text = "> " + suggestions[num4];
			if (num4 == selectedSuggestionIndex)
			{
				autocompletePanel.background.color = Color.gray;
			}
			else
			{
				autocompletePanel.background.color = Color.black;
			}
			autocompletePanel.background.gameObject.SetActive(value: true);
		}
	}

	private void FindSuggestions(string value)
	{
		suggestions.Clear();
		if (value == "")
		{
			SelectSuggestion(0);
			return;
		}
		string[] array = Parse(value);
		Queue<string> queue = new Queue<string>(array.Skip(1));
		if (recognizedCommands.TryGetValue(array[0], out var value2))
		{
			if (value2 is CommandRoot commandRoot)
			{
				(string, Branch) tuple = commandRoot.FindLongestMatchingBranch(commandRoot.Root, queue);
				string soFar = tuple.Item1;
				IEnumerable<Branch> source = tuple.Item2.children.Where((Node n) => n is Branch).Cast<Branch>();
				if (queue.Count > 0)
				{
					string next = queue.Peek();
					source = source.Where((Branch n) => n.name.StartsWith(next));
					suggestions.AddRange(source.Select((Branch n) => soFar + " " + n.name));
				}
			}
		}
		else
		{
			foreach (KeyValuePair<string, ICommand> recognizedCommand in recognizedCommands)
			{
				if (recognizedCommand.Key.StartsWith(array[0]))
				{
					suggestions.Add(recognizedCommand.Value.Command ?? "");
				}
			}
		}
		SelectSuggestion(0);
	}

	private void OnDisable()
	{
		Application.logMessageReceived -= HandleUnityLog;
	}

	private void InsertLog(Log log)
	{
		IncrementCounters(log.Level);
		if (IsOpen)
		{
			RepopulateLogs();
		}
		else
		{
			logsDirty = true;
		}
	}

	private void RepopulateLogs()
	{
		List<ConsoleLog> list = ((logLevelFilter.Count == logLevelCount) ? logs : filteredLogs);
		for (int i = 0; i < logLinePool.Count; i++)
		{
			if (list.Count - i - 1 - scrollState < 0)
			{
				logLinePool[logLinePool.Count - i - 1].gameObject.SetActive(value: false);
			}
			else if (logLinePool.Count - i - 1 >= 0)
			{
				logLinePool[logLinePool.Count - i - 1].gameObject.SetActive(value: true);
				logLinePool[logLinePool.Count - i - 1].PopulateLine(list[list.Count - i - 1 - scrollState]);
			}
		}
	}

	private void HandleUnityLog(string message, string stacktrace, LogType type)
	{
		DefaultDevConsoleOff();
		if (!plogHandler.SuppressingNativeLogs)
		{
			plogHandler.HandleNativeUnityLog(message, stacktrace, type);
		}
	}

	public void Handle(plog.Logger source, Log log)
	{
		if (log.StackTrace == null && (ExtractStackTraces || log.Level == Level.Error))
		{
			log.StackTrace = StackTraceUtility.ExtractStackTrace();
		}
		logs.Add(new ConsoleLog(log, source));
		InsertLog(log);
		if (log.Level == Level.Error)
		{
			onError?.Invoke();
		}
	}
}
}

// GameConsole/ConsoleFilters.cs
namespace GameConsole{
public class ConsoleFilters : MonoBehaviour
{
	[SerializeField]
	private float defaultOpacity = 1f;

	[SerializeField]
	private float hiddenOpacity = 0.1f;

	[Space]
	[SerializeField]
	private FilterButton errorsFilter;

	[SerializeField]
	private FilterButton warningsFilter;

	[SerializeField]
	private FilterButton logsFilter;

	private void Awake()
	{
		errorsFilter.SetOpacity(defaultOpacity);
		warningsFilter.SetOpacity(defaultOpacity);
		logsFilter.SetOpacity(defaultOpacity);
	}

	private void Update()
	{
		errorsFilter.text.text = $"errors ({MonoSingleton<Console>.Instance.errorCount})";
		warningsFilter.text.text = $"warnings ({MonoSingleton<Console>.Instance.warningCount})";
		logsFilter.text.text = $"logs ({MonoSingleton<Console>.Instance.infoCount})";
	}

	public void TogglePopup()
	{
		base.gameObject.SetActive(!base.gameObject.activeSelf);
	}

	private void UpdateFilters()
	{
		MonoSingleton<Console>.Instance.UpdateFilters(errorsFilter.active, warningsFilter.active, logsFilter.active);
	}

	public void ToggleErrorFiltering()
	{
		errorsFilter.active = !errorsFilter.active;
		errorsFilter.SetOpacity(errorsFilter.active ? defaultOpacity : hiddenOpacity);
		errorsFilter.SetCheckmark(errorsFilter.active);
		UpdateFilters();
	}

	public void ToggleWarningFiltering()
	{
		warningsFilter.active = !warningsFilter.active;
		warningsFilter.SetOpacity(warningsFilter.active ? defaultOpacity : hiddenOpacity);
		warningsFilter.SetCheckmark(warningsFilter.active);
		UpdateFilters();
	}

	public void ToggleLogFiltering()
	{
		logsFilter.active = !logsFilter.active;
		logsFilter.SetOpacity(logsFilter.active ? defaultOpacity : hiddenOpacity);
		logsFilter.SetCheckmark(logsFilter.active);
		UpdateFilters();
	}
}
}

// GameConsole/ConsoleLog.cs
namespace GameConsole{
[Serializable]
public class ConsoleLog
{
	public Log log;

	public Logger source;

	public UnscaledTimeSince timeSinceLogged;

	public bool expanded;

	public ConsoleLog(Log log, Logger source)
	{
		this.log = log;
		timeSinceLogged = 0f;
		this.source = source;
		if (log.Level == Level.Error && log.StackTrace != null)
		{
			expanded = true;
		}
	}
}
}

// GameConsole/ErrorBadge.cs
namespace GameConsole{
public class ErrorBadge : MonoBehaviour
{
	[SerializeField]
	private GameObject badgeContainer;

	[SerializeField]
	private TMP_Text errorCountText;

	[SerializeField]
	private CanvasGroup flashGroup;

	[SerializeField]
	private CanvasGroup alertGroup;

	public bool hidden;

	private readonly CustomYieldInstruction waitTime = new WaitForSecondsRealtime(0.03f);

	private void OnEnable()
	{
		Console instance = MonoSingleton<Console>.Instance;
		instance.onError = (Action)Delegate.Combine(instance.onError, new Action(OnError));
	}

	private void OnDisable()
	{
		if (MonoSingleton<Console>.Instance != null)
		{
			Console instance = MonoSingleton<Console>.Instance;
			instance.onError = (Action)Delegate.Remove(instance.onError, new Action(OnError));
		}
	}

	private void OnError()
	{
		badgeContainer.SetActive(!hidden);
		Update();
		flashGroup.alpha = 0f;
		StopAllCoroutines();
		if (!hidden)
		{
			StartCoroutine(FlashBadge());
		}
	}

	private IEnumerator FlashBadge()
	{
		flashGroup.alpha = 0f;
		while (flashGroup.alpha < 1f)
		{
			flashGroup.alpha += 0.2f;
			if (alertGroup.alpha < flashGroup.alpha)
			{
				alertGroup.alpha = (Console.IsOpen ? 0f : flashGroup.alpha);
			}
			yield return waitTime;
		}
		flashGroup.alpha = 1f;
		alertGroup.alpha = (Console.IsOpen ? 0f : flashGroup.alpha);
		while (flashGroup.alpha > 0f)
		{
			flashGroup.alpha -= 0.1f;
			yield return waitTime;
		}
		flashGroup.alpha = 0f;
	}

	public void SetEnabled(bool enabled, bool hide = true)
	{
		hidden = !enabled;
		if (enabled)
		{
			if (MonoSingleton<Console>.Instance.errorCount > 0)
			{
				badgeContainer.SetActive(value: true);
				Update();
			}
		}
		else
		{
			badgeContainer.SetActive(value: false);
		}
	}

	public void Dismiss()
	{
		StopAllCoroutines();
		alertGroup.alpha = 0f;
	}

	private void Update()
	{
		Console instance = MonoSingleton<Console>.Instance;
		if (!(instance == null))
		{
			int errorCount = instance.errorCount;
			if (errorCount != 0)
			{
				errorCountText.text = errorCount + ((errorCount == 1) ? " error" : " errors");
			}
		}
	}
}
}

// GameConsole/FilterButton.cs
namespace GameConsole{
[Serializable]
public class FilterButton
{
	public TMP_Text text;

	public Image buttonBackground;

	public Image miniIndicator;

	public GameObject checkmark;

	public bool active = true;

	public void SetOpacity(float opacity)
	{
		Color color = buttonBackground.color;
		color.a = opacity;
		buttonBackground.color = color;
		miniIndicator.color = color;
	}

	public void SetCheckmark(bool isChecked)
	{
		checkmark.SetActive(isChecked);
	}
}
}

// GameConsole/FilterLevel.cs
namespace GameConsole{
[Flags]
public enum FilterLevel
{
	None = 0,
	Info = 1,
	Warning = 2,
	Error = 4,
	All = 7
}
}

// GameConsole/ICommand.cs
namespace GameConsole{
public interface ICommand
{
	string Name { get; }

	string Description { get; }

	string Command { get; }

	void Execute(Console con, string[] args);
}
}

// GameConsole/IConsoleLogger.cs
namespace GameConsole{
public interface IConsoleLogger
{
	Logger Log { get; }
}
}

// GameConsole/LogLine.cs
namespace GameConsole{
public class LogLine : MonoBehaviour
{
	[SerializeField]
	private TMP_Text timestamp;

	[SerializeField]
	private TMP_Text message;

	[SerializeField]
	private TMP_Text context;

	[SerializeField]
	private Image contextPanel;

	[SerializeField]
	private Image mainPanel;

	[Space]
	[SerializeField]
	private CanvasGroup attentionFlashGroup;

	[Space]
	[SerializeField]
	private Color normalLogColor;

	[SerializeField]
	private Color warningLogColor;

	[SerializeField]
	private Color errorLogColor;

	[SerializeField]
	private Color cliLogColor;

	[Space]
	[SerializeField]
	private float normalHeight = 35f;

	[SerializeField]
	private float expandedHeight = 120f;

	private RectTransform rectTransform;

	private Vector2? defaultTextOffsetMin;

	private Vector2? defaultTextOffsetMax;

	private Vector2? defaultTextSizeDelta;

	private ConsoleLog log;

	private void Awake()
	{
		rectTransform = GetComponent<RectTransform>();
	}

	public void Wipe()
	{
		log = null;
		timestamp.text = "";
		message.text = "";
		mainPanel.color = normalLogColor;
		RefreshSize();
	}

	public void PopulateLine(ConsoleLog capture)
	{
		log = capture;
		timestamp.text = $"{capture.log.Timestamp:HH:mm:ss.f}";
		RefreshSize();
		if (capture.expanded && !string.IsNullOrEmpty(capture.log.StackTrace))
		{
			string stackTrace = capture.log.StackTrace;
			stackTrace = stackTrace.Replace("\r\n", "\n").Replace("\n", "");
			message.text = $"<b><size={message.fontSizeMax}>{capture.log.Message}</size></b>\n{stackTrace}";
			message.enableAutoSizing = true;
		}
		else
		{
			message.text = capture.log.Message;
			message.fontSize = message.fontSizeMax;
			message.enableAutoSizing = false;
		}
		mainPanel.color = ((capture.log.Level == Level.Info) ? normalLogColor : ((capture.log.Level == Level.Warning) ? warningLogColor : ((capture.log.Level == Level.CLI) ? cliLogColor : ((capture.log.Level == Level.Error) ? errorLogColor : normalLogColor))));
		if (capture.source?.Tag != null)
		{
			context.text = capture.source.Tag.ToString();
			var (color, color2) = ColorHelper.GetColorPair(capture.source.Tag.Color);
			context.color = color2.ToUnityColor();
			Color color3 = color.ToUnityColor();
			color3.a = contextPanel.color.a;
			contextPanel.color = color3;
			if (!contextPanel.gameObject.activeSelf)
			{
				contextPanel.gameObject.SetActive(value: true);
				RectTransform rectTransform = message.rectTransform;
				if (defaultTextOffsetMin.HasValue)
				{
					rectTransform.offsetMin = defaultTextOffsetMin.Value;
				}
				if (defaultTextOffsetMax.HasValue)
				{
					rectTransform.offsetMax = defaultTextOffsetMax.Value;
				}
				if (defaultTextSizeDelta.HasValue)
				{
					rectTransform.sizeDelta = defaultTextSizeDelta.Value;
				}
			}
		}
		else if (contextPanel.gameObject.activeSelf)
		{
			contextPanel.gameObject.SetActive(value: false);
			float x = contextPanel.rectTransform.sizeDelta.x;
			RectTransform rectTransform2 = message.rectTransform;
			if (!defaultTextOffsetMin.HasValue)
			{
				defaultTextOffsetMin = rectTransform2.offsetMin;
			}
			if (!defaultTextOffsetMax.HasValue)
			{
				defaultTextOffsetMax = rectTransform2.offsetMax;
			}
			if (!defaultTextSizeDelta.HasValue)
			{
				defaultTextSizeDelta = rectTransform2.sizeDelta;
			}
			rectTransform2.offsetMin = new Vector2(rectTransform2.offsetMin.x - x * 2f, defaultTextOffsetMin.Value.y);
			rectTransform2.offsetMax = new Vector2(rectTransform2.offsetMax.x + x, defaultTextOffsetMax.Value.y);
			rectTransform2.sizeDelta = new Vector2(rectTransform2.sizeDelta.x - x * 2f, defaultTextSizeDelta.Value.y);
		}
		if ((float)capture.timeSinceLogged < 0.5f && base.gameObject.activeInHierarchy)
		{
			attentionFlashGroup.alpha = TimeSinceToFlashAlpha(capture.timeSinceLogged);
		}
	}

	public void ToggleExpand()
	{
		log.expanded = !log.expanded;
		RefreshSize();
		PopulateLine(log);
	}

	private void RefreshSize()
	{
		if (rectTransform == null)
		{
			rectTransform = GetComponent<RectTransform>();
		}
		if (log == null || !log.expanded)
		{
			rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, normalHeight);
		}
		else
		{
			rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, expandedHeight);
		}
	}

	private void Update()
	{
		if (log != null)
		{
			if ((float)log.timeSinceLogged > 0.5f)
			{
				attentionFlashGroup.alpha = 0f;
			}
			else
			{
				attentionFlashGroup.alpha = TimeSinceToFlashAlpha(log.timeSinceLogged);
			}
		}
	}

	private float TimeSinceToFlashAlpha(float timeSinceLogged)
	{
		if (timeSinceLogged < 0.2f)
		{
			return timeSinceLogged / 0.2f;
		}
		return 1f - (timeSinceLogged - 0.2f) / 0.3f;
	}
}
}

// GameConsole/PconAdapter.cs
namespace GameConsole{
public class PconAdapter
{
	private static readonly Logger Log = new Logger("PconAdapter");

	private Assembly pconAssmebly;

	private Type pconClientType;

	private bool startCalled;

	public bool PConLibraryExists()
	{
		if (pconAssmebly != null)
		{
			return true;
		}
		Log.Info("Looking for the pcon.unity library...");
		string value = "pcon.unity";
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly assembly in assemblies)
		{
			if (assembly.FullName.StartsWith(value))
			{
				Log.Info("Found the pcon.unity library!");
				pconAssmebly = assembly;
				pconClientType = pconAssmebly.GetType("pcon.PConClient");
				return true;
			}
		}
		return false;
	}

	public void StartPConClient(Action<string> onExecute, Action onGameModified)
	{
		if (PConLibraryExists() && !startCalled)
		{
			Log.Info("Starting the pcon.unity client...");
			startCalled = true;
			MethodInfo method = pconClientType.GetMethod("StartClient", BindingFlags.Static | BindingFlags.Public);
			if (method != null)
			{
				Log.Info("Starting the pcon.unity client!");
				PCon.MountHandler(new Handler
				{
					onExecute = onExecute,
					onGameModified = onGameModified
				});
				method.Invoke(null, new object[1]);
				MonoSingleton<MapVarRelay>.Instance.enabled = true;
				PCon.RegisterFeature("ultrakill");
			}
			else
			{
				Log.Info("Could not find the pcon.unity client's StartClient method!");
			}
		}
	}
}
}

// NewBlood.IK/FabrikSolver3D.cs
namespace NewBlood.IK{
public sealed class FabrikSolver3D : Solver3D
{
	public const float MinTolerance = 0.001f;

	public const int MinIterations = 1;

	[SerializeField]
	private IKChain3D m_Chain = new IKChain3D();

	[SerializeField]
	[Range(1f, 50f)]
	private int m_Iterations = 10;

	[SerializeField]
	[Range(0.001f, 0.1f)]
	private float m_Tolerance = 0.01f;

	private Vector3[] m_Positions;

	public int iterations
	{
		get
		{
			return m_Iterations;
		}
		set
		{
			m_Iterations = Mathf.Max(value, 1);
		}
	}

	public float tolerance
	{
		get
		{
			return m_Tolerance;
		}
		set
		{
			m_Tolerance = Mathf.Max(value, 0.001f);
		}
	}

	public override IKChain3D GetChain(int index)
	{
		return m_Chain;
	}

	protected override int GetChainCount()
	{
		return 1;
	}

	protected override void DoPrepare()
	{
		base.DoPrepare();
		if (m_Positions == null || m_Positions.Length != m_Chain.transformCount)
		{
			m_Positions = new Vector3[m_Chain.transformCount];
		}
	}

	protected override void DoUpdateIK(List<Vector3> effectorPositions)
	{
		float[] lengths = m_Chain.lengths;
		for (int i = 0; i < m_Positions.Length; i++)
		{
			m_Positions[i] = m_Chain.transforms[i].position;
		}
		Vector3 originPosition = m_Positions[0];
		Vector3 vector = effectorPositions[0];
		float num = Vector3.Magnitude(vector - m_Positions[m_Positions.Length - 1]);
		for (int j = 0; j < iterations; j++)
		{
			if (num <= tolerance)
			{
				break;
			}
			Forward(vector, lengths, m_Positions);
			Backward(originPosition, lengths, m_Positions);
			num = Vector3.Magnitude(vector - m_Positions[m_Positions.Length - 1]);
		}
		for (int k = 0; k < m_Chain.transformCount - 1; k++)
		{
			Vector3 localPosition = m_Chain.transforms[k + 1].localPosition;
			Vector3 toDirection = m_Chain.transforms[k].InverseTransformPoint(m_Positions[k + 1]);
			m_Chain.transforms[k].localRotation *= Quaternion.FromToRotation(localPosition, toDirection);
		}
	}

	private void Forward(Vector3 targetPosition, float[] lengths, Vector3[] positions)
	{
		int num = positions.Length - 1;
		positions[num] = targetPosition;
		for (int num2 = num - 1; num2 >= 0; num2--)
		{
			Vector3 vector = positions[num2 + 1] - positions[num2];
			float num3 = lengths[num2] / vector.magnitude;
			Vector3 vector2 = (1f - num3) * positions[num2 + 1] + num3 * positions[num2];
			positions[num2] = vector2;
		}
	}

	private void Backward(Vector3 originPosition, float[] lengths, Vector3[] positions)
	{
		positions[0] = originPosition;
		int num = positions.Length - 1;
		for (int i = 0; i < num; i++)
		{
			Vector3 vector = positions[i + 1] - positions[i];
			float num2 = lengths[i] / vector.magnitude;
			Vector3 vector2 = (1f - num2) * positions[i] + num2 * positions[i + 1];
			positions[i + 1] = vector2;
		}
	}
}
}

// NewBlood.IK/IKChain3D.cs
namespace NewBlood.IK{
[Serializable]
public sealed class IKChain3D
{
	[SerializeField]
	private Transform m_EffectorTransform;

	[SerializeField]
	private Transform m_TargetTransform;

	[SerializeField]
	private int m_TransformCount;

	[SerializeField]
	private Transform[] m_Transforms;

	[SerializeField]
	private Quaternion[] m_DefaultLocalRotations;

	[SerializeField]
	private Quaternion[] m_StoredLocalRotations;

	private float[] m_Lengths;

	public bool isValid
	{
		get
		{
			if (m_EffectorTransform == null)
			{
				return false;
			}
			if (m_TransformCount == 0)
			{
				return false;
			}
			if (m_Transforms == null || m_Transforms.Length != m_TransformCount)
			{
				return false;
			}
			if (m_DefaultLocalRotations == null || m_DefaultLocalRotations.Length != m_TransformCount)
			{
				return false;
			}
			if (m_StoredLocalRotations == null || m_StoredLocalRotations.Length != m_TransformCount)
			{
				return false;
			}
			if (m_Transforms[0] == null)
			{
				return false;
			}
			if (m_Transforms[m_TransformCount - 1] != m_EffectorTransform)
			{
				return false;
			}
			if (m_TargetTransform != null && IKUtility.IsDescendantOf(m_TargetTransform, m_Transforms[0], m_TransformCount))
			{
				return false;
			}
			return true;
		}
	}

	public int transformCount => m_TransformCount;

	public Transform effector
	{
		get
		{
			return m_EffectorTransform;
		}
		set
		{
			m_EffectorTransform = value;
		}
	}

	public Transform target
	{
		get
		{
			return m_TargetTransform;
		}
		set
		{
			m_TargetTransform = value;
		}
	}

	public Transform[] transforms => m_Transforms;

	public Transform rootTransform
	{
		get
		{
			if (m_TransformCount == 0)
			{
				return null;
			}
			if (m_Transforms == null || m_Transforms.Length != m_TransformCount)
			{
				return null;
			}
			return m_Transforms[0];
		}
	}

	public float[] lengths
	{
		get
		{
			if (isValid)
			{
				PrepareLengths();
				return m_Lengths;
			}
			return null;
		}
	}

	public void Initialize()
	{
		if (!(m_EffectorTransform == null) && m_TransformCount != 0 && IKUtility.AncestorCountAtLeast(m_EffectorTransform, m_TransformCount - 1))
		{
			m_Transforms = new Transform[m_TransformCount];
			m_DefaultLocalRotations = new Quaternion[m_TransformCount];
			m_StoredLocalRotations = new Quaternion[m_TransformCount];
			Transform transform = m_EffectorTransform;
			int num = m_TransformCount - 1;
			while (transform != null && num >= 0)
			{
				m_Transforms[num] = transform;
				m_DefaultLocalRotations[num] = transform.localRotation;
				transform = transform.parent;
				num--;
			}
		}
	}

	public void RestoreDefaultPose(bool targetRotationIsConstrained)
	{
		int num = m_TransformCount;
		if (!targetRotationIsConstrained)
		{
			num--;
		}
		for (int i = 0; i < num; i++)
		{
			m_Transforms[i].localRotation = m_DefaultLocalRotations[i];
		}
	}

	public void StoreLocalRotations()
	{
		for (int i = 0; i < m_Transforms.Length; i++)
		{
			m_StoredLocalRotations[i] = m_Transforms[i].localRotation;
		}
	}

	public void BlendFKToIK(float finalWeight, bool targetRotationIsConstrained)
	{
		int num = m_TransformCount;
		if (!targetRotationIsConstrained)
		{
			num--;
		}
		for (int i = 0; i < num; i++)
		{
			m_Transforms[i].localRotation = Quaternion.Slerp(m_StoredLocalRotations[i], m_Transforms[i].localRotation, finalWeight);
		}
	}

	private void PrepareLengths()
	{
		Transform transform = m_EffectorTransform;
		if (m_Lengths == null || m_Lengths.Length != m_TransformCount - 1)
		{
			m_Lengths = new float[m_TransformCount - 1];
		}
		int num = m_Lengths.Length - 1;
		while (num > 0 && !(transform == null) && !(transform.parent == null))
		{
			m_Lengths[num - 1] = Vector3.Distance(transform.position, transform.parent.position);
			transform = transform.parent;
			num--;
		}
	}
}
}

// NewBlood.IK/IKManager3D.cs
namespace NewBlood.IK{
public sealed class IKManager3D : MonoBehaviour
{
	[SerializeField]
	private List<Solver3D> m_Solvers = new List<Solver3D>();

	[Range(0f, 1f)]
	[SerializeField]
	private float m_Weight = 1f;

	public float weight
	{
		get
		{
			return m_Weight;
		}
		set
		{
			m_Weight = Mathf.Clamp01(value);
		}
	}

	public List<Solver3D> solvers => m_Solvers;

	public void AddSolver(Solver3D solver)
	{
		if (!m_Solvers.Contains(solver))
		{
			m_Solvers.Add(solver);
		}
	}

	public void RemoveSolver(Solver3D solver)
	{
		m_Solvers.Remove(solver);
	}

	public void UpdateManager()
	{
		foreach (Solver3D solver in m_Solvers)
		{
			if (!(solver == null) && solver.isActiveAndEnabled)
			{
				if (!solver.isValid)
				{
					solver.Initialize();
				}
				solver.UpdateIK(m_Weight);
			}
		}
	}

	private void LateUpdate()
	{
		UpdateManager();
	}

	private void FindChildSolvers()
	{
		m_Solvers.Clear();
		base.transform.GetComponentsInChildren(includeInactive: true, m_Solvers);
		for (int num = m_Solvers.Count - 1; num >= 0; num--)
		{
			if (m_Solvers[num].GetComponentInParent<IKManager3D>() != this)
			{
				m_Solvers.RemoveAt(num);
			}
		}
	}
}
}

// NewBlood.IK/IKUtility.cs
namespace NewBlood.IK{
internal static class IKUtility
{
	public static bool IsDescendantOf(Transform transform, Transform ancestor)
	{
		transform = transform.parent;
		while (transform != null)
		{
			if (transform == ancestor)
			{
				return true;
			}
			transform = transform.parent;
		}
		return false;
	}

	public static bool IsDescendantOf(Transform transform, Transform ancestor, int ancestorCount)
	{
		transform = transform.parent;
		for (int i = 0; i < ancestorCount; i++)
		{
			if (transform == null)
			{
				break;
			}
			if (transform == ancestor)
			{
				return true;
			}
			transform = transform.parent;
		}
		return false;
	}

	public static bool AncestorCountAtLeast(Transform transform, int count)
	{
		for (int i = 0; i < count; i++)
		{
			if (transform.parent == null)
			{
				return false;
			}
			transform = transform.parent;
		}
		return true;
	}

	public static int GetAncestorCount(Transform transform)
	{
		int num = 0;
		while (transform.parent != null)
		{
			num++;
			transform = transform.parent;
		}
		return num;
	}

	public static int GetMaxChainCount(IKChain3D chain)
	{
		if (chain.effector != null)
		{
			return GetAncestorCount(chain.effector) + 1;
		}
		return 0;
	}
}
}

// NewBlood.IK/Solver3D.cs
namespace NewBlood.IK{
public abstract class Solver3D : MonoBehaviour
{
	[SerializeField]
	private bool m_ConstrainRotation = true;

	[SerializeField]
	private bool m_SolveFromDefaultPose = true;

	[Range(0f, 1f)]
	[SerializeField]
	private float m_Weight = 1f;

	private List<Vector3> m_TargetPositions = new List<Vector3>();

	public int chainCount => GetChainCount();

	public bool constrainRotation
	{
		get
		{
			return m_ConstrainRotation;
		}
		set
		{
			m_ConstrainRotation = value;
		}
	}

	public bool solveFromDefaultPose
	{
		get
		{
			return m_SolveFromDefaultPose;
		}
		set
		{
			m_SolveFromDefaultPose = value;
		}
	}

	public bool isValid
	{
		get
		{
			for (int i = 0; i < chainCount; i++)
			{
				if (!GetChain(i).isValid)
				{
					return false;
				}
			}
			return DoValidate();
		}
	}

	public bool allChainsHaveTargets
	{
		get
		{
			for (int i = 0; i < chainCount; i++)
			{
				if (GetChain(i).target == null)
				{
					return false;
				}
			}
			return true;
		}
	}

	public float weight
	{
		get
		{
			return m_Weight;
		}
		set
		{
			m_Weight = Mathf.Clamp01(value);
		}
	}

	public void UpdateIK(float globalWeight)
	{
		if (allChainsHaveTargets)
		{
			PrepareEffectorPositions();
			UpdateIK(m_TargetPositions, globalWeight);
		}
	}

	public void UpdateIK(List<Vector3> positions, float globalWeight)
	{
		if (positions.Count != chainCount)
		{
			return;
		}
		float num = globalWeight * m_Weight;
		if (Mathf.Approximately(num, 0f) || !isValid)
		{
			return;
		}
		Prepare();
		if (num < 1f)
		{
			StoreLocalRotations();
		}
		DoUpdateIK(positions);
		if (constrainRotation)
		{
			for (int i = 0; i < chainCount; i++)
			{
				IKChain3D chain = GetChain(i);
				if (!(chain.target == null))
				{
					chain.effector.rotation = chain.target.rotation;
				}
			}
		}
		if (num < 1f)
		{
			BlendFKToIK(num);
		}
	}

	public void Initialize()
	{
		DoInitialize();
		for (int i = 0; i < chainCount; i++)
		{
			GetChain(i).Initialize();
		}
	}

	public abstract IKChain3D GetChain(int index);

	protected abstract int GetChainCount();

	protected abstract void DoUpdateIK(List<Vector3> effectorPositions);

	protected virtual bool DoValidate()
	{
		return true;
	}

	protected virtual void DoInitialize()
	{
	}

	protected virtual void DoPrepare()
	{
	}

	protected virtual Transform GetRootTransform()
	{
		if (chainCount > 0)
		{
			return GetChain(0).rootTransform;
		}
		return null;
	}

	protected virtual void OnValidate()
	{
		m_Weight = Mathf.Clamp01(m_Weight);
	}

	private void Prepare()
	{
		if (solveFromDefaultPose)
		{
			for (int i = 0; i < chainCount; i++)
			{
				IKChain3D chain = GetChain(i);
				bool targetRotationIsConstrained = constrainRotation && chain.target != null;
				chain.RestoreDefaultPose(targetRotationIsConstrained);
			}
		}
		DoPrepare();
	}

	private void PrepareEffectorPositions()
	{
		m_TargetPositions.Clear();
		for (int i = 0; i < chainCount; i++)
		{
			IKChain3D chain = GetChain(i);
			if (!(chain.target == null))
			{
				m_TargetPositions.Add(chain.target.position);
			}
		}
	}

	private void StoreLocalRotations()
	{
		for (int i = 0; i < chainCount; i++)
		{
			GetChain(i).StoreLocalRotations();
		}
	}

	private void BlendFKToIK(float finalWeight)
	{
		for (int i = 0; i < chainCount; i++)
		{
			IKChain3D chain = GetChain(i);
			bool targetRotationIsConstrained = constrainRotation && chain.target != null;
			chain.BlendFKToIK(finalWeight, targetRotationIsConstrained);
		}
	}
}
}

// Sandbox.Arm/AlterMode.cs
namespace Sandbox.Arm{
public class AlterMode : ISandboxArmMode
{
	private static readonly plog.Logger Log = new plog.Logger("AlterMode");

	private SandboxArm hostArm;

	private static readonly int Tap = Animator.StringToHash("Tap");

	private static readonly int Point = Animator.StringToHash("Point");

	private SandboxSpawnableInstance selected;

	public string Name => "Alter";

	public bool CanOpenMenu => selected == null;

	public bool Raycast => true;

	public virtual string Icon => "alter";

	public void EndSession()
	{
		if (!(selected == null))
		{
			if (!selected.frozen)
			{
				selected.Resume();
			}
			if ((bool)selected.attachedParticles)
			{
				Object.Destroy(selected.attachedParticles.gameObject);
			}
			selected = null;
		}
	}

	public void OnEnable(SandboxArm arm)
	{
		arm.ResetAnimator();
		arm.animator.SetBool(Point, value: true);
		hostArm = arm;
	}

	public void OnDisable()
	{
		if ((bool)selected && (bool)MonoSingleton<SandboxAlterMenu>.Instance)
		{
			MonoSingleton<SandboxAlterMenu>.Instance.Close();
		}
	}

	public void OnDestroy()
	{
		if ((bool)selected && (bool)MonoSingleton<SandboxAlterMenu>.Instance)
		{
			MonoSingleton<SandboxAlterMenu>.Instance.Close();
		}
	}

	public void Update()
	{
	}

	public void FixedUpdate()
	{
	}

	public void OnPrimaryDown()
	{
		if (!hostArm.hitSomething)
		{
			return;
		}
		if (!hostArm.hit.collider.TryGetComponent<SandboxSpawnableInstance>(out var component))
		{
			Transform transform = hostArm.hit.collider.transform;
			if (transform.parent == null || !transform.parent.TryGetComponent<SandboxSpawnableInstance>(out component))
			{
				return;
			}
		}
		if (!selected)
		{
			OpenProp(component);
			hostArm.animator.SetTrigger(Tap);
		}
	}

	public void OpenProp(SandboxSpawnableInstance prop)
	{
		Log.Info($"Opening prop {prop}");
		selected = prop;
		MonoSingleton<SandboxAlterMenu>.Instance.editedObject = prop;
		MonoSingleton<SandboxAlterMenu>.Instance.Show(prop, this);
		prop.attachedParticles = Object.Instantiate(hostArm.manipulateEffect, prop.transform, worldPositionStays: true);
		prop.attachedParticles.transform.position = prop.collider.bounds.center;
	}

	public void OnPrimaryUp()
	{
	}

	public void OnSecondaryDown()
	{
		if (!(selected == null))
		{
			MonoSingleton<SandboxAlterMenu>.Instance.Close();
		}
	}

	public void OnSecondaryUp()
	{
	}
}
}

// Sandbox.Arm/ArmModeWithHeldPreview.cs
namespace Sandbox.Arm{
public abstract class ArmModeWithHeldPreview : ISandboxArmMode
{
	protected static readonly int Holding = Animator.StringToHash("Holding");

	protected static readonly int Punch = Animator.StringToHash("Punch");

	protected SandboxArm hostArm;

	protected SpawnableObject currentObject;

	protected GameObject heldPreview;

	public virtual string Name => null;

	public virtual bool CanOpenMenu => true;

	public virtual bool Raycast => true;

	public virtual string Icon => null;

	public virtual void OnEnable(SandboxArm arm)
	{
		hostArm = arm;
		hostArm.ResetAnimator();
		hostArm.animator.SetBool(Holding, value: true);
		if ((bool)heldPreview)
		{
			heldPreview.SetActive(value: true);
		}
	}

	protected IEnumerator HandClosedAnimationThing()
	{
		heldPreview.SetActive(value: false);
		yield return new WaitForSeconds(0.85f);
		heldPreview.SetActive(value: true);
	}

	public virtual void SetPreview(SpawnableObject obj)
	{
		hostArm.selectSound.Play();
		currentObject = obj;
		if ((bool)heldPreview)
		{
			Object.Destroy(heldPreview);
		}
		if ((bool)obj.preview)
		{
			GameObject gameObject = Object.Instantiate(obj.preview, hostArm.holder, worldPositionStays: false);
			gameObject.transform.localPosition += obj.armOffset;
			gameObject.transform.Rotate(obj.armRotationOffset);
			heldPreview = gameObject;
		}
		else
		{
			GameObject gameObject2 = Object.Instantiate(obj.gameObject, hostArm.holder, worldPositionStays: false);
			SandboxUtils.StripForPreview(gameObject2.transform);
			SandboxUtils.SetLayerDeep(gameObject2.transform, hostArm.holder.gameObject.layer);
			gameObject2.SetActive(value: true);
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localScale *= 0.25f;
			heldPreview = gameObject2;
		}
	}

	public virtual void OnDisable()
	{
	}

	public virtual void OnDestroy()
	{
		if ((bool)heldPreview)
		{
			Object.Destroy(heldPreview);
		}
	}

	public virtual void Update()
	{
	}

	public virtual void FixedUpdate()
	{
	}

	public virtual void OnPrimaryDown()
	{
		if (!currentObject)
		{
			hostArm.menu.gameObject.SetActive(value: true);
			return;
		}
		hostArm.StartCoroutine(HandClosedAnimationThing());
		hostArm.jabSound.Play();
		hostArm.animator.SetTrigger(Punch);
	}

	public virtual void OnPrimaryUp()
	{
	}

	public virtual void OnSecondaryDown()
	{
	}

	public virtual void OnSecondaryUp()
	{
	}
}
}

// Sandbox.Arm/BuildMode.cs
namespace Sandbox.Arm{
public class BuildMode : ArmModeWithHeldPreview
{
	private float tickDelay;

	private bool firstBrushPositionSet;

	private Vector3 firstBlockPos;

	private Vector3 secondBlockPos;

	private Vector3 previousSecondBlockPos;

	private Vector3 brushOffset = Vector3.one;

	private GameObject worldPreviewObject;

	private GameObject pointAIndicatorObject;

	private GameObject pointBIndicatorObject;

	private new static readonly int Punch = Animator.StringToHash("Punch");

	public override string Name => "Build";

	public override void SetPreview(SpawnableObject obj)
	{
		base.SetPreview(obj);
		SetupBlockCreator(obj);
	}

	private void SetupBlockCreator(SpawnableObject template)
	{
		firstBrushPositionSet = false;
		if ((bool)pointAIndicatorObject)
		{
			Object.Destroy(pointAIndicatorObject);
		}
		if ((bool)worldPreviewObject)
		{
			Object.Destroy(worldPreviewObject);
		}
		pointAIndicatorObject = Object.Instantiate(hostArm.axisPoint);
		if ((bool)pointBIndicatorObject)
		{
			Object.Destroy(pointBIndicatorObject);
		}
	}

	public override void Update()
	{
		base.Update();
		if (tickDelay > 0f)
		{
			tickDelay = Mathf.MoveTowards(tickDelay, 0f, Time.deltaTime);
		}
		Transform transform = MonoSingleton<CameraController>.Instance.transform;
		RaycastHit hitInfo;
		bool active = Physics.Raycast(transform.position, transform.forward, out hitInfo, 75f, hostArm.raycastLayers);
		if (!firstBrushPositionSet)
		{
			pointAIndicatorObject.SetActive(active);
			pointAIndicatorObject.transform.position = CalculatePropPosition(hitInfo);
			return;
		}
		RaycastHit hitInfo2;
		bool num = Physics.Raycast(transform.position, transform.forward, out hitInfo2, 5f, hostArm.raycastLayers);
		Vector3 zero = Vector3.zero;
		zero = ((!num) ? (transform.position + transform.forward * 4.5f) : (hitInfo2.point + new Vector3(0f, 0f, 0f)));
		zero = SandboxUtils.SnapPos(zero, brushOffset, ULTRAKILL.Cheats.Snapping.SnappingEnabled ? 0.5f : 7.5f);
		pointBIndicatorObject.SetActive(value: true);
		pointBIndicatorObject.transform.position = zero;
		if (Mathf.Abs(firstBlockPos.x - zero.x) >= 1f)
		{
			secondBlockPos.x = zero.x;
		}
		if (Mathf.Abs(firstBlockPos.y - zero.y) >= 1f)
		{
			secondBlockPos.y = zero.y;
		}
		if (Mathf.Abs(firstBlockPos.z - zero.z) >= 1f)
		{
			secondBlockPos.z = zero.z;
		}
		if (secondBlockPos != previousSecondBlockPos)
		{
			if (tickDelay == 0f)
			{
				hostArm.tickSound.pitch = Random.Range(0.74f, 0.76f);
				hostArm.tickSound.Play();
				tickDelay = 0.05f;
			}
			previousSecondBlockPos = secondBlockPos;
			SandboxUtils.SmallerBigger(firstBlockPos, secondBlockPos, out var smaller, out var bigger);
			Vector3 size = bigger - smaller;
			worldPreviewObject.GetComponent<MeshFilter>().mesh = SandboxUtils.GenerateProceduralMesh(size, simple: true);
			worldPreviewObject.transform.position = smaller;
		}
		worldPreviewObject.SetActive(value: true);
	}

	private Vector3 CalculatePropPosition(RaycastHit hit)
	{
		if (!ULTRAKILL.Cheats.Snapping.SnappingEnabled)
		{
			brushOffset = Vector3.zero;
		}
		Vector3 offset = Vector3.zero;
		if ((bool)hit.transform && (bool)SandboxUtils.GetProp(hit.collider.gameObject, ignoreManipulationBlock: true))
		{
			offset = -new Vector3(0f, SandboxUtils.SnapPos(hit.transform.position).y - hit.transform.position.y, 0f);
		}
		Vector3 vector = (ULTRAKILL.Cheats.Snapping.SnappingEnabled ? SandboxUtils.SnapPos(hit.point, offset) : hit.point);
		float distanceToPoint = new Plane(hit.normal, vector).GetDistanceToPoint(hit.point);
		vector += hit.normal * distanceToPoint;
		if ((bool)hit.transform && !SandboxUtils.GetProp(hit.collider.gameObject, ignoreManipulationBlock: true))
		{
			offset = hit.normal * distanceToPoint;
		}
		brushOffset = offset;
		return vector;
	}

	public override void OnPrimaryDown()
	{
		base.OnPrimaryDown();
		if (!currentObject)
		{
			return;
		}
		hostArm.jabSound.Play();
		hostArm.animator.SetTrigger(Punch);
		if (!firstBrushPositionSet && hostArm.hitSomething)
		{
			firstBlockPos = CalculatePropPosition(hostArm.hit);
			secondBlockPos = firstBlockPos + Vector3.one / 0.5f;
			previousSecondBlockPos = secondBlockPos;
			firstBrushPositionSet = true;
			pointBIndicatorObject = Object.Instantiate(hostArm.axisPoint);
			CreateWorldPreview();
			return;
		}
		hostArm.tickSound.Play();
		SandboxUtils.SmallerBigger(firstBlockPos, secondBlockPos, out var smaller, out var bigger);
		Vector3 size = bigger - smaller;
		GameObject gameObject = SandboxUtils.CreateFinalBlock(currentObject, smaller, size, currentObject.isWater);
		if (gameObject.TryGetComponent<BrushBlock>(out var component))
		{
			SandboxSpawnableInstance component2 = gameObject.GetComponent<SandboxSpawnableInstance>();
			component2.frozen = !SpawnPhysics.PhysicsDynamic;
			if (!SpawnPhysics.PhysicsDynamic && MonoSingleton<SandboxNavmesh>.Instance != null)
			{
				MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(component2);
			}
			if (component.TryGetComponent<Rigidbody>(out var component3))
			{
				component3.isKinematic = !SpawnPhysics.PhysicsDynamic;
			}
		}
		firstBrushPositionSet = false;
		SetupBlockCreator(currentObject);
		MonoSingleton<PresenceController>.Instance.AddToStatInt("sandbox_built_brushes", 1);
	}

	private void CreateWorldPreview()
	{
		worldPreviewObject = new GameObject("World Preview");
		worldPreviewObject.AddComponent<MeshFilter>();
		worldPreviewObject.AddComponent<MeshRenderer>().material = hostArm.previewMaterial;
	}

	public override void OnDisable()
	{
		base.OnDisable();
		if ((bool)worldPreviewObject)
		{
			worldPreviewObject.SetActive(value: false);
		}
		if ((bool)pointAIndicatorObject)
		{
			pointAIndicatorObject.SetActive(value: false);
		}
		if ((bool)pointBIndicatorObject)
		{
			pointBIndicatorObject.SetActive(value: false);
		}
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if ((bool)worldPreviewObject)
		{
			Object.Destroy(worldPreviewObject);
		}
		if ((bool)pointAIndicatorObject)
		{
			Object.Destroy(pointAIndicatorObject);
		}
		if ((bool)pointBIndicatorObject)
		{
			Object.Destroy(pointBIndicatorObject);
		}
	}
}
}

// Sandbox.Arm/DestroyMode.cs
namespace Sandbox.Arm{
public class DestroyMode : ISandboxArmMode
{
	private SandboxArm hostArm;

	private static readonly int Tap = Animator.StringToHash("Tap");

	private static readonly int Point = Animator.StringToHash("Point");

	public string Name => "Destroy";

	public bool CanOpenMenu => true;

	public bool Raycast => true;

	public virtual string Icon => "destroy";

	public void OnEnable(SandboxArm arm)
	{
		hostArm = arm;
		arm.ResetAnimator();
		arm.animator.SetBool(Point, value: true);
	}

	public void OnDisable()
	{
	}

	public void OnDestroy()
	{
	}

	public void Update()
	{
	}

	public void FixedUpdate()
	{
	}

	public void OnPrimaryDown()
	{
		if (hostArm.hit.collider == null)
		{
			return;
		}
		EnemyIdentifierIdentifier component = hostArm.hit.collider.GetComponent<EnemyIdentifierIdentifier>();
		GameObject obj;
		if ((bool)component && (bool)component.eid)
		{
			SandboxEnemy componentInParent = component.eid.GetComponentInParent<SandboxEnemy>();
			obj = (componentInParent ? componentInParent.gameObject : component.eid.gameObject);
		}
		else
		{
			SandboxSpawnableInstance prop = SandboxUtils.GetProp(hostArm.hit.collider.gameObject);
			if (prop == null)
			{
				DietProp dietProp = hostArm.hit.collider.GetComponent<DietProp>();
				if (!dietProp)
				{
					return;
				}
				if (dietProp.parent != null)
				{
					dietProp = dietProp.parent;
				}
				obj = dietProp.gameObject;
			}
			else
			{
				obj = prop.gameObject;
			}
		}
		if (hostArm.hit.collider.TryGetComponent<SandboxSpawnableInstance>(out var component2) && hostArm.hit.collider.TryGetComponent<Rigidbody>(out var component3) && component3.isKinematic && (bool)MonoSingleton<SandboxNavmesh>.Instance && (!component || !component.eid))
		{
			MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(component2);
		}
		Object.Instantiate(hostArm.genericBreakParticles).transform.position = hostArm.hit.collider.bounds.center;
		Object.Destroy(obj);
		hostArm.destroySound.Play();
		hostArm.animator.SetTrigger(Tap);
	}

	public void OnPrimaryUp()
	{
	}

	public void OnSecondaryDown()
	{
	}

	public void OnSecondaryUp()
	{
	}
}
}

// Sandbox.Arm/ISandboxArmMode.cs
namespace Sandbox.Arm{
public interface ISandboxArmMode
{
	string Name { get; }

	bool CanOpenMenu { get; }

	bool Raycast { get; }

	string Icon { get; }

	void OnEnable(SandboxArm hostArm);

	void OnDisable();

	void OnDestroy();

	void Update();

	void FixedUpdate();

	void OnPrimaryDown();

	void OnPrimaryUp();

	void OnSecondaryDown();

	void OnSecondaryUp();
}
}

// Sandbox.Arm/MoveMode.cs
namespace Sandbox.Arm{
public class MoveMode : ISandboxArmMode, ISandboxArmDebugGUI
{
	public class ManipulatedObject
	{
		public Transform target;

		public SandboxSpawnableInstance spawnable;

		public GameObject particles;

		public Rigidbody rigidbody;

		public Collider collider;

		public Vector3 positionOffset;

		public float distance;

		public Vector3 originalRotation;

		public float simpleRotationOffset;

		public Quaternion rotationOffset;

		public ManipulatedObject(RaycastHit hit, SandboxSpawnableInstance propOverwrite = null)
		{
			GameObject gameObject = (propOverwrite ? propOverwrite.gameObject : hit.collider.gameObject);
			target = gameObject.transform;
			rigidbody = gameObject.GetComponent<Rigidbody>();
			collider = gameObject.GetComponent<Collider>();
			if (collider == null)
			{
				if (gameObject.TryGetComponent<SandboxPropPart>(out var component))
				{
					collider = component.parent.GetComponent<Collider>();
				}
				if (collider == null)
				{
					collider = gameObject.GetComponentInChildren<Collider>();
				}
			}
			positionOffset = target.position - hit.point;
			CameraController instance = MonoSingleton<CameraController>.Instance;
			distance = Vector3.Distance(instance.transform.position, hit.point);
			originalRotation = target.eulerAngles;
			rotationOffset = Quaternion.Inverse(instance.transform.rotation) * target.rotation;
			simpleRotationOffset = originalRotation.y - instance.rotationY;
			if ((bool)rigidbody)
			{
				rigidbody.isKinematic = true;
			}
			spawnable = (propOverwrite ? propOverwrite : SandboxUtils.GetProp(gameObject));
		}
	}

	private static readonly int Manipulating = Animator.StringToHash("Manipulating");

	private static readonly int Pinched = Animator.StringToHash("Pinched");

	private static readonly int PushZ = Animator.StringToHash("PushZ");

	private static readonly int Crush = Animator.StringToHash("Crush");

	private SandboxArm hostArm;

	private ManipulatedObject manipulatedObject;

	private Vector3 targetPos;

	private Vector3 objectVelocity;

	public string Name => "Move";

	public bool CanOpenMenu => manipulatedObject == null;

	public virtual string Icon => "move";

	public virtual bool Raycast => true;

	public virtual void OnEnable(SandboxArm arm)
	{
		arm.ResetAnimator();
		arm.animator.SetBool(Manipulating, value: true);
		hostArm = arm;
	}

	public void OnDisable()
	{
	}

	public void OnDestroy()
	{
	}

	public void Update()
	{
		IntegrityCheck();
		if (manipulatedObject == null)
		{
			return;
		}
		if (ExperimentalArmRotation.Enabled)
		{
			Quaternion identity = Quaternion.identity;
			if (MonoSingleton<InputManager>.Instance.InputSource.NextVariation.IsPressed)
			{
				Vector2 vector = Mouse.current.delta.ReadValue();
				identity = Quaternion.AngleAxis(vector.x * -0.1f, Vector3.up) * Quaternion.AngleAxis(vector.y * 0.1f, Vector3.right);
				manipulatedObject.rotationOffset = identity * manipulatedObject.rotationOffset;
				MonoSingleton<CameraController>.Instance.activated = false;
			}
			else
			{
				MonoSingleton<CameraController>.Instance.activated = true;
			}
			manipulatedObject.target.rotation = MonoSingleton<CameraController>.Instance.transform.rotation * manipulatedObject.rotationOffset;
		}
		else
		{
			Vector3 vector2 = new Vector3(manipulatedObject.originalRotation.x, MonoSingleton<CameraController>.Instance.rotationY + manipulatedObject.simpleRotationOffset, manipulatedObject.originalRotation.z);
			vector2 = (ULTRAKILL.Cheats.Snapping.SnappingEnabled ? SandboxUtils.SnapRotation(vector2) : vector2);
			manipulatedObject.target.eulerAngles = vector2;
		}
		if (ExperimentalArmRotation.Enabled)
		{
			targetPos = MonoSingleton<CameraController>.Instance.transform.position + MonoSingleton<CameraController>.Instance.transform.forward * manipulatedObject.distance;
			if (ULTRAKILL.Cheats.Snapping.SnappingEnabled)
			{
				targetPos = SandboxUtils.SnapPos(targetPos);
			}
			Vector3 vector3 = targetPos - manipulatedObject.target.position;
			manipulatedObject.particles.transform.position = manipulatedObject.collider.bounds.center;
			manipulatedObject.target.position += vector3 * 15.5f * Time.deltaTime;
			objectVelocity = vector3;
		}
		else
		{
			Vector3 vector4 = new Vector3(manipulatedObject.originalRotation.x, MonoSingleton<CameraController>.Instance.rotationY + manipulatedObject.simpleRotationOffset, manipulatedObject.originalRotation.z);
			vector4 = (ULTRAKILL.Cheats.Snapping.SnappingEnabled ? SandboxUtils.SnapRotation(vector4) : vector4);
			manipulatedObject.target.eulerAngles = vector4;
			Vector3 vector5 = Quaternion.Euler(0f, 0f - (manipulatedObject.originalRotation.y - vector4.y), 0f) * (ULTRAKILL.Cheats.Snapping.SnappingEnabled ? SandboxUtils.SnapPos(manipulatedObject.positionOffset) : manipulatedObject.positionOffset);
			Vector3 vector6 = manipulatedObject.target.position - vector5;
			Vector3 vector7 = (targetPos = MonoSingleton<CameraController>.Instance.transform.position + MonoSingleton<CameraController>.Instance.transform.forward * manipulatedObject.distance);
			if (ULTRAKILL.Cheats.Snapping.SnappingEnabled)
			{
				vector7 = SandboxUtils.SnapPos(vector7);
			}
			Vector3 vector8 = vector7 - vector6;
			manipulatedObject.particles.transform.position = manipulatedObject.collider.bounds.center;
			manipulatedObject.target.position += vector8 * 15.5f * Time.deltaTime;
			objectVelocity = vector8;
		}
		float y = Mouse.current.scroll.ReadValue().y;
		hostArm.animator.SetFloat(PushZ, y);
		manipulatedObject.distance += Mathf.Clamp(manipulatedObject.distance, 1f, 10f) / 10f * y * 0.05f;
		manipulatedObject.distance = Mathf.Max(0f, manipulatedObject.distance);
	}

	public void FixedUpdate()
	{
	}

	public void OnPrimaryDown()
	{
		if (manipulatedObject == null && hostArm.hitSomething)
		{
			SandboxSpawnableInstance prop = SandboxUtils.GetProp(hostArm.hit.collider.gameObject);
			if ((bool)prop)
			{
				prop.Pause();
				MonoSingleton<GunControl>.Instance.activated = false;
				manipulatedObject = new ManipulatedObject(hostArm.hit, prop)
				{
					particles = Object.Instantiate(hostArm.manipulateEffect)
				};
				hostArm.animator.SetBool(Pinched, value: true);
			}
		}
	}

	public void OnPrimaryUp()
	{
		if (manipulatedObject != null)
		{
			Debug.Log("targetPos: " + targetPos);
			Debug.Log("is manipulator null: " + (manipulatedObject == null));
			Debug.Log("manipulatedObject.target.position: " + manipulatedObject.target.position);
			Vector3 vector = objectVelocity;
			manipulatedObject.particles.transform.position = manipulatedObject.collider.bounds.center;
			manipulatedObject.target.position += vector * 15.5f * Time.deltaTime;
			Debug.Log(vector);
			ReleaseManipulatedObject(vector * 6.5f);
		}
	}

	public bool OnGUI()
	{
		if (manipulatedObject == null)
		{
			if (hostArm.hitSomething && hostArm.hit.collider != null)
			{
				GUILayout.Label("Hit: " + hostArm.hit.collider.name);
				GUILayout.Space(8f);
				int layer = hostArm.hit.collider.gameObject.layer;
				GUILayout.Label("Layer: " + layer + " - " + LayerMask.LayerToName(layer));
				GUILayout.Label("Tag: " + hostArm.hit.collider.tag);
			}
			else
			{
				GUILayout.Label("No raycast hit.");
			}
			return true;
		}
		GUILayout.Label("Moving: " + manipulatedObject.target.name);
		GUILayout.Space(8f);
		GUILayout.Label("Computed Target Point: " + targetPos);
		GUILayout.Label("Object's (Pivot) Position " + manipulatedObject.target.position);
		GUILayout.Label("Velocity: " + objectVelocity);
		return true;
	}

	public void OnSecondaryDown()
	{
		if (manipulatedObject != null && (!(manipulatedObject.spawnable != null) || !manipulatedObject.spawnable.disallowFreezing))
		{
			if ((bool)manipulatedObject.particles)
			{
				Object.Destroy(manipulatedObject.particles);
			}
			MonoSingleton<GunControl>.Instance.activated = true;
			hostArm.animator.SetBool(Pinched, value: false);
			hostArm.animator.SetTrigger(Crush);
			SandboxSpawnableInstance component = manipulatedObject.target.GetComponent<SandboxSpawnableInstance>();
			component.Pause();
			if (manipulatedObject.target.CompareTag("Untagged"))
			{
				manipulatedObject.target.tag = "Floor";
			}
			if (MonoSingleton<SandboxNavmesh>.Instance != null)
			{
				MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(component);
			}
			hostArm.freezeSound.pitch = Random.Range(1f, 1.05f);
			hostArm.freezeSound.Play();
			GameObject gameObject = new GameObject("Ghost Effect Wrapper");
			gameObject.transform.position = manipulatedObject.collider.bounds.center;
			GameObject gameObject2 = gameObject;
			SandboxUtils.StripForPreview(Object.Instantiate(manipulatedObject.target, gameObject2.transform, worldPositionStays: true), hostArm.previewMaterial);
			gameObject2.gameObject.AddComponent<SandboxGhostEffect>();
			MonoSingleton<CameraController>.Instance.activated = true;
			manipulatedObject = null;
		}
	}

	public void OnSecondaryUp()
	{
	}

	private void IntegrityCheck()
	{
		if (manipulatedObject != null && (!(manipulatedObject.target != null) || !(manipulatedObject.collider != null)))
		{
			Debug.LogWarning("Integrity check failed, releasing manipulated object");
			ReleaseManipulatedObject(Vector3.zero);
		}
	}

	private void ReleaseManipulatedObject(Vector3 velocity, Quaternion? deltaRot = null)
	{
		Object.Destroy(manipulatedObject.particles);
		MonoSingleton<GunControl>.Instance.activated = true;
		hostArm.animator.SetBool(Pinched, value: false);
		MonoSingleton<CameraController>.Instance.activated = true;
		if (manipulatedObject.target != null && manipulatedObject.target.TryGetComponent<SandboxSpawnableInstance>(out var component))
		{
			if (!component.alwaysFrozen)
			{
				component.Resume();
			}
			else
			{
				component.frozen = true;
			}
		}
		if ((bool)manipulatedObject.rigidbody && (!manipulatedObject.spawnable.sourceObject || !manipulatedObject.spawnable.sourceObject.alwaysKinematic))
		{
			manipulatedObject.rigidbody.isKinematic = false;
			manipulatedObject.rigidbody.velocity = velocity;
			manipulatedObject.rigidbody.angularVelocity = deltaRot?.eulerAngles ?? Vector3.zero;
		}
		manipulatedObject = null;
	}
}
}

// Sandbox.Arm/PlaceMode.cs
namespace Sandbox.Arm{
public class PlaceMode : ArmModeWithHeldPreview
{
	private GameObject worldPreviewObject;

	public override string Name => "Place";

	public override bool Raycast => true;

	public override void SetPreview(SpawnableObject obj)
	{
		base.SetPreview(obj);
		if (worldPreviewObject != null)
		{
			Object.Destroy(worldPreviewObject);
		}
		CreateWorldPreview(obj);
	}

	private void CreateWorldPreview(SpawnableObject obj)
	{
		if (obj.gameObject.TryGetComponent<MeshFilter>(out var component) && obj.gameObject.TryGetComponent<SandboxProp>(out var component2) && !component2.forceFullWorldPreview)
		{
			Mesh sharedMesh = component.sharedMesh;
			CreateWorldPreview();
			worldPreviewObject.transform.localRotation = obj.gameObject.transform.localRotation;
			worldPreviewObject.GetComponent<MeshFilter>().mesh = sharedMesh;
			worldPreviewObject.GetComponent<MeshRenderer>().material = hostArm.previewMaterial;
		}
		else
		{
			worldPreviewObject = Object.Instantiate(obj.gameObject);
			SandboxUtils.StripForPreview(worldPreviewObject.transform, hostArm.previewMaterial);
		}
	}

	private void CreateWorldPreview()
	{
		worldPreviewObject = new GameObject("World Preview");
		worldPreviewObject.AddComponent<MeshFilter>();
		worldPreviewObject.AddComponent<MeshRenderer>().material = hostArm.previewMaterial;
	}

	public override void Update()
	{
		base.Update();
		if ((bool)worldPreviewObject)
		{
			worldPreviewObject.SetActive(hostArm.hitSomething);
			if (hostArm.hitSomething)
			{
				Vector3 normal = ((currentObject.spawnableObjectType == SpawnableObject.SpawnableObjectDataType.Enemy) ? Vector3.up : hostArm.hit.normal);
				worldPreviewObject.transform.SetPositionAndRotation(CalculatePropPosition(hostArm.hit), CalculatePropRotation(normal, currentObject.gameObject.transform.rotation));
			}
		}
	}

	private Quaternion CalculatePropRotation(Vector3 normal, Quaternion baseRotation)
	{
		float num = MonoSingleton<CameraController>.Instance.rotationY;
		if (ULTRAKILL.Cheats.Snapping.SnappingEnabled)
		{
			num /= 90f;
			num = Mathf.Round(num);
			num *= 90f;
		}
		return Quaternion.FromToRotation(Vector3.up, normal) * Quaternion.AngleAxis(num, Vector3.up) * baseRotation;
	}

	private Vector3 CalculatePropPosition(RaycastHit hit)
	{
		if (!ULTRAKILL.Cheats.Snapping.SnappingEnabled)
		{
			if ((bool)currentObject && currentObject.spawnOffset != 0f)
			{
				return hit.point + hit.normal * currentObject.spawnOffset;
			}
			return hit.point;
		}
		Vector3 offset = Vector3.zero;
		if ((bool)hit.transform && (bool)SandboxUtils.GetProp(hit.collider.gameObject, ignoreManipulationBlock: true))
		{
			offset = -new Vector3(0f, SandboxUtils.SnapPos(hit.transform.position).y - hit.transform.position.y, 0f);
		}
		Vector3 vector = SandboxUtils.SnapPos(hit.point, offset);
		float distanceToPoint = new Plane(hit.normal, vector).GetDistanceToPoint(hit.point);
		vector += hit.normal * distanceToPoint;
		if ((bool)currentObject && currentObject.spawnOffset != 0f)
		{
			vector += hit.normal * currentObject.spawnOffset;
		}
		return vector;
	}

	public override void OnPrimaryDown()
	{
		base.OnPrimaryDown();
		if (!currentObject || !hostArm.hitSomething)
		{
			return;
		}
		Vector3 normal = ((currentObject.spawnableObjectType == SpawnableObject.SpawnableObjectDataType.Enemy) ? Vector3.up : hostArm.hit.normal);
		GameObject gameObject = Object.Instantiate(currentObject.gameObject, CalculatePropPosition(hostArm.hit), CalculatePropRotation(normal, currentObject.gameObject.transform.localRotation), hostArm.GetGoreZone().transform);
		if (gameObject.TryGetComponent<SandboxProp>(out var component))
		{
			component.sourceObject = currentObject;
		}
		bool flag = currentObject.spawnableObjectType == SpawnableObject.SpawnableObjectDataType.Enemy;
		if (flag)
		{
			gameObject.AddComponent<SandboxEnemy>().sourceObject = currentObject;
			MonoSingleton<PresenceController>.Instance.AddToStatInt("sandbox_spawned_enemies", 1);
			if ((bool)MonoSingleton<SandboxNavmesh>.Instance)
			{
				MonoSingleton<SandboxNavmesh>.Instance.EnsurePositionWithinBounds(gameObject.transform.position);
			}
		}
		else
		{
			MonoSingleton<PresenceController>.Instance.AddToStatInt("sandbox_spawned_props", 1);
		}
		if (gameObject.TryGetComponent<SandboxSpawnableInstance>(out var component2))
		{
			component2.frozen = !flag && !SpawnPhysics.PhysicsDynamic;
			if (currentObject.defaultSettings != null && currentObject.defaultSettings.Length != 0)
			{
				component2.ApplyAlterOptions(currentObject.defaultSettings);
			}
		}
		gameObject.SetActive(value: true);
		if (currentObject.spawnableObjectType != SpawnableObject.SpawnableObjectDataType.Enemy && gameObject.TryGetComponent<Rigidbody>(out var component3))
		{
			component3.isKinematic = !SpawnPhysics.PhysicsDynamic;
			if (currentObject.spawnableType == SpawnableType.Prop && !SpawnPhysics.PhysicsDynamic && MonoSingleton<SandboxNavmesh>.Instance != null)
			{
				MonoSingleton<SandboxNavmesh>.Instance.MarkAsDirty(component);
			}
		}
	}

	public override void OnEnable(SandboxArm arm)
	{
		base.OnEnable(arm);
		if (worldPreviewObject != null)
		{
			worldPreviewObject.SetActive(value: true);
		}
	}

	public override void OnDisable()
	{
		base.OnDisable();
		if (worldPreviewObject != null)
		{
			worldPreviewObject.SetActive(value: false);
		}
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (worldPreviewObject != null)
		{
			Object.Destroy(worldPreviewObject);
		}
	}
}
}

// Sandbox.Arm/SandboxArm.cs
namespace Sandbox.Arm{
[ConfigureSingleton(SingletonFlags.NoAutoInstance)]
public class SandboxArm : MonoSingleton<SandboxArm>
{
	private static readonly plog.Logger Log = new plog.Logger("SandboxArm");

	[FormerlySerializedAs("onEnableMode")]
	public SpawnableType onEnableType;

	[HideInInspector]
	public CameraController cameraCtrl;

	public LayerMask raycastLayers;

	public GameObject axisPoint;

	[SerializeField]
	private GameObject spawnEffect;

	public Material previewMaterial;

	public Transform holder;

	[FormerlySerializedAs("armAnimator")]
	public Animator animator;

	[Space]
	[SerializeField]
	private WeaponDescriptor genericDescriptor;

	[SerializeField]
	private WeaponDescriptor alterDescriptor;

	[SerializeField]
	private WeaponDescriptor destroyDescriptor;

	[SerializeField]
	private WeaponDescriptor buildOrPlaceDescriptor;

	[Space]
	public AudioSource tickSound;

	public AudioSource jabSound;

	public AudioSource selectSound;

	public AudioSource freezeSound;

	public AudioSource unfreezeSound;

	public AudioSource destroySound;

	public GameObject genericBreakParticles;

	public GameObject manipulateEffect;

	[Space]
	[SerializeField]
	private Image holoIcon;

	[SerializeField]
	private GameObject holoIconContainer;

	[NonSerialized]
	public SpawnMenu menu;

	private GoreZone goreZone;

	private bool debugStarted;

	private TimeSince timeSinceDebug;

	[NonSerialized]
	public bool hitSomething;

	[NonSerialized]
	public RaycastHit hit;

	private WeaponIcon localIcon;

	private bool firstBrushPositionSet;

	private Vector3 firstBlockPos;

	private Vector3 secondBlockPos;

	private Vector3 previousSecondBlockPos;

	public static GoreZone debugZone;

	private ISandboxArmMode currentMode;

	private static readonly int Holding = Animator.StringToHash("Holding");

	private static readonly int Punch = Animator.StringToHash("Punch");

	private static readonly int Manipulating = Animator.StringToHash("Manipulating");

	private static readonly int Pinched = Animator.StringToHash("Pinched");

	private static readonly int Crush = Animator.StringToHash("Crush");

	private static readonly int PushZ = Animator.StringToHash("PushZ");

	private static readonly int Point = Animator.StringToHash("Point");

	private static readonly int Tap = Animator.StringToHash("Tap");

	protected override void Awake()
	{
		base.Awake();
		localIcon = GetComponent<WeaponIcon>();
	}

	public void SetArmMode(ISandboxArmMode mode)
	{
		ResetMode();
		currentMode = mode;
		Log.Info("Setting Arm Mode to: " + currentMode);
		currentMode.OnEnable(this);
		selectSound.Play();
		ReloadIcon();
		ReloadHudIconColor();
	}

	public void ReloadIcon()
	{
		Log.Info("Reloading arm icon");
		if (currentMode == null || string.IsNullOrEmpty(currentMode.Icon))
		{
			holoIconContainer.SetActive(value: false);
			return;
		}
		holoIconContainer.SetActive(value: true);
		if (MonoSingleton<IconManager>.Instance.CurrentIcons.sandboxArmHoloIcons.Select((CheatAssetObject.KeyIcon e) => e.key).Contains(currentMode.Icon))
		{
			holoIcon.sprite = MonoSingleton<IconManager>.Instance.CurrentIcons.sandboxArmHoloIcons.First((CheatAssetObject.KeyIcon e) => e.key == currentMode.Icon).sprite;
		}
		else
		{
			holoIcon.sprite = MonoSingleton<IconManager>.Instance.CurrentIcons.genericSandboxToolIcon;
		}
	}

	private void ReloadHudIconColor()
	{
		if (localIcon == null)
		{
			localIcon = GetComponent<WeaponIcon>();
		}
		if (currentMode is AlterMode)
		{
			localIcon.weaponDescriptor = alterDescriptor;
		}
		else if (currentMode is DestroyMode)
		{
			localIcon.weaponDescriptor = destroyDescriptor;
		}
		else if (currentMode is PlaceMode || currentMode is BuildMode)
		{
			localIcon.weaponDescriptor = buildOrPlaceDescriptor;
		}
		else
		{
			localIcon.weaponDescriptor = genericDescriptor;
		}
		localIcon.UpdateIcon();
	}

	public void ResetAnimator()
	{
		animator.SetBool(Holding, value: false);
		animator.SetBool(Punch, value: false);
		animator.SetBool(Manipulating, value: false);
		animator.SetBool(Pinched, value: false);
		animator.SetBool(Crush, value: false);
		animator.SetBool(Point, value: false);
		animator.SetBool(Tap, value: false);
	}

	public GoreZone GetGoreZone()
	{
		if (!goreZone)
		{
			goreZone = new GameObject("Debug Gore Zone").AddComponent<GoreZone>();
			debugZone = goreZone;
		}
		return goreZone;
	}

	public void SelectObject(SpawnableObject obj)
	{
		ResetMode();
		menu.gameObject.SetActive(value: false);
		MonoSingleton<OptionsManager>.Instance.UnFreeze();
		if (SetArmMode(obj.spawnableType) is ArmModeWithHeldPreview armModeWithHeldPreview)
		{
			armModeWithHeldPreview.SetPreview(obj);
		}
	}

	public ISandboxArmMode SetArmMode(SpawnableType type)
	{
		Log.Info($"Setting arm mode to {type}");
		ISandboxArmMode sandboxArmMode = null;
		switch (type)
		{
		case SpawnableType.MoveHand:
			sandboxArmMode = new MoveMode();
			break;
		case SpawnableType.DestroyHand:
			sandboxArmMode = new DestroyMode();
			break;
		case SpawnableType.AlterHand:
			sandboxArmMode = new AlterMode();
			break;
		case SpawnableType.BuildHand:
			sandboxArmMode = new BuildMode();
			break;
		case SpawnableType.SimpleSpawn:
		case SpawnableType.Prop:
			sandboxArmMode = new PlaceMode();
			break;
		}
		SetArmMode(sandboxArmMode);
		return sandboxArmMode;
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		if (currentMode == null)
		{
			ResetMode();
			SetArmMode(onEnableType);
		}
		else
		{
			currentMode.OnEnable(this);
		}
	}

	private void OnDisable()
	{
		currentMode?.OnDisable();
	}

	private new void OnDestroy()
	{
		ResetMode();
		if ((bool)MonoSingleton<CheatsController>.Instance)
		{
			MonoSingleton<CheatsController>.Instance.arm = null;
		}
	}

	public void ResetMode()
	{
		currentMode?.OnDestroy();
		currentMode = null;
	}

	private void FixedUpdate()
	{
		currentMode?.FixedUpdate();
	}

	private void Update()
	{
		if (Time.timeScale == 0f)
		{
			return;
		}
		if (menu != null && MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame && (currentMode == null || currentMode.CanOpenMenu))
		{
			menu.gameObject.SetActive(value: true);
			MonoSingleton<OptionsManager>.Instance.Freeze();
			return;
		}
		if (menu == null || !menu.gameObject.activeSelf)
		{
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasPerformedThisFrame)
			{
				currentMode?.OnPrimaryDown();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire1.WasCanceledThisFrame)
			{
				currentMode?.OnPrimaryUp();
			}
			if (!MonoSingleton<InputManager>.Instance.PerformingCheatMenuCombo() && MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasPerformedThisFrame)
			{
				currentMode?.OnSecondaryDown();
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Fire2.WasCanceledThisFrame)
			{
				currentMode?.OnSecondaryUp();
			}
		}
		if (currentMode != null && currentMode.Raycast)
		{
			hitSomething = Physics.Raycast(MonoSingleton<CameraController>.Instance.transform.position, MonoSingleton<CameraController>.Instance.transform.forward, out hit, 75f, raycastLayers);
		}
		currentMode?.Update();
	}

	public Vector2? GetHolderScreenPosition()
	{
		Vector3 vector = MonoSingleton<CameraController>.Instance.cam.WorldToScreenPoint(holder.position);
		if (vector.z < 0f)
		{
			return null;
		}
		return vector;
	}

	private void OnGUI()
	{
		if (!SandboxArmDebug.DebugActive || !(currentMode is ISandboxArmDebugGUI sandboxArmDebugGUI))
		{
			return;
		}
		Vector2? holderScreenPosition = GetHolderScreenPosition();
		if (holderScreenPosition.HasValue)
		{
			float num = holderScreenPosition.Value.x - 150f;
			float num2 = (float)Screen.height - holderScreenPosition.Value.y - 150f;
			GUILayout.BeginArea(new Rect(num, num2, Mathf.Min(300f, (float)Screen.width - num), Mathf.Min(250f, (float)Screen.height - num2)), GUI.skin.box);
			GUI.color = ((currentMode == null) ? Color.red : Color.green);
			GUILayout.Label((currentMode == null) ? "No mode is active" : currentMode.ToString());
			GUI.color = Color.white;
			if (!sandboxArmDebugGUI.OnGUI())
			{
				GUILayout.Label("No debug info is available right now.");
			}
			GUILayout.EndArea();
		}
	}
}
}

// DebugOverlays/EnemyIdentifierDebugOverlay.cs
namespace DebugOverlays{
public class EnemyIdentifierDebugOverlay : MonoBehaviour
{
	private EnemyType enemyType;

	private EnemyClass enemyClass;

	private bool dead;

	private bool ignorePlayer;

	private bool attackEnemies;

	private EnemyTarget target;

	public void ConsumeData(EnemyType enemyType, EnemyClass enemyClass, bool dead, bool ignorePlayer, bool attackEnemies, EnemyTarget target)
	{
		this.enemyType = enemyType;
		this.enemyClass = enemyClass;
		this.dead = dead;
		this.ignorePlayer = ignorePlayer;
		this.attackEnemies = attackEnemies;
		this.target = target;
	}

	private void OnGUI()
	{
		Rect? onScreenRect = OnGUIHelper.GetOnScreenRect(base.transform.position);
		if (!onScreenRect.HasValue)
		{
			return;
		}
		Rect value = onScreenRect.Value;
		GUI.Label(value, $"{enemyType} ({enemyClass})");
		if (dead)
		{
			GUI.color = Color.red;
			value.y += 20f;
			GUI.Label(value, "Dead!");
			return;
		}
		GUI.color = Color.white;
		value.y += 20f;
		GUI.Label(value, $"Ignore player: {ignorePlayer}");
		value.y += 20f;
		GUI.Label(value, $"Attack enemies: {attackEnemies}");
		value.y += 20f;
		if (target == null)
		{
			GUI.color = Color.red;
			GUI.Label(value, "Target: Null");
		}
		else if (target.isPlayer)
		{
			GUI.Label(value, "Target: (Player)");
		}
		else if (target.targetTransform != null)
		{
			GUI.Label(value, "Target: (" + target.targetTransform.name + ")");
			Vector3 position = target.position;
			Vector3 vector = MonoSingleton<CameraController>.Instance.cam.WorldToScreenPoint(position);
			if (position.z > 0f)
			{
				Rect position2 = new Rect(vector.x - 5f, (float)Screen.height - vector.y - 5f, 10f, 10f);
				GUI.color = Color.yellow;
				GUI.Box(position2, "");
				GUI.color = Color.white;
			}
		}
		GUI.color = Color.white;
	}
}
}

// DebugOverlays/OnGUIHelper.cs
namespace DebugOverlays{
public static class OnGUIHelper
{
	public static Rect? GetOnScreenRect(Vector3 worldPosition, float width = 300f, float height = 100f)
	{
		Vector3 vector = MonoSingleton<CameraController>.Instance.cam.WorldToScreenPoint(worldPosition);
		if (vector.z < 0f)
		{
			return null;
		}
		return new Rect(vector.x - 50f, (float)Screen.height - vector.y - 50f, width, height);
	}
}
}

// DebugOverlays/SwingCheckDebugOverlay.cs
namespace DebugOverlays{
public class SwingCheckDebugOverlay : MonoBehaviour
{
	private bool damaging;

	private EnemyIdentifier eid;

	public void ConsumeData(bool damaging, EnemyIdentifier eid)
	{
		this.damaging = damaging;
		this.eid = eid;
	}

	private void OnGUI()
	{
		if (!damaging)
		{
			return;
		}
		Rect? onScreenRect = OnGUIHelper.GetOnScreenRect(base.transform.position);
		if (onScreenRect.HasValue)
		{
			Rect value = onScreenRect.Value;
			GUI.Label(value, "SWING!", new GUIStyle
			{
				fontSize = 20,
				fontStyle = FontStyle.Bold,
				normal = 
				{
					textColor = Color.red
				}
			});
			value.y += 20f;
			if (eid == null)
			{
				GUI.Label(value, "No EID", new GUIStyle
				{
					fontSize = 20,
					fontStyle = FontStyle.Bold,
					normal = 
					{
						textColor = Color.magenta
					}
				});
			}
			else if (eid.target == null)
			{
				GUI.Label(value, "No target", new GUIStyle
				{
					fontSize = 20,
					fontStyle = FontStyle.Bold,
					normal = 
					{
						textColor = Color.yellow
					}
				});
			}
			else if (eid.target.isPlayer)
			{
				GUI.Label(value, "Player target", new GUIStyle
				{
					fontSize = 20,
					fontStyle = FontStyle.Bold,
					normal = 
					{
						textColor = Color.green
					}
				});
			}
			else
			{
				GUI.Label(value, eid.target.ToString(), new GUIStyle
				{
					fontSize = 20,
					fontStyle = FontStyle.Bold,
					normal = 
					{
						textColor = Color.blue
					}
				});
			}
		}
	}
}
}

// GameConsole.pcon/Log.cs
namespace GameConsole.pcon{
public class Log : ISend
{
	private const string Type = "pcon.log";

	public string message;

	public string stacktrace;

	[JsonConverter(typeof(StringEnumConverter), new object[] { typeof(CamelCaseNamingStrategy) })]
	public PConLogLevel level;

	public long timestamp;

	public IEnumerable<int> tags;

	public int hash;

	public string type => "pcon.log";

	private void ComputeHash()
	{
		hash = message?.GetHashCode() ?? (0 ^ stacktrace?.GetHashCode()) ?? (0 ^ level.GetHashCode());
	}
}
}

// GameConsole.pcon/MapVarChange.cs
namespace GameConsole.pcon{
[RegisterIncomingMessage("ultrakill.mapvar.update")]
public class MapVarChange : IReceive
{
	private static readonly Logger Log = new Logger("MapVarChange");

	private const string Type = "ultrakill.mapvar.update";

	public MapVarField variable;

	public string type => "ultrakill.mapvar.update";

	public void Receive()
	{
		Log.Fine($"Received change from console <b>{variable.value.type}</b> - <b>{variable.value.value}</b>");
		switch (variable.value.type)
		{
		case "System.Int32":
		{
			if (int.TryParse(variable.value.value.ToString(), out var result2))
			{
				MonoSingleton<MapVarManager>.Instance.SetInt(variable.name, result2);
			}
			else
			{
				Log.Warning($"Failed to parse {variable.value.value} as int");
			}
			break;
		}
		case "System.Boolean":
			if (variable.value.value is bool value)
			{
				MonoSingleton<MapVarManager>.Instance.SetBool(variable.name, value);
			}
			else
			{
				Log.Warning($"Failed to parse {variable.value.value} as bool");
			}
			break;
		case "System.Single":
		{
			if (float.TryParse(variable.value.value.ToString(), out var result))
			{
				MonoSingleton<MapVarManager>.Instance.SetFloat(variable.name, result);
			}
			else
			{
				Log.Warning($"Failed to parse {variable.value.value} as float");
			}
			break;
		}
		case "System.String":
			MonoSingleton<MapVarManager>.Instance.SetString(variable.name, variable.value.value.ToString());
			break;
		default:
			Log.Error("Unknown type " + variable.value.type);
			break;
		}
	}
}
}

// GameConsole.pcon/MapVarField.cs
namespace GameConsole.pcon{
public class MapVarField
{
	public string name;

	public MapVarValue value;
}
}

// GameConsole.pcon/MapVarRelay.cs
namespace GameConsole.pcon{
[ConfigureSingleton(SingletonFlags.PersistAutoInstance)]
public class MapVarRelay : MonoSingleton<MapVarRelay>
{
	private void Start()
	{
		MonoSingleton<MapVarManager>.Instance.RegisterGlobalWatcher(ReceiveChange);
	}

	private void ReceiveChange(string name, object value)
	{
		UpdateMapVars(MonoSingleton<MapVarManager>.Instance.Store);
	}

	public void UpdateMapVars(VarStore store)
	{
		PCon.SendMessage(new MapVarsMessage(store));
	}
}
}

// GameConsole.pcon/MapVarsMessage.cs
namespace GameConsole.pcon{
public class MapVarsMessage : ISend
{
	private const string Type = "ultrakill.mapvars";

	public List<MapVarField> variables;

	public bool clear;

	public string type => "ultrakill.mapvars";

	public MapVarsMessage(VarStore store)
	{
		clear = true;
		variables = new List<MapVarField>();
		foreach (KeyValuePair<string, int> item in store.intStore)
		{
			variables.Add(new MapVarField
			{
				name = item.Key,
				value = new MapVarValue
				{
					value = item.Value.ToString(),
					type = typeof(int).FullName
				}
			});
		}
		foreach (KeyValuePair<string, bool> item2 in store.boolStore)
		{
			variables.Add(new MapVarField
			{
				name = item2.Key,
				value = new MapVarValue
				{
					value = item2.Value,
					type = typeof(bool).FullName
				}
			});
		}
		foreach (KeyValuePair<string, float> item3 in store.floatStore)
		{
			variables.Add(new MapVarField
			{
				name = item3.Key,
				value = new MapVarValue
				{
					value = item3.Value.ToString(CultureInfo.InvariantCulture),
					type = typeof(float).FullName
				}
			});
		}
		foreach (KeyValuePair<string, string> item4 in store.stringStore)
		{
			variables.Add(new MapVarField
			{
				name = item4.Key,
				value = new MapVarValue
				{
					value = item4.Value,
					type = typeof(string).FullName
				}
			});
		}
	}
}
}

// GameConsole.pcon/MapVarValue.cs
namespace GameConsole.pcon{
public class MapVarValue
{
	public string type;

	public object value;
}
}

// GameConsole.pcon/PConLogLevel.cs
namespace GameConsole.pcon{
public enum PConLogLevel
{
	CLI,
	Info,
	Warning,
	Error,
	Unknown
}
}

// LucasMeshCombine/CombineMeshes.cs
namespace LucasMeshCombine{
public class CombineMeshes : MonoBehaviour
{
	private void Awake()
	{
		List<MeshCombineData> list = new List<MeshCombineData>();
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer meshRenderer in componentsInChildren)
		{
			if (!meshRenderer.gameObject.isStatic || MeshCombineManager.Instance.ProcessedMeshRenderers.Contains(meshRenderer) || !meshRenderer.gameObject.TryGetComponent<MeshFilter>(out var component) || meshRenderer.sharedMaterials.Length != component.sharedMesh.subMeshCount)
			{
				continue;
			}
			for (int j = 0; j < component.sharedMesh.subMeshCount; j++)
			{
				Material material = meshRenderer.sharedMaterials[j];
				if (MeshCombineManager.Instance.AllowedShadersToBatch.Contains(material.shader))
				{
					list.Add(new MeshCombineData(base.gameObject, meshRenderer, component, (Texture2D)material.mainTexture, j));
				}
			}
		}
		MeshCombineManager.Instance.AddCombineDatas(list);
	}
}
}

// LucasMeshCombine/MeshCombineData.cs
namespace LucasMeshCombine{
public class MeshCombineData
{
	public readonly GameObject Parent;

	public readonly MeshRenderer MeshRenderer;

	public readonly MeshFilter MeshFilter;

	public readonly Texture2D Texture;

	public readonly int SubMeshIndex;

	public MeshCombineData(GameObject parent, MeshRenderer meshRenderer, MeshFilter meshFilter, Texture2D texture, int subMeshIndex)
	{
		Parent = parent;
		MeshRenderer = meshRenderer;
		MeshFilter = meshFilter;
		Texture = texture;
		SubMeshIndex = subMeshIndex;
	}
}
}

// LucasMeshCombine/MeshCombineManager.cs
namespace LucasMeshCombine{
public class MeshCombineManager : MonoBehaviour
{
	[SerializeField]
	private Shader[] allowedShadersToBatch;

	[SerializeField]
	private Shader atlasedShader;

	[SerializeField]
	private Texture2D textureAtlas;

	private readonly Dictionary<Mesh, Vector4[]> oldMeshUvs = new Dictionary<Mesh, Vector4[]>();

	private readonly List<List<MeshCombineData>> combineSets = new List<List<MeshCombineData>>();

	private readonly List<Texture2D> textures = new List<Texture2D>();

	private readonly HashSet<MeshRenderer> processedMeshRenderers = new HashSet<MeshRenderer>();

	private readonly List<Mesh> createdMeshes = new List<Mesh>();

	private readonly List<GameObject> createdObjects = new List<GameObject>();

	private Material combinedMeshMaterial;

	public static MeshCombineManager Instance { get; private set; }

	public Shader[] AllowedShadersToBatch => allowedShadersToBatch;

	public HashSet<MeshRenderer> ProcessedMeshRenderers => processedMeshRenderers;

	public void AddCombineDatas(List<MeshCombineData> meshCombineDatas)
	{
		combineSets.Add(meshCombineDatas);
	}

	private void Awake()
	{
		if (Instance != null)
		{
			Object.Destroy(base.gameObject);
		}
		Instance = this;
		processedMeshRenderers.Clear();
	}

	private void Start()
	{
		textureAtlas = new Texture2D(1, 1)
		{
			filterMode = FilterMode.Point
		};
		if (combinedMeshMaterial == null)
		{
			combinedMeshMaterial = new Material(atlasedShader)
			{
				name = "Combined Mesh Material",
				hideFlags = HideFlags.HideAndDontSave,
				mainTexture = textureAtlas
			};
		}
		foreach (List<MeshCombineData> combineSet in combineSets)
		{
			for (int i = 0; i < combineSet.Count; i++)
			{
				Texture2D texture = combineSet[i].Texture;
				if (!textures.Contains(texture))
				{
					if (!texture.isReadable)
					{
						Debug.LogWarning("Mesh Combine: Texture not readable " + texture.name, texture);
					}
					else
					{
						textures.Add(texture);
					}
				}
			}
		}
		Rect[] array = textureAtlas.PackTextures(textures.ToArray(), 0, 8192);
		List<Vector4> list = new List<Vector4>();
		foreach (List<MeshCombineData> combineSet2 in combineSets)
		{
			if (combineSet2.Count == 0)
			{
				continue;
			}
			List<CombineInstance> list2 = new List<CombineInstance>(combineSet2.Count);
			for (int j = 0; j < combineSet2.Count; j++)
			{
				MeshCombineData meshCombineData = combineSet2[j];
				Mesh mesh = meshCombineData.MeshFilter.mesh;
				if (mesh.name.StartsWith("Combined Mesh"))
				{
					continue;
				}
				if (!mesh.isReadable)
				{
					Debug.LogWarning("Mesh Combine: Mesh isn't readable! Couldn't combine mesh " + mesh.name + " on GameObject " + meshCombineData.MeshFilter.gameObject.name, meshCombineData.MeshFilter.gameObject);
					continue;
				}
				int num = textures.IndexOf(meshCombineData.Texture);
				if (num < 0)
				{
					continue;
				}
				Rect rect = array[num];
				SubMeshDescriptor subMesh = mesh.GetSubMesh(meshCombineData.SubMeshIndex);
				Vector4[] array2 = new Vector4[mesh.vertexCount];
				mesh.GetUVs(3, list);
				oldMeshUvs[mesh] = array2.ToArray();
				for (int k = 0; k < array2.Length; k++)
				{
					if (k >= subMesh.firstVertex && k < subMesh.firstVertex + subMesh.vertexCount)
					{
						array2[k] = new Vector4(rect.xMin, rect.yMin, rect.xMax, rect.yMax);
					}
					else if (list.Count > k)
					{
						array2[k] = list[k];
					}
				}
				mesh.SetUVs(3, array2);
				mesh.UploadMeshData(markNoLongerReadable: false);
				list2.Add(new CombineInstance
				{
					mesh = mesh,
					subMeshIndex = meshCombineData.SubMeshIndex,
					transform = meshCombineData.MeshRenderer.localToWorldMatrix
				});
				meshCombineData.MeshRenderer.enabled = false;
			}
			if (list2.Count == 0)
			{
				Debug.LogWarning("Mesh Combine: Mesh combination on GameObject " + combineSet2[0].Parent.name + " is not effective (zero mesh combinations). You may want to remove it, or turn off static batching.", combineSet2[0].Parent);
				for (int l = 0; l < combineSet2.Count; l++)
				{
					MeshCombineData meshCombineData2 = combineSet2[l];
					Mesh mesh2 = meshCombineData2.MeshFilter.mesh;
					if (!mesh2.name.StartsWith("Combined Mesh") && mesh2.isReadable && textures.IndexOf(meshCombineData2.Texture) >= 0)
					{
						meshCombineData2.MeshRenderer.enabled = true;
						mesh2.SetUVs(3, oldMeshUvs[mesh2]);
					}
				}
				continue;
			}
			Mesh mesh3 = new Mesh();
			mesh3.CombineMeshes(list2.ToArray());
			mesh3.Optimize();
			GameObject gameObject = new GameObject("Combined Mesh");
			gameObject.transform.parent = combineSet2[0].Parent.transform;
			gameObject.isStatic = true;
			gameObject.layer = combineSet2[0].MeshRenderer.gameObject.layer;
			createdMeshes.Add(mesh3);
			createdObjects.Add(gameObject);
			MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
			meshRenderer.sharedMaterial = combinedMeshMaterial;
			meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			meshRenderer.receiveShadows = false;
			meshRenderer.lightProbeUsage = LightProbeUsage.Off;
			meshRenderer.motionVectorGenerationMode = MotionVectorGenerationMode.ForceNoMotion;
			gameObject.AddComponent<MeshFilter>().sharedMesh = mesh3;
			if (list2.Count <= 1)
			{
				Debug.LogWarning("Mesh Combine: Mesh combination on GameObject " + combineSet2[0].Parent.name + " is not effective (less than two mesh combinations). You may want to remove it.", combineSet2[0].Parent);
			}
		}
		textures.Clear();
		combineSets.Clear();
		processedMeshRenderers.Clear();
	}

	private void OnDestroy()
	{
		foreach (Mesh createdMesh in createdMeshes)
		{
			Object.Destroy(createdMesh);
		}
		foreach (GameObject createdObject in createdObjects)
		{
			Object.Destroy(createdObject);
		}
		foreach (MeshRenderer processedMeshRenderer in processedMeshRenderers)
		{
			if (!(processedMeshRenderer == null))
			{
				processedMeshRenderer.enabled = true;
			}
		}
		Instance = null;
		Object.Destroy(textureAtlas);
		Object.Destroy(combinedMeshMaterial);
	}
}
}

// ULTRAKILL.Cheats/BlindEnemies.cs
namespace ULTRAKILL.Cheats{
public class BlindEnemies : ICheat
{
	private static BlindEnemies _lastInstance;

	private bool active;

	public static bool Blind
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Blind Enemies";

	public string Identifier => "ultrakill.blind-enemies";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "blind";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/ClearMap.cs
namespace ULTRAKILL.Cheats{
public class ClearMap : ICheat
{
	private bool active;

	public string LongName => "Clear Map";

	public string Identifier => "ultrakill.sandbox.clear";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => "CLEAR";

	public string Icon => "delete";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		SandboxSaver.Clear();
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/CrashMode.cs
namespace ULTRAKILL.Cheats{
public class CrashMode : ICheat
{
	private bool active;

	public string LongName => "Clash Mode";

	public string Identifier => "ultrakill.clash-mode";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => "clash";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		if (MonoSingleton<PlayerTracker>.Instance.levelStarted)
		{
			MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.flight");
			MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.noclip");
		}
		active = true;
		MonoSingleton<PlayerTracker>.Instance.ChangeToPlatformer();
	}

	public void Disable()
	{
		active = false;
		MonoSingleton<PlayerTracker>.Instance.ChangeToFPS();
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/DisableEnemySpawns.cs
namespace ULTRAKILL.Cheats{
public class DisableEnemySpawns : ICheat
{
	private static DisableEnemySpawns _lastInstance;

	private bool active;

	public static bool DisableArenaTriggers
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Disable Enemy Spawns";

	public string Identifier => "ultrakill.disable-enemy-spawns";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "no-enemies";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		_lastInstance = this;
		active = true;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/EnemiesHateEnemies.cs
namespace ULTRAKILL.Cheats{
public class EnemiesHateEnemies : ICheat
{
	private static EnemiesHateEnemies _lastInstance;

	private bool active;

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Enemies Attack Each Other";

	public string Identifier => "ultrakill.enemy-hate-enemy";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "enemy-hate-enemy";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/EnemyIdentifierDebug.cs
namespace ULTRAKILL.Cheats{
public class EnemyIdentifierDebug : ICheat
{
	private bool active;

	private static EnemyIdentifierDebug _lastInstance;

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Enemy Identifier Debug";

	public string Identifier => "ultrakill.debug.enemy-identifier";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/EnemyIgnorePlayer.cs
namespace ULTRAKILL.Cheats{
public class EnemyIgnorePlayer : ICheat
{
	private static EnemyIgnorePlayer _lastInstance;

	private bool active;

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Enemies Ignore Player";

	public string Identifier => "ultrakill.enemy-ignore-player";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "enemy-ignore-player";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/ExperimentalArmRotation.cs
namespace ULTRAKILL.Cheats{
public class ExperimentalArmRotation : ICheat
{
	public static bool Enabled;

	public string LongName => "Experimental Arm Rotation";

	public string Identifier => "ultrakill.sandbox.enable-experimental-rotation";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => "rotate";

	public bool IsActive => Enabled;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		Enabled = true;
	}

	public void Disable()
	{
		Enabled = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/Flight.cs
namespace ULTRAKILL.Cheats{
public class Flight : ICheat
{
	private bool active;

	private Rigidbody rigidbody;

	private Transform camera;

	public string LongName => "Flight";

	public string Identifier => "ultrakill.flight";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "flight";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.noclip");
		MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.clash-mode");
		MonoSingleton<NewMovement>.Instance.enabled = false;
		rigidbody = MonoSingleton<NewMovement>.Instance.GetComponent<Rigidbody>();
		camera = MonoSingleton<CameraController>.Instance.transform;
		active = true;
	}

	public void Disable()
	{
		active = false;
		MonoSingleton<NewMovement>.Instance.enabled = true;
		rigidbody.useGravity = true;
	}

	public void Update()
	{
		float num = 1f;
		if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.IsPressed)
		{
			num = 2.5f;
		}
		Vector3 zero = Vector3.zero;
		Vector2 vector = Vector2.ClampMagnitude(MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>(), 1f);
		zero += camera.right * vector.x;
		zero += camera.forward * vector.y;
		if (MonoSingleton<InputManager>.Instance.InputSource.Jump.IsPressed)
		{
			zero += Vector3.up;
		}
		if (MonoSingleton<InputManager>.Instance.InputSource.Slide.IsPressed)
		{
			zero += Vector3.down;
		}
		rigidbody.velocity = zero * 30f * num;
		MonoSingleton<NewMovement>.Instance.enabled = false;
		rigidbody.isKinematic = false;
		rigidbody.useGravity = false;
	}
}
}

// ULTRAKILL.Cheats/ForceBossBars.cs
namespace ULTRAKILL.Cheats{
public class ForceBossBars : ICheat
{
	private bool active;

	private static ForceBossBars _lastInstance;

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Force Enemy Boss Bars";

	public string Identifier => "ultrakill.debug.force-boss-bars";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/FullBright.cs
namespace ULTRAKILL.Cheats{
public class FullBright : ICheat
{
	private static FullBright _instance;

	private bool active;

	private bool lastFogEnabled;

	private Color lastAmbientColor;

	private GameObject lightObject;

	private static Color brightAmbientColor = new Color(0.2f, 0.2f, 0.2f);

	public static bool Enabled => _instance?.IsActive ?? false;

	public string LongName => "Fullbright";

	public string Identifier => "ultrakill.full-bright";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => "light";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		_instance = this;
		active = true;
		lightObject = Object.Instantiate(MonoSingleton<CheatsController>.Instance.fullBrightLight);
		lastFogEnabled = RenderSettings.fog;
		RenderSettings.fog = false;
		lastAmbientColor = RenderSettings.ambientLight;
		RenderSettings.ambientLight = brightAmbientColor;
	}

	public void Disable()
	{
		active = false;
		Object.Destroy(lightObject);
		RenderSettings.fog = lastFogEnabled;
		RenderSettings.ambientLight = lastAmbientColor;
	}

	public void Update()
	{
		if (active)
		{
			if (RenderSettings.fog)
			{
				lastFogEnabled = true;
				RenderSettings.fog = false;
			}
			if (RenderSettings.ambientLight != brightAmbientColor)
			{
				lastAmbientColor = RenderSettings.ambientLight;
				RenderSettings.ambientLight = brightAmbientColor;
			}
		}
	}
}
}

// ULTRAKILL.Cheats/GhostDroneMode.cs
namespace ULTRAKILL.Cheats{
public class GhostDroneMode : ICheat
{
	private static GhostDroneMode _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Drone Haunting";

	public string Identifier => "ultrakill.ghost-drone-mode";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => "ghost";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/GunControlDebug.cs
namespace ULTRAKILL.Cheats{
public class GunControlDebug : ICheat
{
	private bool active;

	private static GunControlDebug _lastInstance;

	public static bool GunControlActivated
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Gun Control Debug";

	public string Identifier => "ultrakill.debug.gun-control";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/HideCheatsStatus.cs
namespace ULTRAKILL.Cheats{
public class HideCheatsStatus : ICheat
{
	private static HideCheatsStatus _lastInstance;

	private bool active;

	public static bool HideStatus
	{
		get
		{
			if (_lastInstance == null || !_lastInstance.active)
			{
				return HideUI.Active;
			}
			return true;
		}
	}

	public string LongName => "Hide Cheats Enabled Status";

	public string Identifier => "ultrakill.debug.hide-cheats-status";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/HideUI.cs
namespace ULTRAKILL.Cheats{
public class HideUI : ICheat
{
	private static readonly plog.Logger Log = new plog.Logger("HideUI");

	private HudController[] hudControllers;

	public static bool Active
	{
		get
		{
			if (Instance != null)
			{
				return Instance.IsActive;
			}
			return false;
		}
	}

	private static HideUI Instance { get; set; }

	public string LongName => "Hide UI";

	public string Identifier => "ultrakill.hide-ui";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon { get; }

	public bool IsActive { get; private set; }

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		Instance = this;
		IsActive = true;
		hudControllers = Object.FindObjectsOfType<HudController>();
		HudController[] array = hudControllers;
		foreach (HudController hudController in array)
		{
			if (hudController != null)
			{
				hudController.CheckSituation();
			}
		}
		if ((bool)MonoSingleton<HUDOptions>.Instance)
		{
			if ((bool)MonoSingleton<HUDOptions>.Instance.crosshair)
			{
				MonoSingleton<HUDOptions>.Instance.crosshair.CheckCrossHair();
			}
			MonoSingleton<HUDOptions>.Instance.SetStyleVisibleTemp();
		}
		if ((bool)MonoSingleton<PowerUpMeter>.Instance)
		{
			MonoSingleton<PowerUpMeter>.Instance.UpdateMeter();
		}
	}

	public void Disable()
	{
		IsActive = false;
		if (hudControllers == null)
		{
			return;
		}
		HudController[] array = hudControllers;
		foreach (HudController hudController in array)
		{
			if (hudController != null)
			{
				hudController.CheckSituation();
			}
		}
		if ((bool)MonoSingleton<HUDOptions>.Instance)
		{
			if ((bool)MonoSingleton<HUDOptions>.Instance.crosshair)
			{
				MonoSingleton<HUDOptions>.Instance.crosshair.CheckCrossHair();
			}
			MonoSingleton<HUDOptions>.Instance.SetStyleVisibleTemp();
		}
		if ((bool)MonoSingleton<PowerUpMeter>.Instance)
		{
			MonoSingleton<PowerUpMeter>.Instance.UpdateMeter();
		}
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/HideWeapons.cs
namespace ULTRAKILL.Cheats{
public class HideWeapons : ICheat
{
	private bool gunControlChanged;

	public static bool Active
	{
		get
		{
			if (Instance != null)
			{
				return Instance.IsActive;
			}
			return false;
		}
	}

	private static HideWeapons Instance { get; set; }

	public string LongName => "Hide Weapons";

	public string Identifier => "ultrakill.hide-weapons";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon { get; }

	public bool IsActive { get; private set; }

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		Instance = this;
		IsActive = true;
	}

	public void Disable()
	{
		IsActive = false;
		if (gunControlChanged && MonoSingleton<GunControl>.Instance != null && !MonoSingleton<GunControl>.Instance.activated)
		{
			MonoSingleton<GunControl>.Instance.YesWeapon();
		}
	}

	public void Update()
	{
		if (IsActive && MonoSingleton<GunControl>.Instance != null && MonoSingleton<GunControl>.Instance.activated)
		{
			gunControlChanged = true;
			MonoSingleton<GunControl>.Instance.NoWeapon();
		}
	}
}
}

// ULTRAKILL.Cheats/InfinitePowerUps.cs
namespace ULTRAKILL.Cheats{
public class InfinitePowerUps : ICheat
{
	private static InfinitePowerUps _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Infinite Power-Ups";

	public string Identifier => "ultrakill.infinite-power-ups";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "infinite-power-ups";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/InfiniteWallJumps.cs
namespace ULTRAKILL.Cheats{
public class InfiniteWallJumps : ICheat
{
	private bool active;

	public string LongName => "Infinite Wall Jumps";

	public string Identifier => "ultrakill.infinite-wall-jumps";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "infinite-wall-jumps";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
		MonoSingleton<NewMovement>.Instance.currentWallJumps = 0;
	}
}
}

// ULTRAKILL.Cheats/Invincibility.cs
namespace ULTRAKILL.Cheats{
public class Invincibility : ICheat
{
	private static Invincibility _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Invincibility";

	public string Identifier => "ultrakill.invincibility";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "invincibility";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/InvincibleEnemies.cs
namespace ULTRAKILL.Cheats{
public class InvincibleEnemies : ICheat
{
	private static InvincibleEnemies _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Invincible Enemies";

	public string Identifier => "ultrakill.invincible-enemies";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "invincible-enemies";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/KeepEnabled.cs
namespace ULTRAKILL.Cheats{
public class KeepEnabled : ICheat
{
	private bool active;

	public string LongName => "Keep Cheats Enabled";

	public string Identifier => "ultrakill.keep-enabled";

	public string ButtonEnabledOverride => "STAY ACTIVE";

	public string ButtonDisabledOverride => "DISABLE ON RELOAD";

	public string Icon => "warning";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/KillAllEnemies.cs
namespace ULTRAKILL.Cheats{
public class KillAllEnemies : ICheat
{
	public string LongName => "Kill All Enemies";

	public string Identifier => "ultrakill.kill-all-enemies";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => "Kill All";

	public string Icon => "death";

	public bool IsActive => false;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		foreach (EnemyIdentifier currentEnemy in MonoSingleton<EnemyTracker>.Instance.GetCurrentEnemies())
		{
			currentEnemy.InstaKill();
		}
	}

	public void Disable()
	{
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/ManageSaves.cs
namespace ULTRAKILL.Cheats{
public class ManageSaves : ICheat
{
	private bool active;

	public string LongName => "Manage Saves";

	public string Identifier => "ultrakill.sandbox.save-menu";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => "OPEN";

	public string Icon => "load";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		if (!GameStateManager.Instance.IsStateActive("sandbox-spawn-menu"))
		{
			MonoSingleton<CheatsManager>.Instance.ShowMenu();
			MonoSingleton<OptionsManager>.Instance.Pause();
		}
		MonoSingleton<SandboxHud>.Instance.ShowSavesMenu();
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/Noclip.cs
namespace ULTRAKILL.Cheats{
public class Noclip : ICheat
{
	private bool active;

	private Rigidbody rigidbody;

	private KeepInBounds kib;

	private Transform transform;

	private Transform camera;

	public string LongName => "Noclip";

	public string Identifier => "ultrakill.noclip";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => "noclip";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.flight");
		MonoSingleton<CheatsManager>.Instance.DisableCheat("ultrakill.clash-mode");
		rigidbody = MonoSingleton<NewMovement>.Instance.GetComponent<Rigidbody>();
		kib = MonoSingleton<NewMovement>.Instance.GetComponent<KeepInBounds>();
		transform = MonoSingleton<NewMovement>.Instance.transform;
		camera = MonoSingleton<CameraController>.Instance.transform;
		active = true;
		kib.enabled = false;
	}

	public void Disable()
	{
		active = false;
		MonoSingleton<NewMovement>.Instance.enabled = true;
		kib.enabled = true;
		rigidbody.isKinematic = false;
	}

	public void Update()
	{
		float num = 1f;
		if (MonoSingleton<InputManager>.Instance.InputSource.Dodge.IsPressed)
		{
			num = 2.5f;
		}
		if (!GameStateManager.Instance.IsStateActive("alter-menu"))
		{
			Vector2 vector = Vector2.ClampMagnitude(MonoSingleton<InputManager>.Instance.InputSource.Move.ReadValue<Vector2>(), 1f);
			transform.position += camera.right * vector.x * 40f * Time.deltaTime * num;
			transform.position += camera.forward * vector.y * 40f * Time.deltaTime * num;
			if (MonoSingleton<InputManager>.Instance.InputSource.Jump.IsPressed)
			{
				transform.position += new Vector3(0f, 40f, 0f) * 1f * Time.deltaTime * num;
			}
			if (MonoSingleton<InputManager>.Instance.InputSource.Slide.IsPressed)
			{
				transform.position += new Vector3(0f, -40f, 0f) * 1f * Time.deltaTime * num;
			}
		}
		MonoSingleton<NewMovement>.Instance.enabled = false;
		rigidbody.isKinematic = true;
	}
}
}

// ULTRAKILL.Cheats/NonConvexJumpDebug.cs
namespace ULTRAKILL.Cheats{
public class NonConvexJumpDebug : ICheat
{
	private static NonConvexJumpDebug _lastInstance;

	private bool active;

	private List<GameObject> _debugObjects = new List<GameObject>();

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Non Convex Jump Debug";

	public string Identifier => "ultrakill.debug.non-convex-jump-debug";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
		Reset();
	}

	public void Update()
	{
	}

	public static void Reset()
	{
		if (_lastInstance == null)
		{
			return;
		}
		foreach (GameObject debugObject in _lastInstance._debugObjects)
		{
			Object.Destroy(debugObject);
		}
		_lastInstance._debugObjects.Clear();
	}

	public static void CreateBall(Color color, Vector3 position, float size = 1f)
	{
		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
		Object.DestroyImmediate(gameObject.GetComponent<Collider>());
		if (_lastInstance == null)
		{
			_lastInstance = new NonConvexJumpDebug();
		}
		_lastInstance._debugObjects.Add(gameObject);
		gameObject.name = "jump debug ball";
		gameObject.transform.position = position;
		gameObject.transform.localScale = Vector3.one * size;
		MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
		Shader shader = Shader.Find("Unlit/Color");
		component.material = new Material(shader);
		component.material.color = color;
		gameObject.AddComponent<RemoveOnTime>().time = 3f;
	}

	public static void CreateTri(Vector3 normal, Triangle<Vector3> triangle, Color color)
	{
		GameObject gameObject = new GameObject("jump debug tri");
		_lastInstance._debugObjects.Add(gameObject);
		gameObject.transform.position += normal * 0.02f;
		MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>().material = new Material(Shader.Find("Unlit/Color"))
		{
			color = color
		};
		Mesh mesh = new Mesh();
		mesh.vertices = new Vector3[3] { triangle.Index0, triangle.Index1, triangle.Index2 };
		mesh.triangles = new int[3] { 0, 1, 2 };
		meshFilter.sharedMesh = mesh;
		gameObject.AddComponent<RemoveOnTime>().time = 3f;
	}
}
}

// ULTRAKILL.Cheats/NoWeaponCooldown.cs
namespace ULTRAKILL.Cheats{
public class NoWeaponCooldown : ICheat
{
	private static NoWeaponCooldown _lastInstance;

	private bool active;

	public static bool NoCooldown
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "No Weapon Cooldown";

	public string Identifier => "ultrakill.no-weapon-cooldown";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "no-weapon-cooldown";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/PauseTimedBombs.cs
namespace ULTRAKILL.Cheats{
public class PauseTimedBombs : ICheat
{
	private static PauseTimedBombs _lastInstance;

	private bool active;

	public static bool Paused
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Pause Timed Bombs";

	public string Identifier => "ultrakill.pause-timed-bombs";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/PlayerParentingDebug.cs
namespace ULTRAKILL.Cheats{
public class PlayerParentingDebug : ICheat, ICheatGUI
{
	private static PlayerParentingDebug _lastInstance;

	private bool active;

	private PlayerMovementParenting[] pmp;

	public static bool Active
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Player Parenting Debug";

	public string Identifier => "ultrakill.debug.player-parent-debug";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
		pmp = Object.FindObjectsOfType<PlayerMovementParenting>();
		if (pmp != null)
		{
			_ = pmp.LongLength;
		}
	}

	public void OnGUI()
	{
		GUILayout.Label("Player Parenting Debug");
		if (pmp == null)
		{
			return;
		}
		PlayerMovementParenting[] array = pmp;
		foreach (PlayerMovementParenting playerMovementParenting in array)
		{
			if (playerMovementParenting == null)
			{
				continue;
			}
			GUILayout.Label(playerMovementParenting.gameObject.name);
			GUILayout.Label("Attached to:");
			foreach (Transform trackedObject in playerMovementParenting.TrackedObjects)
			{
				if (trackedObject == null)
				{
					GUILayout.Label("null");
				}
				else
				{
					GUILayout.Label("- " + trackedObject.name);
				}
			}
			GUILayout.Label("------------------------------");
		}
	}
}
}

// ULTRAKILL.Cheats/QuickLoad.cs
namespace ULTRAKILL.Cheats{
public class QuickLoad : ICheat
{
	private bool active;

	public string LongName => "Quick Load";

	public string Identifier => "ultrakill.sandbox.quick-load";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => "LOAD LATEST SAVE";

	public string Icon => "quick-load";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		MonoSingleton<SandboxSaver>.Instance.QuickLoad();
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/QuickSave.cs
namespace ULTRAKILL.Cheats{
public class QuickSave : ICheat
{
	private PrefsManager prefsManager;

	private SandboxSaver saver;

	public string LongName => "Quick Save";

	public string Identifier => "ultrakill.sandbox.quick-save";

	public string ButtonEnabledOverride => "SAVE";

	public string ButtonDisabledOverride => "NEW SAVE";

	public string Icon => "save";

	public bool IsActive
	{
		get
		{
			if (MonoSingleton<SandboxSaver>.Instance != null)
			{
				return !string.IsNullOrEmpty(MonoSingleton<SandboxSaver>.Instance.activeSave);
			}
			return false;
		}
	}

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		prefsManager = MonoSingleton<PrefsManager>.Instance;
		saver = MonoSingleton<SandboxSaver>.Instance;
		saver.QuickSave();
	}

	public void Disable()
	{
		if (prefsManager == null)
		{
			prefsManager = MonoSingleton<PrefsManager>.Instance;
		}
		if (prefsManager.GetBool("sandboxSaveOverwriteWarnings"))
		{
			MonoSingleton<SandboxSaveConfirmation>.Instance.DisplayDialog();
			return;
		}
		if (saver == null)
		{
			saver = MonoSingleton<SandboxSaver>.Instance;
		}
		saver.Save(MonoSingleton<SandboxSaver>.Instance.activeSave);
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/RebuildNavmesh.cs
namespace ULTRAKILL.Cheats{
public class RebuildNavmesh : ICheat
{
	private bool active;

	public string LongName => "Enemy Navigation";

	public string Identifier => "ultrakill.sandbox.rebuild-nav";

	public string ButtonEnabledOverride => "REBUILDING...";

	public string ButtonDisabledOverride => "REBUILD";

	public string Icon => "navmesh";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		active = true;
		MonoSingleton<CheatsManager>.Instance.StartCoroutine(RebuildDelayed());
	}

	private IEnumerator RebuildDelayed()
	{
		yield return null;
		SandboxNavmesh instance = MonoSingleton<SandboxNavmesh>.Instance;
		instance.navmeshBuilt = (UnityAction)Delegate.Combine(instance.navmeshBuilt, new UnityAction(NavmeshBuilt));
		MonoSingleton<SandboxNavmesh>.Instance.Rebake();
	}

	private void NavmeshBuilt()
	{
		SandboxNavmesh instance = MonoSingleton<SandboxNavmesh>.Instance;
		instance.navmeshBuilt = (UnityAction)Delegate.Remove(instance.navmeshBuilt, new UnityAction(NavmeshBuilt));
		active = false;
		MonoSingleton<CheatsManager>.Instance.UpdateCheatState(this);
	}

	public void Disable()
	{
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/SandboxArmDebug.cs
namespace ULTRAKILL.Cheats{
public class SandboxArmDebug : ICheat
{
	private bool active;

	private static SandboxArmDebug _lastInstance;

	public static bool DebugActive
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Sandbox Arm Debug";

	public string Identifier => "ultrakill.debug.sandbox-arm";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/Snapping.cs
namespace ULTRAKILL.Cheats{
public class Snapping : ICheat
{
	private static Snapping _lastInstance;

	private bool active;

	public static bool SnappingEnabled
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Snapping";

	public string Identifier => "ultrakill.sandbox.snapping";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => "grid";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/SpawnPhysics.cs
namespace ULTRAKILL.Cheats{
public class SpawnPhysics : ICheat
{
	private static SpawnPhysics _lastInstance;

	private bool active;

	public static bool PhysicsDynamic
	{
		get
		{
			if (_lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Spawn With Physics";

	public string Identifier => "ultrakill.sandbox.physics";

	public string ButtonEnabledOverride => "DYNAMIC";

	public string ButtonDisabledOverride => "STATIC";

	public string Icon => "physics";

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/SpreadGasoline.cs
namespace ULTRAKILL.Cheats{
public class SpreadGasoline : ICheat
{
	private bool active;

	private GameObject asset;

	public string LongName => "Spread Gasoline";

	public string Identifier => "ultrakill.debug.spread-gasoline";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride => "Spawn Gasoline Projectiles";

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		if (asset == null)
		{
			GameObject gameObject = AssetHelper.LoadPrefab("Assets/Prefabs/Attacks and Projectiles/GasolineProjectile.prefab");
			if (gameObject == null || gameObject.Equals(null))
			{
				Debug.LogWarning("Failed to load projectile asset.\nRuntime key: Assets/Prefabs/Attacks and Projectiles/GasolineProjectile.prefab");
				MonoSingleton<HudMessageReceiver>.Instance.SendHudMessage("Failed to load gasoline projectile asset");
				return;
			}
			asset = gameObject;
		}
		SpawnProjectiles(asset);
	}

	private void SpawnProjectiles(GameObject projectilePrefab)
	{
		Vector3 position = MonoSingleton<PlayerTracker>.Instance.GetPlayer().position + Vector3.up * 4f;
		int num = 256;
		for (int i = 0; i < num; i++)
		{
			Quaternion quaternion = Random.rotation;
			if (quaternion.eulerAngles.x < 180f)
			{
				quaternion = Quaternion.Euler(180f, quaternion.eulerAngles.y, quaternion.eulerAngles.z);
			}
			GameObject gameObject = Object.Instantiate(projectilePrefab, position, quaternion);
			gameObject.SetActive(value: true);
			if (gameObject.TryGetComponent<Rigidbody>(out var component))
			{
				component.AddForce(quaternion * Vector3.forward * Random.Range(10f, 100f), ForceMode.Impulse);
			}
		}
	}

	public void Disable()
	{
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/StateDebug.cs
namespace ULTRAKILL.Cheats{
public class StateDebug : ICheat, ICheatGUI
{
	private bool active;

	public string LongName => "Game State Debug";

	public string Identifier => "ultrakill.debug.game-state";

	public string ButtonEnabledOverride { get; }

	public string ButtonDisabledOverride { get; }

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = true;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}

	public void OnGUI()
	{
		GUILayout.Label("Game State:");
		GUILayout.Label("opman paused: " + MonoSingleton<OptionsManager>.Instance.paused);
		GUILayout.Label("opman frozen: " + MonoSingleton<OptionsManager>.Instance.frozen);
		GUILayout.Label("fc shopping: " + MonoSingleton<FistControl>.Instance.shopping);
		GUILayout.Label("gc activated: " + MonoSingleton<GunControl>.Instance.activated);
		if ((bool)MonoSingleton<WeaponCharges>.Instance)
		{
			GUILayout.Label("rc: " + MonoSingleton<WeaponCharges>.Instance.rocketCount);
			if (MonoSingleton<WeaponCharges>.Instance.rocketCount != 0 && MonoSingleton<WeaponCharges>.Instance.rocketFrozen)
			{
				GUILayout.Label("ts: " + MonoSingleton<WeaponCharges>.Instance.timeSinceIdleFrozen.ToString());
			}
		}
	}
}
}

// ULTRAKILL.Cheats/SummonSandboxArm.cs
namespace ULTRAKILL.Cheats{
public class SummonSandboxArm : ICheat
{
	private bool active;

	private List<SandboxArm> createdArms = new List<SandboxArm>();

	private Dictionary<SpawnableType, SandboxArm> spawnedArmMap = new Dictionary<SpawnableType, SandboxArm>();

	private SpawnableType[][] mainArmTypes = new SpawnableType[4][]
	{
		new SpawnableType[1] { SpawnableType.MoveHand },
		new SpawnableType[1] { SpawnableType.AlterHand },
		new SpawnableType[1] { SpawnableType.DestroyHand },
		new SpawnableType[3]
		{
			SpawnableType.Prop,
			SpawnableType.SimpleSpawn,
			SpawnableType.BuildHand
		}
	};

	public static List<GameObject> armSlot => MonoSingleton<GunControl>.Instance.slot6;

	public string LongName => "Spawner Arm";

	public string Identifier => "ultrakill.spawner-arm";

	public string ButtonEnabledOverride => "REMOVE";

	public string ButtonDisabledOverride => "EQUIP";

	public string Icon => "spawner-arm";

	public bool IsActive => active;

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public static bool AnyArmActive
	{
		get
		{
			if ((bool)MonoSingleton<GunControl>.Instance && (bool)MonoSingleton<GunControl>.Instance.currentWeapon)
			{
				return MonoSingleton<GunControl>.Instance.currentWeapon.GetComponent<SandboxArm>();
			}
			return false;
		}
	}

	public void Enable()
	{
		if (MonoSingleton<CheatsManager>.Instance.GetCheatState("ultrakill.clash-mode"))
		{
			return;
		}
		if (!active && createdArms.Count > 0)
		{
			DeleteAllArms();
		}
		active = true;
		SpawnMenu componentInChildren = MonoSingleton<HUDOptions>.Instance.GetComponentInChildren<SpawnMenu>(includeInactive: true);
		SpawnableType[][] array = mainArmTypes;
		foreach (SpawnableType[] array2 in array)
		{
			SandboxArm sandboxArm = CreateArm(array2[0]);
			createdArms.Add(sandboxArm);
			sandboxArm.menu = componentInChildren;
			SpawnableType[] array3 = array2;
			foreach (SpawnableType key in array3)
			{
				spawnedArmMap[key] = sandboxArm;
			}
		}
		if ((bool)componentInChildren)
		{
			componentInChildren.armManager = this;
		}
		TryCreateArmType(SpawnableType.MoveHand);
	}

	public void TryCreateArmType(SpawnableType type)
	{
		SandboxArm sandboxArm;
		if (spawnedArmMap.TryGetValue(type, out var value))
		{
			sandboxArm = value;
		}
		else
		{
			sandboxArm = CreateArm(type);
			createdArms.Add(sandboxArm);
			spawnedArmMap[type] = sandboxArm;
		}
		if ((bool)MonoSingleton<GunControl>.Instance)
		{
			MonoSingleton<GunControl>.Instance.ForceWeapon(sandboxArm.gameObject, MonoSingleton<GunControl>.Instance.activated);
		}
	}

	private SandboxArm CreateArm(SpawnableType type)
	{
		GameObject gameObject = Object.Instantiate(MonoSingleton<CheatsController>.Instance.spawnerArm, MonoSingleton<GunControl>.Instance.transform);
		gameObject.name = gameObject.name + " - " + type;
		armSlot.Add(gameObject);
		MonoSingleton<GunControl>.Instance.UpdateWeaponList();
		SandboxArm component = gameObject.GetComponent<SandboxArm>();
		component.cameraCtrl = MonoSingleton<CameraController>.Instance;
		component.onEnableType = type;
		component.SetArmMode(type);
		return component;
	}

	public void SelectArm(SpawnableObject obj)
	{
		SandboxArm sandboxArm = null;
		if (spawnedArmMap.TryGetValue(obj.spawnableType, out var value))
		{
			sandboxArm = value;
			if ((bool)sandboxArm)
			{
				MonoSingleton<GunControl>.Instance.ForceWeapon(sandboxArm.gameObject);
			}
		}
		if (sandboxArm == null)
		{
			sandboxArm = MonoSingleton<GunControl>.Instance.currentWeapon.GetComponent<SandboxArm>();
		}
		if ((bool)sandboxArm)
		{
			sandboxArm.SelectObject(obj);
		}
	}

	public void Disable()
	{
		active = false;
		if (SceneManager.GetActiveScene().isLoaded)
		{
			DeleteAllArms();
		}
	}

	private void DeleteAllArms()
	{
		foreach (SandboxArm createdArm in createdArms)
		{
			if ((bool)MonoSingleton<GunControl>.Instance && armSlot.Contains(createdArm.gameObject))
			{
				armSlot.Remove(createdArm.gameObject);
			}
			Object.Destroy(createdArm.gameObject);
		}
		if ((bool)MonoSingleton<GunControl>.Instance)
		{
			MonoSingleton<GunControl>.Instance.UpdateWeaponList();
		}
		createdArms.Clear();
		spawnedArmMap.Clear();
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats/TeleportMenu.cs
namespace ULTRAKILL.Cheats{
public class TeleportMenu : ICheat
{
	public string LongName => "Teleport Menu";

	public string Identifier => "ultrakill.teleport-menu";

	public string ButtonEnabledOverride => "CLOSE";

	public string ButtonDisabledOverride => "OPEN";

	public string Icon => "teleport";

	public bool IsActive { get; }

	public bool DefaultState { get; }

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.NotPersistent;

	public void Enable()
	{
		if (!GameStateManager.Instance.IsStateActive("sandbox-spawn-menu"))
		{
			MonoSingleton<CheatsManager>.Instance.HideMenu();
			MonoSingleton<OptionsManager>.Instance.UnPause();
		}
		MonoSingleton<CheatsController>.Instance.ShowTeleportPanel();
	}

	public void Disable()
	{
	}

	public void Update()
	{
	}
}
}

// ScriptableObjects/Altars.cs
namespace ScriptableObjects{
[CreateAssetMenu(fileName = "Altars", menuName = "ULTRAKILL/Altars")]
public class Altars : ScriptableObject
{
	public AssetReference[] altarPrefabs;
}
}

// DitzelGames.FastIK/FastIKFabric.cs
namespace DitzelGames.FastIK{
[DefaultExecutionOrder(int.MaxValue)]
public class FastIKFabric : MonoBehaviour
{
	public int chainLength = 2;

	public Transform target;

	public Transform pole;

	[Header("Solver Parameters")]
	public int iterations = 10;

	public float delta = 0.001f;

	[Range(0f, 1f)]
	public float snapBackStrength = 1f;

	protected float[] bonesLength;

	protected float completeLength;

	protected Transform[] bones;

	protected Vector3[] positions;

	protected Vector3[] startDirectionSucc;

	protected Quaternion[] startRotationBone;

	protected Quaternion startRotationTarget;

	protected Transform root;

	private void Awake()
	{
		Init();
	}

	private void Init()
	{
		bones = new Transform[chainLength + 1];
		positions = new Vector3[chainLength + 1];
		bonesLength = new float[chainLength];
		startDirectionSucc = new Vector3[chainLength + 1];
		startRotationBone = new Quaternion[chainLength + 1];
		root = base.transform;
		for (int i = 0; i <= chainLength; i++)
		{
			if (root == null)
			{
				throw new UnityException("The chain value is longer than the ancestor chain!");
			}
			root = root.parent;
		}
		if (target == null)
		{
			target = new GameObject(base.gameObject.name + " Target").transform;
			SetPositionRootSpace(target, GetPositionRootSpace(base.transform));
		}
		startRotationTarget = GetRotationRootSpace(target);
		Transform parent = base.transform;
		completeLength = 0f;
		for (int num = bones.Length - 1; num >= 0; num--)
		{
			bones[num] = parent;
			startRotationBone[num] = GetRotationRootSpace(parent);
			if (num == bones.Length - 1)
			{
				startDirectionSucc[num] = GetPositionRootSpace(target) - GetPositionRootSpace(parent);
			}
			else
			{
				startDirectionSucc[num] = GetPositionRootSpace(bones[num + 1]) - GetPositionRootSpace(parent);
				bonesLength[num] = startDirectionSucc[num].magnitude;
				completeLength += bonesLength[num];
			}
			parent = parent.parent;
		}
	}

	private void LateUpdate()
	{
		ResolveIK();
	}

	private void ResolveIK()
	{
		if (target == null)
		{
			return;
		}
		if (bonesLength.Length != chainLength)
		{
			Init();
		}
		for (int i = 0; i < bones.Length; i++)
		{
			positions[i] = GetPositionRootSpace(bones[i]);
		}
		Vector3 positionRootSpace = GetPositionRootSpace(target);
		GetRotationRootSpace(target);
		float num = Vector3.Distance(positionRootSpace, GetPositionRootSpace(bones[0]));
		if ((positionRootSpace - GetPositionRootSpace(bones[0])).sqrMagnitude >= completeLength * completeLength)
		{
			Vector3 normalized = (positionRootSpace - positions[0]).normalized;
			for (int j = 1; j < positions.Length; j++)
			{
				positions[j] = positions[j - 1] + normalized * bonesLength[j - 1];
			}
		}
		else
		{
			for (int k = 0; k < positions.Length - 1; k++)
			{
				positions[k + 1] = Vector3.Lerp(positions[k + 1], positions[k] + startDirectionSucc[k], snapBackStrength);
			}
			for (int l = 0; l < iterations; l++)
			{
				for (int num2 = positions.Length - 1; num2 > 0; num2--)
				{
					if (num2 == positions.Length - 1)
					{
						positions[num2] = positionRootSpace;
					}
					else
					{
						positions[num2] = positions[num2 + 1] + (positions[num2] - positions[num2 + 1]).normalized * (num / (float)positions.Length);
					}
				}
				for (int m = 1; m < positions.Length; m++)
				{
					positions[m] = positions[m - 1] + (positions[m] - positions[m - 1]).normalized * (num / (float)positions.Length);
				}
				if ((positions[positions.Length - 1] - positionRootSpace).sqrMagnitude < delta * delta)
				{
					break;
				}
			}
		}
		if (pole != null)
		{
			Vector3 positionRootSpace2 = GetPositionRootSpace(pole);
			for (int n = 1; n < positions.Length - 1; n++)
			{
				Plane plane = new Plane(positions[n + 1] - positions[n - 1], positions[n - 1]);
				Vector3 vector = plane.ClosestPointOnPlane(positionRootSpace2);
				float angle = Vector3.SignedAngle(plane.ClosestPointOnPlane(positions[n]) - positions[n - 1], vector - positions[n - 1], plane.normal);
				positions[n] = Quaternion.AngleAxis(angle, plane.normal) * (positions[n] - positions[n - 1]) + positions[n - 1];
			}
		}
		for (int num3 = 0; num3 < positions.Length; num3++)
		{
			SetPositionRootSpace(bones[num3], positions[num3]);
		}
	}

	private Vector3 GetPositionRootSpace(Transform current)
	{
		if (root == null)
		{
			return current.position;
		}
		return Quaternion.Inverse(root.rotation) * (current.position - root.position);
	}

	private void SetPositionRootSpace(Transform current, Vector3 position)
	{
		if (root == null)
		{
			current.position = position;
		}
		else
		{
			current.position = root.rotation * position + root.position;
		}
	}

	private Quaternion GetRotationRootSpace(Transform current)
	{
		if (root == null)
		{
			return current.rotation;
		}
		return Quaternion.Inverse(current.rotation) * root.rotation;
	}

	private void SetRotationRootSpace(Transform current, Quaternion rotation)
	{
		if (root == null)
		{
			current.rotation = rotation;
		}
		else
		{
			current.rotation = root.rotation * rotation;
		}
	}

	private void OnDrawGizmos()
	{
	}
}
}

// NewBlood.Rendering/Triangle.cs
namespace NewBlood.Rendering{
public struct Triangle<TIndex> where TIndex : unmanaged
{
	public TIndex Index0;

	public TIndex Index1;

	public TIndex Index2;

	public TIndex this[int index]
	{
		get
		{
			if ((uint)index > 2u)
			{
				ThrowIndexOutOfRangeException();
			}
			return index switch
			{
				1 => Index1, 
				2 => Index2, 
				_ => Index0, 
			};
		}
		set
		{
			if ((uint)index > 2u)
			{
				ThrowIndexOutOfRangeException();
			}
			switch (index)
			{
			default:
				Index0 = value;
				break;
			case 1:
				Index1 = value;
				break;
			case 2:
				Index2 = value;
				break;
			}
		}
	}

	public Triangle(TIndex index0, TIndex index1, TIndex index2)
	{
		Index0 = index0;
		Index1 = index1;
		Index2 = index2;
	}

	private static TIndex ThrowIndexOutOfRangeException()
	{
		throw new IndexOutOfRangeException();
	}
}
}

// GameConsole.Commands/Buffs.cs
namespace GameConsole.Commands{
internal class Buffs : CommandRoot, IConsoleLogger
{
	public plog.Logger Log { get; } = new plog.Logger("Buffs");


	public override string Name => "Buffs";

	public override string Description => "Modify buffs for enemies";

	public Buffs(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("buffs", BoolMenu("forceradiance", () => OptionsManager.forceRadiance, delegate(bool value)
		{
			OptionsManager.forceRadiance = value;
			EnemyIdentifier[] array5 = Object.FindObjectsOfType<EnemyIdentifier>();
			for (int m = 0; m < array5.Length; m++)
			{
				array5[m].UpdateBuffs();
			}
		}, inverted: false, requireCheats: true), BoolMenu("forcesand", () => OptionsManager.forceSand, delegate(bool value)
		{
			OptionsManager.forceSand = value;
			EnemyIdentifier[] array4 = Object.FindObjectsOfType<EnemyIdentifier>();
			for (int l = 0; l < array4.Length; l++)
			{
				array4[l].Sandify();
			}
		}, inverted: false, requireCheats: true), BoolMenu("forcepuppet", () => OptionsManager.forcePuppet, delegate(bool value)
		{
			OptionsManager.forcePuppet = value;
			EnemyIdentifier[] array3 = Object.FindObjectsOfType<EnemyIdentifier>();
			for (int k = 0; k < array3.Length; k++)
			{
				array3[k].PuppetSpawn();
			}
		}, inverted: false, requireCheats: true), BoolMenu("forcebossbars", () => OptionsManager.forceBossBars, delegate(bool value)
		{
			OptionsManager.forceBossBars = value;
			EnemyIdentifier[] array2 = Object.FindObjectsOfType<EnemyIdentifier>();
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j].BossBar(value);
			}
		}, inverted: false, requireCheats: true), CommandRoot.Branch("radiancetier", CommandRoot.Leaf("get", delegate
		{
			Log.Info($"Current radiance tier is {OptionsManager.radianceTier}");
		}), CommandRoot.Leaf("set", delegate(float amt)
		{
			Log.Info($"Set current radiance tier to {amt}");
			OptionsManager.radianceTier = amt;
			EnemyIdentifier[] array = Object.FindObjectsOfType<EnemyIdentifier>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].UpdateBuffs();
			}
		}, requireCheats: true)));
	}
}
}

// GameConsole.Commands/Clear.cs
namespace GameConsole.Commands{
public class Clear : ICommand
{
	public string Name => "Clear";

	public string Description => "Clears the console.";

	public string Command => "clear";

	public void Execute(Console con, string[] args)
	{
		con.Clear();
	}
}
}

// GameConsole.Commands/ConsoleCmd.cs
namespace GameConsole.Commands{
public class ConsoleCmd : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("ConsoleCmd");


	public override string Name => "Console";

	public override string Description => "Used for configuring the console";

	public ConsoleCmd(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("console", BoolMenu("hide_badge", () => con.errorBadge.hidden, delegate(bool value)
		{
			con.errorBadge.SetEnabled(value);
		}), BoolMenu("force_stacktrace_extraction", () => con.ExtractStackTraces, con.SetForceStackTraceExtraction), CommandRoot.Leaf("change_bind", delegate(string bind, string key)
		{
			if (con.binds.defaultBinds.ContainsKey(bind.ToLower()))
			{
				con.binds.Rebind(bind.ToLower(), key);
			}
			else
			{
				Log.Error(bind.ToLower() + " is not a valid bind.");
				Log.Info("Listing valid binds:");
				ListDefaults(con);
			}
		}, requireCheats: true), CommandRoot.Leaf("list_binds", delegate
		{
			Log.Info("Listing binds:");
			foreach (KeyValuePair<string, InputActionState> registeredBind in con.binds.registeredBinds)
			{
				Log.Info(registeredBind.Key + "  -  " + registeredBind.Value.Action.bindings.First().path);
			}
		}), CommandRoot.Leaf("reset", delegate
		{
			MonoSingleton<Console>.Instance.consoleWindow.ResetWindow();
		}));
	}

	private void ListDefaults(Console con)
	{
		foreach (KeyValuePair<string, string> defaultBind in con.binds.defaultBinds)
		{
			Log.Info(defaultBind.Key + "  -  " + defaultBind.Value);
		}
	}
}
}

// GameConsole.Commands/Debug.cs
namespace GameConsole.Commands{
public class Debug : CommandRoot, IConsoleLogger
{
	public static bool AgonyDebugOverlay = true;

	public plog.Logger Log { get; } = new plog.Logger("Debug");


	public override string Name => "Debug";

	public override string Description => "Console debug stuff.";

	public Debug(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("debug", CommandRoot.Leaf("burst_print", delegate(string count)
		{
			con.StartCoroutine(BurstPrint(con, int.Parse(count), Level.Info));
		}), CommandRoot.Leaf("bulk_print", delegate(string count)
		{
			int num2 = int.Parse(count);
			for (int k = 0; k < num2; k++)
			{
				Log.Info("Bulk print " + k);
			}
		}), CommandRoot.Leaf("print_logger_test", delegate(string count)
		{
			int num = int.Parse(count);
			for (int j = 0; j < num; j++)
			{
				new plog.Logger(Guid.NewGuid().ToString()).Info("Bulk print " + j);
			}
		}), CommandRoot.Leaf("toggle_overlay", delegate
		{
			AgonyDebugOverlay = !AgonyDebugOverlay;
			Log.Info("AgonyDebugOverlay: " + AgonyDebugOverlay);
		}), CommandRoot.Leaf("error", delegate
		{
			throw new Exception("Umm, ermm, guuh!!");
		}), CommandRoot.Leaf("log", delegate(string text)
		{
			UnityEngine.Debug.Log(text);
		}), CommandRoot.Leaf("freeze_game", delegate(string confrm)
		{
			if (confrm == "pretty_please")
			{
				while (true)
				{
				}
			}
			Log.Info("Usage: freeze_game pretty_please");
		}), CommandRoot.Leaf("timescale", delegate(string timescale)
		{
			Time.timeScale = float.Parse(timescale);
		}, requireCheats: true), CommandRoot.Leaf("die_respawn", delegate
		{
			Log.Info("Killing and immediately respawning player...");
			bool paused = MonoSingleton<OptionsManager>.Instance.paused;
			if (paused)
			{
				MonoSingleton<OptionsManager>.Instance.UnPause();
			}
			con.StartCoroutine(KillRespawnDelayed(paused));
		}, requireCheats: true), CommandRoot.Leaf("total_secrets", delegate
		{
			Log.Info(GameProgressSaver.GetTotalSecretsFound().ToString());
		}), CommandRoot.Leaf("auto_register", delegate
		{
			Log.Info("Attempting to auto register all commands...");
			List<ICommand> list = new List<ICommand>();
			Type[] types = typeof(ICommand).Assembly.GetTypes();
			foreach (Type type in types)
			{
				if (!con.registeredCommandTypes.Contains(type) && typeof(ICommand).IsAssignableFrom(type) && !type.IsInterface)
				{
					list.Add((ICommand)Activator.CreateInstance(type));
				}
			}
			con.RegisterCommands(list);
		}));
	}

	private IEnumerator BurstPrint(Console console, int count, Level type)
	{
		for (int i = 0; i < count; i++)
		{
			Log.Log("Hello World " + i, type);
			yield return new WaitForSecondsRealtime(3f / (float)count);
		}
	}

	private IEnumerator KillRespawnDelayed(bool wasPaused)
	{
		yield return new WaitForEndOfFrame();
		MonoSingleton<NewMovement>.Instance.GetHurt(999999, invincible: false, 1f, explosion: false, instablack: true);
		MonoSingleton<StatsManager>.Instance.Restart();
		if (wasPaused)
		{
			MonoSingleton<OptionsManager>.Instance.Pause();
		}
	}
}
}

// GameConsole.Commands/Echo.cs
namespace GameConsole.Commands{
public class Echo : ICommand, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Echo");


	public string Name => "Echo";

	public string Description => "Echo the given text";

	public string Command => "echo";

	public void Execute(Console con, string[] args)
	{
		Log.Info("Echoing: " + string.Join(" ", args));
	}
}
}

// GameConsole.Commands/Exit.cs
namespace GameConsole.Commands{
public class Exit : ICommand, IConsoleLogger
{
	public plog.Logger Log { get; } = new plog.Logger("Exit");


	public string Name => "Exit";

	public string Description => "Quits the game.";

	public string Command => Name.ToLower();

	public void Execute(Console con, string[] args)
	{
		Log.Info("Goodbye \ud83d\udc4b");
		Application.Quit();
	}
}
}

// GameConsole.Commands/Help.cs
namespace GameConsole.Commands{
public class Help : ICommand, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Help");


	public string Name => "Help";

	public string Description => "Helps you with things, does helpful things, lists things maybe??? Just a helpful pal.";

	public string Command => "help";

	public void Execute(Console con, string[] args)
	{
		if (args.Length != 0)
		{
			if (con.recognizedCommands.ContainsKey(args[0].ToLower()))
			{
				Log.Info("<b>" + args[0].ToLower() + "</b> - " + con.recognizedCommands[args[0].ToLower()].Description);
			}
			else
			{
				Log.Info("Command not found.");
			}
			return;
		}
		Log.Info("Listing recognized commands:");
		foreach (KeyValuePair<string, ICommand> recognizedCommand in con.recognizedCommands)
		{
			Log.Info("<b>" + recognizedCommand.Key + "</b> - " + recognizedCommand.Value.Description);
		}
	}
}
}

// GameConsole.Commands/InputCommands.cs
namespace GameConsole.Commands{
internal class InputCommands : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Input");


	public override string Name => "Input";

	public override string Description => "Modify inputs";

	public InputCommands(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("input", CommandRoot.Branch("mouse", CommandRoot.Leaf("sensitivity", delegate(float amount)
		{
			Log.Info($"Set mouse sensitivity to {amount}");
			MonoSingleton<OptionsMenuToManager>.Instance.MouseSensitivity(amount);
			MonoSingleton<OptionsMenuToManager>.Instance.UpdateSensitivitySlider(amount);
		})), CommandRoot.Leaf("bindings", delegate(string name)
		{
			InputAction inputAction = MonoSingleton<InputManager>.Instance.InputSource.Actions.FindAction(name);
			if (inputAction == null)
			{
				Log.Error("No action found with name or id '" + name + "'");
				return;
			}
			Log.Info("'" + name + "' has the following bindings:");
			foreach (InputBinding binding in inputAction.bindings)
			{
				if (binding.isPartOfComposite)
				{
					Log.Info("-- " + binding.path);
				}
				else
				{
					Log.Info("- " + binding.path);
				}
			}
		}));
	}
}
}

// GameConsole.Commands/MapVar.cs
namespace GameConsole.Commands{
public class MapVar : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("MapVar");


	public override string Name => "MapVar";

	public override string Description => "Map variables";

	public MapVar(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("mapvar", CommandRoot.Leaf("reset", delegate
		{
			MonoSingleton<MapVarManager>.Instance.ResetStores();
			Log.Info("Stores have been reset.");
		}, requireCheats: true), CommandRoot.Leaf("stash_info", delegate
		{
			bool hasStashedStore = MonoSingleton<MapVarManager>.Instance.HasStashedStore;
			Log.Info("Stash exists: " + hasStashedStore);
		}, requireCheats: true), CommandRoot.Leaf("stash_stores", delegate
		{
			MonoSingleton<MapVarManager>.Instance.StashStore();
			Log.Info("Stores have been stashed.");
		}, requireCheats: true), CommandRoot.Leaf("restore_stash", delegate
		{
			MonoSingleton<MapVarManager>.Instance.RestoreStashedStore();
			Log.Info("Stores have been restored.");
		}, requireCheats: true), CommandRoot.Leaf("list", delegate
		{
			List<VariableSnapshot> allVariables = MonoSingleton<MapVarManager>.Instance.GetAllVariables();
			foreach (VariableSnapshot item in allVariables)
			{
				Log.Info($"{item.name} ({GetFriendlyTypeName(item.type)}) - <color=orange>{item.value}</color>");
			}
			if (allVariables.Count == 0)
			{
				Log.Info("No map variables have been set.");
			}
		}, requireCheats: true), BoolMenu("logging", () => MapVarManager.LoggingEnabled, delegate(bool value)
		{
			MapVarManager.LoggingEnabled = value;
		}, inverted: false, requireCheats: true), CommandRoot.Leaf("set_int", delegate(string variableName, int value)
		{
			MonoSingleton<MapVarManager>.Instance.SetInt(variableName, value);
		}, requireCheats: true), CommandRoot.Leaf("set_bool", delegate(string variableName, bool value)
		{
			MonoSingleton<MapVarManager>.Instance.SetBool(variableName, value);
		}, requireCheats: true), CommandRoot.Leaf("toggle_bool", delegate(string variableName)
		{
			MonoSingleton<MapVarManager>.Instance.SetBool(variableName, !(MonoSingleton<MapVarManager>.Instance.GetBool(variableName) ?? false));
		}, requireCheats: true), CommandRoot.Leaf("set_float", delegate(string variableName, float value)
		{
			MonoSingleton<MapVarManager>.Instance.SetFloat(variableName, value);
		}, requireCheats: true), CommandRoot.Leaf("set_string", delegate(string variableName, string value)
		{
			MonoSingleton<MapVarManager>.Instance.SetString(variableName, value);
		}, requireCheats: true));
	}

	public static string GetFriendlyTypeName(Type type)
	{
		if (type == typeof(int))
		{
			return "int";
		}
		if (type == typeof(float))
		{
			return "float";
		}
		if (type == typeof(string))
		{
			return "string";
		}
		if (type == typeof(bool))
		{
			return "bool";
		}
		return type.Name;
	}
}
}

// GameConsole.Commands/Pcon.cs
namespace GameConsole.Commands{
public class Pcon : CommandRoot
{
	public override string Name => "pcon";

	public override string Description => "pcon commands";

	public Pcon(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("pcon", CommandRoot.Leaf("connect", delegate
		{
			MonoSingleton<Console>.Instance.StartPCon();
		}), BoolMenu("autostart", () => MonoSingleton<PrefsManager>.Instance.GetBoolLocal("pcon.autostart"), delegate(bool value)
		{
			MonoSingleton<PrefsManager>.Instance.SetBoolLocal("pcon.autostart", value);
			if (value)
			{
				MonoSingleton<Console>.Instance.StartPCon();
			}
		}));
	}
}
}

// GameConsole.Commands/Prefs.cs
namespace GameConsole.Commands{
public class Prefs : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Prefs");


	public override string Name => "Prefs";

	public override string Description => "Interfaces with the PrefsManager.";

	public Prefs(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("prefs", CommandRoot.Branch("get", CommandRoot.Leaf("bool", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetBool(key)}");
		}), CommandRoot.Leaf("int", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetInt(key)}");
		}), CommandRoot.Leaf("float", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetFloat(key)}");
		}), CommandRoot.Leaf("string", delegate(string key)
		{
			Log.Info(key + " = " + MonoSingleton<PrefsManager>.Instance.GetString(key));
		})), CommandRoot.Branch("set", CommandRoot.Leaf("bool", delegate(string key, bool value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetBool(key, value);
		}), CommandRoot.Leaf("int", delegate(string key, int value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetInt(key, value);
		}), CommandRoot.Leaf("float", delegate(string key, float value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetFloat(key, value);
		}), CommandRoot.Leaf("string", delegate(string key, string value)
		{
			Log.Info("Set " + key + " to " + value);
			MonoSingleton<PrefsManager>.Instance.SetString(key, value);
		})), CommandRoot.Branch("get_local", CommandRoot.Leaf("bool", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetBoolLocal(key)}");
		}), CommandRoot.Leaf("int", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetIntLocal(key)}");
		}), CommandRoot.Leaf("float", delegate(string key)
		{
			Log.Info($"{key} = {MonoSingleton<PrefsManager>.Instance.GetFloatLocal(key)}");
		}), CommandRoot.Leaf("string", delegate(string key)
		{
			Log.Info(key + " = " + MonoSingleton<PrefsManager>.Instance.GetStringLocal(key));
		})), CommandRoot.Branch("set_local", CommandRoot.Leaf("bool", delegate(string key, bool value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetBoolLocal(key, value);
		}), CommandRoot.Leaf("int", delegate(string key, int value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetIntLocal(key, value);
		}), CommandRoot.Leaf("float", delegate(string key, float value)
		{
			Log.Info($"Set {key} to {value}");
			MonoSingleton<PrefsManager>.Instance.SetFloatLocal(key, value);
		}), CommandRoot.Leaf("string", delegate(string key, string value)
		{
			Log.Info("Set " + key + " to " + value);
			MonoSingleton<PrefsManager>.Instance.SetStringLocal(key, value);
		})), CommandRoot.Leaf("delete", delegate(string key)
		{
			Log.Info("Deleted " + key);
			MonoSingleton<PrefsManager>.Instance.DeleteKey(key);
		}), CommandRoot.Leaf("list_defaults", delegate
		{
			Log.Info("<b>Default Prefs:</b>");
			foreach (KeyValuePair<string, object> defaultValue in MonoSingleton<PrefsManager>.Instance.defaultValues)
			{
				Log.Info($"{defaultValue.Key} = {defaultValue.Value}");
			}
		}), CommandRoot.Leaf("list_cached", delegate
		{
			Log.Info("<b>Cached Prefs:</b>");
			foreach (KeyValuePair<string, object> item in MonoSingleton<PrefsManager>.Instance.prefMap)
			{
				Log.Info($"{item.Key} = {item.Value}");
			}
		}), CommandRoot.Leaf("list_cached_local", delegate
		{
			Log.Info("<b>Local Cached Prefs:</b>");
			foreach (KeyValuePair<string, object> item2 in MonoSingleton<PrefsManager>.Instance.localPrefMap)
			{
				Log.Info($"{item2.Key} = {item2.Value}");
			}
		}), CommandRoot.Leaf("last_played", delegate
		{
			Log.Info($"The game has been played {PrefsManager.monthsSinceLastPlayed} months ago last.\nThis is only valid per session.");
		}));
	}
}
}

// GameConsole.Commands/Rumble.cs
namespace GameConsole.Commands{
public class Rumble : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Rumble");


	public override string Name => "Rumble";

	public override string Description => "Command for managing ULTRAKILL's controller rumble system";

	public Rumble(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("rumble", CommandRoot.Leaf("status", delegate
		{
			Log.Info($"Pending Vibrations ({MonoSingleton<RumbleManager>.Instance.pendingVibrations.Count}):");
			foreach (KeyValuePair<RumbleKey, PendingVibration> pendingVibration in MonoSingleton<RumbleManager>.Instance.pendingVibrations)
			{
				Log.Info($" - {pendingVibration.Key} ({pendingVibration.Value.Intensity}) for {pendingVibration.Value.Duration} seconds");
			}
			Log.Info(string.Empty);
			Log.Info($"Current Intensity: {MonoSingleton<RumbleManager>.Instance.currentIntensity}");
		}), CommandRoot.Leaf("list", delegate
		{
			Log.Info("Available Keys:");
			PropertyInfo[] properties = typeof(RumbleProperties).GetProperties();
			for (int i = 0; i < properties.Length; i++)
			{
				string text = properties[i].GetValue(null) as string;
				Log.Info(" - " + text);
			}
		}), CommandRoot.Leaf("vibrate", delegate(string key)
		{
			MonoSingleton<RumbleManager>.Instance.SetVibration(new RumbleKey(key));
		}), CommandRoot.Leaf("stop", delegate(string key)
		{
			MonoSingleton<RumbleManager>.Instance.StopVibration(new RumbleKey(key));
		}), CommandRoot.Leaf("stop_all", delegate
		{
			MonoSingleton<RumbleManager>.Instance.StopAllVibrations();
		}), CommandRoot.Leaf("toggle_preview", delegate
		{
			DebugUI.previewRumble = !DebugUI.previewRumble;
		}));
	}
}
}

// GameConsole.Commands/Scene.cs
namespace GameConsole.Commands{
public class Scene : ICommand, IConsoleLogger
{
	public plog.Logger Log { get; } = new plog.Logger("Scene");


	public string Name => "Scene";

	public string Description => "Loads a scene.";

	public string Command => "scene";

	public void Execute(Console con, string[] args)
	{
		if (con.CheatBlocker())
		{
			return;
		}
		if (args.Length == 0)
		{
			Log.Info("Usage: scene <scene name>");
			return;
		}
		string sceneName = string.Join(" ", args);
		if (!UnityEngine.Debug.isDebugBuild && MonoSingleton<SceneHelper>.Instance.IsSceneSpecial(sceneName))
		{
			Log.Info("Scene is special and cannot be loaded in release mode. \ud83e\udd7a");
		}
		else
		{
			SceneHelper.LoadScene(sceneName);
		}
	}
}
}

// GameConsole.Commands/Scenes.cs
namespace GameConsole.Commands{
public class Scenes : ICommand, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Scenes");


	public string Name => "Scenes";

	public string Description => "Lists all scenes.";

	public string Command => "scenes";

	public void Execute(Console con, string[] args)
	{
		if (con.CheatBlocker())
		{
			return;
		}
		Log.Info("<b>Available Scenes:</b>");
		foreach (IResourceLocation item in Addressables.LoadResourceLocationsAsync("Assets/Scenes").WaitForCompletion())
		{
			string text = item.InternalId;
			if (item.InternalId.StartsWith("Assets/Scenes/"))
			{
				text = item.InternalId.Substring(14);
			}
			if (item.InternalId.EndsWith(".unity"))
			{
				text = text.Substring(0, text.Length - 6);
			}
			Log.Info(text + " [<color=orange>" + item.InternalId + "</color>]");
		}
	}
}
}

// GameConsole.Commands/Style.cs
namespace GameConsole.Commands{
internal class Style : CommandRoot, IConsoleLogger
{
	public Logger Log { get; } = new Logger("Style");


	public override string Name => "Style";

	public override string Description => "Modify your style score";

	public Style(Console con)
		: base(con)
	{
	}

	protected override Branch BuildTree(Console con)
	{
		return CommandRoot.Branch("style", BoolMenu("meter", () => MonoSingleton<StyleHUD>.Instance.forceMeterOn, delegate(bool value)
		{
			MonoSingleton<StyleHUD>.Instance.forceMeterOn = value;
		}, inverted: false, requireCheats: true), CommandRoot.Branch("freshness", CommandRoot.Leaf("get", delegate
		{
			Log.Info($"Current weapon freshness is {MonoSingleton<StyleHUD>.Instance.GetFreshness(MonoSingleton<GunControl>.Instance.currentWeapon)}");
		}), CommandRoot.Leaf("set", delegate(float amt)
		{
			Log.Info($"Set current weapon freshness to {amt}");
			MonoSingleton<StyleHUD>.Instance.SetFreshness(MonoSingleton<GunControl>.Instance.currentWeapon, amt);
		}, requireCheats: true), CommandRoot.Leaf("lock_state", delegate(int slot, StyleFreshnessState state)
		{
			Log.Info($"Locking slot {slot} to {Enum.GetName(typeof(StyleFreshnessState), state)}");
			MonoSingleton<StyleHUD>.Instance.LockFreshness(slot, state);
		}, requireCheats: true), CommandRoot.Leaf("unlock", delegate(int slot)
		{
			Log.Info($"Unlocking slot {slot}");
			MonoSingleton<StyleHUD>.Instance.UnlockFreshness(slot);
		}, requireCheats: true)));
	}
}
}

// GameConsole.CommandTree/Branch.cs
namespace GameConsole.CommandTree{
public class Branch : Node
{
	public readonly string name;

	public readonly Node[] children;

	public Branch(string name, bool requireCheats, params Node[] children)
		: base(requireCheats)
	{
		this.name = name;
		this.children = children;
	}

	public Branch(string name, params Node[] children)
	{
		this.name = name;
		this.children = children;
	}

	public Branch(string name, bool requireCheats = false, params Delegate[] onLeafExecutes)
		: base(requireCheats)
	{
		this.name = name;
		Node[] array = onLeafExecutes.Select((Delegate onExecute) => new Leaf(onExecute, requireCheats)).ToArray();
		children = array;
	}

	public Branch(string name, params Delegate[] onLeafExecutes)
	{
		this.name = name;
		Node[] array = onLeafExecutes.Select((Delegate onExecute) => new Leaf(onExecute, requireCheats: false)).ToArray();
		children = array;
	}
}
}

// GameConsole.CommandTree/Leaf.cs
namespace GameConsole.CommandTree{
public class Leaf : Node
{
	public readonly Delegate onExecute;

	public Leaf(Delegate onExecute, bool requireCheats)
		: base(requireCheats)
	{
		this.onExecute = onExecute;
	}

	public Leaf(Delegate onExecute)
	{
		this.onExecute = onExecute;
	}
}
}

// GameConsole.CommandTree/Node.cs
namespace GameConsole.CommandTree{
public abstract class Node
{
	public readonly bool requireCheats;

	protected Node(bool requireCheats = false)
	{
		this.requireCheats = requireCheats;
	}
}
}

// ULTRAKILL.Cheats.UnityEditor/MannequinDebugGizmos.cs
namespace ULTRAKILL.Cheats.UnityEditor{
public class MannequinDebugGizmos : ICheat
{
	private static MannequinDebugGizmos _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (Application.isEditor && Debug.isDebugBuild && _lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Mannequin Debug Gizmos";

	public string Identifier => "ultrakill.editor.debug-gizmos";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = Application.isEditor;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats.UnityEditor/NapalmDebugVoxels.cs
namespace ULTRAKILL.Cheats.UnityEditor{
public class NapalmDebugVoxels : ICheat
{
	private static NapalmDebugVoxels _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (Application.isEditor && Debug.isDebugBuild && _lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Napalm Debug Voxels";

	public string Identifier => "ultrakill.editor.debug-napalm-voxels";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = Application.isEditor;
		_lastInstance = this;
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}

// ULTRAKILL.Cheats.UnityEditor/OverwriteUnlocks.cs
namespace ULTRAKILL.Cheats.UnityEditor{
public class OverwriteUnlocks : ICheat
{
	private static OverwriteUnlocks _lastInstance;

	private bool active;

	public static bool Enabled
	{
		get
		{
			if (Application.isEditor && Debug.isDebugBuild && _lastInstance != null)
			{
				return _lastInstance.active;
			}
			return false;
		}
	}

	public string LongName => "Overwrite Unlocks";

	public string Identifier => "ultrakill.editor.overwrite-unlocks";

	public string ButtonEnabledOverride => null;

	public string ButtonDisabledOverride => null;

	public string Icon => null;

	public bool IsActive => active;

	public bool DefaultState => false;

	public StatePersistenceMode PersistenceMode => StatePersistenceMode.Persistent;

	public void Enable()
	{
		active = Application.isEditor;
		_lastInstance = this;
		if ((bool)MonoSingleton<SpawnMenu>.Instance)
		{
			MonoSingleton<SpawnMenu>.Instance.RebuildMenu();
		}
	}

	public void Disable()
	{
		active = false;
	}

	public void Update()
	{
	}
}
}
